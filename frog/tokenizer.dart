// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Generated by scripts/tokenizer_gen.py.

class InterpStack {
  InterpStack next, previous;
  final int quote;
  final bool isMultiline;
  int depth;

  InterpStack(this.previous, this.quote, this.isMultiline): depth = -1;

  InterpStack pop() {
    return this.previous;
  }

  static InterpStack push(InterpStack stack, int quote, bool isMultiline) {
    var newStack = new InterpStack(stack, quote, isMultiline);
    if (stack != null) newStack.previous = stack;
    return newStack;
  }
}

/**
 * The base class for our tokenizer. The hand coded parts are in this file, with
 * the generated parts in the subclass Tokenizer.
 */
class TokenizerBase extends TokenizerHelpers {
  final SourceFile _source;
  final bool _skipWhitespace;
  String _text;

  int _index;
  int _startIndex;

  /** Keeps track of string interpolation state. */
  InterpStack _interpStack;

  TokenizerBase(this._source, this._skipWhitespace, [this._index = 0]) {
    _text = _source.text;
  }

  abstract Token next();
  abstract int getIdentifierKind();

  int _nextChar() {
    if (_index < _text.length) {
      return _text.charCodeAt(_index++);
    } else {
      return 0;
    }
  }

  int _peekChar() {
    if (_index < _text.length) {
      return _text.charCodeAt(_index);
    } else {
      return 0;
    }
  }

  bool _maybeEatChar(int ch) {
    if (_index < _text.length) {
      if (_text.charCodeAt(_index) == ch) {
        _index++;
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }

  String _tokenText() {
    if (_index < _text.length) {
      return _text.substring(_startIndex, _index);
    } else {
      return _text.substring(_startIndex, _text.length);
    }
  }

  Token _finishToken(int kind) {
    return new Token(kind, _source, _startIndex, _index);
  }

  // TODO(jmesserly): we need a way to emit human readable error messages from
  // the tokenizer.
  Token _errorToken() {
    return _finishToken(TokenKind.ERROR);
  }

  Token nextFromPreviousLine(int kind) {
    _startIndex = _index;

    switch(kind) {
      case TokenKind.INCOMPLETE_COMMENT:
        return finishMultiLineComment();
      case TokenKind.INCOMPLETE_MULTILINE_STRING_DQ:
        return finishMultilineString(34/*"*/);
      case TokenKind.INCOMPLETE_MULTILINE_STRING_SQ:
        return finishMultilineString(39/*'*/);
      default:
        return next();
    }
  }

  Token finishWhitespace() {
    _index--;
    while (_index < _text.length) {
      final ch = _text.charCodeAt(_index++);
      if (ch == 32/*' '*/ || ch == 9/*'\t'*/ || ch == 13/*'\r'*/) {
        // do nothing
      } else if (ch == 10/*'\n'*/) {
        if (!_skipWhitespace) {
          return _finishToken(TokenKind.WHITESPACE); // note the newline?
        }
      } else {
        _index--;
        if (_skipWhitespace) {
          return next();
        } else {
          return _finishToken(TokenKind.WHITESPACE);
        }
      }

    }
    return _finishToken(TokenKind.END_OF_FILE);
  }

  Token finishHashBang() {
    while (true) {
      int ch = _nextChar();
      if (ch == 0 || ch == 10/*'\n'*/ || ch == 13/*'\r'*/) {
        return _finishToken(TokenKind.HASHBANG);
      }
    }
  }

  Token finishSingleLineComment() {
    while (true) {
      int ch = _nextChar();
      if (ch == 0 || ch == 10/*'\n'*/ || ch == 13/*'\r'*/) {
        if (_skipWhitespace) {
          return next();
        } else {
          return _finishToken(TokenKind.COMMENT);
        }
      }
    }
  }

  Token finishMultiLineComment() {
    while (true) {
      int ch = _nextChar();
      if (ch == 0) {
        return _finishToken(TokenKind.INCOMPLETE_COMMENT);
      } else if (ch == 42/*'*'*/) {
        if (_maybeEatChar(47/*'/'*/)) {
          if (_skipWhitespace) {
            return next();
          } else {
            return _finishToken(TokenKind.COMMENT);
          }
        }
      }
    }
    return _errorToken();
  }

  void eatDigits() {
    while (_index < _text.length) {
      if (isDigit(_text.charCodeAt(_index))) {
        _index++;
      } else {
        return;
      }
    }
  }

  void eatHexDigits() {
    while (_index < _text.length) {
     if (isHexDigit(_text.charCodeAt(_index))) {
       _index++;
     } else {
       return;
     }
    }
  }

  bool maybeEatHexDigit() {
    if (_index < _text.length && isHexDigit(_text.charCodeAt(_index))) {
      _index++;
      return true;
    }
    return false;
  }

  Token finishHex() {
    eatHexDigits();
    return _finishToken(TokenKind.HEX_INTEGER);
  }

  Token finishNumber() {
    eatDigits();

    if (_peekChar() == 46/*.*/) {
      // Handle the case of 1.toString().
      _nextChar();
      if (isDigit(_peekChar())) {
        eatDigits();
        return finishNumberExtra(TokenKind.DOUBLE);
      } else {
        _index--;
      }
    }

    return finishNumberExtra(TokenKind.INTEGER);
  }

  Token finishNumberExtra(int kind) {
    if (_maybeEatChar(101/*e*/) || _maybeEatChar(69/*E*/)) {
      kind = TokenKind.DOUBLE;
      _maybeEatChar(45/*-*/);
      _maybeEatChar(43/*+*/);
      eatDigits();
    }
    if (_peekChar() != 0 && isIdentifierStart(_peekChar())) {
      _nextChar();
      // numbers cannot contain identifiers
      return _errorToken();
    }

    return _finishToken(kind);
  }

  Token finishMultilineString(int quote) {
    while (true) {
      int ch = _nextChar();
      if (ch == 0) {
        final kind = quote == 34/*"*/ ?
            TokenKind.INCOMPLETE_MULTILINE_STRING_DQ :
            TokenKind.INCOMPLETE_MULTILINE_STRING_SQ;
        return _finishToken(kind);
      } else if (ch == quote) {
        if (_maybeEatChar(quote)) {
          if (_maybeEatChar(quote)) {
            return _finishToken(TokenKind.STRING);
          }
        }
      } else if (ch == 36/*$*/) {
        // start of string interp
        _interpStack = InterpStack.push(_interpStack, quote, true);
        return _finishToken(TokenKind.INCOMPLETE_STRING); // TODO
      } else if (ch == 92/*\*/) {
        if (!eatEscapeSequence()) {
          // invalid hex escape sequence
          return _errorToken();
        }
      }
    }
  }

  Token _finishOpenBrace() {
    if (_interpStack != null) {
      if (_interpStack.depth == -1) {
        _interpStack.depth = 1;
      } else {
        assert(_interpStack.depth >= 0);
        _interpStack.depth += 1;
      }
    }
    return _finishToken(TokenKind.LBRACE);
  }

  Token _finishCloseBrace() {
    if (_interpStack != null) {
      _interpStack.depth -= 1;
      assert(_interpStack.depth >= 0);
    }
    return _finishToken(TokenKind.RBRACE);
  }

  Token finishString(int quote) {
    if (_maybeEatChar(quote)) {
      if (_maybeEatChar(quote)) {
        return finishMultilineString(quote);
      } else {
        return _finishToken(TokenKind.STRING);
      }
    }
    return finishStringBody(quote);
  }

  Token finishRawString(int quote) {
    if (_maybeEatChar(quote)) {
      if (_maybeEatChar(quote)) {
        return finishMultilineRawString(quote);
      } else {
        return _finishToken(TokenKind.STRING);
      }
    }
    while (true) {
      int ch = _nextChar();
      if (ch == quote) {
        return _finishToken(TokenKind.STRING);
      } else if (ch == 0) {
        return _finishToken(TokenKind.INCOMPLETE_STRING);
      }
    }
  }

  Token finishMultilineRawString(int quote) {
    while (true) {
      int ch = _nextChar();
      if (ch == 0) {
        final kind = quote == 34/*"*/ ?
            TokenKind.INCOMPLETE_MULTILINE_STRING_DQ :
            TokenKind.INCOMPLETE_MULTILINE_STRING_SQ;
        return _finishToken(kind);
      } else if (ch == quote && _maybeEatChar(quote) && _maybeEatChar(quote)) {
        return _finishToken(TokenKind.STRING);
      }
    }
  }

  Token finishStringBody(int quote) {
    while (true) {
      int ch = _nextChar();
      if (ch == quote) {
        return _finishToken(TokenKind.STRING);
      } else if (ch == 36/*$*/) {
        // start of string interp
        _interpStack = InterpStack.push(_interpStack, quote, false);
        return _finishToken(TokenKind.INCOMPLETE_STRING); // TODO
      } else if (ch == 0) {
        return _finishToken(TokenKind.INCOMPLETE_STRING);
      } else if (ch == 92/*\*/) {
        if (!eatEscapeSequence()) {
          // invalid hex escape sequence
          return _errorToken();
        }
      }
    }
  }

  bool eatEscapeSequence() {
    String hex;
    switch (_nextChar()) {
      case 120/*x*/:
        return maybeEatHexDigit() && maybeEatHexDigit();
      case 117/*u*/:
        if (_maybeEatChar(123/*{*/)) {
          int start = _index;
          eatHexDigits();
          int chars = _index - start;
          if (chars > 0 && chars <= 6 && _maybeEatChar(125/*}*/)) {
            hex = _text.substring(start, start + chars);
            break;
          } else {
            return false;
          }
        } else {
          if (maybeEatHexDigit() && maybeEatHexDigit() &&
              maybeEatHexDigit() && maybeEatHexDigit()) {
            hex = _text.substring(_index - 4, _index);
            break;
          } else {
            return false;
          }
        }
      default: return true;
    }
    // According to the Unicode standard the high and low surrogate halves
    // used by UTF-16 (U+D800 through U+DFFF) and values above U+10FFFF
    // are not legal Unicode values.
    num n = Parser.parseHex(hex);
    return n < 0xD800 || n > 0xDFFF && n <= 0x10FFFF;
  }

  Token finishDot() {
    if (isDigit(_peekChar())) {
      eatDigits();
      return finishNumberExtra(TokenKind.DOUBLE);
    } else {
      return _finishToken(TokenKind.DOT);
    }
  }

  Token finishIdentifier(int ch) {
    if (_interpStack != null && _interpStack.depth == -1) {
      _interpStack.depth = 0;
      if (ch == 36/*$*/) {
        // illegal character after $ in string interpolation
        return _errorToken();
      }
      while (_index < _text.length) {
        if (!isInterpIdentifierPart(_text.charCodeAt(_index++))) {
          _index--;
          break;
        }
      }
    } else {
      while (_index < _text.length) {
        if (!isIdentifierPart(_text.charCodeAt(_index++))) {
          _index--;
          break;
        }
      }
    }
    int kind = getIdentifierKind();
    if (kind == TokenKind.IDENTIFIER) {
      return _finishToken(TokenKind.IDENTIFIER);
    } else {
      return _finishToken(kind);
    }
  }
}
