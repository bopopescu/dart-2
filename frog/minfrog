#!/usr/bin/env node
//  ********** Library dart:core **************
//  ********** Natives dart:core **************
/**
 * Generates a dynamic call stub for a function.
 * Our goal is to create a stub method like this on-the-fly:
 *   function($0, $1, capture) { return this($0, $1, true, capture); }
 *
 * This stub then replaces the dynamic one on Function, with one that is
 * specialized for that particular function, taking into account its default
 * arguments.
 */
Function.prototype.$genStub = function(argsLength, names) {
  // Fast path: if no named arguments and arg count matches
  if (this.length == argsLength && !names) {
    return this;
  }

  function $throwArgMismatch() {
    // TODO(jmesserly): better error message
    $throw(new ClosureArgumentMismatchException());
  }

  var paramsNamed = this.$optional ? (this.$optional.length / 2) : 0;
  var paramsBare = this.length - paramsNamed;
  var argsNamed = names ? names.length : 0;
  var argsBare = argsLength - argsNamed;

  // Check we got the right number of arguments
  if (argsBare < paramsBare || argsLength > this.length ||
      argsNamed > paramsNamed) {
    return $throwArgMismatch;
  }

  // First, fill in all of the default values
  var p = new Array(paramsBare);
  if (paramsNamed) {
    p = p.concat(this.$optional.slice(paramsNamed));
  }
  // Fill in positional args
  var a = new Array(argsLength);
  for (var i = 0; i < argsBare; i++) {
    p[i] = a[i] = '$' + i;
  }
  // Then overwrite with supplied values for optional args
  var lastParameterIndex;
  var namesInOrder = true;
  for (var i = 0; i < argsNamed; i++) {
    var name = names[i];
    a[i + argsBare] = name;
    var j = this.$optional.indexOf(name);
    if (j < 0 || j >= paramsNamed) {
      return $throwArgMismatch;
    } else if (lastParameterIndex && lastParameterIndex > j) {
      namesInOrder = false;
    }
    p[j + paramsBare] = name;
    lastParameterIndex = j;
  }

  if (this.length == argsLength && namesInOrder) {
    // Fast path #2: named arguments, but they're in order.
    return this;
  }

  // Note: using Function instead of 'eval' to get a clean scope.
  // TODO(jmesserly): evaluate the performance of these stubs.
  var f = 'function(' + a.join(',') + '){return $f(' + p.join(',') + ');}';
  return new Function('$f', 'return ' + f + '').call(null, this);
}
function $throw(e) {
  // If e is not a value, we can use V8's captureStackTrace utility method.
  // TODO(jmesserly): capture the stack trace on other JS engines.
  if (e && (typeof e == 'object') && Error.captureStackTrace) {
    // TODO(jmesserly): this will clobber the e.stack property
    Error.captureStackTrace(e, $throw);
  }
  throw e;
}
Object.prototype.$index = function(i) { return this[i]; }
Array.prototype.$index = function(i) { return this[i]; }
String.prototype.$index = function(i) { return this[i]; }
Object.prototype.$setindex = function(i, value) { return this[i] = value; }
Array.prototype.$setindex = function(i, value) { return this[i] = value; }
function $eq(x, y) {
  if (x == null) return y == null;
  return (typeof(x) == 'number' && typeof(y) == 'number') ||
         (typeof(x) == 'boolean' && typeof(y) == 'boolean') ||
         (typeof(x) == 'string' && typeof(y) == 'string')
    ? x == y : x.$eq(y);
}
// TODO(jimhug): Should this or should it not match equals?
Object.prototype.$eq = function(other) { return this === other; }
function $mod(x, y) {
  if (typeof(x) == 'number' && typeof(y) == 'number') {
    var result = x % y;
    if (result == 0) {
      return 0;  // Make sure we don't return -0.0.
    } else if (result < 0) {
      if (y < 0) {
        return result - y;
      } else {
        return result + y;
      }
    }
    return result;
  } else {
    return x.$mod(y);
  }
}
function $ne(x, y) {
  if (x == null) return y != null;
  return (typeof(x) == 'number' && typeof(y) == 'number') ||
         (typeof(x) == 'boolean' && typeof(y) == 'boolean') ||
         (typeof(x) == 'string' && typeof(y) == 'string')
    ? x != y : !x.$eq(y);
}
function $truncdiv(x, y) {
  if (typeof(x) == 'number' && typeof(y) == 'number') {
    if (y == 0) $throw(new IntegerDivisionByZeroException());
    var tmp = x / y;
    return (tmp < 0) ? Math.ceil(tmp) : Math.floor(tmp);
  } else {
    return x.$truncdiv(y);
  }
}
// ********** Code for Clock **************
function Clock() {}
Clock.now = function() {
  return new Date().getTime();
}
Clock.frequency = function() {
  return 1000;
}
// ********** Code for Object **************
Object.prototype.get$dynamic = function() {
  return this;
}
Object.prototype.noSuchMethod = function(name, args) {
  $throw(new NoSuchMethodException(this, name, args));
}
Object.prototype._checkExtends$0 = function() {
  return this.noSuchMethod("_checkExtends", []);
};
Object.prototype._checkNonStatic$1 = function($0) {
  return this.noSuchMethod("_checkNonStatic", [$0]);
};
Object.prototype._get$3 = function($0, $1, $2) {
  return this.noSuchMethod("_get", [$0, $1, $2]);
};
Object.prototype._get$3$isDynamic = function($0, $1, $2, isDynamic) {
  return this.noSuchMethod("_get", [$0, $1, $2, isDynamic]);
};
Object.prototype._get$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("_get", [$0, $1, $2, $3]);
};
Object.prototype._set$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("_set", [$0, $1, $2, $3]);
};
Object.prototype._set$4$isDynamic = function($0, $1, $2, $3, isDynamic) {
  return this.noSuchMethod("_set", [$0, $1, $2, $3, isDynamic]);
};
Object.prototype._set$5 = function($0, $1, $2, $3, $4) {
  return this.noSuchMethod("_set", [$0, $1, $2, $3, $4]);
};
Object.prototype._wrapDomCallback$2 = function($0, $1) {
  return this.noSuchMethod("_wrapDomCallback", [$0, $1]);
};
Object.prototype.add$1 = function($0) {
  return this.noSuchMethod("add", [$0]);
};
Object.prototype.addAll$1 = function($0) {
  return this.noSuchMethod("addAll", [$0]);
};
Object.prototype.addDirectSubtype$1 = function($0) {
  return this.noSuchMethod("addDirectSubtype", [$0]);
};
Object.prototype.addMethod$2 = function($0, $1) {
  return this.noSuchMethod("addMethod", [$0, $1]);
};
Object.prototype.addSource$1 = function($0) {
  return this.noSuchMethod("addSource", [$0]);
};
Object.prototype.block$0 = function() {
  return this.noSuchMethod("block", []);
};
Object.prototype.canInvoke$2 = function($0, $1) {
  return this.noSuchMethod("canInvoke", [$0, $1]);
};
Object.prototype.checkFirstClass$1 = function($0) {
  return this.noSuchMethod("checkFirstClass", [$0]);
};
Object.prototype.compareTo$1 = function($0) {
  return this.noSuchMethod("compareTo", [$0]);
};
Object.prototype.computeValue$0 = function() {
  return this.noSuchMethod("computeValue", []);
};
Object.prototype.contains$1 = function($0) {
  return this.noSuchMethod("contains", [$0]);
};
Object.prototype.containsKey$1 = function($0) {
  return this.noSuchMethod("containsKey", [$0]);
};
Object.prototype.convertTo$3 = function($0, $1, $2) {
  return this.noSuchMethod("convertTo", [$0, $1, $2]);
};
Object.prototype.convertTo$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("convertTo", [$0, $1, $2, $3]);
};
Object.prototype.copyWithNewType$2 = function($0, $1) {
  return this.noSuchMethod("copyWithNewType", [$0, $1]);
};
Object.prototype.end$0 = function() {
  return this.noSuchMethod("end", []);
};
Object.prototype.endsWith$1 = function($0) {
  return this.noSuchMethod("endsWith", [$0]);
};
Object.prototype.ensureSubtypeOf$3 = function($0, $1, $2) {
  return this.noSuchMethod("ensureSubtypeOf", [$0, $1, $2]);
};
Object.prototype.every$1 = function($0) {
  return this.noSuchMethod("every", [$0]);
};
Object.prototype.filter$1 = function($0) {
  return this.noSuchMethod("filter", [$0]);
};
Object.prototype.findTypeByName$1 = function($0) {
  return this.noSuchMethod("findTypeByName", [$0]);
};
Object.prototype.forEach$1 = function($0) {
  return this.noSuchMethod("forEach", [$0]);
};
Object.prototype.genValue$2 = function($0, $1) {
  return this.noSuchMethod("genValue", [$0, $1]);
};
Object.prototype.generate$1 = function($0) {
  return this.noSuchMethod("generate", [$0]);
};
Object.prototype.getColumn$2 = function($0, $1) {
  return this.noSuchMethod("getColumn", [$0, $1]);
};
Object.prototype.getConstructor$1 = function($0) {
  return this.noSuchMethod("getConstructor", [$0]);
};
Object.prototype.getFactory$2 = function($0, $1) {
  return this.noSuchMethod("getFactory", [$0, $1]);
};
Object.prototype.getKeys$0 = function() {
  return this.noSuchMethod("getKeys", []);
};
Object.prototype.getLine$1 = function($0) {
  return this.noSuchMethod("getLine", [$0]);
};
Object.prototype.getMember$1 = function($0) {
  return this.noSuchMethod("getMember", [$0]);
};
Object.prototype.getOrMakeConcreteType$1 = function($0) {
  return this.noSuchMethod("getOrMakeConcreteType", [$0]);
};
Object.prototype.getValues$0 = function() {
  return this.noSuchMethod("getValues", []);
};
Object.prototype.get_$3 = function($0, $1, $2) {
  return this.noSuchMethod("get_", [$0, $1, $2]);
};
Object.prototype.hasNext$0 = function() {
  return this.noSuchMethod("hasNext", []);
};
Object.prototype.hashCode$0 = function() {
  return this.noSuchMethod("hashCode", []);
};
Object.prototype.indexOf$1 = function($0) {
  return this.noSuchMethod("indexOf", [$0]);
};
Object.prototype.instanceOf$3$isTrue$forceCheck = function($0, $1, $2, isTrue, forceCheck) {
  return this.noSuchMethod("instanceOf", [$0, $1, $2, isTrue, forceCheck]);
};
Object.prototype.instanceOf$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("instanceOf", [$0, $1, $2, $3]);
};
Object.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("invoke", [$0, $1, $2, $3]);
};
Object.prototype.invoke$4$isDynamic = function($0, $1, $2, $3, isDynamic) {
  return this.noSuchMethod("invoke", [$0, $1, $2, $3, isDynamic]);
};
Object.prototype.invoke$5 = function($0, $1, $2, $3, $4) {
  return this.noSuchMethod("invoke", [$0, $1, $2, $3, $4]);
};
Object.prototype.is$List = function() {
  return false;
};
Object.prototype.is$RegExp = function() {
  return false;
};
Object.prototype.isAssignable$1 = function($0) {
  return this.noSuchMethod("isAssignable", [$0]);
};
Object.prototype.isEmpty$0 = function() {
  return this.noSuchMethod("isEmpty", []);
};
Object.prototype.isSubtypeOf$1 = function($0) {
  return this.noSuchMethod("isSubtypeOf", [$0]);
};
Object.prototype.iterator$0 = function() {
  return this.noSuchMethod("iterator", []);
};
Object.prototype.last$0 = function() {
  return this.noSuchMethod("last", []);
};
Object.prototype.markUsed$0 = function() {
  return this.noSuchMethod("markUsed", []);
};
Object.prototype.namesInOrder$1 = function($0) {
  return this.noSuchMethod("namesInOrder", [$0]);
};
Object.prototype.needsConversion$1 = function($0) {
  return this.noSuchMethod("needsConversion", [$0]);
};
Object.prototype.next$0 = function() {
  return this.noSuchMethod("next", []);
};
Object.prototype.provideFieldSyntax$0 = function() {
  return this.noSuchMethod("provideFieldSyntax", []);
};
Object.prototype.providePropertySyntax$0 = function() {
  return this.noSuchMethod("providePropertySyntax", []);
};
Object.prototype.removeLast$0 = function() {
  return this.noSuchMethod("removeLast", []);
};
Object.prototype.replaceAll$2 = function($0, $1) {
  return this.noSuchMethod("replaceAll", [$0, $1]);
};
Object.prototype.replaceFirst$2 = function($0, $1) {
  return this.noSuchMethod("replaceFirst", [$0, $1]);
};
Object.prototype.resolve$0 = function() {
  return this.noSuchMethod("resolve", []);
};
Object.prototype.resolveTypeParams$1 = function($0) {
  return this.noSuchMethod("resolveTypeParams", [$0]);
};
Object.prototype.setDefinition$1 = function($0) {
  return this.noSuchMethod("setDefinition", [$0]);
};
Object.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("set_", [$0, $1, $2, $3]);
};
Object.prototype.some$1 = function($0) {
  return this.noSuchMethod("some", [$0]);
};
Object.prototype.sort$1 = function($0) {
  return this.noSuchMethod("sort", [$0]);
};
Object.prototype.start$0 = function() {
  return this.noSuchMethod("start", []);
};
Object.prototype.startsWith$1 = function($0) {
  return this.noSuchMethod("startsWith", [$0]);
};
Object.prototype.substring$1 = function($0) {
  return this.noSuchMethod("substring", [$0]);
};
Object.prototype.substring$2 = function($0, $1) {
  return this.noSuchMethod("substring", [$0, $1]);
};
Object.prototype.toString$0 = function() {
  return this.toString();
};
Object.prototype.visit$1 = function($0) {
  return this.noSuchMethod("visit", [$0]);
};
Object.prototype.visitBinaryExpression$1 = function($0) {
  return this.noSuchMethod("visitBinaryExpression", [$0]);
};
Object.prototype.visitPostfixExpression$1 = function($0) {
  return this.noSuchMethod("visitPostfixExpression", [$0]);
};
Object.prototype.visitSources$0 = function() {
  return this.noSuchMethod("visitSources", []);
};
Object.prototype.writeDefinition$2 = function($0, $1) {
  return this.noSuchMethod("writeDefinition", [$0, $1]);
};
// ********** Code for NoSuchMethodException **************
function NoSuchMethodException(_receiver, _functionName, _arguments) {
  this._receiver = _receiver;
  this._functionName = _functionName;
  this._arguments = _arguments;
  // Initializers done
}
NoSuchMethodException.prototype.toString = function() {
  var sb = new StringBufferImpl("");
  for (var i = 0;
   i < this._arguments.length; i++) {
    if (i > 0) {
      sb.add(", ");
    }
    sb.add(this._arguments.$index(i));
  }
  sb.add("]");
  return ("NoSuchMethodException - receiver: '" + this._receiver + "' ") + ("function name: '" + this._functionName + "' arguments: [" + sb + "]");
}
NoSuchMethodException.prototype.toString$0 = NoSuchMethodException.prototype.toString;
// ********** Code for ObjectNotClosureException **************
function ObjectNotClosureException() {
  // Initializers done
}
ObjectNotClosureException.prototype.toString = function() {
  return "Object is not closure";
}
ObjectNotClosureException.prototype.toString$0 = ObjectNotClosureException.prototype.toString;
// ********** Code for StackOverflowException **************
function StackOverflowException() {
  // Initializers done
}
StackOverflowException.prototype.toString = function() {
  return "Stack Overflow";
}
StackOverflowException.prototype.toString$0 = StackOverflowException.prototype.toString;
// ********** Code for BadNumberFormatException **************
function BadNumberFormatException() {}
BadNumberFormatException.prototype.toString = function() {
  return ("BadNumberFormatException: '" + this._s + "'");
}
BadNumberFormatException.prototype.toString$0 = BadNumberFormatException.prototype.toString;
// ********** Code for NullPointerException **************
function NullPointerException() {
  // Initializers done
}
NullPointerException.prototype.toString = function() {
  return "NullPointerException";
}
NullPointerException.prototype.toString$0 = NullPointerException.prototype.toString;
// ********** Code for NoMoreElementsException **************
function NoMoreElementsException() {
  // Initializers done
}
NoMoreElementsException.prototype.toString = function() {
  return "NoMoreElementsException";
}
NoMoreElementsException.prototype.toString$0 = NoMoreElementsException.prototype.toString;
// ********** Code for EmptyQueueException **************
function EmptyQueueException() {
  // Initializers done
}
EmptyQueueException.prototype.toString = function() {
  return "EmptyQueueException";
}
EmptyQueueException.prototype.toString$0 = EmptyQueueException.prototype.toString;
// ********** Code for Function **************
Function.prototype.to$call$0 = function() {
  this.call$0 = this.$genStub(0);
  this.to$call$0 = function() { return this.call$0; };
  return this.call$0;
};
Function.prototype.call$0 = function() {
  return this.to$call$0()();
};
function to$call$0(f) { return f && f.to$call$0(); }
Function.prototype.to$call$1 = function() {
  this.call$1 = this.$genStub(1);
  this.to$call$1 = function() { return this.call$1; };
  return this.call$1;
};
Function.prototype.call$1 = function($0) {
  return this.to$call$1()($0);
};
function to$call$1(f) { return f && f.to$call$1(); }
Function.prototype.to$call$2 = function() {
  this.call$2 = this.$genStub(2);
  this.to$call$2 = function() { return this.call$2; };
  return this.call$2;
};
Function.prototype.call$2 = function($0, $1) {
  return this.to$call$2()($0, $1);
};
function to$call$2(f) { return f && f.to$call$2(); }
// ********** Code for Math **************
Math.parseInt = function(str) {
  var ret = parseInt(str);
    if (isNaN(ret)) $throw(new BadNumberFormatException(str));
    return ret;
}
Math.parseDouble = function(str) {
  var ret = parseFloat(str);
    if (isNaN(ret) && str != 'NaN') $throw(new BadNumberFormatException(str));
    return ret;
}
Math.min = function(a, b) {
  if (a == b) return a;
    if (a < b) {
      if (isNaN(b)) return b;
      else return a;
    }
    if (isNaN(a)) return a;
    else return b;
}
// ********** Code for Strings **************
function Strings() {}
Strings.join = function(strings, separator) {
  return StringBase.join(strings, separator);
}
// ********** Code for top level **************
function print(obj) {
  return _print(obj);
}
function _print(obj) {
  if (typeof console == 'object') {
    if (obj) obj = obj.toString();
    console.log(obj);
  } else {
    write(obj);
    write('\n');
  }
}
function _map(itemsAndKeys) {
  var ret = new LinkedHashMapImplementation();
  for (var i = 0;
   i < itemsAndKeys.length; ) {
    ret.$setindex(itemsAndKeys.$index(i++), itemsAndKeys.$index(i++));
  }
  return ret;
}
function _toDartException(e) {
  function attachStack(dartEx) {
    // TODO(jmesserly): setting the stack property is not a long term solution.
    var stack = e.stack;
    // The stack contains the error message, and the stack is all that is
    // printed (the exception's toString() is never called).  Make the Dart
    // exception's toString() be the dominant message.
    if (typeof stack == 'string') {
      var message = dartEx.toString();
      if (/^(Type|Range)Error:/.test(stack)) {
        // Indent JS message (it can be helpful) so new message stands out.
        stack = '    (' + stack.substring(0, stack.indexOf('\n')) + ')\n' +
                stack.substring(stack.indexOf('\n') + 1);
      }
      stack = message + '\n' + stack;
    }
    dartEx.stack = stack;
    return dartEx;
  }

  if (e instanceof TypeError) {
    switch(e.type) {
      case 'property_not_function':
      case 'called_non_callable':
        if (e.arguments[0] == null) {
          return attachStack(new NullPointerException());
        } else {
          return attachStack(new ObjectNotClosureException());
        }
        break;
      case 'non_object_property_call':
      case 'non_object_property_load':
        return attachStack(new NullPointerException());
        break;
      case 'undefined_method':
        var mname = e.arguments[0];
        if (typeof(mname) == 'string' && (mname.indexOf('call$') == 0
            || mname == 'call' || mname == 'apply')) {
          return attachStack(new ObjectNotClosureException());
        } else {
          // TODO(jmesserly): fix noSuchMethod on operators so we don't hit this
          return attachStack(new NoSuchMethodException('', e.arguments[0], []));
        }
        break;
    }
  } else if (e instanceof RangeError) {
    if (e.message.indexOf('call stack') >= 0) {
      return attachStack(new StackOverflowException());
    }
  }
  return e;
}
//  ********** Library dart:coreimpl **************
// ********** Code for ListFactory **************
ListFactory = Array;
ListFactory.prototype.is$List = function(){return true};
ListFactory.ListFactory$from$factory = function(other) {
  var list = [];
  for (var $$i = other.iterator(); $$i.hasNext$0(); ) {
    var e = $$i.next$0();
    list.add(e);
  }
  return list;
}
ListFactory.prototype.add = function(value) {
  this.push(value);
}
ListFactory.prototype.addLast = function(value) {
  this.push(value);
}
ListFactory.prototype.addAll = function(collection) {
  for (var $$i = collection.iterator(); $$i.hasNext$0(); ) {
    var item = $$i.next$0();
    this.add(item);
  }
}
ListFactory.prototype.clear = function() {
  this.length = 0;
}
ListFactory.prototype.removeLast = function() {
  return this.pop();
}
ListFactory.prototype.last = function() {
  return this[this.length - 1];
}
ListFactory.prototype.getRange = function(start, length) {
  return this.slice(start, start + length);
}
ListFactory.prototype.isEmpty = function() {
  return this.length == 0;
}
ListFactory.prototype.iterator = function() {
  return new ListIterator(this);
}
ListFactory.prototype.add$1 = ListFactory.prototype.add;
ListFactory.prototype.addAll$1 = ListFactory.prototype.addAll;
ListFactory.prototype.every$1 = function($0) {
  return this.every(to$call$1($0));
};
ListFactory.prototype.filter$1 = function($0) {
  return this.filter(to$call$1($0));
};
ListFactory.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$1($0));
};
ListFactory.prototype.indexOf$1 = ListFactory.prototype.indexOf;
ListFactory.prototype.isEmpty$0 = ListFactory.prototype.isEmpty;
ListFactory.prototype.iterator$0 = ListFactory.prototype.iterator;
ListFactory.prototype.last$0 = ListFactory.prototype.last;
ListFactory.prototype.removeLast$0 = ListFactory.prototype.removeLast;
ListFactory.prototype.some$1 = function($0) {
  return this.some(to$call$1($0));
};
ListFactory.prototype.sort$1 = function($0) {
  return this.sort(to$call$2($0));
};
ListFactory_E = ListFactory;
ListFactory_K = ListFactory;
ListFactory_String = ListFactory;
ListFactory_V = ListFactory;
// ********** Code for ListIterator **************
function ListIterator(array) {
  this._array = array;
  this._dart_coreimpl_pos = 0;
  // Initializers done
}
ListIterator.prototype.hasNext = function() {
  return this._array.length > this._dart_coreimpl_pos;
}
ListIterator.prototype.next = function() {
  if (!this.hasNext()) {
    $throw(const$0/*const NoMoreElementsException()*/);
  }
  return this._array.$index(this._dart_coreimpl_pos++);
}
ListIterator.prototype.hasNext$0 = ListIterator.prototype.hasNext;
ListIterator.prototype.next$0 = ListIterator.prototype.next;
// ********** Code for NumImplementation **************
NumImplementation = Number;
NumImplementation.prototype.isNaN = function() {
  return isNaN(this);
}
NumImplementation.prototype.isNegative = function() {
  return this == 0 ? (1 / this) < 0 : this < 0;
}
NumImplementation.prototype.hashCode = function() {
  return this & 0xFFFFFFF;
}
NumImplementation.prototype.toInt = function() {
  if (isNaN(this)) throw new BadNumberFormatException("NaN");
    if ((this == Infinity) || (this == -Infinity)) {
      throw new BadNumberFormatException("Infinity");
    }
    var truncated = (this < 0) ? Math.ceil(this) : Math.floor(this);

    if (truncated == -0.0) return 0;
    return truncated;
}
NumImplementation.prototype.toDouble = function() {
  return this + 0;
}
NumImplementation.prototype.compareTo = function(other) {
  var thisValue = this.toDouble();
  if (thisValue < other) {
    return -1;
  }
  else if (thisValue > other) {
    return 1;
  }
  else if (thisValue == other) {
    if (thisValue == 0) {
      var thisIsNegative = this.isNegative();
      var otherIsNegative = other.isNegative();
      if ($eq(thisIsNegative, otherIsNegative)) return 0;
      if (thisIsNegative) return -1;
      return 1;
    }
    return 0;
  }
  else if (this.isNaN()) {
    if (other.isNaN()) {
      return 0;
    }
    return 1;
  }
  else {
    return -1;
  }
}
NumImplementation.prototype.compareTo$1 = NumImplementation.prototype.compareTo;
NumImplementation.prototype.hashCode$0 = NumImplementation.prototype.hashCode;
// ********** Code for HashMapImplementation **************
function HashMapImplementation() {
  // Initializers done
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
HashMapImplementation.HashMapImplementation$from$factory = function(other) {
  var result = new HashMapImplementation();
  other.forEach((function (key, value) {
    result.$setindex(key, value);
  })
  );
  return result;
}
HashMapImplementation._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
HashMapImplementation._firstProbe = function(hashCode, length) {
  return hashCode & (length - 1);
}
HashMapImplementation._nextProbe = function(currentProbe, numberOfProbes, length) {
  return (currentProbe + numberOfProbes) & (length - 1);
}
HashMapImplementation.prototype._probeForAdding = function(key) {
  var hash = HashMapImplementation._firstProbe(key.hashCode$0(), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  var insertionIndex = -1;
  while (true) {
    var existingKey = this._keys.$index(hash);
    if (existingKey == null) {
      if (insertionIndex < 0) return hash;
      return insertionIndex;
    }
    else if ($eq(existingKey, key)) {
      return hash;
    }
    else if ((insertionIndex < 0) && (const$3/*HashMapImplementation._DELETED_KEY*/ === existingKey)) {
      insertionIndex = hash;
    }
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation.prototype._probeForLookup = function(key) {
  var hash = HashMapImplementation._firstProbe(key.hashCode$0(), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  while (true) {
    var existingKey = this._keys.$index(hash);
    if (existingKey == null) return -1;
    if ($eq(existingKey, key)) return hash;
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation.prototype._ensureCapacity = function() {
  var newNumberOfEntries = this._numberOfEntries + 1;
  if (newNumberOfEntries >= this._loadLimit) {
    this._grow(this._keys.length * 2);
    return;
  }
  var capacity = this._keys.length;
  var numberOfFreeOrDeleted = capacity - newNumberOfEntries;
  var numberOfFree = numberOfFreeOrDeleted - this._numberOfDeleted;
  if (this._numberOfDeleted > numberOfFree) {
    this._grow(this._keys.length);
  }
}
HashMapImplementation._isPowerOfTwo = function(x) {
  return ((x & (x - 1)) == 0);
}
HashMapImplementation.prototype._grow = function(newCapacity) {
  var capacity = this._keys.length;
  this._loadLimit = HashMapImplementation._computeLoadLimit(newCapacity);
  var oldKeys = this._keys;
  var oldValues = this._values;
  this._keys = new ListFactory(newCapacity);
  this._values = new ListFactory(newCapacity);
  for (var i = 0;
   i < capacity; i++) {
    var key = oldKeys.$index(i);
    if (key == null || key === const$3/*HashMapImplementation._DELETED_KEY*/) {
      continue;
    }
    var value = oldValues.$index(i);
    var newIndex = this._probeForAdding(key);
    this._keys.$setindex(newIndex, key);
    this._values.$setindex(newIndex, value);
  }
  this._numberOfDeleted = 0;
}
HashMapImplementation.prototype.$setindex = function(key, value) {
  this._ensureCapacity();
  var index = this._probeForAdding(key);
  if ((this._keys.$index(index) == null) || (this._keys.$index(index) === const$3/*HashMapImplementation._DELETED_KEY*/)) {
    this._numberOfEntries++;
  }
  this._keys.$setindex(index, key);
  this._values.$setindex(index, value);
}
HashMapImplementation.prototype.$index = function(key) {
  var index = this._probeForLookup(key);
  if (index < 0) return null;
  return this._values.$index(index);
}
HashMapImplementation.prototype.remove = function(key) {
  var index = this._probeForLookup(key);
  if (index >= 0) {
    this._numberOfEntries--;
    var value = this._values.$index(index);
    this._values.$setindex(index);
    this._keys.$setindex(index, const$3/*HashMapImplementation._DELETED_KEY*/);
    this._numberOfDeleted++;
    return value;
  }
  return null;
}
HashMapImplementation.prototype.isEmpty = function() {
  return this._numberOfEntries == 0;
}
HashMapImplementation.prototype.get$length = function() {
  return this._numberOfEntries;
}
Object.defineProperty(HashMapImplementation.prototype, "length", {
  get: HashMapImplementation.prototype.get$length
});
HashMapImplementation.prototype.forEach = function(f) {
  var length = this._keys.length;
  for (var i = 0;
   i < length; i++) {
    if ((this._keys.$index(i) != null) && (this._keys.$index(i) !== const$3/*HashMapImplementation._DELETED_KEY*/)) {
      f(this._keys.$index(i), this._values.$index(i));
    }
  }
}
HashMapImplementation.prototype.getKeys = function() {
  var list = new ListFactory(this.get$length());
  var i = 0;
  this.forEach(function _(key, value) {
    list.$setindex(i++, key);
  }
  );
  return list;
}
HashMapImplementation.prototype.getValues = function() {
  var list = new ListFactory(this.get$length());
  var i = 0;
  this.forEach(function _(key, value) {
    list.$setindex(i++, value);
  }
  );
  return list;
}
HashMapImplementation.prototype.containsKey = function(key) {
  return (this._probeForLookup(key) != -1);
}
HashMapImplementation.prototype.containsKey$1 = HashMapImplementation.prototype.containsKey;
HashMapImplementation.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$2($0));
};
HashMapImplementation.prototype.getKeys$0 = HashMapImplementation.prototype.getKeys;
HashMapImplementation.prototype.getValues$0 = HashMapImplementation.prototype.getValues;
HashMapImplementation.prototype.isEmpty$0 = HashMapImplementation.prototype.isEmpty;
// ********** Code for HashMapImplementation_E$E **************
function HashMapImplementation_E$E() {
  // Initializers done
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
/** Implements extends for Dart classes on JavaScript prototypes. */
function $inherits(child, parent) {
  if (child.prototype.__proto__) {
    child.prototype.__proto__ = parent.prototype;
  } else {
    function tmp() {};
    tmp.prototype = parent.prototype;
    child.prototype = new tmp();
    child.prototype.constructor = child;
  }
}
$inherits(HashMapImplementation_E$E, HashMapImplementation);
HashMapImplementation_E$E._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
HashMapImplementation_E$E._firstProbe = function(hashCode, length) {
  return hashCode & (length - 1);
}
HashMapImplementation_E$E._nextProbe = function(currentProbe, numberOfProbes, length) {
  return (currentProbe + numberOfProbes) & (length - 1);
}
HashMapImplementation_E$E.prototype._probeForAdding = function(key) {
  var hash = HashMapImplementation._firstProbe(key.hashCode$0(), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  var insertionIndex = -1;
  while (true) {
    var existingKey = this._keys.$index(hash);
    if (existingKey == null) {
      if (insertionIndex < 0) return hash;
      return insertionIndex;
    }
    else if ($eq(existingKey, key)) {
      return hash;
    }
    else if ((insertionIndex < 0) && (const$3/*HashMapImplementation._DELETED_KEY*/ === existingKey)) {
      insertionIndex = hash;
    }
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation_E$E.prototype._probeForLookup = function(key) {
  var hash = HashMapImplementation._firstProbe(key.hashCode$0(), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  while (true) {
    var existingKey = this._keys.$index(hash);
    if (existingKey == null) return -1;
    if ($eq(existingKey, key)) return hash;
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation_E$E.prototype._ensureCapacity = function() {
  var newNumberOfEntries = this._numberOfEntries + 1;
  if (newNumberOfEntries >= this._loadLimit) {
    this._grow(this._keys.length * 2);
    return;
  }
  var capacity = this._keys.length;
  var numberOfFreeOrDeleted = capacity - newNumberOfEntries;
  var numberOfFree = numberOfFreeOrDeleted - this._numberOfDeleted;
  if (this._numberOfDeleted > numberOfFree) {
    this._grow(this._keys.length);
  }
}
HashMapImplementation_E$E._isPowerOfTwo = function(x) {
  return ((x & (x - 1)) == 0);
}
HashMapImplementation_E$E.prototype._grow = function(newCapacity) {
  var capacity = this._keys.length;
  this._loadLimit = HashMapImplementation._computeLoadLimit(newCapacity);
  var oldKeys = this._keys;
  var oldValues = this._values;
  this._keys = new ListFactory(newCapacity);
  this._values = new ListFactory(newCapacity);
  for (var i = 0;
   i < capacity; i++) {
    var key = oldKeys.$index(i);
    if (key == null || key === const$3/*HashMapImplementation._DELETED_KEY*/) {
      continue;
    }
    var value = oldValues.$index(i);
    var newIndex = this._probeForAdding(key);
    this._keys.$setindex(newIndex, key);
    this._values.$setindex(newIndex, value);
  }
  this._numberOfDeleted = 0;
}
HashMapImplementation_E$E.prototype.$setindex = function(key, value) {
  this._ensureCapacity();
  var index = this._probeForAdding(key);
  if ((this._keys.$index(index) == null) || (this._keys.$index(index) === const$3/*HashMapImplementation._DELETED_KEY*/)) {
    this._numberOfEntries++;
  }
  this._keys.$setindex(index, key);
  this._values.$setindex(index, value);
}
HashMapImplementation_E$E.prototype.remove = function(key) {
  var index = this._probeForLookup(key);
  if (index >= 0) {
    this._numberOfEntries--;
    var value = this._values.$index(index);
    this._values.$setindex(index);
    this._keys.$setindex(index, const$3/*HashMapImplementation._DELETED_KEY*/);
    this._numberOfDeleted++;
    return value;
  }
  return null;
}
HashMapImplementation_E$E.prototype.isEmpty = function() {
  return this._numberOfEntries == 0;
}
HashMapImplementation_E$E.prototype.forEach = function(f) {
  var length = this._keys.length;
  for (var i = 0;
   i < length; i++) {
    if ((this._keys.$index(i) != null) && (this._keys.$index(i) !== const$3/*HashMapImplementation._DELETED_KEY*/)) {
      f(this._keys.$index(i), this._values.$index(i));
    }
  }
}
HashMapImplementation_E$E.prototype.getKeys = function() {
  var list = new ListFactory(this.get$length());
  var i = 0;
  this.forEach(function _(key, value) {
    list.$setindex(i++, key);
  }
  );
  return list;
}
HashMapImplementation_E$E.prototype.containsKey = function(key) {
  return (this._probeForLookup(key) != -1);
}
// ********** Code for HashMapImplementation_K$DoubleLinkedQueueEntry_KeyValuePair_K$V **************
function HashMapImplementation_K$DoubleLinkedQueueEntry_KeyValuePair_K$V() {}
$inherits(HashMapImplementation_K$DoubleLinkedQueueEntry_KeyValuePair_K$V, HashMapImplementation);
// ********** Code for HashMapImplementation_String$EvaluatedValue **************
function HashMapImplementation_String$EvaluatedValue() {}
$inherits(HashMapImplementation_String$EvaluatedValue, HashMapImplementation);
// ********** Code for HashSetImplementation **************
function HashSetImplementation() {
  // Initializers done
  this._backingMap = new HashMapImplementation_E$E();
}
HashSetImplementation.HashSetImplementation$from$factory = function(other) {
  var set = new HashSetImplementation();
  for (var $$i = other.iterator(); $$i.hasNext$0(); ) {
    var e = $$i.next$0();
    set.add(e);
  }
  return set;
}
HashSetImplementation.prototype.add = function(value) {
  this._backingMap.$setindex(value, value);
}
HashSetImplementation.prototype.contains = function(value) {
  return this._backingMap.containsKey(value);
}
HashSetImplementation.prototype.remove = function(value) {
  if (!this._backingMap.containsKey(value)) return false;
  this._backingMap.remove(value);
  return true;
}
HashSetImplementation.prototype.addAll = function(collection) {
  var $this = this; // closure support
  collection.forEach(function _(value) {
    $this.add(value);
  }
  );
}
HashSetImplementation.prototype.forEach = function(f) {
  this._backingMap.forEach(function _(key, value) {
    f(key);
  }
  );
}
HashSetImplementation.prototype.filter = function(f) {
  var result = new HashSetImplementation();
  this._backingMap.forEach(function _(key, value) {
    if (f(key)) result.add(key);
  }
  );
  return result;
}
HashSetImplementation.prototype.every = function(f) {
  var keys = this._backingMap.getKeys();
  return keys.every(f);
}
HashSetImplementation.prototype.some = function(f) {
  var keys = this._backingMap.getKeys();
  return keys.some(f);
}
HashSetImplementation.prototype.isEmpty = function() {
  return this._backingMap.isEmpty();
}
HashSetImplementation.prototype.get$length = function() {
  return this._backingMap.get$length();
}
Object.defineProperty(HashSetImplementation.prototype, "length", {
  get: HashSetImplementation.prototype.get$length
});
HashSetImplementation.prototype.iterator = function() {
  return new HashSetIterator_E(this);
}
HashSetImplementation.prototype.add$1 = HashSetImplementation.prototype.add;
HashSetImplementation.prototype.addAll$1 = HashSetImplementation.prototype.addAll;
HashSetImplementation.prototype.contains$1 = HashSetImplementation.prototype.contains;
HashSetImplementation.prototype.every$1 = function($0) {
  return this.every(to$call$1($0));
};
HashSetImplementation.prototype.filter$1 = function($0) {
  return this.filter(to$call$1($0));
};
HashSetImplementation.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$1($0));
};
HashSetImplementation.prototype.isEmpty$0 = HashSetImplementation.prototype.isEmpty;
HashSetImplementation.prototype.iterator$0 = HashSetImplementation.prototype.iterator;
HashSetImplementation.prototype.some$1 = function($0) {
  return this.some(to$call$1($0));
};
// ********** Code for HashSetImplementation_E **************
function HashSetImplementation_E() {}
$inherits(HashSetImplementation_E, HashSetImplementation);
// ********** Code for HashSetImplementation_String **************
function HashSetImplementation_String() {}
$inherits(HashSetImplementation_String, HashSetImplementation);
// ********** Code for HashSetImplementation_Type **************
function HashSetImplementation_Type() {}
$inherits(HashSetImplementation_Type, HashSetImplementation);
// ********** Code for HashSetIterator **************
function HashSetIterator(set_) {
  this._nextValidIndex = -1;
  this._entries = set_._backingMap._keys;
  // Initializers done
  this._advance();
}
HashSetIterator.prototype.hasNext = function() {
  if (this._nextValidIndex >= this._entries.length) return false;
  if (this._entries.$index(this._nextValidIndex) === const$3/*HashMapImplementation._DELETED_KEY*/) {
    this._advance();
  }
  return this._nextValidIndex < this._entries.length;
}
HashSetIterator.prototype.next = function() {
  if (!this.hasNext()) {
    $throw(const$0/*const NoMoreElementsException()*/);
  }
  var res = this._entries.$index(this._nextValidIndex);
  this._advance();
  return res;
}
HashSetIterator.prototype._advance = function() {
  var length = this._entries.length;
  var entry;
  var deletedKey = const$3/*HashMapImplementation._DELETED_KEY*/;
  do {
    if (++this._nextValidIndex >= length) break;
    entry = this._entries.$index(this._nextValidIndex);
  }
  while ((entry == null) || (entry === deletedKey))
}
HashSetIterator.prototype.hasNext$0 = HashSetIterator.prototype.hasNext;
HashSetIterator.prototype.next$0 = HashSetIterator.prototype.next;
// ********** Code for HashSetIterator_E **************
function HashSetIterator_E(set_) {
  this._nextValidIndex = -1;
  this._entries = set_._backingMap._keys;
  // Initializers done
  this._advance();
}
$inherits(HashSetIterator_E, HashSetIterator);
HashSetIterator_E.prototype._advance = function() {
  var length = this._entries.length;
  var entry;
  var deletedKey = const$3/*HashMapImplementation._DELETED_KEY*/;
  do {
    if (++this._nextValidIndex >= length) break;
    entry = this._entries.$index(this._nextValidIndex);
  }
  while ((entry == null) || (entry === deletedKey))
}
// ********** Code for _DeletedKeySentinel **************
function _DeletedKeySentinel() {
  // Initializers done
}
// ********** Code for KeyValuePair **************
function KeyValuePair(key, value) {
  this.key = key;
  this.value = value;
  // Initializers done
}
KeyValuePair.prototype.get$value = function() { return this.value; };
KeyValuePair.prototype.set$value = function(value) { return this.value = value; };
// ********** Code for KeyValuePair_K$V **************
function KeyValuePair_K$V(key, value) {
  this.key = key;
  this.value = value;
  // Initializers done
}
$inherits(KeyValuePair_K$V, KeyValuePair);
// ********** Code for LinkedHashMapImplementation **************
function LinkedHashMapImplementation() {
  // Initializers done
  this._map = new HashMapImplementation();
  this._list = new DoubleLinkedQueue_KeyValuePair_K$V();
}
LinkedHashMapImplementation.prototype.$setindex = function(key, value) {
  if (this._map.containsKey(key)) {
    this._map.$index(key).get$element().set$value(value);
  }
  else {
    this._list.addLast(new KeyValuePair_K$V(key, value));
    this._map.$setindex(key, this._list.lastEntry());
  }
}
LinkedHashMapImplementation.prototype.$index = function(key) {
  var entry = this._map.$index(key);
  if (entry == null) return null;
  return entry.get$element().get$value();
}
LinkedHashMapImplementation.prototype.getKeys = function() {
  var list = new ListFactory(this.get$length());
  var index = 0;
  this._list.forEach(function _(entry) {
    list.$setindex(index++, entry.key);
  }
  );
  return list;
}
LinkedHashMapImplementation.prototype.getValues = function() {
  var list = new ListFactory(this.get$length());
  var index = 0;
  this._list.forEach(function _(entry) {
    list.$setindex(index++, entry.value);
  }
  );
  return list;
}
LinkedHashMapImplementation.prototype.forEach = function(f) {
  this._list.forEach(function _(entry) {
    f(entry.key, entry.value);
  }
  );
}
LinkedHashMapImplementation.prototype.containsKey = function(key) {
  return this._map.containsKey(key);
}
LinkedHashMapImplementation.prototype.get$length = function() {
  return this._map.get$length();
}
Object.defineProperty(LinkedHashMapImplementation.prototype, "length", {
  get: LinkedHashMapImplementation.prototype.get$length
});
LinkedHashMapImplementation.prototype.isEmpty = function() {
  return this.get$length() == 0;
}
LinkedHashMapImplementation.prototype.containsKey$1 = LinkedHashMapImplementation.prototype.containsKey;
LinkedHashMapImplementation.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$2($0));
};
LinkedHashMapImplementation.prototype.getKeys$0 = LinkedHashMapImplementation.prototype.getKeys;
LinkedHashMapImplementation.prototype.getValues$0 = LinkedHashMapImplementation.prototype.getValues;
LinkedHashMapImplementation.prototype.isEmpty$0 = LinkedHashMapImplementation.prototype.isEmpty;
// ********** Code for DoubleLinkedQueueEntry **************
function DoubleLinkedQueueEntry(e) {
  // Initializers done
  this._element = e;
}
DoubleLinkedQueueEntry.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
DoubleLinkedQueueEntry.prototype.prepend = function(e) {
  new DoubleLinkedQueueEntry_E(e)._link(this._previous, this);
}
DoubleLinkedQueueEntry.prototype.remove = function() {
  this._previous._next = this._next;
  this._next._previous = this._previous;
  this._next = null;
  this._previous = null;
  return this._element;
}
DoubleLinkedQueueEntry.prototype._asNonSentinelEntry = function() {
  return this;
}
DoubleLinkedQueueEntry.prototype.previousEntry = function() {
  return this._previous._asNonSentinelEntry();
}
DoubleLinkedQueueEntry.prototype.get$element = function() {
  return this._element;
}
// ********** Code for DoubleLinkedQueueEntry_E **************
function DoubleLinkedQueueEntry_E(e) {
  // Initializers done
  this._element = e;
}
$inherits(DoubleLinkedQueueEntry_E, DoubleLinkedQueueEntry);
DoubleLinkedQueueEntry_E.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
DoubleLinkedQueueEntry_E.prototype.prepend = function(e) {
  new DoubleLinkedQueueEntry_E(e)._link(this._previous, this);
}
DoubleLinkedQueueEntry_E.prototype.remove = function() {
  this._previous._next = this._next;
  this._next._previous = this._previous;
  this._next = null;
  this._previous = null;
  return this._element;
}
DoubleLinkedQueueEntry_E.prototype._asNonSentinelEntry = function() {
  return this;
}
DoubleLinkedQueueEntry_E.prototype.previousEntry = function() {
  return this._previous._asNonSentinelEntry();
}
// ********** Code for DoubleLinkedQueueEntry_KeyValuePair_K$V **************
function DoubleLinkedQueueEntry_KeyValuePair_K$V(e) {
  // Initializers done
  this._element = e;
}
$inherits(DoubleLinkedQueueEntry_KeyValuePair_K$V, DoubleLinkedQueueEntry);
DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype.prepend = function(e) {
  new DoubleLinkedQueueEntry_KeyValuePair_K$V(e)._link(this._previous, this);
}
DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype._asNonSentinelEntry = function() {
  return this;
}
DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype.previousEntry = function() {
  return this._previous._asNonSentinelEntry();
}
// ********** Code for _DoubleLinkedQueueEntrySentinel **************
function _DoubleLinkedQueueEntrySentinel() {
  // Initializers done
  DoubleLinkedQueueEntry_E.call(this, null);
  this._link(this, this);
}
$inherits(_DoubleLinkedQueueEntrySentinel, DoubleLinkedQueueEntry_E);
_DoubleLinkedQueueEntrySentinel.prototype.remove = function() {
  $throw(const$2/*const EmptyQueueException()*/);
}
_DoubleLinkedQueueEntrySentinel.prototype._asNonSentinelEntry = function() {
  return null;
}
_DoubleLinkedQueueEntrySentinel.prototype.get$element = function() {
  $throw(const$2/*const EmptyQueueException()*/);
}
// ********** Code for _DoubleLinkedQueueEntrySentinel_E **************
function _DoubleLinkedQueueEntrySentinel_E() {
  // Initializers done
  DoubleLinkedQueueEntry_E.call(this, null);
  this._link(this, this);
}
$inherits(_DoubleLinkedQueueEntrySentinel_E, _DoubleLinkedQueueEntrySentinel);
// ********** Code for _DoubleLinkedQueueEntrySentinel_KeyValuePair_K$V **************
function _DoubleLinkedQueueEntrySentinel_KeyValuePair_K$V() {
  // Initializers done
  DoubleLinkedQueueEntry_KeyValuePair_K$V.call(this, null);
  this._link(this, this);
}
$inherits(_DoubleLinkedQueueEntrySentinel_KeyValuePair_K$V, _DoubleLinkedQueueEntrySentinel);
// ********** Code for DoubleLinkedQueue **************
function DoubleLinkedQueue() {
  // Initializers done
  this._sentinel = new _DoubleLinkedQueueEntrySentinel_E();
}
DoubleLinkedQueue.prototype.addLast = function(value) {
  this._sentinel.prepend(value);
}
DoubleLinkedQueue.prototype.add = function(value) {
  this.addLast(value);
}
DoubleLinkedQueue.prototype.addAll = function(collection) {
  for (var $$i = collection.iterator(); $$i.hasNext$0(); ) {
    var e = $$i.next$0();
    this.add(e);
  }
}
DoubleLinkedQueue.prototype.removeLast = function() {
  return this._sentinel._previous.remove();
}
DoubleLinkedQueue.prototype.last = function() {
  return this._sentinel._previous.get$element();
}
DoubleLinkedQueue.prototype.lastEntry = function() {
  return this._sentinel.previousEntry();
}
DoubleLinkedQueue.prototype.get$length = function() {
  var counter = 0;
  this.forEach(function _(element) {
    counter++;
  }
  );
  return counter;
}
Object.defineProperty(DoubleLinkedQueue.prototype, "length", {
  get: DoubleLinkedQueue.prototype.get$length
});
DoubleLinkedQueue.prototype.isEmpty = function() {
  return (this._sentinel._next === this._sentinel);
}
DoubleLinkedQueue.prototype.forEach = function(f) {
  var entry = this._sentinel._next;
  while (entry !== this._sentinel) {
    var nextEntry = entry._next;
    f(entry._element);
    entry = nextEntry;
  }
}
DoubleLinkedQueue.prototype.every = function(f) {
  var entry = this._sentinel._next;
  while (entry !== this._sentinel) {
    var nextEntry = entry._next;
    if (!f(entry._element)) return false;
    entry = nextEntry;
  }
  return true;
}
DoubleLinkedQueue.prototype.some = function(f) {
  var entry = this._sentinel._next;
  while (entry !== this._sentinel) {
    var nextEntry = entry._next;
    if (f(entry._element)) return true;
    entry = nextEntry;
  }
  return false;
}
DoubleLinkedQueue.prototype.filter = function(f) {
  var other = new DoubleLinkedQueue();
  var entry = this._sentinel._next;
  while (entry !== this._sentinel) {
    var nextEntry = entry._next;
    if (f(entry._element)) other.addLast(entry._element);
    entry = nextEntry;
  }
  return other;
}
DoubleLinkedQueue.prototype.iterator = function() {
  return new _DoubleLinkedQueueIterator_E(this._sentinel);
}
DoubleLinkedQueue.prototype.add$1 = DoubleLinkedQueue.prototype.add;
DoubleLinkedQueue.prototype.addAll$1 = DoubleLinkedQueue.prototype.addAll;
DoubleLinkedQueue.prototype.every$1 = function($0) {
  return this.every(to$call$1($0));
};
DoubleLinkedQueue.prototype.filter$1 = function($0) {
  return this.filter(to$call$1($0));
};
DoubleLinkedQueue.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$1($0));
};
DoubleLinkedQueue.prototype.isEmpty$0 = DoubleLinkedQueue.prototype.isEmpty;
DoubleLinkedQueue.prototype.iterator$0 = DoubleLinkedQueue.prototype.iterator;
DoubleLinkedQueue.prototype.last$0 = DoubleLinkedQueue.prototype.last;
DoubleLinkedQueue.prototype.removeLast$0 = DoubleLinkedQueue.prototype.removeLast;
DoubleLinkedQueue.prototype.some$1 = function($0) {
  return this.some(to$call$1($0));
};
// ********** Code for DoubleLinkedQueue_E **************
function DoubleLinkedQueue_E() {}
$inherits(DoubleLinkedQueue_E, DoubleLinkedQueue);
// ********** Code for DoubleLinkedQueue_KeyValuePair_K$V **************
function DoubleLinkedQueue_KeyValuePair_K$V() {
  // Initializers done
  this._sentinel = new _DoubleLinkedQueueEntrySentinel_KeyValuePair_K$V();
}
$inherits(DoubleLinkedQueue_KeyValuePair_K$V, DoubleLinkedQueue);
DoubleLinkedQueue_KeyValuePair_K$V.prototype.addLast = function(value) {
  this._sentinel.prepend(value);
}
DoubleLinkedQueue_KeyValuePair_K$V.prototype.lastEntry = function() {
  return this._sentinel.previousEntry();
}
DoubleLinkedQueue_KeyValuePair_K$V.prototype.forEach = function(f) {
  var entry = this._sentinel._next;
  while (entry !== this._sentinel) {
    var nextEntry = entry._next;
    f(entry._element);
    entry = nextEntry;
  }
}
// ********** Code for _DoubleLinkedQueueIterator **************
function _DoubleLinkedQueueIterator(_sentinel) {
  this._sentinel = _sentinel;
  // Initializers done
  this._currentEntry = this._sentinel;
}
_DoubleLinkedQueueIterator.prototype.hasNext = function() {
  return this._currentEntry._next !== this._sentinel;
}
_DoubleLinkedQueueIterator.prototype.next = function() {
  if (!this.hasNext()) {
    $throw(const$0/*const NoMoreElementsException()*/);
  }
  this._currentEntry = this._currentEntry._next;
  return this._currentEntry.get$element();
}
_DoubleLinkedQueueIterator.prototype.hasNext$0 = _DoubleLinkedQueueIterator.prototype.hasNext;
_DoubleLinkedQueueIterator.prototype.next$0 = _DoubleLinkedQueueIterator.prototype.next;
// ********** Code for _DoubleLinkedQueueIterator_E **************
function _DoubleLinkedQueueIterator_E(_sentinel) {
  this._sentinel = _sentinel;
  // Initializers done
  this._currentEntry = this._sentinel;
}
$inherits(_DoubleLinkedQueueIterator_E, _DoubleLinkedQueueIterator);
// ********** Code for StopwatchImplementation **************
function StopwatchImplementation() {
  this._start = null;
  this._stop = null;
  // Initializers done
}
StopwatchImplementation.prototype.start = function() {
  if (this._start == null) {
    this._start = Clock.now();
  }
  else {
    if (this._stop == null) {
      return;
    }
    this._start = Clock.now() - (this._stop - this._start);
  }
}
StopwatchImplementation.prototype.get$start = function() {
  return StopwatchImplementation.prototype.start.bind(this);
}
StopwatchImplementation.prototype.stop = function() {
  if (this._start == null) {
    return;
  }
  this._stop = Clock.now();
}
StopwatchImplementation.prototype.elapsed = function() {
  if (this._start == null) {
    return 0;
  }
  return (this._stop == null) ? (Clock.now() - this._start) : (this._stop - this._start);
}
StopwatchImplementation.prototype.elapsedInMs = function() {
  return $truncdiv((this.elapsed() * 1000), this.frequency());
}
StopwatchImplementation.prototype.frequency = function() {
  return Clock.frequency();
}
StopwatchImplementation.prototype.start$0 = StopwatchImplementation.prototype.start;
// ********** Code for StringBufferImpl **************
function StringBufferImpl(content) {
  // Initializers done
  this.clear();
  this.add(content);
}
StringBufferImpl.prototype.get$length = function() {
  return this._length;
}
Object.defineProperty(StringBufferImpl.prototype, "length", {
  get: StringBufferImpl.prototype.get$length
});
StringBufferImpl.prototype.isEmpty = function() {
  return this._length == 0;
}
StringBufferImpl.prototype.add = function(obj) {
  var str = obj.toString();
  if (str == null || str.isEmpty()) return this;
  this._buffer.add(str);
  this._length += str.length;
  return this;
}
StringBufferImpl.prototype.addAll = function(objects) {
  for (var $$i = objects.iterator(); $$i.hasNext$0(); ) {
    var obj = $$i.next$0();
    this.add(obj);
  }
  return this;
}
StringBufferImpl.prototype.clear = function() {
  this._buffer = new ListFactory();
  this._length = 0;
  return this;
}
StringBufferImpl.prototype.toString = function() {
  if (this._buffer.length == 0) return "";
  if (this._buffer.length == 1) return this._buffer.$index(0);
  var result = StringBase.concatAll(this._buffer);
  this._buffer.clear();
  this._buffer.add(result);
  return result;
}
StringBufferImpl.prototype.add$1 = StringBufferImpl.prototype.add;
StringBufferImpl.prototype.addAll$1 = StringBufferImpl.prototype.addAll;
StringBufferImpl.prototype.isEmpty$0 = StringBufferImpl.prototype.isEmpty;
StringBufferImpl.prototype.toString$0 = StringBufferImpl.prototype.toString;
// ********** Code for StringBase **************
function StringBase() {}
StringBase.join = function(strings, separator) {
  if (strings.length == 0) return '';
  var s = strings.$index(0);
  for (var i = 1;
   i < strings.length; i++) {
    s = s + separator + strings.$index(i);
  }
  return s;
}
StringBase.concatAll = function(strings) {
  return StringBase.join(strings, "");
}
// ********** Code for StringImplementation **************
StringImplementation = String;
StringImplementation.prototype.endsWith = function(other) {
  if (other.length > this.length) return false;
    return other == this.substring(this.length - other.length);
}
StringImplementation.prototype.startsWith = function(other) {
  if (other.length > this.length) return false;
    return other == this.substring(0, other.length);
}
StringImplementation.prototype.isEmpty = function() {
  return this.length == 0;
}
StringImplementation.prototype.contains = function(pattern, startIndex) {
  return this.indexOf(pattern, startIndex) >= 0;
}
StringImplementation.prototype._replaceFirst = function(from, to) {
  return this.replace(from, to);
}
StringImplementation.prototype._replaceFirstRegExp = function(from, to) {
  return this.replace(from.re, to);
}
StringImplementation.prototype.replaceFirst = function(from, to) {
  if ((typeof(from) == 'string')) return this._replaceFirst(from, to);
  if (!!(from && from.is$RegExp())) return this._replaceFirstRegExp(from, to);
  var $$list = from.allMatches(this);
  for (var $$i = from.allMatches(this).iterator(); $$i.hasNext$0(); ) {
    var match = $$i.next$0();
    return this.substring(0, match.start$0()) + to + this.substring(match.end$0());
  }
}
StringImplementation.prototype.replaceAll = function(from, to) {
  if (typeof(from) == 'string' || from instanceof String) {
    from = new RegExp(from.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'g');
    to = to.replace(/\$/g, '$$$$'); // Escape sequences are fun!
  }
  return this.replace(from, to);
}
StringImplementation.prototype.hashCode = function() {
  if (this.hash_ === undefined) {
      for (var i = 0; i < this.length; i++) {
        var ch = this.charCodeAt(i);
        this.hash_ += ch;
        this.hash_ += this.hash_ << 10;
        this.hash_ ^= this.hash_ >> 6;
      }

      this.hash_ += this.hash_ << 3;
      this.hash_ ^= this.hash_ >> 11;
      this.hash_ += this.hash_ << 15;
      this.hash_ = this.hash_ & ((1 << 29) - 1);
    }
    return this.hash_;
}
StringImplementation.prototype.compareTo = function(other) {
  return this == other ? 0 : this < other ? -1 : 1;
}
StringImplementation.prototype.compareTo$1 = StringImplementation.prototype.compareTo;
StringImplementation.prototype.contains$1 = StringImplementation.prototype.contains;
StringImplementation.prototype.endsWith$1 = StringImplementation.prototype.endsWith;
StringImplementation.prototype.hashCode$0 = StringImplementation.prototype.hashCode;
StringImplementation.prototype.indexOf$1 = StringImplementation.prototype.indexOf;
StringImplementation.prototype.isEmpty$0 = StringImplementation.prototype.isEmpty;
StringImplementation.prototype.replaceAll$2 = StringImplementation.prototype.replaceAll;
StringImplementation.prototype.replaceFirst$2 = StringImplementation.prototype.replaceFirst;
StringImplementation.prototype.startsWith$1 = StringImplementation.prototype.startsWith;
StringImplementation.prototype.substring$1 = StringImplementation.prototype.substring;
StringImplementation.prototype.substring$2 = StringImplementation.prototype.substring;
// ********** Code for Collections **************
function Collections() {}
Collections.forEach = function(iterable, f) {
  for (var $$i = iterable.iterator(); $$i.hasNext$0(); ) {
    var e = $$i.next$0();
    f(e);
  }
}
Collections.some = function(iterable, f) {
  for (var $$i = iterable.iterator(); $$i.hasNext$0(); ) {
    var e = $$i.next$0();
    if (f(e)) return true;
  }
  return false;
}
Collections.every = function(iterable, f) {
  for (var $$i = iterable.iterator(); $$i.hasNext$0(); ) {
    var e = $$i.next$0();
    if (!f(e)) return false;
  }
  return true;
}
Collections.filter = function(source, destination, f) {
  for (var $$i = source.iterator(); $$i.hasNext$0(); ) {
    var e = $$i.next$0();
    if (f(e)) destination.add(e);
  }
  return destination;
}
// ********** Code for top level **************
//  ********** Library node **************
// ********** Code for process **************
// ********** Code for vm **************
vm = require('vm');
// ********** Code for fs **************
fs = require('fs');
// ********** Code for path **************
path = require('path');
// ********** Code for top level **************
function createSandbox() {
  return {'require': require, 'process': process, 'console': console,
        'setTimeout': setTimeout, 'clearTimeout': clearTimeout};
}
//  ********** Library file_system **************
// ********** Code for top level **************
function joinPaths(path1, path2) {
  var pieces = path1.split('/');
  var $$list = path2.split('/');
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var piece = $$list.$index($$i);
    if ($eq(piece, '..') && pieces.length > 0 && $ne(pieces.last$0(), '.') && $ne(pieces.last$0(), '..')) {
      pieces.removeLast$0();
    }
    else if ($ne(piece, '')) {
      if (pieces.length > 0 && $eq(pieces.last$0(), '.')) {
        pieces.removeLast$0();
      }
      pieces.add$1(piece);
    }
  }
  return Strings.join(pieces, '/');
}
function dirname(path) {
  var lastSlash = path.lastIndexOf('/', path.length);
  if (lastSlash == -1) {
    return '.';
  }
  else {
    return path.substring(0, lastSlash);
  }
}
function basename(path) {
  var lastSlash = path.lastIndexOf('/', path.length);
  if (lastSlash == -1) {
    return path;
  }
  else {
    return path.substring(lastSlash + 1);
  }
}
//  ********** Library file_system_node **************
// ********** Code for NodeFileSystem **************
function NodeFileSystem() {
  // Initializers done
}
NodeFileSystem.prototype.writeString = function(outfile, text) {
  fs.writeFileSync(outfile, text);
}
NodeFileSystem.prototype.readAll = function(filename) {
  return fs.readFileSync(filename, 'utf8');
}
NodeFileSystem.prototype.fileExists = function(filename) {
  return path.existsSync(filename);
}
// ********** Code for top level **************
//  ********** Library lang **************
// ********** Code for CodeWriter **************
function CodeWriter() {
  this._indentation = 0
  this._pendingIndent = false
  this.writeComments = true
  this._buf = new StringBufferImpl("");
  // Initializers done
}
CodeWriter.prototype.get$text = function() {
  return this._buf.toString();
}
CodeWriter.prototype._indent = function() {
  this._pendingIndent = false;
  for (var i = 0;
   i < this._indentation; i++) {
    this._buf.add('  '/*CodeWriter.INDENTATION*/);
  }
}
CodeWriter.prototype.comment = function(text) {
  if (this.writeComments) {
    this.writeln(text);
  }
}
CodeWriter.prototype.write = function(text) {
  if (text.length == 0) return;
  if (this._pendingIndent) this._indent();
  if (text.indexOf('\n') != -1) {
    var lines = text.split('\n');
    for (var i = 0;
     i < lines.length - 1; i++) {
      this.writeln(lines.$index(i));
    }
    this.write(lines.$index(lines.length - 1));
  }
  else {
    this._buf.add(text);
  }
}
CodeWriter.prototype.writeln = function(text) {
  if (text != null) {
    this.write(text);
  }
  if (!text.endsWith('\n')) this._buf.add('\n'/*CodeWriter.NEWLINE*/);
  this._pendingIndent = true;
}
CodeWriter.prototype.enterBlock = function(text) {
  this.writeln(text);
  this._indentation++;
}
CodeWriter.prototype.exitBlock = function(text) {
  this._indentation--;
  this.writeln(text);
}
CodeWriter.prototype.nextBlock = function(text) {
  this._indentation--;
  this.writeln(text);
  this._indentation++;
}
// ********** Code for CoreJs **************
function CoreJs() {
  this.useStackTraceOf = false
  this.useThrow = false
  this.useGenStub = false
  this.useAssert = false
  this.useNotNullBool = false
  this.useIndex = false
  this.useSetIndex = false
  this.useWrap0 = false
  this.useWrap1 = false
  this.useIsolates = false
  this.useToString = false
  this._generatedTypeNameOf = false
  this._generatedDynamicProto = false
  this._generatedInherits = false
  this._usedOperators = new HashMapImplementation();
  this.writer = new CodeWriter();
  // Initializers done
}
CoreJs.prototype.useOperator = function(name) {
  if (this._usedOperators.$index(name) != null) return;
  var code;
  switch (name) {
    case ':ne':

      code = "function $ne(x, y) {\n  if (x == null) return y != null;\n  return (typeof(x) == 'number' && typeof(y) == 'number') ||\n         (typeof(x) == 'boolean' && typeof(y) == 'boolean') ||\n         (typeof(x) == 'string' && typeof(y) == 'string')\n    ? x != y : !x.$eq(y);\n}";
      break;

    case ':eq':

      code = "function $eq(x, y) {\n  if (x == null) return y == null;\n  return (typeof(x) == 'number' && typeof(y) == 'number') ||\n         (typeof(x) == 'boolean' && typeof(y) == 'boolean') ||\n         (typeof(x) == 'string' && typeof(y) == 'string')\n    ? x == y : x.$eq(y);\n}\n// TODO(jimhug): Should this or should it not match equals?\nObject.prototype.$eq = function(other) { return this === other; }";
      break;

    case ':bit_not':

      code = "function $bit_not(x) {\n  return (typeof(x) == 'number') ? ~x : x.$bit_not();\n}";
      break;

    case ':negate':

      code = "function $negate(x) {\n  return (typeof(x) == 'number') ? -x : x.$negate();\n}";
      break;

    case ':add':

      code = "function $add(x, y) {\n  return ((typeof(x) == 'number' && typeof(y) == 'number') ||\n          (typeof(x) == 'string'))\n    ? x + y : x.$add(y);\n}";
      break;

    case ':truncdiv':

      this.useThrow = true;
      code = "function $truncdiv(x, y) {\n  if (typeof(x) == 'number' && typeof(y) == 'number') {\n    if (y == 0) $throw(new IntegerDivisionByZeroException());\n    var tmp = x / y;\n    return (tmp < 0) ? Math.ceil(tmp) : Math.floor(tmp);\n  } else {\n    return x.$truncdiv(y);\n  }\n}";
      break;

    case ':mod':

      code = "function $mod(x, y) {\n  if (typeof(x) == 'number' && typeof(y) == 'number') {\n    var result = x % y;\n    if (result == 0) {\n      return 0;  // Make sure we don't return -0.0.\n    } else if (result < 0) {\n      if (y < 0) {\n        return result - y;\n      } else {\n        return result + y;\n      }\n    }\n    return result;\n  } else {\n    return x.$mod(y);\n  }\n}";
      break;

    default:

      var op = TokenKind.rawOperatorFromMethod(name);
      var jsname = $globals.world.toJsIdentifier(name);
      code = ("function " + jsname + "(x, y) {\n  return (typeof(x) == 'number' && typeof(y) == 'number')\n    ? x " + op + " y : x." + jsname + "(y);\n}");
      break;

  }
  this._usedOperators.$setindex(name, code);
}
CoreJs.prototype.ensureDynamicProto = function() {
  if (this._generatedDynamicProto) return;
  this._generatedDynamicProto = true;
  this.ensureTypeNameOf();
  this.writer.writeln("function $dynamic(name) {\n  var f = Object.prototype[name];\n  if (f && f.methods) return f.methods;\n\n  var methods = {};\n  if (f) methods.Object = f;\n  function $dynamicBind() {\n    // Find the target method\n    var method;\n    var proto = Object.getPrototypeOf(this);\n    var obj = this;\n    do {\n      method = methods[obj.$typeNameOf()];\n      if (method) break;\n      obj = Object.getPrototypeOf(obj);\n    } while (obj);\n\n    // Patch the prototype, but don't overwrite an existing stub, like\n    // the one on Object.prototype.\n    if (!proto.hasOwnProperty(name)) proto[name] = method || methods.Object;\n\n    return method.apply(this, Array.prototype.slice.call(arguments));\n  };\n  $dynamicBind.methods = methods;\n  Object.prototype[name] = $dynamicBind;\n  return methods;\n}");
}
CoreJs.prototype.ensureTypeNameOf = function() {
  if (this._generatedTypeNameOf) return;
  this._generatedTypeNameOf = true;
  this.writer.writeln("Object.prototype.$typeNameOf = function() {\n  if ((typeof(window) != 'undefined' && window.constructor.name == 'DOMWindow')\n      || typeof(process) != 'undefined') { // fast-path for Chrome and Node\n    return this.constructor.name;\n  }\n  var str = Object.prototype.toString.call(this);\n  str = str.substring(8, str.length - 1);\n  if (str == 'Window') str = 'DOMWindow';\n  return str;\n}");
}
CoreJs.prototype.ensureInheritsHelper = function() {
  if (this._generatedInherits) return;
  this._generatedInherits = true;
  this.writer.writeln("/** Implements extends for Dart classes on JavaScript prototypes. */\nfunction $inherits(child, parent) {\n  if (child.prototype.__proto__) {\n    child.prototype.__proto__ = parent.prototype;\n  } else {\n    function tmp() {};\n    tmp.prototype = parent.prototype;\n    child.prototype = new tmp();\n    child.prototype.constructor = child;\n  }\n}");
}
CoreJs.prototype.generate = function(w) {
  w.write(this.writer.get$text());
  this.writer = w;
  if (this.useGenStub) {
    this.useThrow = true;
    w.writeln("/**\n * Generates a dynamic call stub for a function.\n * Our goal is to create a stub method like this on-the-fly:\n *   function($0, $1, capture) { return this($0, $1, true, capture); }\n *\n * This stub then replaces the dynamic one on Function, with one that is\n * specialized for that particular function, taking into account its default\n * arguments.\n */\nFunction.prototype.$genStub = function(argsLength, names) {\n  // Fast path: if no named arguments and arg count matches\n  if (this.length == argsLength && !names) {\n    return this;\n  }\n\n  function $throwArgMismatch() {\n    // TODO(jmesserly): better error message\n    $throw(new ClosureArgumentMismatchException());\n  }\n\n  var paramsNamed = this.$optional ? (this.$optional.length / 2) : 0;\n  var paramsBare = this.length - paramsNamed;\n  var argsNamed = names ? names.length : 0;\n  var argsBare = argsLength - argsNamed;\n\n  // Check we got the right number of arguments\n  if (argsBare < paramsBare || argsLength > this.length ||\n      argsNamed > paramsNamed) {\n    return $throwArgMismatch;\n  }\n\n  // First, fill in all of the default values\n  var p = new Array(paramsBare);\n  if (paramsNamed) {\n    p = p.concat(this.$optional.slice(paramsNamed));\n  }\n  // Fill in positional args\n  var a = new Array(argsLength);\n  for (var i = 0; i < argsBare; i++) {\n    p[i] = a[i] = '$' + i;\n  }\n  // Then overwrite with supplied values for optional args\n  var lastParameterIndex;\n  var namesInOrder = true;\n  for (var i = 0; i < argsNamed; i++) {\n    var name = names[i];\n    a[i + argsBare] = name;\n    var j = this.$optional.indexOf(name);\n    if (j < 0 || j >= paramsNamed) {\n      return $throwArgMismatch;\n    } else if (lastParameterIndex && lastParameterIndex > j) {\n      namesInOrder = false;\n    }\n    p[j + paramsBare] = name;\n    lastParameterIndex = j;\n  }\n\n  if (this.length == argsLength && namesInOrder) {\n    // Fast path #2: named arguments, but they're in order.\n    return this;\n  }\n\n  // Note: using Function instead of 'eval' to get a clean scope.\n  // TODO(jmesserly): evaluate the performance of these stubs.\n  var f = 'function(' + a.join(',') + '){return $f(' + p.join(',') + ');}';\n  return new Function('$f', 'return ' + f + '').call(null, this);\n}");
  }
  if (this.useStackTraceOf) {
    w.writeln("function $stackTraceOf(e) {\n  // TODO(jmesserly): we shouldn't be relying on the e.stack property.\n  // Need to mangle it.\n  return  (e && e.stack) ? e.stack : null;\n}");
  }
  if (this.useNotNullBool) {
    this.useThrow = true;
    w.writeln("function $notnull_bool(test) {\n  if (test === true || test === false) return test;\n  $throw(new TypeError(test, 'bool'));\n}");
  }
  if (this.useThrow) {
    w.writeln("function $throw(e) {\n  // If e is not a value, we can use V8's captureStackTrace utility method.\n  // TODO(jmesserly): capture the stack trace on other JS engines.\n  if (e && (typeof e == 'object') && Error.captureStackTrace) {\n    // TODO(jmesserly): this will clobber the e.stack property\n    Error.captureStackTrace(e, $throw);\n  }\n  throw e;\n}");
  }
  if (this.useToString) {
    w.writeln("function $toString(o) {\n  if (o == null) return 'null';\n  var t = typeof(o);\n  if (t == 'object') { return o.toString(); }\n  else if (t == 'string') { return o; }\n  else if (t == 'bool') { return ''+o; }\n  else if (t == 'number') { return ''+o; }\n  else return o.toString();\n}");
  }
  if (this.useIndex) {
    w.writeln("Object.prototype.$index = function(i) { return this[i]; }\nArray.prototype.$index = function(i) { return this[i]; }\nString.prototype.$index = function(i) { return this[i]; }");
  }
  if (this.useSetIndex) {
    w.writeln("Object.prototype.$setindex = function(i, value) { return this[i] = value; }\nArray.prototype.$setindex = function(i, value) { return this[i] = value; }");
  }
  if (this.useIsolates) {
    if (this.useWrap0) {
      w.writeln("// Wrap a 0-arg dom-callback to bind it with the current isolate:\nfunction $wrap_call$0(fn) { return fn && fn.wrap$call$0(); }\nFunction.prototype.wrap$call$0 = function() {\n  var isolateContext = $globalState.currentContext;\n  var self = this;\n  this.wrap$0 = function() {\n    isolateContext.eval(self);\n    $globalState.topEventLoop.run();\n  };\n  this.wrap$call$0 = function() { return this.wrap$0; };\n  return this.wrap$0;\n}");
    }
    if (this.useWrap1) {
      w.writeln("// Wrap a 1-arg dom-callback to bind it with the current isolate:\nfunction $wrap_call$1(fn) { return fn && fn.wrap$call$1(); }\nFunction.prototype.wrap$call$1 = function() {\n  var isolateContext = $globalState.currentContext;\n  var self = this;\n  this.wrap$1 = function(arg) {\n    isolateContext.eval(function() { self(arg); });\n    $globalState.topEventLoop.run();\n  };\n  this.wrap$call$1 = function() { return this.wrap$1; };\n  return this.wrap$1;\n}");
    }
    w.writeln("var $globalThis = this;\nvar $globals = null;\nvar $globalState = null;");
  }
  else {
    if (this.useWrap0) {
      w.writeln("function $wrap_call$0(fn) { return fn; }");
    }
    if (this.useWrap1) {
      w.writeln("function $wrap_call$1(fn) { return fn; }");
    }
  }
  var $$list = orderValuesByKeys(this._usedOperators);
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var opImpl = $$list.$index($$i);
    w.writeln(opImpl);
  }
}
CoreJs.prototype.generate$1 = CoreJs.prototype.generate;
// ********** Code for Element **************
function Element(name, _enclosingElement) {
  this.name = name;
  this._enclosingElement = _enclosingElement;
  // Initializers done
  this._jsname = $globals.world.toJsIdentifier(this.name);
}
Element.prototype.get$name = function() { return this.name; };
Element.prototype.set$name = function(value) { return this.name = value; };
Element.prototype.get$_jsname = function() { return this._jsname; };
Element.prototype.set$_jsname = function(value) { return this._jsname = value; };
Element.prototype.get$library = function() {
  return null;
}
Element.prototype.get$span = function() {
  return null;
}
Element.prototype.get$isNative = function() {
  return false;
}
Element.prototype.hashCode = function() {
  return this.name.hashCode();
}
Element.prototype.get$jsname = function() {
  return this._jsname;
}
Element.prototype.resolve = function() {

}
Element.prototype.get$typeParameters = function() {
  return null;
}
Element.prototype.get$enclosingElement = function() {
  return this._enclosingElement == null ? this.get$library() : this._enclosingElement;
}
Element.prototype.set$enclosingElement = function(e) {
  return this._enclosingElement = e;
}
Element.prototype.resolveType = function(node, typeErrors) {
  if (node == null) return $globals.world.varType;
  if (node.type != null) return node.type;
  if ((node instanceof NameTypeReference)) {
    var typeRef = node;
    var name;
    if (typeRef.names != null) {
      name = typeRef.names.last().get$name();
    }
    else {
      name = typeRef.name.name;
    }
    if (this.get$typeParameters() != null) {
      var $$list = this.get$typeParameters();
      for (var $$i = 0;$$i < $$list.length; $$i++) {
        var tp = $$list.$index($$i);
        if ($eq(tp.get$name(), name)) {
          typeRef.type = tp;
        }
      }
    }
    if (typeRef.type != null) {
      return typeRef.type;
    }
    return this.get$enclosingElement().resolveType(node, typeErrors);
  }
  else if ((node instanceof GenericTypeReference)) {
    var typeRef = node;
    var baseType = this.resolveType(typeRef.baseType, typeErrors);
    if (!baseType.get$isGeneric()) {
      $globals.world.error(('' + baseType.get$name() + ' is not generic'), typeRef.span);
      return null;
    }
    if (typeRef.typeArguments.length != baseType.get$typeParameters().length) {
      $globals.world.error('wrong number of type arguments', typeRef.span);
      return null;
    }
    var typeArgs = [];
    for (var i = 0;
     i < typeRef.typeArguments.length; i++) {
      typeArgs.add$1(this.resolveType(typeRef.typeArguments.$index(i), typeErrors));
    }
    typeRef.type = baseType.getOrMakeConcreteType$1(typeArgs);
  }
  else if ((node instanceof FunctionTypeReference)) {
    var typeRef = node;
    var name = '';
    if (typeRef.func.name != null) {
      name = typeRef.func.name.name;
    }
    typeRef.type = this.get$library().getOrAddFunctionType(this, name, typeRef.func);
  }
  else {
    $globals.world.internalError('unknown type reference', node.span);
  }
  return node.type;
}
Element.prototype.hashCode$0 = Element.prototype.hashCode;
Element.prototype.resolve$0 = Element.prototype.resolve;
// ********** Code for WorldGenerator **************
function WorldGenerator(main, writer) {
  this.hasStatics = false
  this.main = main;
  this.writer = writer;
  this.globals = new HashMapImplementation();
  this.corejs = new CoreJs();
  // Initializers done
}
WorldGenerator.prototype.run = function() {
  var metaGen = new MethodGenerator(this.main, null);
  var mainTarget = new Value.type$ctor(this.main.declaringType, this.main.get$span());
  var mainCall = this.main.invoke(metaGen, null, mainTarget, Arguments.get$EMPTY(), false);
  this.main.declaringType.markUsed();
  if ($globals.options.compileAll) {
    this.markLibraryUsed($globals.world.corelib);
    this.markLibraryUsed(this.main.declaringType.get$library());
  }
  else {
    $globals.world.corelib.types.$index('BadNumberFormatException').markUsed$0();
    $globals.world.get$coreimpl().types.$index('NumImplementation').markUsed$0();
    $globals.world.get$coreimpl().types.$index('StringImplementation').markUsed$0();
    this.genMethod($globals.world.get$coreimpl().types.$index('StringImplementation').getMember$1('contains'));
  }
  if ($globals.world.corelib.types.$index('Isolate').get$isUsed() || $globals.world.get$coreimpl().types.$index('ReceivePortImpl').get$isUsed()) {
    if (this.corejs.useWrap0 || this.corejs.useWrap1) {
      this.genMethod($globals.world.get$coreimpl().types.$index('IsolateContext').getMember$1('eval'));
      this.genMethod($globals.world.get$coreimpl().types.$index('EventLoop').getMember$1('run'));
    }
    this.corejs.useIsolates = true;
    var isolateMain = $globals.world.get$coreimpl().topType.resolveMember('startRootIsolate').members.$index(0);
    var isolateMainTarget = new Value.type$ctor($globals.world.get$coreimpl().topType, this.main.get$span());
    mainCall = isolateMain.invoke(metaGen, null, isolateMainTarget, new Arguments(null, [this.main._get(metaGen, this.main.definition, null, false)]), false);
  }
  this.writeTypes($globals.world.get$coreimpl());
  this.writeTypes($globals.world.corelib);
  this.writeTypes(this.main.declaringType.get$library());
  if (this._mixins != null) this.writer.write(this._mixins.get$text());
  this.writeGlobals();
  this.writer.writeln(('' + mainCall.get$code() + ';'));
}
WorldGenerator.prototype.markLibraryUsed = function(l) {
  var $this = this; // closure support
  if (l.isMarked) return;
  l.isMarked = true;
  l.imports.forEach((function (i) {
    return $this.markLibraryUsed(i.get$library());
  })
  );
  var $$list = l.types.getValues();
  for (var $$i = l.types.getValues().iterator$0(); $$i.hasNext$0(); ) {
    var type = $$i.next$0();
    if (!type.get$isClass()) continue;
    type.markUsed$0();
    type.set$isTested(!type.get$isTop() && !(type.get$isNative() && type.get$members().getValues$0().every$1((function (m) {
      return m.get$isStatic() && !m.get$isFactory();
    })
    )));
    var $list0 = type.get$members().getValues$0();
    for (var $i0 = type.get$members().getValues$0().iterator$0(); $i0.hasNext$0(); ) {
      var member = $i0.next$0();
      if ((member instanceof PropertyMember)) {
        if (member.get$getter() != null) this.genMethod(member.get$getter());
        if (member.get$setter() != null) this.genMethod(member.get$setter());
      }
      if (member.get$isMethod()) this.genMethod(member);
    }
  }
}
WorldGenerator.prototype.globalForStaticField = function(field, fieldValue, dependencies) {
  this.hasStatics = true;
  var fullname = ("" + field.declaringType.get$jsname() + "." + field.get$jsname());
  if (!this.globals.containsKey(fullname)) {
    this.globals.$setindex(fullname, GlobalValue.GlobalValue$fromStatic$factory(field, fieldValue, dependencies));
  }
  return this.globals.$index(fullname);
}
WorldGenerator.prototype.globalForConst = function(exp, dependencies) {
  var key = exp.get$type().get$jsname() + ':' + exp.canonicalCode;
  if (!this.globals.containsKey(key)) {
    this.globals.$setindex(key, GlobalValue.GlobalValue$fromConst$factory(this.globals.get$length(), exp, dependencies));
  }
  return this.globals.$index(key);
}
WorldGenerator.prototype.writeTypes = function(lib) {
  if (lib.isWritten) return;
  lib.isWritten = true;
  var $$list = lib.imports;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var import_ = $$list.$index($$i);
    this.writeTypes(import_.get$library());
  }
  for (var i = 0;
   i < lib.sources.length; i++) {
    lib.sources.$index(i).set$orderInLibrary(i);
  }
  this.writer.comment(('//  ********** Library ' + lib.name + ' **************'));
  if (lib.get$isCore()) {
    this.writer.comment('//  ********** Natives dart:core **************');
    this.corejs.generate(this.writer);
  }
  var $$list = lib.natives;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var file = $$list.$index($$i);
    var filename = basename(file.get$filename());
    this.writer.comment(('//  ********** Natives ' + filename + ' **************'));
    this.writer.writeln(file.get$text());
  }
  lib.topType.markUsed();
  var $$list = this._orderValues(lib.types);
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var type = $$list.$index($$i);
    if ((type.get$isUsed() || type.get$isHiddenNativeType()) && type.get$isClass()) {
      this.writeType(type);
      if (type.get$isGeneric()) {
        var $list0 = this._orderValues(type.get$_concreteTypes());
        for (var $i0 = 0;$i0 < $list0.length; $i0++) {
          var ct = $list0.$index($i0);
          this.writeType(ct);
        }
      }
    }
    else if (type.get$isFunction() && type.get$varStubs().length > 0) {
      this.writer.comment(('// ********** Code for ' + type.get$jsname() + ' **************'));
      this._writeDynamicStubs(type);
    }
    if (type.get$typeCheckCode() != null) {
      this.writer.writeln(type.get$typeCheckCode());
    }
  }
}
WorldGenerator.prototype.genMethod = function(meth, enclosingMethod) {
  if (!meth.isGenerated && !meth.get$isAbstract() && meth.get$definition() != null) {
    new MethodGenerator(meth, enclosingMethod).run();
  }
}
WorldGenerator.prototype._prototypeOf = function(type, name) {
  if (type.get$isSingletonNative()) {
    return ('' + type.get$jsname() + '.' + name);
  }
  else if (type.get$isHiddenNativeType()) {
    this.corejs.ensureDynamicProto();
    return ('\$dynamic("' + name + '").' + type.get$jsname());
  }
  else {
    return ('' + type.get$jsname() + '.prototype.' + name);
  }
}
WorldGenerator.prototype._maybeIsTest = function(onType, checkType) {
  var isSubtype = onType.isSubtypeOf(checkType);
  if (checkType.isTested) {
    this.writer.writeln(this._prototypeOf(onType, ('is\$' + checkType.get$jsname())) + (' = function(){return ' + isSubtype + '};'));
  }
  if (checkType.isChecked) {
    var body = 'return this';
    var checkName = ('assert\$' + checkType.get$jsname());
    if (!isSubtype) {
      body = $globals.world.objectType.varStubs.$index(checkName).get$body();
    }
    else if (onType.name == 'StringImplementation' || onType.name == 'NumImplementation') {
      body = ('return ' + onType.get$nativeType().name + '(this)');
    }
    this.writer.writeln(this._prototypeOf(onType, checkName) + (' = function(){' + body + '};'));
  }
}
WorldGenerator.prototype.writeType = function(type) {
  if (type.name != null && (type instanceof ConcreteType) && $eq(type.get$library(), $globals.world.get$coreimpl()) && type.name.startsWith('ListFactory')) {
    this.writer.writeln(('' + type.get$jsname() + ' = ' + type.get$genericType().get$jsname() + ';'));
    return;
  }
  var typeName = type.get$jsname() != null ? type.get$jsname() : 'top level';
  this.writer.comment(('// ********** Code for ' + typeName + ' **************'));
  if (type.get$isNative() && !type.get$isTop()) {
    var nativeName = type.get$definition().get$nativeType().get$name();
    if ($eq(nativeName, '')) {
      this.writer.writeln(('function ' + type.get$jsname() + '() {}'));
    }
    else if (type.get$jsname() != nativeName) {
      this.writer.writeln(('' + type.get$jsname() + ' = ' + nativeName + ';'));
    }
  }
  if (type.get$isTop()) {
  }
  else if (type.get$constructors().get$length() == 0) {
    if (!type.get$isNative()) {
      this.writer.writeln(('function ' + type.get$jsname() + '() {}'));
    }
  }
  else {
    var standardConstructor = type.get$constructors().$index('');
    if (standardConstructor == null || standardConstructor.generator == null) {
      if (!type.get$isNative()) {
        this.writer.writeln(('function ' + type.get$jsname() + '() {}'));
      }
    }
    else {
      standardConstructor.generator.writeDefinition(this.writer, null);
    }
    var $$list = type.get$constructors().getValues();
    for (var $$i = type.get$constructors().getValues().iterator$0(); $$i.hasNext$0(); ) {
      var c = $$i.next$0();
      if (c.get$generator() != null && $ne(c, standardConstructor)) {
        c.get$generator().writeDefinition$2(this.writer);
      }
    }
  }
  if (!type.get$isTop()) {
    if ((type instanceof ConcreteType)) {
      var c = type;
      this.corejs.ensureInheritsHelper();
      this.writer.writeln(('\$inherits(' + c.get$jsname() + ', ' + c.genericType.get$jsname() + ');'));
      for (var p = c._parent;
       (p instanceof ConcreteType); p = p.get$_parent()) {
        this._ensureInheritMembersHelper();
        this._mixins.writeln(('\$inheritsMembers(' + c.get$jsname() + ', ' + p.get$jsname() + ');'));
      }
    }
    else if (!type.get$isNative()) {
      if (type.get$parent() != null && !type.get$parent().get$isObject()) {
        this.corejs.ensureInheritsHelper();
        this.writer.writeln(('\$inherits(' + type.get$jsname() + ', ' + type.get$parent().get$jsname() + ');'));
      }
    }
  }
  if (!(type instanceof ConcreteType)) {
    this._maybeIsTest(type, type);
  }
  if (type.get$genericType()._concreteTypes != null) {
    var $$list = this._orderValues(type.get$genericType()._concreteTypes);
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var ct = $$list.$index($$i);
      this._maybeIsTest(type, ct);
    }
  }
  if (type.get$interfaces() != null) {
    var seen = new HashSetImplementation();
    var worklist = [];
    worklist.addAll(type.get$interfaces());
    seen.addAll(type.get$interfaces());
    while (!worklist.isEmpty()) {
      var interface_ = worklist.removeLast();
      this._maybeIsTest(type, interface_.get$genericType());
      if (interface_.get$genericType().get$_concreteTypes() != null) {
        var $$list = this._orderValues(interface_.get$genericType().get$_concreteTypes());
        for (var $$i = 0;$$i < $$list.length; $$i++) {
          var ct = $$list.$index($$i);
          this._maybeIsTest(type, ct);
        }
      }
      var $$list = interface_.get$interfaces();
      for (var $$i = interface_.get$interfaces().iterator$0(); $$i.hasNext$0(); ) {
        var other = $$i.next$0();
        if (!seen.contains(other)) {
          worklist.addLast(other);
          seen.add(other);
        }
      }
    }
  }
  type.get$factories().forEach(this.get$_writeMethod());
  var $$list = this._orderValues(type.get$members());
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var member = $$list.$index($$i);
    if ((member instanceof FieldMember)) {
      this._writeField(member);
    }
    if ((member instanceof PropertyMember)) {
      this._writeProperty(member);
    }
    if (member.get$isMethod()) {
      this._writeMethod(member);
    }
  }
  this._writeDynamicStubs(type);
}
WorldGenerator.prototype._ensureInheritMembersHelper = function() {
  if (this._mixins != null) return;
  this._mixins = new CodeWriter();
  this._mixins.comment('// ********** Generic Type Inheritance **************');
  this._mixins.writeln("/** Implements extends for generic types. */\nfunction $inheritsMembers(child, parent) {\n  child = child.prototype;\n  parent = parent.prototype;\n  Object.getOwnPropertyNames(parent).forEach(function(name) {\n    if (typeof(child[name]) == 'undefined') child[name] = parent[name];\n  });\n}");
}
WorldGenerator.prototype._writeDynamicStubs = function(type) {
  var $$list = orderValuesByKeys(type.varStubs);
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var stub = $$list.$index($$i);
    stub.generate$1(this.writer);
  }
}
WorldGenerator.prototype._writeStaticField = function(field) {
  if (field.isFinal) return;
  var fullname = ("" + field.declaringType.get$jsname() + "." + field.get$jsname());
  if (this.globals.containsKey(fullname)) {
    var value = this.globals.$index(fullname);
    if (field.declaringType.get$isTop() && !field.isNative) {
      this.writer.writeln(('\$globals.' + field.get$jsname() + ' = ' + value.get$exp().get$code() + ';'));
    }
    else {
      this.writer.writeln(('\$globals.' + field.declaringType.get$jsname() + '_' + field.get$jsname()) + (' = ' + value.get$exp().get$code() + ';'));
    }
  }
}
WorldGenerator.prototype._writeField = function(field) {
  if (field.declaringType.get$isTop() && !field.isNative && field.value == null) {
    this.writer.writeln(('var ' + field.get$jsname() + ';'));
  }
  if (field._providePropertySyntax) {
    this.writer.writeln(this._prototypeOf(field.declaringType, ('get\$' + field.get$jsname())) + (' = function() { return this.' + field.get$jsname() + '; };'));
    if (!field.isFinal) {
      this.writer.writeln(this._prototypeOf(field.declaringType, ('set\$' + field.get$jsname())) + (' = function(value) { return this.' + field.get$jsname() + ' = value; };'));
    }
  }
}
WorldGenerator.prototype._writeProperty = function(property) {
  if (property.getter != null) this._writeMethod(property.getter);
  if (property.setter != null) this._writeMethod(property.setter);
  if (property._provideFieldSyntax) {
    this.writer.enterBlock('Object.defineProperty(' + ('' + property.declaringType.get$jsname() + '.prototype, "' + property.get$jsname() + '", {'));
    if (property.getter != null) {
      this.writer.write(('get: ' + property.declaringType.get$jsname() + '.prototype.' + property.getter.get$jsname()));
      this.writer.writeln(property.setter == null ? '' : ',');
    }
    if (property.setter != null) {
      this.writer.writeln(('set: ' + property.declaringType.get$jsname() + '.prototype.' + property.setter.get$jsname()));
    }
    this.writer.exitBlock('});');
  }
}
WorldGenerator.prototype._writeMethod = function(method) {
  if (method.generator != null) {
    method.generator.writeDefinition(this.writer, null);
  }
}
WorldGenerator.prototype.get$_writeMethod = function() {
  return WorldGenerator.prototype._writeMethod.bind(this);
}
WorldGenerator.prototype.writeGlobals = function() {
  if (this.globals.get$length() > 0) {
    this.writer.comment('//  ********** Globals **************');
    var list = this.globals.getValues();
    list.sort$1((function (a, b) {
      return a.compareTo$1(b);
    })
    );
    this.writer.enterBlock('function \$static_init(){');
    for (var $$i = list.iterator$0(); $$i.hasNext$0(); ) {
      var global = $$i.next$0();
      if (global.get$field() != null) {
        this._writeStaticField(global.get$field());
      }
    }
    this.writer.exitBlock('}');
    for (var $$i = list.iterator$0(); $$i.hasNext$0(); ) {
      var global0 = $$i.next$0();
      if (global0.get$field() == null) {
        this.writer.writeln(('var ' + global0.get$name() + ' = ' + global0.get$exp().get$code() + ';'));
      }
    }
  }
  if (!this.corejs.useIsolates) {
    if (this.hasStatics) {
      this.writer.writeln('var \$globals = {};');
    }
    if (this.globals.get$length() > 0) {
      this.writer.writeln('\$static_init();');
    }
  }
}
WorldGenerator.prototype._orderValues = function(map) {
  var values = map.getValues();
  values.sort(this.get$_compareMembers());
  return values;
}
WorldGenerator.prototype._compareMembers = function(x, y) {
  if (x.get$span() != null && y.get$span() != null) {
    var spans = x.get$span().compareTo$1(y.get$span());
    if (spans != 0) return spans;
  }
  if (x.get$span() == null) return 1;
  if (y.get$span() == null) return -1;
  return x.get$name().compareTo$1(y.get$name());
}
WorldGenerator.prototype.get$_compareMembers = function() {
  return WorldGenerator.prototype._compareMembers.bind(this);
}
// ********** Code for BlockScope **************
function BlockScope(enclosingMethod, parent, reentrant) {
  this.enclosingMethod = enclosingMethod;
  this.parent = parent;
  this.reentrant = reentrant;
  this._vars = new HashMapImplementation();
  this._jsNames = new HashSetImplementation();
  // Initializers done
  if (this.get$isMethodScope()) {
    this._closedOver = new HashSetImplementation();
  }
  else {
    this.reentrant = reentrant || this.parent.reentrant;
  }
}
BlockScope.prototype.get$enclosingMethod = function() { return this.enclosingMethod; };
BlockScope.prototype.set$enclosingMethod = function(value) { return this.enclosingMethod = value; };
BlockScope.prototype.get$parent = function() { return this.parent; };
BlockScope.prototype.set$parent = function(value) { return this.parent = value; };
BlockScope.prototype.get$_vars = function() { return this._vars; };
BlockScope.prototype.set$_vars = function(value) { return this._vars = value; };
BlockScope.prototype.get$_jsNames = function() { return this._jsNames; };
BlockScope.prototype.set$_jsNames = function(value) { return this._jsNames = value; };
BlockScope.prototype.get$_closedOver = function() { return this._closedOver; };
BlockScope.prototype.set$_closedOver = function(value) { return this._closedOver = value; };
BlockScope.prototype.get$rethrow = function() { return this.rethrow; };
BlockScope.prototype.set$rethrow = function(value) { return this.rethrow = value; };
BlockScope.prototype.get$reentrant = function() { return this.reentrant; };
BlockScope.prototype.set$reentrant = function(value) { return this.reentrant = value; };
BlockScope.prototype.get$isMethodScope = function() {
  return this.parent == null || $ne(this.parent.enclosingMethod, this.enclosingMethod);
}
BlockScope.prototype.get$methodScope = function() {
  var s = this;
  while (!s.get$isMethodScope()) s = s.get$parent();
  return s;
}
BlockScope.prototype.lookup = function(name) {
  var ret = this._vars.$index(name);
  if (ret != null) return ret;
  for (var s = this.parent;
   s != null; s = s.get$parent()) {
    ret = s.get$_vars().$index(name);
    if (ret != null) {
      if ($ne(s.get$enclosingMethod(), this.enclosingMethod)) {
        s.get$methodScope().get$_closedOver().add$1(ret.get$code());
        if (this.enclosingMethod.captures != null && s.get$reentrant()) {
          this.enclosingMethod.captures.add(ret.get$code());
        }
      }
      return ret;
    }
  }
}
BlockScope.prototype._isDefinedInParent = function(name) {
  if (this.get$isMethodScope() && this._closedOver.contains(name)) return true;
  for (var s = this.parent;
   s != null; s = s.get$parent()) {
    if (s.get$_vars().containsKey$1(name)) return true;
    if (s.get$_jsNames().contains$1(name)) return true;
    if (s.get$isMethodScope() && s.get$_closedOver().contains$1(name)) return true;
  }
  var type = this.enclosingMethod.method.declaringType;
  if (type.get$library().lookup(name, null) != null) return true;
  return false;
}
BlockScope.prototype.create = function(name, type, span, isFinal, isParameter) {
  var jsName = $globals.world.toJsIdentifier(name);
  if (this._vars.containsKey(name)) {
    $globals.world.error(('duplicate name "' + name + '"'), span);
  }
  if (!isParameter) {
    var index = 0;
    while (this._isDefinedInParent(jsName)) {
      jsName = ('' + name + (index++));
    }
  }
  var ret = new Value(type, jsName, span, false);
  ret.set$isFinal(isFinal);
  this._vars.$setindex(name, ret);
  if (name != jsName) this._jsNames.add(jsName);
  return ret;
}
BlockScope.prototype.declareParameter = function(p) {
  return this.create(p.name, p.type, p.definition.span, false, true);
}
BlockScope.prototype.declare = function(id) {
  var type = this.enclosingMethod.method.resolveType(id.type, false);
  return this.create(id.name.name, type, id.span, false, false);
}
BlockScope.prototype.getRethrow = function() {
  var scope = this;
  while (scope.get$rethrow() == null && scope.get$parent() != null) {
    scope = scope.get$parent();
  }
  return scope.get$rethrow();
}
// ********** Code for MethodGenerator **************
function MethodGenerator(method, enclosingMethod) {
  this.method = method;
  this.enclosingMethod = enclosingMethod;
  this.writer = new CodeWriter();
  this.needsThis = false;
  // Initializers done
  if (this.enclosingMethod != null) {
    this._scope = new BlockScope(this, this.enclosingMethod._scope, false);
    this.captures = new HashSetImplementation();
  }
  else {
    this._scope = new BlockScope(this, null, false);
  }
  this._usedTemps = new HashSetImplementation();
  this._freeTemps = [];
}
MethodGenerator.prototype.get$enclosingMethod = function() { return this.enclosingMethod; };
MethodGenerator.prototype.set$enclosingMethod = function(value) { return this.enclosingMethod = value; };
MethodGenerator.prototype.get$needsThis = function() { return this.needsThis; };
MethodGenerator.prototype.set$needsThis = function(value) { return this.needsThis = value; };
MethodGenerator.prototype.get$library = function() {
  return this.method.get$library();
}
MethodGenerator.prototype.findMembers = function(name) {
  return this.get$library()._findMembers(name);
}
MethodGenerator.prototype.get$isClosure = function() {
  return (this.enclosingMethod != null);
}
MethodGenerator.prototype.get$isStatic = function() {
  return this.method.get$isStatic();
}
MethodGenerator.prototype.getTemp = function(value) {
  return value.needsTemp ? this.forceTemp(value) : value;
}
MethodGenerator.prototype.forceTemp = function(value) {
  var name;
  if (this._freeTemps.length > 0) {
    name = this._freeTemps.removeLast();
  }
  else {
    name = '\$' + this._usedTemps.get$length();
  }
  this._usedTemps.add(name);
  return new Value(value.get$type(), name, value.span, false);
}
MethodGenerator.prototype.assignTemp = function(tmp, v) {
  if ($eq(tmp, v)) {
    return v;
  }
  else {
    return new Value(v.get$type(), ('(' + tmp.code + ' = ' + v.code + ')'), v.span, true);
  }
}
MethodGenerator.prototype.freeTemp = function(value) {
  if (this._usedTemps.remove(value.code)) {
    this._freeTemps.add(value.code);
  }
  else {
    $globals.world.internalError(('tried to free unused value or non-temp "' + value.code + '"'));
  }
}
MethodGenerator.prototype.run = function() {
  if (this.method.isGenerated) return;
  this.method.isGenerated = true;
  this.method.generator = this;
  this.writeBody();
  if (this.method.get$definition().get$nativeBody() != null) {
    this.writer = new CodeWriter();
    if ($eq(this.method.get$definition().get$nativeBody(), '')) {
      this.method.generator = null;
    }
    else {
      this._paramCode = map(this.method.get$parameters(), (function (p) {
        return p.get$name();
      })
      );
      this.writer.write(this.method.get$definition().get$nativeBody());
    }
  }
}
MethodGenerator.prototype.writeDefinition = function(defWriter, lambda) {
  var paramCode = this._paramCode;
  var names = null;
  if (this.captures != null && this.captures.get$length() > 0) {
    names = ListFactory.ListFactory$from$factory(this.captures);
    names.sort$1((function (x, y) {
      return x.compareTo$1(y);
    })
    );
    paramCode = ListFactory.ListFactory$from$factory(names);
    paramCode.addAll$1(this._paramCode);
  }
  var _params = ('(' + Strings.join(this._paramCode, ", ") + ')');
  var params = ('(' + Strings.join(paramCode, ", ") + ')');
  if (this.method.declaringType.get$isTop() && !this.get$isClosure()) {
    defWriter.enterBlock(('function ' + this.method.get$jsname() + params + ' {'));
  }
  else if (this.get$isClosure()) {
    if (this.method.name == '') {
      defWriter.enterBlock(('(function ' + params + ' {'));
    }
    else if (names != null) {
      if (lambda == null) {
        defWriter.enterBlock(('var ' + this.method.get$jsname() + ' = (function' + params + ' {'));
      }
      else {
        defWriter.enterBlock(('(function ' + this.method.get$jsname() + params + ' {'));
      }
    }
    else {
      defWriter.enterBlock(('function ' + this.method.get$jsname() + params + ' {'));
    }
  }
  else if (this.method.get$isConstructor()) {
    if (this.method.get$constructorName() == '') {
      defWriter.enterBlock(('function ' + this.method.declaringType.get$jsname() + params + ' {'));
    }
    else {
      defWriter.enterBlock(('' + this.method.declaringType.get$jsname() + '.' + this.method.get$constructorName() + '\$ctor = function' + params + ' {'));
    }
  }
  else if (this.method.get$isFactory()) {
    defWriter.enterBlock(('' + this.method.get$generatedFactoryName() + ' = function' + _params + ' {'));
  }
  else if (this.method.get$isStatic()) {
    defWriter.enterBlock(('' + this.method.declaringType.get$jsname() + '.' + this.method.get$jsname() + ' = function' + _params + ' {'));
  }
  else {
    defWriter.enterBlock(('' + this.method.declaringType.get$jsname() + '.prototype.') + ('' + this.method.get$jsname() + ' = function' + _params + ' {'));
  }
  if (this.needsThis) {
    defWriter.writeln('var \$this = this; // closure support');
  }
  if (this._usedTemps.get$length() > 0 || this._freeTemps.length > 0) {
    this._freeTemps.addAll(this._usedTemps);
    this._freeTemps.sort((function (x, y) {
      return x.compareTo$1(y);
    })
    );
    defWriter.writeln(('var ' + Strings.join(this._freeTemps, ", ") + ';'));
  }
  defWriter.writeln(this.writer.get$text());
  if (names != null) {
    defWriter.exitBlock(('}).bind(null, ' + Strings.join(names, ", ") + ')'));
  }
  else if (this.get$isClosure() && this.method.name == '') {
    defWriter.exitBlock('})');
  }
  else {
    defWriter.exitBlock('}');
  }
  if (this.method.get$isConstructor() && this.method.get$constructorName() != '') {
    defWriter.writeln(('' + this.method.declaringType.get$jsname() + '.' + this.method.get$constructorName() + '\$ctor.prototype = ') + ('' + this.method.declaringType.get$jsname() + '.prototype;'));
  }
  this._provideOptionalParamInfo(defWriter);
  if ((this.method instanceof MethodMember)) {
    var m = this.method;
    if (m._providePropertySyntax) {
      defWriter.enterBlock(('' + m.declaringType.get$jsname() + '.prototype') + ('.get\$' + m.get$jsname() + ' = function() {'));
      defWriter.writeln(('return ' + m.declaringType.get$jsname() + '.prototype.') + ('' + m.get$jsname() + '.bind(this);'));
      defWriter.exitBlock('}');
      if (m._provideFieldSyntax) {
        $globals.world.internalError('bound m accessed with field syntax');
      }
    }
  }
}
MethodGenerator.prototype._provideOptionalParamInfo = function(defWriter) {
  if ((this.method instanceof MethodMember)) {
    var meth = this.method;
    if (meth._provideOptionalParamInfo) {
      var optNames = [];
      var optValues = [];
      meth.genParameterValues();
      var $$list = meth.parameters;
      for (var $$i = 0;$$i < $$list.length; $$i++) {
        var param = $$list.$index($$i);
        if (param.get$isOptional()) {
          optNames.add$1(param.get$name());
          optValues.add$1(MethodGenerator._escapeString(param.get$value().get$code()));
        }
      }
      if (optNames.length > 0) {
        var start = '';
        if (meth.isStatic) {
          if (!meth.declaringType.get$isTop()) {
            start = meth.declaringType.get$jsname() + '.';
          }
        }
        else {
          start = meth.declaringType.get$jsname() + '.prototype.';
        }
        optNames.addAll$1(optValues);
        var optional = "['" + Strings.join(optNames, "', '") + "']";
        defWriter.writeln(('' + start + meth.get$jsname() + '.\$optional = ' + optional));
      }
    }
  }
}
MethodGenerator.prototype.writeBody = function() {
  var initializers = null;
  var initializedFields = null;
  var allMembers = null;
  if (this.method.get$isConstructor()) {
    initializers = [];
    initializedFields = new HashSetImplementation();
    allMembers = $globals.world.gen._orderValues(this.method.declaringType.getAllMembers());
    for (var $$i = allMembers.iterator$0(); $$i.hasNext$0(); ) {
      var f = $$i.next$0();
      if (f.get$isField() && !f.get$isStatic()) {
        var cv = f.computeValue$0();
        if (cv != null) {
          initializers.add$1(('this.' + f.get$jsname() + ' = ' + cv.get$code()));
          initializedFields.add$1(f.get$name());
        }
      }
    }
  }
  this._paramCode = [];
  var $$list = this.method.get$parameters();
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var p = $$list.$index($$i);
    if (initializers != null && p.get$isInitializer()) {
      var field = this.method.declaringType.getMember(p.get$name());
      if (field == null) {
        $globals.world.error('bad this parameter - no matching field', p.get$definition().get$span());
      }
      if (!field.get$isField()) {
        $globals.world.error(('"this.' + p.get$name() + '" does not refer to a field'), p.get$definition().get$span());
      }
      var paramValue = new Value(field.get$returnType(), p.get$name(), p.get$definition().get$span(), false);
      this._paramCode.add(paramValue.get$code());
      initializers.add$1(('this.' + field.get$jsname() + ' = ' + paramValue.get$code() + ';'));
      initializedFields.add$1(p.get$name());
    }
    else {
      var paramValue = this._scope.declareParameter(p);
      this._paramCode.add(paramValue.get$code());
    }
  }
  var body = this.method.get$definition().get$body();
  if (body == null && !this.method.get$isConstructor() && !this.method.get$isNative()) {
    $globals.world.error(('unexpected empty body for ' + this.method.name), this.method.get$definition().get$span());
  }
  var initializerCall = null;
  var declaredInitializers = this.method.get$definition().get$initializers();
  if (initializers != null) {
    for (var $$i = initializers.iterator$0(); $$i.hasNext$0(); ) {
      var i = $$i.next$0();
      this.writer.writeln(i);
    }
    if (declaredInitializers != null) {
      for (var $$i = declaredInitializers.iterator$0(); $$i.hasNext$0(); ) {
        var init = $$i.next$0();
        if ((init instanceof CallExpression)) {
          if (initializerCall != null) {
            $globals.world.error('only one initializer redirecting call is allowed', init.get$span());
          }
          initializerCall = init;
        }
        else if ((init instanceof BinaryExpression) && TokenKind.kindFromAssign(init.get$op().get$kind()) == 0) {
          var left = init.get$x();
          if (!((left instanceof DotExpression) && (left.get$self() instanceof ThisExpression) || (left instanceof VarExpression))) {
            $globals.world.error('invalid left side of initializer', left.get$span());
            continue;
          }
          var f = this.method.declaringType.getMember(left.get$name().get$name());
          if (f == null) {
            $globals.world.error('bad initializer - no matching field', left.get$span());
            continue;
          }
          else if (!f.get$isField()) {
            $globals.world.error(('"' + left.get$name().get$name() + '" does not refer to a field'), left.get$span());
            continue;
          }
          initializedFields.add$1(f.get$name());
          this.writer.writeln(('this.' + f.get$jsname() + ' = ' + this.visitValue(init.get$y()).get$code() + ';'));
        }
        else {
          $globals.world.error('invalid initializer', init.get$span());
        }
      }
    }
    this.writer.comment('// Initializers done');
  }
  if (this.method.get$isConstructor() && initializerCall == null && !this.method.get$isNative()) {
    var parentType = this.method.declaringType.get$parent();
    if (parentType != null && !parentType.get$isObject()) {
      initializerCall = new CallExpression(new SuperExpression(this.method.get$span()), [], this.method.get$span());
    }
  }
  if (initializerCall != null) {
    var target = this._writeInitializerCall(initializerCall);
    if (!target.get$isSuper()) {
      if (initializers.length > 0) {
        var $$list = this.method.get$parameters();
        for (var $$i = 0;$$i < $$list.length; $$i++) {
          var p = $$list.$index($$i);
          if (p.get$isInitializer()) {
            $globals.world.error('no initialization allowed on redirecting constructors', p.get$definition().get$span());
            break;
          }
        }
      }
      if (declaredInitializers != null && declaredInitializers.length > 1) {
        var init = $eq(declaredInitializers.$index(0), initializerCall) ? declaredInitializers.$index(1) : declaredInitializers.$index(0);
        $globals.world.error('no initialization allowed on redirecting constructors', init.get$span());
      }
      initializedFields = null;
    }
  }
  if (initializedFields != null) {
    for (var $$i = allMembers.iterator$0(); $$i.hasNext$0(); ) {
      var member = $$i.next$0();
      if (member.get$isField() && member.get$isFinal() && !member.get$isStatic() && !this.method.get$isNative() && !initializedFields.contains$1(member.get$name())) {
        $globals.world.error(('Field "' + member.get$name() + '" is final and was not initialized'), this.method.get$definition().get$span());
      }
    }
  }
  this.visitStatementsInBlock(body);
}
MethodGenerator.prototype._writeInitializerCall = function(node) {
  var contructorName = '';
  var targetExp = node.target;
  if ((targetExp instanceof DotExpression)) {
    var dot = targetExp;
    targetExp = dot.self;
    contructorName = dot.name.name;
  }
  var target = null;
  if ((targetExp instanceof SuperExpression)) {
    target = this._makeSuperValue(targetExp);
  }
  else if ((targetExp instanceof ThisExpression)) {
    target = this._makeThisValue(targetExp);
  }
  else {
    $globals.world.error('bad call in initializers', node.span);
  }
  target.set$isInitializerTarget(true);
  var m = target.get$type().getConstructor$1(contructorName);
  this.method.set$initDelegate(m);
  var other = m;
  while (other != null) {
    if ($eq(other, this.method)) {
      $globals.world.error('initialization cycle', node.span);
      break;
    }
    other = other.get$initDelegate();
  }
  $globals.world.gen.genMethod(m);
  var value = m.invoke$4(this, node, target, this._makeArgs(node.arguments));
  if ($ne(target.get$type(), $globals.world.objectType)) {
    this.writer.writeln(('' + value.get$code() + ';'));
  }
  return target;
}
MethodGenerator.prototype._makeArgs = function(arguments) {
  var args = [];
  var seenLabel = false;
  for (var $$i = 0;$$i < arguments.length; $$i++) {
    var arg = arguments.$index($$i);
    if (arg.get$label() != null) {
      seenLabel = true;
    }
    else if (seenLabel) {
      $globals.world.error('bare argument can not follow named arguments', arg.get$span());
    }
    args.add$1(this.visitValue(arg.get$value()));
  }
  return new Arguments(arguments, args);
}
MethodGenerator.prototype._invokeNative = function(name, arguments) {
  var args = Arguments.get$EMPTY();
  if (arguments.length > 0) {
    args = new Arguments(null, arguments);
  }
  var method = $globals.world.corelib.topType.members.$index(name);
  return method.invoke$4(this, method.get$definition(), new Value($globals.world.corelib.topType, null, null, true), args);
}
MethodGenerator._escapeString = function(text) {
  return text.replaceAll('\\', '\\\\').replaceAll('"', '\\"').replaceAll('\n', '\\n').replaceAll('\r', '\\r');
}
MethodGenerator.prototype.visitStatementsInBlock = function(body) {
  if ((body instanceof BlockStatement)) {
    var block = body;
    var $$list = block.body;
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var stmt = $$list.$index($$i);
      stmt.visit$1(this);
    }
  }
  else {
    if (body != null) body.visit(this);
  }
  return false;
}
MethodGenerator.prototype._pushBlock = function(reentrant) {
  this._scope = new BlockScope(this, this._scope, reentrant);
}
MethodGenerator.prototype._popBlock = function() {
  this._scope = this._scope.parent;
}
MethodGenerator.prototype._makeLambdaMethod = function(name, func) {
  var meth = new MethodMember(name, this.method.declaringType, func);
  meth.set$isLambda(true);
  meth.set$enclosingElement(this.method);
  meth.resolve$0();
  return meth;
}
MethodGenerator.prototype.visitBool = function(node) {
  return this.visitValue(node).convertTo$3(this, $globals.world.nonNullBool, node);
}
MethodGenerator.prototype.visitValue = function(node) {
  if (node == null) return null;
  var value = node.visit(this);
  value.checkFirstClass$1(node.span);
  return value;
}
MethodGenerator.prototype.visitTypedValue = function(node, expectedType) {
  return this.visitValue(node).convertTo$3(this, expectedType, node);
}
MethodGenerator.prototype.visitVoid = function(node) {
  if ((node instanceof PostfixExpression)) {
    var value = this.visitPostfixExpression(node, true);
    value.checkFirstClass$1(node.span);
    return value;
  }
  else if ((node instanceof BinaryExpression)) {
    var value = this.visitBinaryExpression(node, true);
    value.checkFirstClass$1(node.span);
    return value;
  }
  return this.visitValue(node);
}
MethodGenerator.prototype.visitDietStatement = function(node) {
  var parser = new Parser(node.span.file, false, false, false, node.span.start);
  this.visitStatementsInBlock(parser.block$0());
  return false;
}
MethodGenerator.prototype.visitVariableDefinition = function(node) {
  var isFinal = false;
  if (node.modifiers != null && $eq(node.modifiers.$index(0).get$kind(), 98/*TokenKind.FINAL*/)) {
    isFinal = true;
  }
  this.writer.write('var ');
  var type = this.method.resolveType(node.type, false);
  for (var i = 0;
   i < node.names.length; i++) {
    var thisType = type;
    if (i > 0) {
      this.writer.write(', ');
    }
    var name = node.names.$index(i).get$name();
    var value = this.visitValue(node.values.$index(i));
    if (isFinal) {
      if (value == null) {
        $globals.world.error('no value specified for final variable', node.span);
      }
      else {
        if (thisType.get$isVar()) thisType = value.get$type();
      }
    }
    var val = this._scope.create(name, thisType, node.names.$index(i).get$span(), isFinal, false);
    if (value == null) {
      if (this._scope.reentrant) {
        this.writer.write(('' + val.get$code() + ' = null'));
      }
      else {
        this.writer.write(('' + val.get$code()));
      }
    }
    else {
      value = value.convertTo$3(this, type, node.values.$index(i));
      this.writer.write(('' + val.get$code() + ' = ' + value.get$code()));
    }
  }
  this.writer.writeln(';');
  return false;
}
MethodGenerator.prototype.visitFunctionDefinition = function(node) {
  var meth = this._makeLambdaMethod(node.name.name, node);
  var funcValue = this._scope.create(meth.get$name(), meth.get$functionType(), this.method.get$definition().get$span(), true, false);
  $globals.world.gen.genMethod(meth, this);
  meth.get$generator().writeDefinition$2(this.writer);
  return false;
}
MethodGenerator.prototype.visitReturnStatement = function(node) {
  if (node.value == null) {
    this.writer.writeln('return;');
  }
  else {
    if (this.method.get$isConstructor()) {
      $globals.world.error('return of value not allowed from constructor', node.span);
    }
    var value = this.visitTypedValue(node.value, this.method.get$returnType());
    this.writer.writeln(('return ' + value.get$code() + ';'));
  }
  return true;
}
MethodGenerator.prototype.visitThrowStatement = function(node) {
  if (node.value != null) {
    var value = this.visitValue(node.value);
    value.invoke$4(this, 'toString', node, Arguments.get$EMPTY());
    this.writer.writeln(('\$throw(' + value.get$code() + ');'));
    $globals.world.gen.corejs.useThrow = true;
  }
  else {
    var rethrow = this._scope.getRethrow();
    if (rethrow == null) {
      $globals.world.error('rethrow outside of catch', node.span);
    }
    else {
      this.writer.writeln(('throw ' + rethrow.get$code() + ';'));
    }
  }
  return true;
}
MethodGenerator.prototype.visitAssertStatement = function(node) {
  var test = this.visitValue(node.test);
  if ($globals.options.enableAsserts) {
    var span = node.test.span;
    var line = span.get$file().getLine$1(span.get$start()) + 1;
    var column = span.get$file().getColumn$2(line - 1, span.get$start()) + 1;
    var args = [test, EvaluatedValue.EvaluatedValue$factory($globals.world.stringType, MethodGenerator._escapeString(span.get$text()), ('"' + MethodGenerator._escapeString(span.get$text()) + '"'), null), EvaluatedValue.EvaluatedValue$factory($globals.world.stringType, MethodGenerator._escapeString(span.get$file().get$filename()), ('"' + MethodGenerator._escapeString(span.get$file().get$filename()) + '"'), null), EvaluatedValue.EvaluatedValue$factory($globals.world.intType, line, line.toString$0(), null), EvaluatedValue.EvaluatedValue$factory($globals.world.intType, column, column.toString$0(), null)];
    var tp = $globals.world.corelib.topType;
    var f = tp.getMember$1('_assert');
    var value = f.invoke(this, node, new Value.type$ctor(tp, null), new Arguments(null, args), false);
    this.writer.writeln(('' + value.get$code() + ';'));
  }
  return false;
}
MethodGenerator.prototype.visitBreakStatement = function(node) {
  if (node.label == null) {
    this.writer.writeln('break;');
  }
  else {
    this.writer.writeln(('break ' + node.label.name + ';'));
  }
  return true;
}
MethodGenerator.prototype.visitContinueStatement = function(node) {
  if (node.label == null) {
    this.writer.writeln('continue;');
  }
  else {
    this.writer.writeln(('continue ' + node.label.name + ';'));
  }
  return true;
}
MethodGenerator.prototype.visitIfStatement = function(node) {
  var test = this.visitBool(node.test);
  this.writer.write(('if (' + test.get$code() + ') '));
  var exit1 = node.trueBranch.visit(this);
  if (node.falseBranch != null) {
    this.writer.write('else ');
    if (node.falseBranch.visit(this) && exit1) {
      return true;
    }
  }
  return false;
}
MethodGenerator.prototype.visitWhileStatement = function(node) {
  var test = this.visitBool(node.test);
  this.writer.write(('while (' + test.get$code() + ') '));
  this._pushBlock(true);
  node.body.visit(this);
  this._popBlock();
  return false;
}
MethodGenerator.prototype.visitDoStatement = function(node) {
  this.writer.write('do ');
  this._pushBlock(true);
  node.body.visit(this);
  this._popBlock();
  var test = this.visitBool(node.test);
  this.writer.writeln(('while (' + test.get$code() + ')'));
  return false;
}
MethodGenerator.prototype.visitForStatement = function(node) {
  this._pushBlock(false);
  this.writer.write('for (');
  if (node.init != null) node.init.visit(this);
  else this.writer.write(';');
  if (node.test != null) {
    var test = this.visitBool(node.test);
    this.writer.write((' ' + test.get$code() + '; '));
  }
  else {
    this.writer.write('; ');
  }
  var needsComma = false;
  var $$list = node.step;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var s = $$list.$index($$i);
    if (needsComma) this.writer.write(', ');
    var sv = this.visitVoid(s);
    this.writer.write(sv.get$code());
    needsComma = true;
  }
  this.writer.write(') ');
  this._pushBlock(true);
  node.body.visit(this);
  this._popBlock();
  this._popBlock();
  return false;
}
MethodGenerator.prototype._isFinal = function(typeRef) {
  if ((typeRef instanceof GenericTypeReference)) {
    typeRef = typeRef.get$baseType();
  }
  return typeRef != null && typeRef.get$isFinal();
}
MethodGenerator.prototype.visitForInStatement = function(node) {
  var itemType = this.method.resolveType(node.item.type, false);
  var itemName = node.item.name.name;
  var list = node.list.visit(this);
  this._pushBlock(true);
  var isFinal = this._isFinal(node.item.type);
  var item = this._scope.create(itemName, itemType, node.item.name.span, isFinal, false);
  var listVar = list;
  if (list.get$needsTemp()) {
    listVar = this._scope.create('\$list', list.get$type(), null, false, false);
    this.writer.writeln(('var ' + listVar.code + ' = ' + list.get$code() + ';'));
  }
  if (list.get$type().get$isList()) {
    var tmpi = this._scope.create('\$i', $globals.world.numType, null, false, false);
    this.writer.enterBlock(('for (var ' + tmpi.get$code() + ' = 0;') + ('' + tmpi.get$code() + ' < ' + listVar.code + '.length; ' + tmpi.get$code() + '++) {'));
    var value = listVar.invoke(this, ':index', node.list, new Arguments(null, [tmpi]), false);
    this.writer.writeln(('var ' + item.get$code() + ' = ' + value.get$code() + ';'));
  }
  else {
    this._pushBlock(false);
    var iterator = list.invoke$4(this, 'iterator', node.list, Arguments.get$EMPTY());
    var tmpi = this._scope.create('\$i', iterator.get$type(), null, false, false);
    var hasNext = tmpi.invoke$4(this, 'hasNext', node.list, Arguments.get$EMPTY());
    var next = tmpi.invoke$4(this, 'next', node.list, Arguments.get$EMPTY());
    this.writer.enterBlock(('for (var ' + tmpi.get$code() + ' = ' + iterator.get$code() + '; ' + hasNext.get$code() + '; ) {'));
    this.writer.writeln(('var ' + item.get$code() + ' = ' + next.get$code() + ';'));
  }
  this.visitStatementsInBlock(node.body);
  this.writer.exitBlock('}');
  this._popBlock();
  return false;
}
MethodGenerator.prototype._genToDartException = function(ex, node) {
  var result = this._invokeNative("_toDartException", [ex]);
  this.writer.writeln(('' + ex.code + ' = ' + result.get$code() + ';'));
}
MethodGenerator.prototype.visitTryStatement = function(node) {
  this.writer.enterBlock('try {');
  this._pushBlock(false);
  this.visitStatementsInBlock(node.body);
  this._popBlock();
  if (node.catches.length == 1) {
    var catch_ = node.catches.$index(0);
    this._pushBlock(false);
    var ex = this._scope.declare(catch_.get$exception());
    this._scope.rethrow = ex;
    this.writer.nextBlock(('} catch (' + ex.get$code() + ') {'));
    if (catch_.get$trace() != null) {
      var trace = this._scope.declare(catch_.get$trace());
      this.writer.writeln(('var ' + trace.get$code() + ' = \$stackTraceOf(' + ex.get$code() + ');'));
      $globals.world.gen.corejs.useStackTraceOf = true;
    }
    this._genToDartException(ex, node);
    if (!ex.get$type().get$isVarOrObject()) {
      var test = ex.instanceOf$3$isTrue$forceCheck(this, ex.get$type(), catch_.get$exception().get$span(), false, true);
      this.writer.writeln(('if (' + test.get$code() + ') throw ' + ex.get$code() + ';'));
    }
    this.visitStatementsInBlock(node.catches.$index(0).get$body());
    this._popBlock();
  }
  else if (node.catches.length > 0) {
    this._pushBlock(false);
    var ex = this._scope.create('\$ex', $globals.world.varType, null, false, false);
    this._scope.rethrow = ex;
    this.writer.nextBlock(('} catch (' + ex.get$code() + ') {'));
    var trace = null;
    if (node.catches.some((function (c) {
      return c.get$trace() != null;
    })
    )) {
      trace = this._scope.create('\$trace', $globals.world.varType, null, false, false);
      this.writer.writeln(('var ' + trace.get$code() + ' = \$stackTraceOf(' + ex.get$code() + ');'));
      $globals.world.gen.corejs.useStackTraceOf = true;
    }
    this._genToDartException(ex, node);
    var needsRethrow = true;
    for (var i = 0;
     i < node.catches.length; i++) {
      var catch_ = node.catches.$index(i);
      this._pushBlock(false);
      var tmp = this._scope.declare(catch_.get$exception());
      if (!tmp.get$type().get$isVarOrObject()) {
        var test = ex.instanceOf$3$isTrue$forceCheck(this, tmp.get$type(), catch_.get$exception().get$span(), true, true);
        if (i == 0) {
          this.writer.enterBlock(('if (' + test.get$code() + ') {'));
        }
        else {
          this.writer.nextBlock(('} else if (' + test.get$code() + ') {'));
        }
      }
      else if (i > 0) {
        this.writer.nextBlock('} else {');
      }
      this.writer.writeln(('var ' + tmp.get$code() + ' = ' + ex.get$code() + ';'));
      if (catch_.get$trace() != null) {
        var tmptrace = this._scope.declare(catch_.get$trace());
        this.writer.writeln(('var ' + tmptrace.get$code() + ' = ' + trace.get$code() + ';'));
      }
      this.visitStatementsInBlock(catch_.get$body());
      this._popBlock();
      if (tmp.get$type().get$isVarOrObject()) {
        if (i + 1 < node.catches.length) {
          $globals.world.error('Unreachable catch clause', node.catches.$index(i + 1).get$span());
        }
        if (i > 0) {
          this.writer.exitBlock('}');
        }
        needsRethrow = false;
        break;
      }
    }
    if (needsRethrow) {
      this.writer.nextBlock('} else {');
      this.writer.writeln(('throw ' + ex.get$code() + ';'));
      this.writer.exitBlock('}');
    }
    this._popBlock();
  }
  if (node.finallyBlock != null) {
    this.writer.nextBlock('} finally {');
    this._pushBlock(false);
    this.visitStatementsInBlock(node.finallyBlock);
    this._popBlock();
  }
  this.writer.exitBlock('}');
  return false;
}
MethodGenerator.prototype.visitSwitchStatement = function(node) {
  var test = this.visitValue(node.test);
  this.writer.enterBlock(('switch (' + test.get$code() + ') {'));
  var $$list = node.cases;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var case_ = $$list.$index($$i);
    if (case_.get$label() != null) {
      $globals.world.error('unimplemented: labeled case statement', case_.get$span());
    }
    this._pushBlock(false);
    for (var i = 0;
     i < case_.get$cases().length; i++) {
      var expr = case_.get$cases().$index(i);
      if (expr == null) {
        if (i < case_.get$cases().length - 1) {
          $globals.world.error('default clause must be the last case', case_.get$span());
        }
        this.writer.writeln('default:');
      }
      else {
        var value = this.visitValue(expr);
        this.writer.writeln(('case ' + value.get$code() + ':'));
      }
    }
    this.writer.enterBlock('');
    var caseExits = this._visitAllStatements(case_.get$statements(), false);
    if ($ne(case_, node.cases.$index(node.cases.length - 1)) && !caseExits) {
      var span = case_.get$statements().$index(case_.get$statements().length - 1).get$span();
      this.writer.writeln('\$throw(new FallThroughError());');
      $globals.world.gen.corejs.useThrow = true;
    }
    this.writer.exitBlock('');
    this._popBlock();
  }
  this.writer.exitBlock('}');
  return false;
}
MethodGenerator.prototype._visitAllStatements = function(statementList, exits) {
  for (var i = 0;
   i < statementList.length; i++) {
    var stmt = statementList.$index(i);
    exits = stmt.visit$1(this);
    if ($ne(stmt, statementList.$index(statementList.length - 1)) && exits) {
      $globals.world.warning('unreachable code', statementList.$index(i + 1).get$span());
    }
  }
  return exits;
}
MethodGenerator.prototype.visitBlockStatement = function(node) {
  this._pushBlock(false);
  this.writer.enterBlock('{');
  var exits = this._visitAllStatements(node.body, false);
  this.writer.exitBlock('}');
  this._popBlock();
  return exits;
}
MethodGenerator.prototype.visitLabeledStatement = function(node) {
  this.writer.writeln(('' + node.name.name + ':'));
  node.body.visit(this);
  return false;
}
MethodGenerator.prototype.visitExpressionStatement = function(node) {
  if ((node.body instanceof VarExpression) || (node.body instanceof ThisExpression)) {
    $globals.world.warning('variable used as statement', node.span);
  }
  var value = this.visitVoid(node.body);
  this.writer.writeln(('' + value.get$code() + ';'));
  return false;
}
MethodGenerator.prototype.visitEmptyStatement = function(node) {
  this.writer.writeln(';');
  return false;
}
MethodGenerator.prototype._checkNonStatic = function(node) {
  if (this.get$isStatic()) {
    $globals.world.warning('not allowed in static method', node.span);
  }
}
MethodGenerator.prototype._makeSuperValue = function(node) {
  var parentType = this.method.declaringType.get$parent();
  this._checkNonStatic(node);
  if (parentType == null) {
    $globals.world.error('no super class', node.span);
  }
  var ret = new Value(parentType, 'this', node.span, false);
  ret.set$isSuper(true);
  return ret;
}
MethodGenerator.prototype._getOutermostMethod = function() {
  var result = this;
  while (result.get$enclosingMethod() != null) {
    result = result.get$enclosingMethod();
  }
  return result;
}
MethodGenerator.prototype._makeThisCode = function() {
  if (this.enclosingMethod != null) {
    this._getOutermostMethod().set$needsThis(true);
    return '\$this';
  }
  else {
    return 'this';
  }
}
MethodGenerator.prototype._makeThisValue = function(node) {
  if (this.enclosingMethod != null) {
    var outermostMethod = this._getOutermostMethod();
    outermostMethod._checkNonStatic$1(node);
    outermostMethod.set$needsThis(true);
    return new Value(outermostMethod.method.get$declaringType(), '\$this', node != null ? node.span : null, false);
  }
  else {
    this._checkNonStatic(node);
    return new Value(this.method.declaringType, 'this', node != null ? node.span : null, false);
  }
}
MethodGenerator.prototype.visitLambdaExpression = function(node) {
  var name = (node.func.name != null) ? node.func.name.name : '';
  var meth = this._makeLambdaMethod(name, node.func);
  var lambdaGen = new MethodGenerator(meth, this);
  if ($ne(name, '')) {
    lambdaGen._scope.create(name, meth.get$functionType(), meth.definition.span, true, false);
    lambdaGen._pushBlock(false);
  }
  lambdaGen.run();
  var w = new CodeWriter();
  meth.generator.writeDefinition(w, node);
  return new Value(meth.get$functionType(), w.get$text(), node.span, true);
}
MethodGenerator.prototype.visitCallExpression = function(node) {
  var target;
  var position = node.target;
  var name = ':call';
  if ((node.target instanceof DotExpression)) {
    var dot = node.target;
    target = dot.self.visit(this);
    name = dot.name.name;
    position = dot.name;
  }
  else if ((node.target instanceof VarExpression)) {
    var varExpr = node.target;
    name = varExpr.name.name;
    target = this._scope.lookup(name);
    if (target != null) {
      return target.invoke$4(this, ':call', node, this._makeArgs(node.arguments));
    }
    target = this._makeThisOrType(varExpr.span);
    return target.invoke$4(this, name, node, this._makeArgs(node.arguments));
  }
  else {
    target = node.target.visit(this);
  }
  return target.invoke$4(this, name, position, this._makeArgs(node.arguments));
}
MethodGenerator.prototype.visitIndexExpression = function(node) {
  var target = this.visitValue(node.target);
  var index = this.visitValue(node.index);
  return target.invoke$4(this, ':index', node, new Arguments(null, [index]));
}
MethodGenerator.prototype.visitBinaryExpression = function(node, isVoid) {
  var kind = node.op.kind;
  if (kind == 35/*TokenKind.AND*/ || kind == 34/*TokenKind.OR*/) {
    var x = this.visitTypedValue(node.x, $globals.world.nonNullBool);
    var y = this.visitTypedValue(node.y, $globals.world.nonNullBool);
    var code = ('' + x.get$code() + ' ' + node.op + ' ' + y.get$code());
    if (x.get$isConst() && y.get$isConst()) {
      var value = (kind == 35/*TokenKind.AND*/) ? x.get$actualValue() && y.get$actualValue() : x.get$actualValue() || y.get$actualValue();
      return EvaluatedValue.EvaluatedValue$factory($globals.world.nonNullBool, value, ('' + value), node.span);
    }
    return new Value($globals.world.nonNullBool, code, node.span, true);
  }
  else if (kind == 50/*TokenKind.EQ_STRICT*/ || kind == 51/*TokenKind.NE_STRICT*/) {
    var x = this.visitValue(node.x);
    var y = this.visitValue(node.y);
    if (x.get$isConst() && y.get$isConst()) {
      var xVal = x.get$actualValue();
      var yVal = y.get$actualValue();
      if (x.get$type().get$isString() && y.get$type().get$isString() && $ne(xVal.$index(0), yVal.$index(0))) {
        if ($eq(xVal.$index(0), '"')) {
          xVal = xVal.substring$2(1, xVal.length - 1);
          yVal = toDoubleQuote(yVal.substring$2(1, yVal.length - 1));
        }
        else {
          xVal = toDoubleQuote(xVal.substring$2(1, xVal.length - 1));
          yVal = yVal.substring$2(1, yVal.length - 1);
        }
      }
      var value = kind == 50/*TokenKind.EQ_STRICT*/ ? $eq(xVal, yVal) : $ne(xVal, yVal);
      return EvaluatedValue.EvaluatedValue$factory($globals.world.nonNullBool, value, ("" + value), node.span);
    }
    if ($eq(x.get$code(), 'null') || $eq(y.get$code(), 'null')) {
      var op = node.op.toString().substring(0, 2);
      return new Value($globals.world.nonNullBool, ('' + x.get$code() + ' ' + op + ' ' + y.get$code()), node.span, true);
    }
    else {
      return new Value($globals.world.nonNullBool, ('' + x.get$code() + ' ' + node.op + ' ' + y.get$code()), node.span, true);
    }
  }
  var assignKind = TokenKind.kindFromAssign(node.op.kind);
  if (assignKind == -1) {
    var x = this.visitValue(node.x);
    var y = this.visitValue(node.y);
    var name = TokenKind.binaryMethodName(node.op.kind);
    if (node.op.kind == 49/*TokenKind.NE*/) {
      name = ':ne';
    }
    if (name == null) {
      $globals.world.internalError(('unimplemented binary op ' + node.op), node.span);
      return;
    }
    return x.invoke$4(this, name, node, new Arguments(null, [y]));
  }
  else {
    return this._visitAssign(assignKind, node.x, node.y, node, to$call$1(null), isVoid);
  }
}
MethodGenerator.prototype._visitAssign = function(kind, xn, yn, position, captureOriginal, isVoid) {
  if (captureOriginal == null) {
    captureOriginal = (function (x) {
      return x;
    })
    ;
  }
  if ((xn instanceof VarExpression)) {
    return this._visitVarAssign(kind, xn, yn, position, captureOriginal);
  }
  else if ((xn instanceof IndexExpression)) {
    return this._visitIndexAssign(kind, xn, yn, position, captureOriginal, isVoid);
  }
  else if ((xn instanceof DotExpression)) {
    return this._visitDotAssign(kind, xn, yn, position, captureOriginal);
  }
  else {
    $globals.world.error('illegal lhs', xn.span);
  }
}
MethodGenerator.prototype._visitVarAssign = function(kind, xn, yn, position, captureOriginal) {
  var name = xn.name.name;
  var x = this._scope.lookup(name);
  var y = this.visitValue(yn);
  if (x == null) {
    var members = this.method.declaringType.resolveMember(name);
    x = this._makeThisOrType(position.span);
    if (members != null) {
      if ($globals.options.forceDynamic && !members.get$isStatic()) {
        members = this.findMembers(xn.name.name);
      }
      if (kind == 0) {
        return x.set_$4(this, name, position, y);
      }
      else if (!members.get$treatAsField() || members.get$containsMethods()) {
        var right = x.get_$3(this, name, position);
        right = captureOriginal(right);
        y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
        return x.set_$4(this, name, position, y);
      }
      else {
        x = x.get_$3(this, name, position);
      }
    }
    else {
      var member = this.get$library().lookup(name, xn.name.span);
      if (member == null) {
        $globals.world.warning(('can not resolve ' + name), xn.span);
        return this._makeMissingValue(name);
      }
      members = new MemberSet(member, false);
      if (!members.get$treatAsField() || members.get$containsMethods()) {
        if (kind != 0) {
          var right = members._get$3(this, position, x);
          right = captureOriginal(right);
          y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
        }
        return members._set$4(this, position, x, y);
      }
      else {
        x = members._get$3(this, position, x);
      }
    }
  }
  if (x.get$isFinal()) {
    $globals.world.error(('final variable "' + x.get$code() + '" is not assignable'), position.span);
  }
  y = y.convertTo$3(this, x.get$type(), yn);
  if (kind == 0) {
    x = captureOriginal(x);
    return new Value(y.get$type(), ('' + x.get$code() + ' = ' + y.get$code()), position.span, true);
  }
  else if (x.get$type().get$isNum() && y.get$type().get$isNum() && (kind != 46/*TokenKind.TRUNCDIV*/)) {
    x = captureOriginal(x);
    var op = TokenKind.kindToString(kind);
    return new Value(y.get$type(), ('' + x.get$code() + ' ' + op + '= ' + y.get$code()), position.span, true);
  }
  else {
    var right = x;
    right = captureOriginal(right);
    y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
    return new Value(y.get$type(), ('' + x.get$code() + ' = ' + y.get$code()), position.span, true);
  }
}
MethodGenerator.prototype._visitIndexAssign = function(kind, xn, yn, position, captureOriginal, isVoid) {
  var target = this.visitValue(xn.target);
  var index = this.visitValue(xn.index);
  var y = this.visitValue(yn);
  var tmptarget = target;
  var tmpindex = index;
  if (kind != 0) {
    tmptarget = this.getTemp(target);
    tmpindex = this.getTemp(index);
    index = this.assignTemp(tmpindex, index);
    var right = tmptarget.invoke$4(this, ':index', position, new Arguments(null, [tmpindex]));
    right = captureOriginal(right);
    y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
  }
  var tmpy = null;
  if (!isVoid) {
    tmpy = this.getTemp(y);
    y = this.assignTemp(tmpy, y);
  }
  var ret = this.assignTemp(tmptarget, target).invoke(this, ':setindex', position, new Arguments(null, [index, y]), false);
  if (tmpy != null) {
    ret = new Value(ret.get$type(), ('(' + ret.get$code() + ', ' + tmpy.get$code() + ')'), ret.get$span(), true);
    if ($ne(tmpy, y)) this.freeTemp(tmpy);
  }
  if ($ne(tmptarget, target)) this.freeTemp(tmptarget);
  if ($ne(tmpindex, index)) this.freeTemp(tmpindex);
  return ret;
}
MethodGenerator.prototype._visitDotAssign = function(kind, xn, yn, position, captureOriginal) {
  var target = xn.self.visit(this);
  var y = this.visitValue(yn);
  var tmptarget = target;
  if (kind != 0) {
    tmptarget = this.getTemp(target);
    var right = tmptarget.get_$3(this, xn.name.name, xn.name);
    right = captureOriginal(right);
    y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
  }
  var ret = this.assignTemp(tmptarget, target).set_(this, xn.name.name, xn.name, y, false);
  if ($ne(tmptarget, target)) this.freeTemp(tmptarget);
  return ret;
}
MethodGenerator.prototype.visitUnaryExpression = function(node) {
  var value = this.visitValue(node.self);
  switch (node.op.kind) {
    case 16/*TokenKind.INCR*/:
    case 17/*TokenKind.DECR*/:

      if (value.get$type().get$isNum()) {
        return new Value(value.get$type(), ('' + node.op + value.get$code()), node.span, true);
      }
      else {
        var kind = (16/*TokenKind.INCR*/ == node.op.kind ? 42/*TokenKind.ADD*/ : 43/*TokenKind.SUB*/);
        var operand = new LiteralExpression(1, new TypeReference(node.span, $globals.world.numType), '1', node.span);
        var assignValue = this._visitAssign(kind, node.self, operand, node, to$call$1(null), false);
        return new Value(assignValue.get$type(), ('(' + assignValue.get$code() + ')'), node.span, true);
      }

    case 19/*TokenKind.NOT*/:

      if (value.get$type().get$isBool() && value.get$isConst()) {
        var newVal = !value.get$actualValue();
        return EvaluatedValue.EvaluatedValue$factory(value.get$type(), newVal, ('' + newVal), node.span);
      }
      else {
        var newVal = value.convertTo$3(this, $globals.world.nonNullBool, node);
        return new Value(newVal.get$type(), ('!' + newVal.get$code()), node.span, true);
      }

    case 42/*TokenKind.ADD*/:

      return value.convertTo$3(this, $globals.world.numType, node);

    case 43/*TokenKind.SUB*/:
    case 18/*TokenKind.BIT_NOT*/:

      if (node.op.kind == 18/*TokenKind.BIT_NOT*/) {
        return value.invoke$4(this, ':bit_not', node, Arguments.get$EMPTY());
      }
      else if (node.op.kind == 43/*TokenKind.SUB*/) {
        return value.invoke$4(this, ':negate', node, Arguments.get$EMPTY());
      }
      else {
        $globals.world.internalError(('unimplemented: unary ' + node.op), node.span);
      }
      $throw(new FallThroughError());

    default:

      $globals.world.internalError(('unimplemented: ' + node.op), node.span);

  }
}
MethodGenerator.prototype.visitAwaitExpression = function(node) {
  $globals.world.internalError('Await expressions should have been eliminated before code generation', node.span);
}
MethodGenerator.prototype.visitPostfixExpression = function(node, isVoid) {
  var $this = this; // closure support
  var value = this.visitValue(node.body);
  if (value.get$type().get$isNum() && !value.get$isFinal()) {
    return new Value(value.get$type(), ('' + value.get$code() + node.op), node.span, true);
  }
  var kind = (16/*TokenKind.INCR*/ == node.op.kind) ? 42/*TokenKind.ADD*/ : 43/*TokenKind.SUB*/;
  var operand = new LiteralExpression(1, new TypeReference(node.span, $globals.world.numType), '1', node.span);
  var tmpleft = null, left = null;
  var ret = this._visitAssign(kind, node.body, operand, node, (function (l) {
    if (isVoid) {
      return l;
    }
    else {
      left = l;
      tmpleft = $this.forceTemp(l);
      return $this.assignTemp(tmpleft, left);
    }
  })
  , false);
  if (tmpleft != null) {
    ret = new Value(ret.get$type(), ("(" + ret.get$code() + ", " + tmpleft.get$code() + ")"), node.span, true);
  }
  if ($ne(tmpleft, left)) {
    this.freeTemp(tmpleft);
  }
  return ret;
}
MethodGenerator.prototype.visitNewExpression = function(node) {
  var typeRef = node.type;
  var constructorName = '';
  if (node.name != null) {
    constructorName = node.name.name;
  }
  if ($eq(constructorName, '') && !(typeRef instanceof GenericTypeReference) && typeRef.get$names() != null) {
    var names = ListFactory.ListFactory$from$factory(typeRef.get$names());
    constructorName = names.removeLast$0().get$name();
    if ($eq(names.length, 0)) names = null;
    typeRef = new NameTypeReference(typeRef.get$isFinal(), typeRef.get$name(), names, typeRef.get$span());
  }
  var type = this.method.resolveType(typeRef, true);
  if (type.get$isTop()) {
    type = type.get$library().findTypeByName$1(constructorName);
    constructorName = '';
  }
  if ((type instanceof ParameterType)) {
    $globals.world.error('cannot instantiate a type parameter', node.span);
    return this._makeMissingValue(constructorName);
  }
  var m = type.getConstructor$1(constructorName);
  if (m == null) {
    var name = type.get$jsname();
    if (type.get$isVar()) {
      name = typeRef.get$name().get$name();
    }
    $globals.world.error(('no matching constructor for ' + name), node.span);
    return this._makeMissingValue(name);
  }
  if (node.isConst) {
    if (!m.get$isConst()) {
      $globals.world.error('can\'t use const on a non-const constructor', node.span);
    }
    var $$list = node.arguments;
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var arg = $$list.$index($$i);
      if (!this.visitValue(arg.get$value()).get$isConst()) {
        $globals.world.error('const constructor expects const arguments', arg.get$span());
      }
    }
  }
  var target = new Value.type$ctor(type, typeRef.get$span());
  return m.invoke$4(this, node, target, this._makeArgs(node.arguments));
}
MethodGenerator.prototype.visitListExpression = function(node) {
  var argsCode = [];
  var argValues = [];
  var type = null;
  if (node.type != null) {
    type = this.method.resolveType(node.type, true).get$typeArgsInOrder().$index(0);
    if (node.isConst && ((type instanceof ParameterType) || type.get$hasTypeParams())) {
      $globals.world.error('type parameter cannot be used in const list literals');
    }
  }
  var $$list = node.values;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var item = $$list.$index($$i);
    var arg = type == null ? this.visitValue(item) : this.visitTypedValue(item, type);
    argValues.add$1(arg);
    if (node.isConst) {
      if (!arg.get$isConst()) {
        $globals.world.error('const list can only contain const values', item.get$span());
        argsCode.add$1(arg.get$code());
      }
      else {
        argsCode.add$1(arg.get$canonicalCode());
      }
    }
    else {
      argsCode.add$1(arg.get$code());
    }
  }
  $globals.world.get$coreimpl().types.$index('ListFactory').markUsed$0();
  var code = ('[' + Strings.join(argsCode, ", ") + ']');
  var value = new Value($globals.world.listType, code, node.span, true);
  if (node.isConst) {
    var immutableList = $globals.world.get$coreimpl().types.$index('ImmutableList');
    var immutableListCtor = immutableList.getConstructor$1('from');
    var result = immutableListCtor.invoke$4(this, node, new Value.type$ctor(value.get$type(), node.span), new Arguments(null, [value]));
    value = $globals.world.gen.globalForConst(ConstListValue.ConstListValue$factory(immutableList, argValues, ('const ' + code), result.get$code(), node.span), argValues);
  }
  return value;
}
MethodGenerator.prototype.visitMapExpression = function(node) {
  if (node.items.length == 0 && !node.isConst) {
    return $globals.world.mapType.getConstructor('').invoke$4(this, node, new Value.type$ctor($globals.world.mapType, node.span), Arguments.get$EMPTY());
  }
  var argValues = [];
  var argsCode = [];
  var type = null;
  if (node.type != null) {
    type = this.method.resolveType(node.type, true).get$typeArgsInOrder().$index(1);
    if (node.isConst && ((type instanceof ParameterType) || type.get$hasTypeParams())) {
      $globals.world.error('type parameter cannot be used in const map literals');
    }
  }
  for (var i = 0;
   i < node.items.length; i += 2) {
    var key = this.visitTypedValue(node.items.$index(i), $globals.world.stringType);
    var valueItem = node.items.$index(i + 1);
    var value = type == null ? this.visitValue(valueItem) : this.visitTypedValue(valueItem, type);
    argValues.add$1(key);
    argValues.add$1(value);
    if (node.isConst) {
      if (!key.get$isConst() || !value.get$isConst()) {
        $globals.world.error('const map can only contain const values', valueItem.get$span());
        argsCode.add$1(key.get$code());
        argsCode.add$1(value.get$code());
      }
      else {
        argsCode.add$1(key.get$canonicalCode());
        argsCode.add$1(value.get$canonicalCode());
      }
    }
    else {
      argsCode.add$1(key.get$code());
      argsCode.add$1(value.get$code());
    }
  }
  var argList = ('[' + Strings.join(argsCode, ", ") + ']');
  var items = new Value($globals.world.listType, argList, node.span, true);
  var tp = $globals.world.corelib.topType;
  var f = node.isConst ? tp.getMember$1('_constMap') : tp.getMember$1('_map');
  var value = f.invoke(this, node, new Value.type$ctor(tp, null), new Arguments(null, [items]), false);
  if (node.isConst) {
    value = ConstMapValue.ConstMapValue$factory(value.get$type(), argValues, value.get$code(), value.get$code(), value.get$span());
    return $globals.world.gen.globalForConst(value, argValues);
  }
  else {
    return value;
  }
}
MethodGenerator.prototype.visitConditionalExpression = function(node) {
  var test = this.visitBool(node.test);
  var trueBranch = this.visitValue(node.trueBranch);
  var falseBranch = this.visitValue(node.falseBranch);
  var code = ('' + test.get$code() + ' ? ' + trueBranch.get$code() + ' : ' + falseBranch.get$code());
  return new Value(Type.union(trueBranch.get$type(), falseBranch.get$type()), code, node.span, true);
}
MethodGenerator.prototype.visitIsExpression = function(node) {
  var value = this.visitValue(node.x);
  var type = this.method.resolveType(node.type, false);
  return value.instanceOf$4(this, type, node.span, node.isTrue);
}
MethodGenerator.prototype.visitParenExpression = function(node) {
  var body = this.visitValue(node.body);
  if (body.get$isConst()) {
    return EvaluatedValue.EvaluatedValue$factory(body.get$type(), body.get$actualValue(), ('(' + body.get$canonicalCode() + ')'), node.span);
  }
  return new Value(body.get$type(), ('(' + body.get$code() + ')'), node.span, true);
}
MethodGenerator.prototype.visitDotExpression = function(node) {
  var target = node.self.visit(this);
  return target.get_$3(this, node.name.name, node.name);
}
MethodGenerator.prototype.visitVarExpression = function(node) {
  var name = node.name.name;
  var ret = this._scope.lookup(name);
  if (ret != null) return ret;
  return this._makeThisOrType(node.span).get_$3(this, name, node);
}
MethodGenerator.prototype._makeMissingValue = function(name) {
  return new Value($globals.world.varType, ('' + name + '()/*NotFound*/'), null, true);
}
MethodGenerator.prototype._makeThisOrType = function(span) {
  return new BareValue(this, this._getOutermostMethod(), span);
}
MethodGenerator.prototype.visitThisExpression = function(node) {
  return this._makeThisValue(node);
}
MethodGenerator.prototype.visitSuperExpression = function(node) {
  return this._makeSuperValue(node);
}
MethodGenerator.prototype.visitNullExpression = function(node) {
  return EvaluatedValue.EvaluatedValue$factory($globals.world.varType, null, 'null', null);
}
MethodGenerator.prototype._isUnaryIncrement = function(item) {
  if ((item instanceof UnaryExpression)) {
    var u = item;
    return u.op.kind == 16/*TokenKind.INCR*/ || u.op.kind == 17/*TokenKind.DECR*/;
  }
  else {
    return false;
  }
}
MethodGenerator.prototype.visitLiteralExpression = function(node) {
  var $0;
  var type = node.type.type;
  if (!!(($0 = node.value) && $0.is$List())) {
    var items = [];
    var $$list = node.value;
    for (var $$i = node.value.iterator$0(); $$i.hasNext$0(); ) {
      var item = $$i.next$0();
      var val = this.visitValue(item);
      val.invoke$4(this, 'toString', item, Arguments.get$EMPTY());
      var code = val.get$code();
      if ((item instanceof BinaryExpression) || (item instanceof ConditionalExpression) || (item instanceof PostfixExpression) || this._isUnaryIncrement(item)) {
        code = ('(' + code + ')');
      }
      if ($eq(items.length, 0) || ($ne(code, "''") && $ne(code, '""'))) {
        items.add$1(code);
      }
    }
    return new Value(type, ('(' + Strings.join(items, " + ") + ')'), node.span, true);
  }
  var text = node.text;
  if (type.get$isString()) {
    if (text.startsWith$1('@')) {
      text = MethodGenerator._escapeString(parseStringLiteral(text));
      text = ('"' + text + '"');
    }
    else if (isMultilineString(text)) {
      text = parseStringLiteral(text);
      text = text.replaceAll$2('\n', '\\n');
      text = toDoubleQuote(text);
      text = ('"' + text + '"');
    }
    if (text !== node.text) {
      node.value = text;
      node.text = text;
    }
  }
  return EvaluatedValue.EvaluatedValue$factory(type, node.value, node.text, null);
}
MethodGenerator.prototype._checkNonStatic$1 = MethodGenerator.prototype._checkNonStatic;
MethodGenerator.prototype.visitBinaryExpression$1 = function($0) {
  return this.visitBinaryExpression($0, false);
};
MethodGenerator.prototype.visitPostfixExpression$1 = function($0) {
  return this.visitPostfixExpression($0, false);
};
MethodGenerator.prototype.writeDefinition$2 = MethodGenerator.prototype.writeDefinition;
// ********** Code for Arguments **************
function Arguments(nodes, values) {
  this.nodes = nodes;
  this.values = values;
  // Initializers done
}
Arguments.Arguments$bare$factory = function(arity) {
  var values = [];
  for (var i = 0;
   i < arity; i++) {
    values.add$1(new Value($globals.world.varType, ('\$' + i), null, false));
  }
  return new Arguments(null, values);
}
Arguments.get$EMPTY = function() {
  if ($globals.Arguments__empty == null) {
    $globals.Arguments__empty = new Arguments(null, []);
  }
  return $globals.Arguments__empty;
}
Arguments.prototype.get$values = function() { return this.values; };
Arguments.prototype.set$values = function(value) { return this.values = value; };
Arguments.prototype.get$nameCount = function() {
  return this.get$length() - this.get$bareCount();
}
Arguments.prototype.get$hasNames = function() {
  return this.get$bareCount() < this.get$length();
}
Arguments.prototype.get$length = function() {
  return this.values.length;
}
Object.defineProperty(Arguments.prototype, "length", {
  get: Arguments.prototype.get$length
});
Arguments.prototype.getName = function(i) {
  return this.nodes.$index(i).get$label().get$name();
}
Arguments.prototype.getIndexOfName = function(name) {
  for (var i = this.get$bareCount();
   i < this.get$length(); i++) {
    if (this.getName(i) == name) {
      return i;
    }
  }
  return -1;
}
Arguments.prototype.getValue = function(name) {
  var i = this.getIndexOfName(name);
  return i >= 0 ? this.values.$index(i) : null;
}
Arguments.prototype.get$bareCount = function() {
  if (this._bareCount == null) {
    this._bareCount = this.get$length();
    if (this.nodes != null) {
      for (var i = 0;
       i < this.nodes.length; i++) {
        if (this.nodes.$index(i).get$label() != null) {
          this._bareCount = i;
          break;
        }
      }
    }
  }
  return this._bareCount;
}
Arguments.prototype.getCode = function() {
  var argsCode = [];
  for (var i = 0;
   i < this.get$length(); i++) {
    argsCode.add$1(this.values.$index(i).get$code());
  }
  Arguments.removeTrailingNulls(argsCode);
  return Strings.join(argsCode, ", ");
}
Arguments.removeTrailingNulls = function(argsCode) {
  while (argsCode.length > 0 && $eq(argsCode.last(), 'null')) {
    argsCode.removeLast();
  }
}
Arguments.prototype.getNames = function() {
  var names = [];
  for (var i = this.get$bareCount();
   i < this.get$length(); i++) {
    names.add$1(this.getName(i));
  }
  return names;
}
Arguments.prototype.toCallStubArgs = function() {
  var result = [];
  for (var i = 0;
   i < this.get$bareCount(); i++) {
    result.add$1(new Value($globals.world.varType, ('\$' + i), null, false));
  }
  for (var i = this.get$bareCount();
   i < this.get$length(); i++) {
    var name = this.getName(i);
    if (name == null) name = ('\$' + i);
    result.add$1(new Value($globals.world.varType, name, null, false));
  }
  return new Arguments(this.nodes, result);
}
// ********** Code for LibraryImport **************
function LibraryImport(library, prefix) {
  this.library = library;
  this.prefix = prefix;
  // Initializers done
}
LibraryImport.prototype.get$prefix = function() { return this.prefix; };
LibraryImport.prototype.set$prefix = function(value) { return this.prefix = value; };
LibraryImport.prototype.get$library = function() { return this.library; };
LibraryImport.prototype.set$library = function(value) { return this.library = value; };
// ********** Code for Library **************
function Library(baseSource) {
  this.isWritten = false
  this.isMarked = false
  this.baseSource = baseSource;
  // Initializers done
  Element.call(this, null, null);
  this.sourceDir = dirname(this.baseSource.filename);
  this.topType = new DefinedType(null, this, null, true);
  this.types = _map(['', this.topType]);
  this.imports = [];
  this.natives = [];
  this.sources = [];
  this._privateMembers = new HashMapImplementation();
}
$inherits(Library, Element);
Library.prototype.get$baseSource = function() { return this.baseSource; };
Library.prototype.get$types = function() { return this.types; };
Library.prototype.set$types = function(value) { return this.types = value; };
Library.prototype.get$_privateMembers = function() { return this._privateMembers; };
Library.prototype.set$_privateMembers = function(value) { return this._privateMembers = value; };
Library.prototype.get$topType = function() { return this.topType; };
Library.prototype.set$topType = function(value) { return this.topType = value; };
Library.prototype.get$enclosingElement = function() {
  return null;
}
Library.prototype.get$library = function() {
  return this;
}
Library.prototype.get$isNative = function() {
  return this.topType.isNative;
}
Library.prototype.get$isCore = function() {
  return $eq(this, $globals.world.corelib);
}
Library.prototype.get$isCoreImpl = function() {
  return $eq(this, $globals.world.get$coreimpl());
}
Library.prototype.get$span = function() {
  return new SourceSpan(this.baseSource, 0, 0);
}
Library.prototype.makeFullPath = function(filename) {
  if (filename.startsWith('dart:')) return filename;
  if (filename.startsWith('/')) return filename;
  if (filename.startsWith('file:///')) return filename;
  if (filename.startsWith('http://')) return filename;
  return joinPaths(this.sourceDir, filename);
}
Library.prototype.addImport = function(fullname, prefix) {
  var newLib = $globals.world.getOrAddLibrary(fullname);
  this.imports.add(new LibraryImport(newLib, prefix));
  return newLib;
}
Library.prototype.addNative = function(fullname) {
  this.natives.add($globals.world.reader.readFile(fullname));
}
Library.prototype._findMembers = function(name) {
  if (name.startsWith('_')) {
    return this._privateMembers.$index(name);
  }
  else {
    return $globals.world._members.$index(name);
  }
}
Library.prototype._addMember = function(member) {
  if (member.get$isPrivate()) {
    if (member.get$isStatic()) {
      if (member.declaringType.get$isTop()) {
        $globals.world._addTopName(member);
      }
      return;
    }
    var mset = this._privateMembers.$index(member.name);
    if (mset == null) {
      var $$list = $globals.world.libraries.getValues();
      for (var $$i = $globals.world.libraries.getValues().iterator$0(); $$i.hasNext$0(); ) {
        var lib = $$i.next$0();
        if (lib.get$_privateMembers().containsKey$1(member.get$jsname())) {
          member._jsname = ('_' + this.get$jsname() + member.get$jsname());
          break;
        }
      }
      mset = new MemberSet(member, true);
      this._privateMembers.$setindex(member.name, mset);
    }
    else {
      mset.get$members().add$1(member);
    }
  }
  else {
    $globals.world._addMember(member);
  }
}
Library.prototype.getOrAddFunctionType = function(enclosingElement, name, func) {
  var def = new FunctionTypeDefinition(func, null, func.span);
  var type = new DefinedType(name, this, def, false);
  type.addMethod(':call', func);
  var m = type.members.$index(':call');
  m.set$enclosingElement(enclosingElement);
  m.resolve$0();
  type.interfaces = [$globals.world.functionType];
  return type;
}
Library.prototype.addType = function(name, definition, isClass) {
  if (this.types.containsKey(name)) {
    var existingType = this.types.$index(name);
    if (this.get$isCore() && existingType.get$definition() == null) {
      existingType.setDefinition$1(definition);
    }
    else {
      $globals.world.warning(('duplicate definition of ' + name), definition.span, existingType.get$span());
    }
  }
  else {
    this.types.$setindex(name, new DefinedType(name, this, definition, isClass));
  }
  return this.types.$index(name);
}
Library.prototype.findType = function(type) {
  var result = this.findTypeByName(type.name.name);
  if (result == null) return null;
  if (type.names != null) {
    if (type.names.length > 1) {
      return null;
    }
    if (!result.get$isTop()) {
      return null;
    }
    return result.get$library().findTypeByName(type.names.$index(0).get$name());
  }
  return result;
}
Library.prototype.findTypeByName = function(name) {
  var ret = this.types.$index(name);
  var $$list = this.imports;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var imported = $$list.$index($$i);
    var newRet = null;
    if (imported.get$prefix() == null) {
      newRet = imported.get$library().get$types().$index(name);
    }
    else if ($eq(imported.get$prefix(), name)) {
      newRet = imported.get$library().get$topType();
    }
    if (newRet != null) {
      if (ret != null && $ne(ret, newRet)) {
        $globals.world.error(('conflicting types for "' + name + '"'), ret.get$span(), newRet.get$span());
      }
      else {
        ret = newRet;
      }
    }
  }
  return ret;
}
Library.prototype.resolveType = function(node, typeErrors) {
  if (node == null) return $globals.world.varType;
  if (node.type != null) return node.type;
  node.type = this.findType(node);
  if (node.type == null) {
    var message = ('cannot find type ' + Library._getDottedName(node));
    if (typeErrors) {
      $globals.world.error(message, node.span);
      node.type = $globals.world.objectType;
    }
    else {
      $globals.world.warning(message, node.span);
      node.type = $globals.world.varType;
    }
  }
  return node.type;
}
Library._getDottedName = function(type) {
  if (type.names != null) {
    var names = map(type.names, (function (n) {
      return n.get$name();
    })
    );
    return type.name.name + '.' + Strings.join(names, '.');
  }
  else {
    return type.name.name;
  }
}
Library.prototype.lookup = function(name, span) {
  var retType = this.findTypeByName(name);
  var ret = null;
  if (retType != null) {
    ret = retType.get$typeMember();
  }
  var newRet = this.topType.getMember(name);
  if (newRet != null) {
    if (ret != null && $ne(ret, newRet)) {
      $globals.world.error(('conflicting members for "' + name + '"'), span, ret.get$span(), newRet.get$span());
    }
    else {
      ret = newRet;
    }
  }
  var $$list = this.imports;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var imported = $$list.$index($$i);
    if (imported.get$prefix() == null) {
      newRet = imported.get$library().get$topType().getMember$1(name);
      if (newRet != null) {
        if (ret != null && $ne(ret, newRet)) {
          $globals.world.error(('conflicting members for "' + name + '"'), span, ret.get$span(), newRet.get$span());
        }
        else {
          ret = newRet;
        }
      }
    }
  }
  return ret;
}
Library.prototype.resolve = function() {
  if (this.name == null) {
    this.name = this.baseSource.filename;
    var index = this.name.lastIndexOf('/', this.name.length);
    if (index >= 0) {
      this.name = this.name.substring(index + 1);
    }
    index = this.name.indexOf('.');
    if (index > 0) {
      this.name = this.name.substring(0, index);
    }
  }
  this._jsname = this.name.replaceAll('.', '_').replaceAll(':', '_').replaceAll(' ', '_');
  var $$list = this.types.getValues();
  for (var $$i = this.types.getValues().iterator$0(); $$i.hasNext$0(); ) {
    var type = $$i.next$0();
    type.resolve$0();
  }
}
Library.prototype.visitSources = function() {
  var visitor = new _LibraryVisitor(this);
  visitor.addSource$1(this.baseSource);
}
Library.prototype.toString = function() {
  return this.baseSource.filename;
}
Library.prototype.hashCode = function() {
  return this.baseSource.filename.hashCode();
}
Library.prototype.$eq = function(other) {
  return (other instanceof Library) && $eq(other.get$baseSource().get$filename(), this.baseSource.filename);
}
Library.prototype.findTypeByName$1 = Library.prototype.findTypeByName;
Library.prototype.hashCode$0 = Library.prototype.hashCode;
Library.prototype.resolve$0 = Library.prototype.resolve;
Library.prototype.toString$0 = Library.prototype.toString;
Library.prototype.visitSources$0 = Library.prototype.visitSources;
// ********** Code for _LibraryVisitor **************
function _LibraryVisitor(library) {
  this.seenImport = false
  this.seenSource = false
  this.seenResource = false
  this.isTop = true
  this.library = library;
  // Initializers done
  this.currentType = this.library.topType;
  this.sources = [];
}
_LibraryVisitor.prototype.get$library = function() { return this.library; };
_LibraryVisitor.prototype.get$isTop = function() { return this.isTop; };
_LibraryVisitor.prototype.set$isTop = function(value) { return this.isTop = value; };
_LibraryVisitor.prototype.addSourceFromName = function(name, span) {
  var filename = this.library.makeFullPath(name);
  if ($eq(filename, this.library.baseSource.filename)) {
    $globals.world.error('library can not source itself', span);
    return;
  }
  else if (this.sources.some((function (s) {
    return $eq(s.get$filename(), filename);
  })
  )) {
    $globals.world.error(('file "' + filename + '" has already been sourced'), span);
    return;
  }
  var source = $globals.world.readFile(this.library.makeFullPath(name));
  this.sources.add(source);
}
_LibraryVisitor.prototype.addSource = function(source) {
  var $this = this; // closure support
  if (this.library.sources.some((function (s) {
    return $eq(s.get$filename(), source.filename);
  })
  )) {
    $globals.world.error(('duplicate source file "' + source.filename + '"'));
    return;
  }
  this.library.sources.add(source);
  var parser = new Parser(source, $globals.options.dietParse, false, false, 0);
  var unit = parser.compilationUnit();
  unit.forEach((function (def) {
    return def.visit$1($this);
  })
  );
  this.isTop = false;
  var newSources = this.sources;
  this.sources = [];
  for (var $$i = newSources.iterator$0(); $$i.hasNext$0(); ) {
    var source0 = $$i.next$0();
    this.addSource(source0);
  }
}
_LibraryVisitor.prototype.visitDirectiveDefinition = function(node) {
  if (!this.isTop) {
    $globals.world.error('directives not allowed in sourced file', node.span);
    return;
  }
  var name;
  switch (node.name.name) {
    case "library":

      name = this.getSingleStringArg(node);
      if (this.library.name == null) {
        this.library.name = name;
        if ($eq(name, 'node') || $eq(name, 'dom')) {
          this.library.topType.isNative = true;
        }
        if (this.seenImport || this.seenSource || this.seenResource) {
          $globals.world.error('#library must be first directive in file', node.span);
        }
      }
      else {
        $globals.world.error('already specified library name', node.span);
      }
      break;

    case "import":

      this.seenImport = true;
      name = this.getFirstStringArg(node);
      var prefix = this.tryGetNamedStringArg(node, 'prefix');
      if (node.arguments.length > 2 || node.arguments.length == 2 && prefix == null) {
        $globals.world.error('expected at most one "name" argument and one optional "prefix"' + (' but found ' + node.arguments.length), node.span);
      }
      else if (prefix != null && prefix.indexOf$1('.') >= 0) {
        $globals.world.error('library prefix canot contain "."', node.span);
      }
      else if (this.seenSource || this.seenResource) {
        $globals.world.error('#imports must come before any #source or #resource', node.span);
      }
      if ($eq(prefix, '')) prefix = null;
      var filename = this.library.makeFullPath(name);
      if (this.library.imports.some((function (li) {
        return $eq(li.get$library().get$baseSource(), filename);
      })
      )) {
        $globals.world.error(('duplicate import of "' + name + '"'), node.span);
        return;
      }
      var newLib = this.library.addImport(filename, prefix);
      break;

    case "source":

      this.seenSource = true;
      name = this.getSingleStringArg(node);
      this.addSourceFromName(name, node.span);
      if (this.seenResource) {
        $globals.world.error('#sources must come before any #resource', node.span);
      }
      break;

    case "native":

      name = this.getSingleStringArg(node);
      this.library.addNative(this.library.makeFullPath(name));
      break;

    case "resource":

      this.seenResource = true;
      this.getFirstStringArg(node);
      break;

    default:

      $globals.world.error(('unknown directive: ' + node.name.name), node.span);

  }
}
_LibraryVisitor.prototype.getSingleStringArg = function(node) {
  if (node.arguments.length != 1) {
    $globals.world.error(('expected exactly one argument but found ' + node.arguments.length), node.span);
  }
  return this.getFirstStringArg(node);
}
_LibraryVisitor.prototype.getFirstStringArg = function(node) {
  if (node.arguments.length < 1) {
    $globals.world.error(('expected at least one argument but found ' + node.arguments.length), node.span);
  }
  var arg = node.arguments.$index(0);
  if (arg.get$label() != null) {
    $globals.world.error('label not allowed for directive', node.span);
  }
  return this._parseStringArgument(arg);
}
_LibraryVisitor.prototype.tryGetNamedStringArg = function(node, argName) {
  var args = node.arguments.filter((function (a) {
    return a.get$label() != null && $eq(a.get$label().get$name(), argName);
  })
  );
  if ($eq(args.length, 0)) {
    return null;
  }
  if (args.length > 1) {
    $globals.world.error(('expected at most one "' + argName + '" argument but found ') + node.arguments.length, node.span);
  }
  for (var $$i = args.iterator$0(); $$i.hasNext$0(); ) {
    var arg = $$i.next$0();
    return this._parseStringArgument(arg);
  }
}
_LibraryVisitor.prototype._parseStringArgument = function(arg) {
  var expr = arg.value;
  if (!(expr instanceof LiteralExpression) || !expr.get$type().get$type().get$isString()) {
    $globals.world.error('expected string', expr.get$span());
  }
  return parseStringLiteral(expr.get$value());
}
_LibraryVisitor.prototype.visitTypeDefinition = function(node) {
  var oldType = this.currentType;
  this.currentType = this.library.addType(node.name.name, node, node.isClass);
  var $$list = node.body;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var member = $$list.$index($$i);
    member.visit$1(this);
  }
  this.currentType = oldType;
}
_LibraryVisitor.prototype.visitVariableDefinition = function(node) {
  this.currentType.addField(node);
}
_LibraryVisitor.prototype.visitFunctionDefinition = function(node) {
  this.currentType.addMethod(node.name.name, node);
}
_LibraryVisitor.prototype.visitFunctionTypeDefinition = function(node) {
  var type = this.library.addType(node.func.name.name, node, false);
  type.addMethod$2(':call', node.func);
}
_LibraryVisitor.prototype.addSource$1 = _LibraryVisitor.prototype.addSource;
// ********** Code for Parameter **************
function Parameter(definition, method) {
  this.isInitializer = false
  this.definition = definition;
  this.method = method;
  // Initializers done
}
Parameter.prototype.get$definition = function() { return this.definition; };
Parameter.prototype.set$definition = function(value) { return this.definition = value; };
Parameter.prototype.get$name = function() { return this.name; };
Parameter.prototype.set$name = function(value) { return this.name = value; };
Parameter.prototype.get$type = function() { return this.type; };
Parameter.prototype.set$type = function(value) { return this.type = value; };
Parameter.prototype.get$isInitializer = function() { return this.isInitializer; };
Parameter.prototype.set$isInitializer = function(value) { return this.isInitializer = value; };
Parameter.prototype.get$value = function() { return this.value; };
Parameter.prototype.set$value = function(value) { return this.value = value; };
Parameter.prototype.resolve = function() {
  this.name = this.definition.name.name;
  if (this.name.startsWith('this.')) {
    this.name = this.name.substring(5);
    this.isInitializer = true;
  }
  this.type = this.method.resolveType(this.definition.type, false);
  if (this.definition.value != null) {
    if (!this.get$hasDefaultValue()) return;
    if (this.method.name == ':call') {
      if (this.method.get$definition().get$body() == null) {
        $globals.world.error('default value not allowed on function type', this.definition.span);
      }
    }
    else if (this.method.get$isAbstract()) {
      $globals.world.error('default value not allowed on abstract methods', this.definition.span);
    }
  }
  else if (this.isInitializer && !this.method.get$isConstructor()) {
    $globals.world.error('initializer parameters only allowed on constructors', this.definition.span);
  }
}
Parameter.prototype.genValue = function(method, context) {
  if (this.definition.value == null || this.value != null) return;
  if (context == null) {
    context = new MethodGenerator(method, null);
  }
  this.value = this.definition.value.visit(context);
  if (!this.value.get$isConst()) {
    $globals.world.error('default parameter values must be constant', this.value.span);
  }
  this.value = this.value.convertTo(context, this.type, this.definition.value, false);
}
Parameter.prototype.copyWithNewType = function(newMethod, newType) {
  var ret = new Parameter(this.definition, newMethod);
  ret.set$type(newType);
  ret.set$name(this.name);
  ret.set$isInitializer(this.isInitializer);
  return ret;
}
Parameter.prototype.get$isOptional = function() {
  return this.definition != null && this.definition.value != null;
}
Parameter.prototype.get$hasDefaultValue = function() {
  return !(this.definition.value instanceof NullExpression) || (this.definition.value.span.start != this.definition.span.start);
}
Parameter.prototype.copyWithNewType$2 = Parameter.prototype.copyWithNewType;
Parameter.prototype.genValue$2 = Parameter.prototype.genValue;
Parameter.prototype.resolve$0 = Parameter.prototype.resolve;
// ********** Code for Member **************
function Member(name, declaringType) {
  this.isGenerated = false;
  this.declaringType = declaringType;
  // Initializers done
  Element.call(this, name, declaringType);
}
$inherits(Member, Element);
Member.prototype.get$declaringType = function() { return this.declaringType; };
Member.prototype.get$generator = function() { return this.generator; };
Member.prototype.set$generator = function(value) { return this.generator = value; };
Member.prototype.get$library = function() {
  return this.declaringType.get$library();
}
Member.prototype.get$isPrivate = function() {
  return this.name.startsWith('_');
}
Member.prototype.get$isConstructor = function() {
  return false;
}
Member.prototype.get$isField = function() {
  return false;
}
Member.prototype.get$isMethod = function() {
  return false;
}
Member.prototype.get$isProperty = function() {
  return false;
}
Member.prototype.get$isAbstract = function() {
  return false;
}
Member.prototype.get$isFinal = function() {
  return false;
}
Member.prototype.get$isConst = function() {
  return false;
}
Member.prototype.get$isFactory = function() {
  return false;
}
Member.prototype.get$isOperator = function() {
  return this.name.startsWith(':');
}
Member.prototype.get$isCallMethod = function() {
  return this.name == ':call';
}
Member.prototype.get$prefersPropertySyntax = function() {
  return true;
}
Member.prototype.get$requiresFieldSyntax = function() {
  return false;
}
Member.prototype.get$isNative = function() {
  return false;
}
Member.prototype.get$constructorName = function() {
  $globals.world.internalError('can not be a constructor', this.get$span());
}
Member.prototype.provideFieldSyntax = function() {

}
Member.prototype.providePropertySyntax = function() {

}
Member.prototype.get$initDelegate = function() {
  $globals.world.internalError('cannot have initializers', this.get$span());
}
Member.prototype.set$initDelegate = function(ctor) {
  $globals.world.internalError('cannot have initializers', this.get$span());
}
Member.prototype.computeValue = function() {
  $globals.world.internalError('cannot have value', this.get$span());
}
Member.prototype.get$inferredResult = function() {
  var t = this.get$returnType();
  if (t.get$isBool() && (this.get$library().get$isCore() || this.get$library().get$isCoreImpl())) {
    return $globals.world.nonNullBool;
  }
  return t;
}
Member.prototype.get$definition = function() {
  return null;
}
Member.prototype.get$parameters = function() {
  return [];
}
Member.prototype.canInvoke = function(context, args) {
  return this.get$canGet() && new Value(this.get$returnType(), null, null, true).canInvoke(context, ':call', args);
}
Member.prototype.invoke = function(context, node, target, args, isDynamic) {
  var newTarget = this._get(context, node, target, isDynamic);
  return newTarget.invoke$5(context, ':call', node, args, isDynamic);
}
Member.prototype.override = function(other) {
  if (this.get$isStatic()) {
    $globals.world.error('static members can not hide parent members', this.get$span(), other.get$span());
    return false;
  }
  else if (other.get$isStatic()) {
    $globals.world.error('can not override static member', this.get$span(), other.get$span());
    return false;
  }
  return true;
}
Member.prototype.get$generatedFactoryName = function() {
  var prefix = ('' + this.declaringType.get$jsname() + '.' + this.get$constructorName() + '\$');
  if (this.name == '') {
    return ('' + prefix + 'factory');
  }
  else {
    return ('' + prefix + this.name + '\$factory');
  }
}
Member.prototype.hashCode = function() {
  var typeCode = this.declaringType == null ? 1 : this.declaringType.hashCode();
  var nameCode = this.get$isConstructor() ? this.get$constructorName().hashCode() : this.name.hashCode();
  return (typeCode << 4) ^ nameCode;
}
Member.prototype.$eq = function(other) {
  return (other instanceof Member) && $eq(this.get$isConstructor(), other.get$isConstructor()) && $eq(this.declaringType, other.get$declaringType()) && (this.get$isConstructor() ? this.get$constructorName() == other.get$constructorName() : this.name == other.get$name());
}
Member.prototype._get$3 = Member.prototype._get;
Member.prototype._get$3$isDynamic = Member.prototype._get;
Member.prototype._get$4 = Member.prototype._get;
Member.prototype._set$4 = Member.prototype._set;
Member.prototype._set$4$isDynamic = Member.prototype._set;
Member.prototype._set$5 = Member.prototype._set;
Member.prototype.canInvoke$2 = Member.prototype.canInvoke;
Member.prototype.computeValue$0 = Member.prototype.computeValue;
Member.prototype.hashCode$0 = Member.prototype.hashCode;
Member.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke($0, $1, $2, $3, false);
};
Member.prototype.invoke$4$isDynamic = Member.prototype.invoke;
Member.prototype.invoke$5 = Member.prototype.invoke;
Member.prototype.provideFieldSyntax$0 = Member.prototype.provideFieldSyntax;
Member.prototype.providePropertySyntax$0 = Member.prototype.providePropertySyntax;
// ********** Code for TypeMember **************
function TypeMember(type) {
  this.type = type;
  // Initializers done
  Member.call(this, type.name, type.library.topType);
}
$inherits(TypeMember, Member);
TypeMember.prototype.get$type = function() { return this.type; };
TypeMember.prototype.get$span = function() {
  return this.type.definition.span;
}
TypeMember.prototype.get$isStatic = function() {
  return true;
}
TypeMember.prototype.get$returnType = function() {
  return $globals.world.varType;
}
TypeMember.prototype.canInvoke = function(context, args) {
  return false;
}
TypeMember.prototype.get$canGet = function() {
  return true;
}
TypeMember.prototype.get$canSet = function() {
  return false;
}
TypeMember.prototype.get$requiresFieldSyntax = function() {
  return true;
}
TypeMember.prototype._get = function(context, node, target, isDynamic) {
  return new Value.type$ctor(this.type, node.span);
}
TypeMember.prototype._set = function(context, node, target, value, isDynamic) {
  $globals.world.error('cannot set type', node.span);
}
TypeMember.prototype.invoke = function(context, node, target, args, isDynamic) {
  $globals.world.error('cannot invoke type', node.span);
}
TypeMember.prototype._get$3 = function($0, $1, $2) {
  return this._get($0, $1, $2, false);
};
TypeMember.prototype._get$3$isDynamic = TypeMember.prototype._get;
TypeMember.prototype._get$4 = TypeMember.prototype._get;
TypeMember.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set($0, $1, $2, $3, false);
};
TypeMember.prototype._set$4$isDynamic = TypeMember.prototype._set;
TypeMember.prototype._set$5 = TypeMember.prototype._set;
TypeMember.prototype.canInvoke$2 = TypeMember.prototype.canInvoke;
TypeMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke($0, $1, $2, $3, false);
};
TypeMember.prototype.invoke$4$isDynamic = TypeMember.prototype.invoke;
TypeMember.prototype.invoke$5 = TypeMember.prototype.invoke;
// ********** Code for FieldMember **************
function FieldMember(name, declaringType, definition, value) {
  this._providePropertySyntax = false
  this._computing = false
  this.definition = definition;
  this.value = value;
  this.isNative = false;
  // Initializers done
  Member.call(this, name, declaringType);
}
$inherits(FieldMember, Member);
FieldMember.prototype.get$definition = function() { return this.definition; };
FieldMember.prototype.get$value = function() { return this.value; };
FieldMember.prototype.get$type = function() { return this.type; };
FieldMember.prototype.set$type = function(value) { return this.type = value; };
FieldMember.prototype.get$isStatic = function() { return this.isStatic; };
FieldMember.prototype.set$isStatic = function(value) { return this.isStatic = value; };
FieldMember.prototype.get$isFinal = function() { return this.isFinal; };
FieldMember.prototype.set$isFinal = function(value) { return this.isFinal = value; };
FieldMember.prototype.get$isNative = function() { return this.isNative; };
FieldMember.prototype.set$isNative = function(value) { return this.isNative = value; };
FieldMember.prototype.override = function(other) {
  if (!Member.prototype.override.call(this, other)) return false;
  if (other.get$isProperty()) {
    return true;
  }
  else {
    $globals.world.error('field can not override anything but property', this.get$span(), other.get$span());
    return false;
  }
}
FieldMember.prototype.get$prefersPropertySyntax = function() {
  return false;
}
FieldMember.prototype.get$requiresFieldSyntax = function() {
  return this.isNative;
}
FieldMember.prototype.provideFieldSyntax = function() {

}
FieldMember.prototype.providePropertySyntax = function() {
  this._providePropertySyntax = true;
}
FieldMember.prototype.get$span = function() {
  return this.definition == null ? null : this.definition.span;
}
FieldMember.prototype.get$returnType = function() {
  return this.type;
}
FieldMember.prototype.get$canGet = function() {
  return true;
}
FieldMember.prototype.get$canSet = function() {
  return !this.isFinal;
}
FieldMember.prototype.get$isField = function() {
  return true;
}
FieldMember.prototype.resolve = function() {
  this.isStatic = this.declaringType.get$isTop();
  this.isFinal = false;
  if (this.definition.modifiers != null) {
    var $$list = this.definition.modifiers;
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var mod = $$list.$index($$i);
      if ($eq(mod.get$kind(), 86/*TokenKind.STATIC*/)) {
        if (this.isStatic) {
          $globals.world.error('duplicate static modifier', mod.get$span());
        }
        this.isStatic = true;
      }
      else if ($eq(mod.get$kind(), 98/*TokenKind.FINAL*/)) {
        if (this.isFinal) {
          $globals.world.error('duplicate final modifier', mod.get$span());
        }
        this.isFinal = true;
      }
      else {
        $globals.world.error(('' + mod + ' modifier not allowed on field'), mod.get$span());
      }
    }
  }
  this.type = this.resolveType(this.definition.type, false);
  if (this.isStatic && this.type.get$hasTypeParams()) {
    $globals.world.error('using type parameter in static context', this.definition.type.span);
  }
  if (this.isStatic && this.isFinal && this.value == null) {
    $globals.world.error('static final field is missing initializer', this.get$span());
  }
  this.get$library()._addMember(this);
}
FieldMember.prototype.computeValue = function() {
  if (this.value == null) return null;
  if (this._computedValue == null) {
    if (this._computing) {
      $globals.world.error('circular reference', this.value.span);
      return null;
    }
    this._computing = true;
    var finalMethod = new MethodMember('final_context', this.declaringType, null);
    finalMethod.set$isStatic(true);
    var finalGen = new MethodGenerator(finalMethod, null);
    this._computedValue = this.value.visit(finalGen);
    if (!this._computedValue.get$isConst()) {
      if (this.isStatic) {
        $globals.world.error('non constant static field must be initialized in functions', this.value.span);
      }
      else {
        $globals.world.error('non constant field must be initialized in constructor', this.value.span);
      }
    }
    if (this.isStatic) {
      this._computedValue = $globals.world.gen.globalForStaticField(this, this._computedValue, [this._computedValue]);
    }
    this._computing = false;
  }
  return this._computedValue;
}
FieldMember.prototype._get = function(context, node, target, isDynamic) {
  if (this.isNative && this.get$returnType() != null) {
    this.get$returnType().markUsed();
    if ((this.get$returnType() instanceof DefinedType)) {
      var factory_ = this.get$returnType().get$genericType().factory_;
      if (factory_ != null && factory_.get$isNative()) {
        factory_.markUsed$0();
      }
    }
  }
  if (this.isStatic) {
    this.declaringType.markUsed();
    var cv = this.computeValue();
    if (this.isFinal) {
      return cv;
    }
    $globals.world.gen.hasStatics = true;
    if (this.declaringType.get$isTop()) {
      if ($eq(this.declaringType.get$library(), $globals.world.get$dom())) {
        return new Value(this.type, ('' + this.get$jsname()), node.span, true);
      }
      else {
        return new Value(this.type, ('\$globals.' + this.get$jsname()), node.span, true);
      }
    }
    else if (this.declaringType.get$isNative()) {
      if (this.declaringType.get$isHiddenNativeType()) {
        $globals.world.error('static field of hidden native type is inaccessible', node.span);
      }
      return new Value(this.type, ('' + this.declaringType.get$jsname() + '.' + this.get$jsname()), node.span, true);
    }
    else {
      return new Value(this.type, ('\$globals.' + this.declaringType.get$jsname() + '_' + this.get$jsname()), node.span, true);
    }
  }
  else if (target.get$isConst() && this.isFinal) {
    var constTarget = (target instanceof GlobalValue) ? target.get$dynamic().get$exp() : target;
    if ((constTarget instanceof ConstObjectValue)) {
      return constTarget.get$fields().$index(this.name);
    }
    else if ($eq(constTarget.get$type(), $globals.world.stringType) && this.name == 'length') {
      return new Value(this.type, ('' + constTarget.get$actualValue().length), node.span, true);
    }
  }
  return new Value(this.type, ('' + target.code + '.' + this.get$jsname()), node.span, true);
}
FieldMember.prototype._set = function(context, node, target, value, isDynamic) {
  var lhs = this._get(context, node, target, isDynamic);
  value = value.convertTo(context, this.type, node, isDynamic);
  return new Value(this.type, ('' + lhs.get$code() + ' = ' + value.code), node.span, true);
}
FieldMember.prototype._get$3 = function($0, $1, $2) {
  return this._get($0, $1, $2, false);
};
FieldMember.prototype._get$3$isDynamic = FieldMember.prototype._get;
FieldMember.prototype._get$4 = FieldMember.prototype._get;
FieldMember.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set($0, $1, $2, $3, false);
};
FieldMember.prototype._set$4$isDynamic = FieldMember.prototype._set;
FieldMember.prototype._set$5 = FieldMember.prototype._set;
FieldMember.prototype.computeValue$0 = FieldMember.prototype.computeValue;
FieldMember.prototype.provideFieldSyntax$0 = FieldMember.prototype.provideFieldSyntax;
FieldMember.prototype.providePropertySyntax$0 = FieldMember.prototype.providePropertySyntax;
FieldMember.prototype.resolve$0 = FieldMember.prototype.resolve;
// ********** Code for PropertyMember **************
function PropertyMember(name, declaringType) {
  this._provideFieldSyntax = false
  // Initializers done
  Member.call(this, name, declaringType);
}
$inherits(PropertyMember, Member);
PropertyMember.prototype.get$getter = function() { return this.getter; };
PropertyMember.prototype.set$getter = function(value) { return this.getter = value; };
PropertyMember.prototype.get$setter = function() { return this.setter; };
PropertyMember.prototype.set$setter = function(value) { return this.setter = value; };
PropertyMember.prototype.get$span = function() {
  return this.getter != null ? this.getter.get$span() : null;
}
PropertyMember.prototype.get$canGet = function() {
  return this.getter != null;
}
PropertyMember.prototype.get$canSet = function() {
  return this.setter != null;
}
PropertyMember.prototype.get$prefersPropertySyntax = function() {
  return true;
}
PropertyMember.prototype.get$requiresFieldSyntax = function() {
  return false;
}
PropertyMember.prototype.provideFieldSyntax = function() {
  this._provideFieldSyntax = true;
}
PropertyMember.prototype.providePropertySyntax = function() {

}
PropertyMember.prototype.get$isStatic = function() {
  return this.getter == null ? this.setter.isStatic : this.getter.isStatic;
}
PropertyMember.prototype.get$isProperty = function() {
  return true;
}
PropertyMember.prototype.get$returnType = function() {
  return this.getter == null ? this.setter.returnType : this.getter.returnType;
}
PropertyMember.prototype.override = function(other) {
  if (!Member.prototype.override.call(this, other)) return false;
  if (other.get$isProperty() || other.get$isField()) {
    if (other.get$isProperty()) this.addFromParent(other);
    else this._overriddenField = other;
    return true;
  }
  else {
    $globals.world.error('property can only override field or property', this.get$span(), other.get$span());
    return false;
  }
}
PropertyMember.prototype._get = function(context, node, target, isDynamic) {
  if (this.getter == null) {
    if (this._overriddenField != null) {
      return this._overriddenField._get(context, node, target, isDynamic);
    }
    return target.invokeNoSuchMethod(context, ('get:' + this.name), node);
  }
  return this.getter.invoke(context, node, target, Arguments.get$EMPTY(), false);
}
PropertyMember.prototype._set = function(context, node, target, value, isDynamic) {
  if (this.setter == null) {
    if (this._overriddenField != null) {
      return this._overriddenField._set(context, node, target, value, isDynamic);
    }
    return target.invokeNoSuchMethod(context, ('set:' + this.name), node, new Arguments(null, [value]));
  }
  return this.setter.invoke(context, node, target, new Arguments(null, [value]), isDynamic);
}
PropertyMember.prototype.addFromParent = function(parentMember) {
  var parent;
  if ((parentMember instanceof ConcreteMember)) {
    var c = parentMember;
    parent = c.baseMember;
  }
  else {
    parent = parentMember;
  }
  if (this.getter == null) this.getter = parent.getter;
  if (this.setter == null) this.setter = parent.setter;
}
PropertyMember.prototype.resolve = function() {
  if (this.getter != null) this.getter.resolve();
  if (this.setter != null) this.setter.resolve();
  this.get$library()._addMember(this);
}
PropertyMember.prototype._get$3 = function($0, $1, $2) {
  return this._get($0, $1, $2, false);
};
PropertyMember.prototype._get$3$isDynamic = PropertyMember.prototype._get;
PropertyMember.prototype._get$4 = PropertyMember.prototype._get;
PropertyMember.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set($0, $1, $2, $3, false);
};
PropertyMember.prototype._set$4$isDynamic = PropertyMember.prototype._set;
PropertyMember.prototype._set$5 = PropertyMember.prototype._set;
PropertyMember.prototype.provideFieldSyntax$0 = PropertyMember.prototype.provideFieldSyntax;
PropertyMember.prototype.providePropertySyntax$0 = PropertyMember.prototype.providePropertySyntax;
PropertyMember.prototype.resolve$0 = PropertyMember.prototype.resolve;
// ********** Code for ConcreteMember **************
function ConcreteMember(name, declaringType, baseMember) {
  this.baseMember = baseMember;
  // Initializers done
  Member.call(this, name, declaringType);
  this.parameters = [];
  this.returnType = this.baseMember.get$returnType().resolveTypeParams(declaringType);
  var $$list = this.baseMember.get$parameters();
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var p = $$list.$index($$i);
    var newType = p.get$type().resolveTypeParams$1(declaringType);
    if ($ne(newType, p.get$type())) {
      this.parameters.add(p.copyWithNewType$2(this, newType));
    }
    else {
      this.parameters.add(p);
    }
  }
}
$inherits(ConcreteMember, Member);
ConcreteMember.prototype.get$returnType = function() { return this.returnType; };
ConcreteMember.prototype.set$returnType = function(value) { return this.returnType = value; };
ConcreteMember.prototype.get$parameters = function() { return this.parameters; };
ConcreteMember.prototype.set$parameters = function(value) { return this.parameters = value; };
ConcreteMember.prototype.get$span = function() {
  return this.baseMember.get$span();
}
ConcreteMember.prototype.get$isStatic = function() {
  return this.baseMember.get$isStatic();
}
ConcreteMember.prototype.get$isAbstract = function() {
  return this.baseMember.get$isAbstract();
}
ConcreteMember.prototype.get$isConst = function() {
  return this.baseMember.get$isConst();
}
ConcreteMember.prototype.get$isFactory = function() {
  return this.baseMember.get$isFactory();
}
ConcreteMember.prototype.get$isFinal = function() {
  return this.baseMember.get$isFinal();
}
ConcreteMember.prototype.get$isNative = function() {
  return this.baseMember.get$isNative();
}
ConcreteMember.prototype.get$jsname = function() {
  return this.baseMember.get$jsname();
}
ConcreteMember.prototype.get$canGet = function() {
  return this.baseMember.get$canGet();
}
ConcreteMember.prototype.get$canSet = function() {
  return this.baseMember.get$canSet();
}
ConcreteMember.prototype.canInvoke = function(context, args) {
  return this.baseMember.canInvoke(context, args);
}
ConcreteMember.prototype.get$isField = function() {
  return this.baseMember.get$isField();
}
ConcreteMember.prototype.get$isMethod = function() {
  return this.baseMember.get$isMethod();
}
ConcreteMember.prototype.get$isProperty = function() {
  return this.baseMember.get$isProperty();
}
ConcreteMember.prototype.get$prefersPropertySyntax = function() {
  return this.baseMember.get$prefersPropertySyntax();
}
ConcreteMember.prototype.get$requiresFieldSyntax = function() {
  return this.baseMember.get$requiresFieldSyntax();
}
ConcreteMember.prototype.provideFieldSyntax = function() {
  return this.baseMember.provideFieldSyntax();
}
ConcreteMember.prototype.providePropertySyntax = function() {
  return this.baseMember.providePropertySyntax();
}
ConcreteMember.prototype.get$isConstructor = function() {
  return this.name == this.declaringType.name;
}
ConcreteMember.prototype.get$constructorName = function() {
  return this.baseMember.get$constructorName();
}
ConcreteMember.prototype.get$definition = function() {
  return this.baseMember.get$definition();
}
ConcreteMember.prototype.get$initDelegate = function() {
  return this.baseMember.get$initDelegate();
}
ConcreteMember.prototype.set$initDelegate = function(ctor) {
  this.baseMember.set$initDelegate(ctor);
}
ConcreteMember.prototype.resolveType = function(node, isRequired) {
  var type = this.baseMember.resolveType(node, isRequired);
  return type.resolveTypeParams$1(this.declaringType);
}
ConcreteMember.prototype.computeValue = function() {
  return this.baseMember.computeValue();
}
ConcreteMember.prototype.override = function(other) {
  return this.baseMember.override(other);
}
ConcreteMember.prototype._get = function(context, node, target, isDynamic) {
  var ret = this.baseMember._get(context, node, target, isDynamic);
  return new Value(this.get$inferredResult(), ret.code, node.span, true);
}
ConcreteMember.prototype._set = function(context, node, target, value, isDynamic) {
  var ret = this.baseMember._set(context, node, target, value, isDynamic);
  return new Value(this.returnType, ret.code, node.span, true);
}
ConcreteMember.prototype.invoke = function(context, node, target, args, isDynamic) {
  var ret = this.baseMember.invoke(context, node, target, args, isDynamic);
  var code = ret.code;
  if (this.get$isConstructor()) {
    code = code.replaceFirst$2(this.declaringType.get$genericType().get$jsname(), this.declaringType.get$jsname());
  }
  if ((this.baseMember instanceof MethodMember)) {
    this.declaringType.genMethod(this);
  }
  return new Value(this.get$inferredResult(), code, node.span, true);
}
ConcreteMember.prototype._get$3 = function($0, $1, $2) {
  return this._get($0, $1, $2, false);
};
ConcreteMember.prototype._get$3$isDynamic = ConcreteMember.prototype._get;
ConcreteMember.prototype._get$4 = ConcreteMember.prototype._get;
ConcreteMember.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set($0, $1, $2, $3, false);
};
ConcreteMember.prototype._set$4$isDynamic = ConcreteMember.prototype._set;
ConcreteMember.prototype._set$5 = ConcreteMember.prototype._set;
ConcreteMember.prototype.canInvoke$2 = ConcreteMember.prototype.canInvoke;
ConcreteMember.prototype.computeValue$0 = ConcreteMember.prototype.computeValue;
ConcreteMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke($0, $1, $2, $3, false);
};
ConcreteMember.prototype.invoke$4$isDynamic = ConcreteMember.prototype.invoke;
ConcreteMember.prototype.invoke$5 = ConcreteMember.prototype.invoke;
ConcreteMember.prototype.provideFieldSyntax$0 = ConcreteMember.prototype.provideFieldSyntax;
ConcreteMember.prototype.providePropertySyntax$0 = ConcreteMember.prototype.providePropertySyntax;
// ********** Code for MethodMember **************
function MethodMember(name, declaringType, definition) {
  this.isStatic = false
  this.isAbstract = false
  this.isConst = false
  this.isFactory = false
  this.isLambda = false
  this._providePropertySyntax = false
  this._provideFieldSyntax = false
  this._provideOptionalParamInfo = false
  this.definition = definition;
  // Initializers done
  Member.call(this, name, declaringType);
}
$inherits(MethodMember, Member);
MethodMember.prototype.get$definition = function() { return this.definition; };
MethodMember.prototype.set$definition = function(value) { return this.definition = value; };
MethodMember.prototype.get$returnType = function() { return this.returnType; };
MethodMember.prototype.set$returnType = function(value) { return this.returnType = value; };
MethodMember.prototype.get$parameters = function() { return this.parameters; };
MethodMember.prototype.set$parameters = function(value) { return this.parameters = value; };
MethodMember.prototype.get$typeParameters = function() { return this.typeParameters; };
MethodMember.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
MethodMember.prototype.get$isStatic = function() { return this.isStatic; };
MethodMember.prototype.set$isStatic = function(value) { return this.isStatic = value; };
MethodMember.prototype.get$isAbstract = function() { return this.isAbstract; };
MethodMember.prototype.set$isAbstract = function(value) { return this.isAbstract = value; };
MethodMember.prototype.get$isConst = function() { return this.isConst; };
MethodMember.prototype.set$isConst = function(value) { return this.isConst = value; };
MethodMember.prototype.get$isFactory = function() { return this.isFactory; };
MethodMember.prototype.set$isFactory = function(value) { return this.isFactory = value; };
MethodMember.prototype.get$isLambda = function() { return this.isLambda; };
MethodMember.prototype.set$isLambda = function(value) { return this.isLambda = value; };
MethodMember.prototype.get$initDelegate = function() { return this.initDelegate; };
MethodMember.prototype.set$initDelegate = function(value) { return this.initDelegate = value; };
MethodMember.prototype.get$isConstructor = function() {
  return this.name == this.declaringType.name;
}
MethodMember.prototype.get$isMethod = function() {
  return !this.get$isConstructor();
}
MethodMember.prototype.get$isNative = function() {
  return this.definition.nativeBody != null;
}
MethodMember.prototype.get$canGet = function() {
  return false;
}
MethodMember.prototype.get$canSet = function() {
  return false;
}
MethodMember.prototype.get$span = function() {
  return this.definition == null ? null : this.definition.span;
}
MethodMember.prototype.get$constructorName = function() {
  var returnType = this.definition.returnType;
  if (returnType == null) return '';
  if ((returnType instanceof GenericTypeReference)) {
    return '';
  }
  if (returnType.get$names() != null) {
    return returnType.get$names().$index(0).get$name();
  }
  else if (returnType.get$name() != null) {
    return returnType.get$name().get$name();
  }
  $globals.world.internalError('no valid constructor name', this.definition.span);
}
MethodMember.prototype.get$functionType = function() {
  if (this._functionType == null) {
    this._functionType = this.get$library().getOrAddFunctionType(this.declaringType, this.name, this.definition);
    if (this.parameters == null) {
      this.resolve();
    }
  }
  return this._functionType;
}
MethodMember.prototype.override = function(other) {
  if (!Member.prototype.override.call(this, other)) return false;
  if (other.get$isMethod()) {
    return true;
  }
  else {
    $globals.world.error('method can only override methods', this.get$span(), other.get$span());
    return false;
  }
}
MethodMember.prototype.canInvoke = function(context, args) {
  var bareCount = args.get$bareCount();
  if (bareCount > this.parameters.length) return false;
  if (bareCount == this.parameters.length) {
    if (bareCount != args.get$length()) return false;
  }
  else {
    if (!this.parameters.$index(bareCount).get$isOptional()) return false;
    for (var i = bareCount;
     i < args.get$length(); i++) {
      if (this.indexOfParameter(args.getName(i)) < 0) {
        return false;
      }
    }
  }
  return true;
}
MethodMember.prototype.indexOfParameter = function(name) {
  for (var i = 0;
   i < this.parameters.length; i++) {
    var p = this.parameters.$index(i);
    if (p.get$isOptional() && $eq(p.get$name(), name)) {
      return i;
    }
  }
  return -1;
}
MethodMember.prototype.get$prefersPropertySyntax = function() {
  return true;
}
MethodMember.prototype.get$requiresFieldSyntax = function() {
  return false;
}
MethodMember.prototype.provideFieldSyntax = function() {
  this._provideFieldSyntax = true;
}
MethodMember.prototype.providePropertySyntax = function() {
  this._providePropertySyntax = true;
}
MethodMember.prototype._set = function(context, node, target, value, isDynamic) {
  $globals.world.error('cannot set method', node.span);
}
MethodMember.prototype._get = function(context, node, target, isDynamic) {
  this.declaringType.genMethod(this);
  this._provideOptionalParamInfo = true;
  if (this.isStatic) {
    this.declaringType.markUsed();
    var type = this.declaringType.get$isTop() ? '' : ('' + this.declaringType.get$jsname() + '.');
    return new Value(this.get$functionType(), ('' + type + this.get$jsname()), node.span, true);
  }
  this._providePropertySyntax = true;
  return new Value(this.get$functionType(), ('' + target.code + '.get\$' + this.get$jsname() + '()'), node.span, true);
}
MethodMember.prototype.namesInOrder = function(args) {
  if (!args.get$hasNames()) return true;
  var lastParameter = null;
  for (var i = args.get$bareCount();
   i < this.parameters.length; i++) {
    var p = args.getIndexOfName(this.parameters.$index(i).get$name());
    if (p >= 0 && args.values.$index(p).get$needsTemp()) {
      if (lastParameter != null && lastParameter > p) {
        return false;
      }
      lastParameter = p;
    }
  }
  return true;
}
MethodMember.prototype.needsArgumentConversion = function(args) {
  var bareCount = args.get$bareCount();
  for (var i = 0;
   i < bareCount; i++) {
    var arg = args.values.$index(i);
    if (arg.needsConversion$1(this.parameters.$index(i).get$type())) {
      return true;
    }
  }
  if (bareCount < this.parameters.length) {
    this.genParameterValues();
    for (var i = bareCount;
     i < this.parameters.length; i++) {
      var arg = args.getValue(this.parameters.$index(i).get$name());
      if (arg != null && arg.needsConversion$1(this.parameters.$index(i).get$type())) {
        return true;
      }
    }
  }
  return false;
}
MethodMember._argCountMsg = function(actual, expected, atLeast) {
  return 'wrong number of arguments, expected ' + ('' + (atLeast ? "at least " : "") + expected + ' but found ' + actual);
}
MethodMember.prototype._argError = function(context, node, target, args, msg) {
  if (this.isStatic || this.get$isConstructor()) {
    $globals.world.error(msg, node.span);
  }
  else {
    $globals.world.warning(msg, node.span);
  }
  return target.invokeNoSuchMethod(context, this.name, node, args);
}
MethodMember.prototype.genParameterValues = function() {
  var $$list = this.parameters;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var p = $$list.$index($$i);
    p.genValue$2(this, this.generator);
  }
}
MethodMember.prototype.invoke = function(context, node, target, args, isDynamic) {
  if (this.parameters == null) {
    $globals.world.info(('surprised to need to resolve: ' + this.declaringType.name + '.' + this.name));
    this.resolve();
  }
  this.declaringType.genMethod(this);
  if (this.isStatic || this.isFactory) {
    this.declaringType.markUsed();
  }
  if (this.get$isNative() && this.returnType != null) this.returnType.markUsed();
  if (!this.namesInOrder(args)) {
    return context.findMembers(this.name).invokeOnVar(context, node, target, args);
  }
  var argsCode = [];
  if (!target.isType && (this.get$isConstructor() || target.isSuper)) {
    argsCode.add$1('this');
  }
  var bareCount = args.get$bareCount();
  for (var i = 0;
   i < bareCount; i++) {
    var arg = args.values.$index(i);
    if (i >= this.parameters.length) {
      var msg = MethodMember._argCountMsg(args.get$length(), this.parameters.length, false);
      return this._argError(context, node, target, args, msg);
    }
    arg = arg.convertTo$4(context, this.parameters.$index(i).get$type(), node, isDynamic);
    if (this.isConst && arg.get$isConst()) {
      argsCode.add$1(arg.get$canonicalCode());
    }
    else {
      argsCode.add$1(arg.get$code());
    }
  }
  if (bareCount < this.parameters.length) {
    this.genParameterValues();
    var namedArgsUsed = 0;
    for (var i = bareCount;
     i < this.parameters.length; i++) {
      var arg = args.getValue(this.parameters.$index(i).get$name());
      if (arg == null) {
        arg = this.parameters.$index(i).get$value();
      }
      else {
        arg = arg.convertTo$4(context, this.parameters.$index(i).get$type(), node, isDynamic);
        namedArgsUsed++;
      }
      if (arg == null || !this.parameters.$index(i).get$isOptional()) {
        var msg = MethodMember._argCountMsg(Math.min(i, args.get$length()), i + 1, true);
        return this._argError(context, node, target, args, msg);
      }
      else {
        argsCode.add$1(this.isConst && arg.get$isConst() ? arg.get$canonicalCode() : arg.get$code());
      }
    }
    if (namedArgsUsed < args.get$nameCount()) {
      var seen = new HashSetImplementation();
      for (var i = bareCount;
       i < args.get$length(); i++) {
        var name = args.getName(i);
        if (seen.contains$1(name)) {
          return this._argError(context, node, target, args, ('duplicate argument "' + name + '"'));
        }
        seen.add$1(name);
        var p = this.indexOfParameter(name);
        if (p < 0) {
          return this._argError(context, node, target, args, ('method does not have optional parameter "' + name + '"'));
        }
        else if (p < bareCount) {
          return this._argError(context, node, target, args, ('argument "' + name + '" passed as positional and named'));
        }
      }
      $globals.world.internalError(('wrong named arguments calling ' + this.name), node.span);
    }
    Arguments.removeTrailingNulls(argsCode);
  }
  var argsString = Strings.join(argsCode, ', ');
  if (this.get$isConstructor()) {
    return this._invokeConstructor(context, node, target, args, argsString);
  }
  if (target.isSuper) {
    return new Value(this.get$inferredResult(), ('' + this.declaringType.get$jsname() + '.prototype.' + this.get$jsname() + '.call(' + argsString + ')'), node.span, true);
  }
  if (this.get$isOperator()) {
    return this._invokeBuiltin(context, node, target, args, argsCode, isDynamic);
  }
  if (this.isFactory) {
    return new Value(target.get$type(), ('' + this.get$generatedFactoryName() + '(' + argsString + ')'), node.span, true);
  }
  if (this.isStatic) {
    if (this.declaringType.get$isTop()) {
      return new Value(this.get$inferredResult(), ('' + this.get$jsname() + '(' + argsString + ')'), node != null ? node.span : node, true);
    }
    return new Value(this.get$inferredResult(), ('' + this.declaringType.get$jsname() + '.' + this.get$jsname() + '(' + argsString + ')'), node.span, true);
  }
  var code = ('' + target.code + '.' + this.get$jsname() + '(' + argsString + ')');
  if (target.get$isConst()) {
    if ((target instanceof GlobalValue)) {
      target = target.get$dynamic().get$exp();
    }
    if (this.name == 'get:length') {
      if ((target instanceof ConstListValue) || (target instanceof ConstMapValue)) {
        code = ('' + target.get$dynamic().get$values().length);
      }
    }
    else if (this.name == 'isEmpty') {
      if ((target instanceof ConstListValue) || (target instanceof ConstMapValue)) {
        code = ('' + target.get$dynamic().get$values().isEmpty$0());
      }
    }
  }
  if (this.name == 'get:typeName' && $eq(this.declaringType.get$library(), $globals.world.get$dom())) {
    $globals.world.gen.corejs.ensureTypeNameOf();
  }
  return new Value(this.get$inferredResult(), code, node.span, true);
}
MethodMember.prototype._invokeConstructor = function(context, node, target, args, argsString) {
  this.declaringType.markUsed();
  if (!target.isType) {
    var code = (this.get$constructorName() != '') ? ('' + this.declaringType.get$jsname() + '.' + this.get$constructorName() + '\$ctor.call(' + argsString + ')') : ('' + this.declaringType.get$jsname() + '.call(' + argsString + ')');
    return new Value(target.get$type(), code, node.span, true);
  }
  else {
    var code = (this.get$constructorName() != '') ? ('new ' + this.declaringType.get$jsname() + '.' + this.get$constructorName() + '\$ctor(' + argsString + ')') : ('new ' + this.declaringType.get$jsname() + '(' + argsString + ')');
    if (this.isConst && (node instanceof NewExpression) && node.get$dynamic().get$isConst()) {
      return this._invokeConstConstructor(node, code, target, args);
    }
    else {
      return new Value(target.get$type(), code, node.span, true);
    }
  }
}
MethodMember.prototype._invokeConstConstructor = function(node, code, target, args) {
  var fields = new HashMapImplementation();
  for (var i = 0;
   i < this.parameters.length; i++) {
    var param = this.parameters.$index(i);
    if (param.get$isInitializer()) {
      var value = null;
      if (i < args.get$length()) {
        value = args.values.$index(i);
      }
      else {
        value = args.getValue(param.get$name());
        if (value == null) {
          value = param.get$value();
        }
      }
      fields.$setindex(param.get$name(), value);
    }
  }
  if (this.definition.initializers != null) {
    this.generator._pushBlock(false);
    for (var j = 0;
     j < this.definition.formals.length; j++) {
      var name = this.definition.formals.$index(j).get$name().get$name();
      var value = null;
      if (j < args.get$length()) {
        value = args.values.$index(j);
      }
      else {
        value = args.getValue(this.parameters.$index(j).get$name());
        if (value == null) {
          value = this.parameters.$index(j).get$value();
        }
      }
      this.generator._scope._vars.$setindex(name, value);
    }
    var $$list = this.definition.initializers;
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var init = $$list.$index($$i);
      if ((init instanceof CallExpression)) {
        var delegateArgs = this.generator._makeArgs(init.get$arguments());
        var value = this.initDelegate.invoke(this.generator, node, target, delegateArgs, false);
        if ((init.get$target() instanceof ThisExpression)) {
          return value;
        }
        else {
          if ((value instanceof GlobalValue)) {
            value = value.get$exp();
          }
          var $list0 = value.get$fields().getKeys$0();
          for (var $i0 = value.get$fields().getKeys$0().iterator$0(); $i0.hasNext$0(); ) {
            var fname = $i0.next$0();
            fields.$setindex(fname, value.get$fields().$index(fname));
          }
        }
      }
      else {
        var assign = init;
        var x = assign.x;
        var fname = x.get$name().get$name();
        var val = this.generator.visitValue(assign.y);
        fields.$setindex(fname, val);
      }
    }
    this.generator._popBlock();
  }
  var $$list = this.declaringType.get$members().getValues();
  for (var $$i = this.declaringType.get$members().getValues().iterator$0(); $$i.hasNext$0(); ) {
    var f = $$i.next$0();
    if ((f instanceof FieldMember) && !f.get$isStatic() && f.get$value() != null && !fields.containsKey(f.get$name())) {
      fields.$setindex(f.get$name(), f.computeValue$0());
    }
  }
  return $globals.world.gen.globalForConst(ConstObjectValue.ConstObjectValue$factory(target.get$type(), fields, code, node.span), args.values);
}
MethodMember.prototype._invokeBuiltin = function(context, node, target, args, argsCode, isDynamic) {
  var allConst = target.get$isConst() && args.values.every((function (arg) {
    return arg.get$isConst();
  })
  );
  if (this.declaringType.get$isNum()) {
    if (!allConst) {
      var code;
      if (this.name == ':negate') {
        code = ('-' + target.code);
      }
      else if (this.name == ':bit_not') {
        code = ('~' + target.code);
      }
      else if (this.name == ':truncdiv' || this.name == ':mod') {
        $globals.world.gen.corejs.useOperator(this.name);
        code = ('' + this.get$jsname() + '(' + target.code + ', ' + argsCode.$index(0) + ')');
      }
      else {
        var op = TokenKind.rawOperatorFromMethod(this.name);
        code = ('' + target.code + ' ' + op + ' ' + argsCode.$index(0));
      }
      return new Value(this.get$inferredResult(), code, node.span, true);
    }
    else {
      var value;
      var val0, val1, ival0, ival1;
      val0 = target.get$dynamic().get$actualValue();
      ival0 = val0.toInt();
      if (args.values.length > 0) {
        val1 = args.values.$index(0).get$dynamic().get$actualValue();
        ival1 = val1.toInt();
      }
      switch (this.name) {
        case ':negate':

          value = -val0;
          break;

        case ':add':

          value = val0 + val1;
          break;

        case ':sub':

          value = val0 - val1;
          break;

        case ':mul':

          value = val0 * val1;
          break;

        case ':div':

          value = val0 / val1;
          break;

        case ':truncdiv':

          value = $truncdiv(val0, val1);
          break;

        case ':mod':

          value = $mod(val0, val1);
          break;

        case ':eq':

          value = val0 == val1;
          break;

        case ':lt':

          value = val0 < val1;
          break;

        case ':gt':

          value = val0 > val1;
          break;

        case ':lte':

          value = val0 <= val1;
          break;

        case ':gte':

          value = val0 >= val1;
          break;

        case ':ne':

          value = val0 != val1;
          break;

        case ':bit_not':

          value = (~ival0).toDouble();
          break;

        case ':bit_or':

          value = (ival0 | ival1).toDouble();
          break;

        case ':bit_xor':

          value = (ival0 ^ ival1).toDouble();
          break;

        case ':bit_and':

          value = (ival0 & ival1).toDouble();
          break;

        case ':shl':

          value = (ival0 << ival1).toDouble();
          break;

        case ':sar':

          value = (ival0 >> ival1).toDouble();
          break;

        case ':shr':

          value = (ival0 >>> ival1).toDouble();
          break;

      }
      return EvaluatedValue.EvaluatedValue$factory(this.get$inferredResult(), value, ("" + value), node.span);
    }
  }
  else if (this.declaringType.get$isString()) {
    if (this.name == ':index') {
      return new Value(this.declaringType, ('' + target.code + '[' + argsCode.$index(0) + ']'), node.span, true);
    }
    else if (this.name == ':add') {
      if (allConst) {
        var value = this._normConcat(target, args.values.$index(0));
        return EvaluatedValue.EvaluatedValue$factory($globals.world.stringType, value, value, node.span);
      }
      return new Value(this.declaringType, ('' + target.code + ' + ' + argsCode.$index(0)), node.span, true);
    }
  }
  else if (this.declaringType.get$isNative()) {
    if (this.name == ':index') {
      return new Value(this.returnType, ('' + target.code + '[' + argsCode.$index(0) + ']'), node.span, true);
    }
    else if (this.name == ':setindex') {
      return new Value(this.returnType, ('' + target.code + '[' + argsCode.$index(0) + '] = ' + argsCode.$index(1)), node.span, true);
    }
  }
  if (this.name == ':eq' || this.name == ':ne') {
    var op = this.name == ':eq' ? '==' : '!=';
    if (this.name == ':ne') {
      target.invoke(context, ':eq', node, args, isDynamic);
    }
    if (allConst) {
      var val0 = target.get$dynamic().get$actualValue();
      var val1 = args.values.$index(0).get$dynamic().get$actualValue();
      var newVal = this.name == ':eq' ? $eq(val0, val1) : $ne(val0, val1);
      return EvaluatedValue.EvaluatedValue$factory($globals.world.nonNullBool, newVal, ("" + newVal), node.span);
    }
    if ($eq(argsCode.$index(0), 'null')) {
      return new Value(this.get$inferredResult(), ('' + target.code + ' ' + op + ' null'), node.span, true);
    }
    else if (target.get$type().get$isNum() || target.get$type().get$isString()) {
      return new Value(this.get$inferredResult(), ('' + target.code + ' ' + op + ' ' + argsCode.$index(0)), node.span, true);
    }
    $globals.world.gen.corejs.useOperator(this.name);
    return new Value(this.get$inferredResult(), ('' + this.get$jsname() + '(' + target.code + ', ' + argsCode.$index(0) + ')'), node.span, true);
  }
  if (this.get$isCallMethod()) {
    this.declaringType.markUsed();
    return new Value(this.get$inferredResult(), ('' + target.code + '(' + Strings.join(argsCode, ", ") + ')'), node.span, true);
  }
  if (this.name == ':index') {
    $globals.world.gen.corejs.useIndex = true;
  }
  else if (this.name == ':setindex') {
    $globals.world.gen.corejs.useSetIndex = true;
  }
  var argsString = Strings.join(argsCode, ', ');
  return new Value(this.get$inferredResult(), ('' + target.code + '.' + this.get$jsname() + '(' + argsString + ')'), node.span, true);
}
MethodMember.prototype._normConcat = function(a, b) {
  var val0 = a.get$dynamic().get$actualValue();
  var quote0 = val0.$index(0);
  val0 = val0.substring$2(1, val0.length - 1);
  var val1 = b.get$dynamic().get$actualValue();
  var quote1 = null;
  if (b.get$type().get$isString()) {
    quote1 = val1.$index(0);
    val1 = val1.substring$2(1, val1.length - 1);
  }
  var value;
  if ($eq(quote0, quote1) || quote1 == null) {
    value = ('' + quote0 + val0 + val1 + quote0);
  }
  else if ($eq(quote0, '"')) {
    value = ('' + quote0 + val0 + toDoubleQuote(val1) + quote0);
  }
  else {
    value = ('' + quote1 + toDoubleQuote(val0) + val1 + quote1);
  }
  return value;
}
MethodMember.prototype.resolve = function() {
  this.isStatic = this.declaringType.get$isTop();
  this.isConst = false;
  this.isFactory = false;
  this.isAbstract = !this.declaringType.get$isClass();
  if (this.definition.modifiers != null) {
    var $$list = this.definition.modifiers;
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var mod = $$list.$index($$i);
      if ($eq(mod.get$kind(), 86/*TokenKind.STATIC*/)) {
        if (this.isStatic) {
          $globals.world.error('duplicate static modifier', mod.get$span());
        }
        this.isStatic = true;
      }
      else if (this.get$isConstructor() && $eq(mod.get$kind(), 92/*TokenKind.CONST*/)) {
        if (this.isConst) {
          $globals.world.error('duplicate const modifier', mod.get$span());
        }
        this.isConst = true;
      }
      else if ($eq(mod.get$kind(), 75/*TokenKind.FACTORY*/)) {
        if (this.isFactory) {
          $globals.world.error('duplicate factory modifier', mod.get$span());
        }
        this.isFactory = true;
      }
      else if ($eq(mod.get$kind(), 71/*TokenKind.ABSTRACT*/)) {
        if (this.isAbstract) {
          if (this.declaringType.get$isClass()) {
            $globals.world.error('duplicate abstract modifier', mod.get$span());
          }
          else {
            $globals.world.error('abstract modifier not allowed on interface members', mod.get$span());
          }
        }
        this.isAbstract = true;
      }
      else {
        $globals.world.error(('' + mod + ' modifier not allowed on method'), mod.get$span());
      }
    }
  }
  if (this.isFactory) {
    this.isStatic = true;
  }
  if (this.definition.typeParameters != null) {
    if (!this.isFactory) {
      $globals.world.error('Only factories are allowed to have explicit type parameters', this.definition.typeParameters.$index(0).get$span());
    }
    else {
      this.typeParameters = this.definition.typeParameters;
      var $$list = this.definition.typeParameters;
      for (var $$i = 0;$$i < $$list.length; $$i++) {
        var tp = $$list.$index($$i);
        tp.set$enclosingElement(this);
        tp.resolve$0();
      }
    }
  }
  if (this.get$isOperator() && this.isStatic && !this.get$isCallMethod()) {
    $globals.world.error(('operator method may not be static "' + this.name + '"'), this.get$span());
  }
  if (this.isAbstract) {
    if (this.definition.body != null && !(this.declaringType.get$definition() instanceof FunctionTypeDefinition)) {
      $globals.world.error('abstract method can not have a body', this.get$span());
    }
    if (this.isStatic && !(this.declaringType.get$definition() instanceof FunctionTypeDefinition)) {
      $globals.world.error('static method can not be abstract', this.get$span());
    }
  }
  else {
    if (this.definition.body == null && !this.get$isConstructor() && !this.get$isNative()) {
      $globals.world.error('method needs a body', this.get$span());
    }
  }
  if (this.get$isConstructor() && !this.isFactory) {
    this.returnType = this.declaringType;
  }
  else {
    this.returnType = this.resolveType(this.definition.returnType, false);
  }
  this.parameters = [];
  var $$list = this.definition.formals;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var formal = $$list.$index($$i);
    var param = new Parameter(formal, this);
    param.resolve$0();
    this.parameters.add(param);
  }
  if (!this.isLambda) {
    this.get$library()._addMember(this);
  }
}
MethodMember.prototype.resolveType = function(node, typeErrors) {
  var t = Element.prototype.resolveType.call(this, node, typeErrors);
  if (this.isStatic && (t instanceof ParameterType) && (this.typeParameters == null || !this.typeParameters.some((function (p) {
    return p === t;
  })
  ))) {
    $globals.world.error('using type parameter in static context.', node.span);
  }
  return t;
}
MethodMember.prototype._get$3 = function($0, $1, $2) {
  return this._get($0, $1, $2, false);
};
MethodMember.prototype._get$3$isDynamic = MethodMember.prototype._get;
MethodMember.prototype._get$4 = MethodMember.prototype._get;
MethodMember.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set($0, $1, $2, $3, false);
};
MethodMember.prototype._set$4$isDynamic = MethodMember.prototype._set;
MethodMember.prototype._set$5 = MethodMember.prototype._set;
MethodMember.prototype.canInvoke$2 = MethodMember.prototype.canInvoke;
MethodMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke($0, $1, $2, $3, false);
};
MethodMember.prototype.invoke$4$isDynamic = MethodMember.prototype.invoke;
MethodMember.prototype.invoke$5 = MethodMember.prototype.invoke;
MethodMember.prototype.namesInOrder$1 = MethodMember.prototype.namesInOrder;
MethodMember.prototype.provideFieldSyntax$0 = MethodMember.prototype.provideFieldSyntax;
MethodMember.prototype.providePropertySyntax$0 = MethodMember.prototype.providePropertySyntax;
MethodMember.prototype.resolve$0 = MethodMember.prototype.resolve;
// ********** Code for MemberSet **************
function MemberSet(member, isVar) {
  this.name = member.name;
  this.members = [member];
  this.jsname = member.get$jsname();
  this.isVar = isVar;
  // Initializers done
}
MemberSet.prototype.get$name = function() { return this.name; };
MemberSet.prototype.get$members = function() { return this.members; };
MemberSet.prototype.get$jsname = function() { return this.jsname; };
MemberSet.prototype.get$isVar = function() { return this.isVar; };
MemberSet.prototype.toString = function() {
  return ('' + this.name + ':' + this.members.length);
}
MemberSet.prototype.get$containsMethods = function() {
  return this.members.some((function (m) {
    return (m instanceof MethodMember);
  })
  );
}
MemberSet.prototype.add = function(member) {
  return this.members.add(member);
}
MemberSet.prototype.get$isStatic = function() {
  return this.members.length == 1 && this.members.$index(0).get$isStatic();
}
MemberSet.prototype.get$isOperator = function() {
  return this.members.$index(0).get$isOperator();
}
MemberSet.prototype.canInvoke = function(context, args) {
  return this.members.some((function (m) {
    return m.canInvoke$2(context, args);
  })
  );
}
MemberSet.prototype._makeError = function(node, target, action) {
  if (!target.get$type().get$isVar()) {
    $globals.world.warning(('could not find applicable ' + action + ' for "' + this.name + '"'), node.span);
  }
  return new Value($globals.world.varType, ('' + target.code + '.' + this.jsname + '() /*no applicable ' + action + '*/'), node.span, true);
}
MemberSet.prototype.get$treatAsField = function() {
  if (this._treatAsField == null) {
    this._treatAsField = !this.isVar;
    var $$list = this.members;
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var member = $$list.$index($$i);
      if (member.get$requiresFieldSyntax()) {
        this._treatAsField = true;
        break;
      }
      if (member.get$prefersPropertySyntax()) {
        this._treatAsField = false;
      }
    }
    var $$list = this.members;
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var member = $$list.$index($$i);
      if (this._treatAsField) {
        member.provideFieldSyntax$0();
      }
      else {
        member.providePropertySyntax$0();
      }
    }
  }
  return this._treatAsField;
}
MemberSet.prototype._get = function(context, node, target, isDynamic) {
  var returnValue;
  var targets = this.members.filter((function (m) {
    return m.get$canGet();
  })
  );
  if (this.isVar) {
    targets.forEach$1((function (m) {
      return m._get$3$isDynamic(context, node, target, true);
    })
    );
    returnValue = new Value(this._foldTypes(targets), null, node.span, true);
  }
  else {
    if (this.members.length == 1) {
      return this.members.$index(0)._get$4(context, node, target, isDynamic);
    }
    else if ($eq(targets.length, 1)) {
      return targets.$index(0)._get$4(context, node, target, isDynamic);
    }
    for (var $$i = targets.iterator$0(); $$i.hasNext$0(); ) {
      var member = $$i.next$0();
      var value = member._get$3$isDynamic(context, node, target, true);
      returnValue = this._tryUnion(returnValue, value, node);
    }
    if (returnValue == null) {
      return this._makeError(node, target, 'getter');
    }
  }
  if (returnValue.code == null) {
    if (this.get$treatAsField()) {
      return new Value(returnValue.get$type(), ('' + target.code + '.' + this.jsname), node.span, true);
    }
    else {
      return new Value(returnValue.get$type(), ('' + target.code + '.get\$' + this.jsname + '()'), node.span, true);
    }
  }
  return returnValue;
}
MemberSet.prototype._set = function(context, node, target, value, isDynamic) {
  var returnValue;
  var targets = this.members.filter((function (m) {
    return m.get$canSet();
  })
  );
  if (this.isVar) {
    targets.forEach$1((function (m) {
      return m._set$4$isDynamic(context, node, target, value, true);
    })
    );
    returnValue = new Value(this._foldTypes(targets), null, node.span, true);
  }
  else {
    if (this.members.length == 1) {
      return this.members.$index(0)._set$5(context, node, target, value, isDynamic);
    }
    else if ($eq(targets.length, 1)) {
      return targets.$index(0)._set$5(context, node, target, value, isDynamic);
    }
    for (var $$i = targets.iterator$0(); $$i.hasNext$0(); ) {
      var member = $$i.next$0();
      var res = member._set$4$isDynamic(context, node, target, value, true);
      returnValue = this._tryUnion(returnValue, res, node);
    }
    if (returnValue == null) {
      return this._makeError(node, target, 'setter');
    }
  }
  if (returnValue.code == null) {
    if (this.get$treatAsField()) {
      return new Value(returnValue.get$type(), ('' + target.code + '.' + this.jsname + ' = ' + value.code), node.span, true);
    }
    else {
      return new Value(returnValue.get$type(), ('' + target.code + '.set\$' + this.jsname + '(' + value.code + ')'), node.span, true);
    }
  }
  return returnValue;
}
MemberSet.prototype.invoke = function(context, node, target, args, isDynamic) {
  if (this.isVar && !this.get$isOperator()) {
    return this.invokeOnVar(context, node, target, args);
  }
  if (this.members.length == 1) {
    return this.members.$index(0).invoke$5(context, node, target, args, isDynamic);
  }
  var targets = this.members.filter((function (m) {
    return m.canInvoke$2(context, args);
  })
  );
  if ($eq(targets.length, 1)) {
    return targets.$index(0).invoke$5(context, node, target, args, isDynamic);
  }
  var returnValue = null;
  for (var $$i = targets.iterator$0(); $$i.hasNext$0(); ) {
    var member = $$i.next$0();
    var res = member.invoke$4$isDynamic(context, node, target, args, true);
    returnValue = this._tryUnion(returnValue, res, node);
  }
  if (returnValue == null) {
    return this._makeError(node, target, 'method');
  }
  if (returnValue.code == null) {
    if (this.name == ':call') {
      return target._varCall(context, args);
    }
    else if (this.get$isOperator()) {
      return this.invokeSpecial(target, args, returnValue.get$type());
    }
    else {
      return this.invokeOnVar(context, node, target, args);
    }
  }
  return returnValue;
}
MemberSet.prototype.invokeSpecial = function(target, args, returnType) {
  var argsString = args.getCode();
  if (this.name == ':index' || this.name == ':setindex') {
    return new Value(returnType, ('' + target.code + '.' + this.jsname + '(' + argsString + ')'), target.span, true);
  }
  else {
    if (argsString.length > 0) argsString = (', ' + argsString);
    $globals.world.gen.corejs.useOperator(this.name);
    return new Value(returnType, ('' + this.jsname + '(' + target.code + argsString + ')'), target.span, true);
  }
}
MemberSet.prototype.invokeOnVar = function(context, node, target, args) {
  var member = this.getVarMember(context, node, args);
  return member.invoke$4(context, node, target, args);
}
MemberSet.prototype._tryUnion = function(x, y, node) {
  if (x == null) return y;
  var type = Type.union(x.get$type(), y.get$type());
  if (x.code == y.code) {
    if ($eq(type, x.get$type())) {
      return x;
    }
    else if (x.get$isConst() || y.get$isConst()) {
      $globals.world.internalError("unexpected: union of const values ");
    }
    else {
      var ret = new Value(type, x.code, node.span, true);
      ret.set$isSuper(x.isSuper && y.isSuper);
      ret.set$needsTemp(x.needsTemp || y.needsTemp);
      ret.set$isType(x.isType && y.isType);
      return ret;
    }
  }
  else {
    return new Value(type, null, node.span, true);
  }
}
MemberSet.prototype.getVarMember = function(context, node, args) {
  if ($globals.world.objectType.varStubs == null) {
    $globals.world.objectType.varStubs = new HashMapImplementation();
  }
  var stubName = _getCallStubName(this.name, args);
  var stub = $globals.world.objectType.varStubs.$index(stubName);
  if (stub == null) {
    var mset = context.findMembers(this.name).members;
    var targets = mset.filter((function (m) {
      return m.canInvoke$2(context, args);
    })
    );
    stub = new VarMethodSet(this.name, stubName, targets, args, this._foldTypes(targets));
    $globals.world.objectType.varStubs.$setindex(stubName, stub);
  }
  return stub;
}
MemberSet.prototype._foldTypes = function(targets) {
  return reduce(map(targets, (function (t) {
    return t.get$returnType();
  })
  ), Type.union, $globals.world.varType);
}
MemberSet.prototype._get$3 = function($0, $1, $2) {
  return this._get($0, $1, $2, false);
};
MemberSet.prototype._get$3$isDynamic = MemberSet.prototype._get;
MemberSet.prototype._get$4 = MemberSet.prototype._get;
MemberSet.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set($0, $1, $2, $3, false);
};
MemberSet.prototype._set$4$isDynamic = MemberSet.prototype._set;
MemberSet.prototype._set$5 = MemberSet.prototype._set;
MemberSet.prototype.add$1 = MemberSet.prototype.add;
MemberSet.prototype.canInvoke$2 = MemberSet.prototype.canInvoke;
MemberSet.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke($0, $1, $2, $3, false);
};
MemberSet.prototype.invoke$4$isDynamic = MemberSet.prototype.invoke;
MemberSet.prototype.invoke$5 = MemberSet.prototype.invoke;
MemberSet.prototype.toString$0 = MemberSet.prototype.toString;
// ********** Code for FactoryMap **************
function FactoryMap() {
  this.factories = new HashMapImplementation();
  // Initializers done
}
FactoryMap.prototype.getFactoriesFor = function(typeName) {
  var ret = this.factories.$index(typeName);
  if (ret == null) {
    ret = new HashMapImplementation();
    this.factories.$setindex(typeName, ret);
  }
  return ret;
}
FactoryMap.prototype.addFactory = function(typeName, name, member) {
  this.getFactoriesFor(typeName).$setindex(name, member);
}
FactoryMap.prototype.getFactory = function(typeName, name) {
  return this.getFactoriesFor(typeName).$index(name);
}
FactoryMap.prototype.forEach = function(f) {
  this.factories.forEach((function (_, constructors) {
    constructors.forEach((function (_, member) {
      f(member);
    })
    );
  })
  );
}
FactoryMap.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$1($0));
};
FactoryMap.prototype.getFactory$2 = FactoryMap.prototype.getFactory;
// ********** Code for Token **************
function Token(kind, source, start, end) {
  this.kind = kind;
  this.source = source;
  this.start = start;
  this.end = end;
  // Initializers done
}
Token.prototype.get$kind = function() { return this.kind; };
Token.prototype.get$end = function() { return this.end; };
Token.prototype.get$start = function() { return this.start; };
Token.prototype.get$text = function() {
  return this.source.get$text().substring(this.start, this.end);
}
Token.prototype.toString = function() {
  var kindText = TokenKind.kindToString(this.kind);
  var actualText = this.get$text();
  if ($ne(kindText, actualText)) {
    if (actualText.length > 10) {
      actualText = actualText.substring$2(0, 8) + '...';
    }
    return ('' + kindText + '(' + actualText + ')');
  }
  else {
    return kindText;
  }
}
Token.prototype.get$span = function() {
  return new SourceSpan(this.source, this.start, this.end);
}
Token.prototype.end$0 = function() {
  return this.end();
};
Token.prototype.start$0 = function() {
  return this.start();
};
Token.prototype.toString$0 = Token.prototype.toString;
// ********** Code for ErrorToken **************
function ErrorToken(kind, source, start, end, message) {
  this.message = message;
  // Initializers done
  Token.call(this, kind, source, start, end);
}
$inherits(ErrorToken, Token);
ErrorToken.prototype.get$message = function() { return this.message; };
ErrorToken.prototype.set$message = function(value) { return this.message = value; };
// ********** Code for SourceFile **************
function SourceFile(filename, _text) {
  this.filename = filename;
  this._text = _text;
  // Initializers done
}
SourceFile.prototype.get$filename = function() { return this.filename; };
SourceFile.prototype.get$orderInLibrary = function() { return this.orderInLibrary; };
SourceFile.prototype.set$orderInLibrary = function(value) { return this.orderInLibrary = value; };
SourceFile.prototype.get$text = function() {
  return this._text;
}
SourceFile.prototype.get$lineStarts = function() {
  if (this._lineStarts == null) {
    var starts = [0];
    var index = 0;
    while (index < this.get$text().length) {
      index = this.get$text().indexOf('\n', index) + 1;
      if (index <= 0) break;
      starts.add$1(index);
    }
    starts.add$1(this.get$text().length + 1);
    this._lineStarts = starts;
  }
  return this._lineStarts;
}
SourceFile.prototype.getLine = function(position) {
  var starts = this.get$lineStarts();
  for (var i = 0;
   i < starts.length; i++) {
    if (starts.$index(i) > position) return i - 1;
  }
  $globals.world.internalError('bad position');
}
SourceFile.prototype.getColumn = function(line, position) {
  return position - this.get$lineStarts().$index(line);
}
SourceFile.prototype.getLocationMessage = function(message, start, end, includeText) {
  var line = this.getLine(start);
  var column = this.getColumn(line, start);
  var buf = new StringBufferImpl(('' + this.filename + ':' + (line + 1) + ':' + (column + 1) + ': ' + message));
  if (includeText) {
    buf.add$1('\n');
    var textLine;
    if ((line + 2) < this._lineStarts.length) {
      textLine = this.get$text().substring(this._lineStarts.$index(line), this._lineStarts.$index(line + 1));
    }
    else {
      textLine = this.get$text().substring(this._lineStarts.$index(line)) + '\n';
    }
    var toColumn = Math.min(column + (end - start), textLine.length);
    if ($globals.options.useColors) {
      buf.add$1(textLine.substring$2(0, column));
      buf.add$1($globals._RED_COLOR);
      buf.add$1(textLine.substring$2(column, toColumn));
      buf.add$1($globals._NO_COLOR);
      buf.add$1(textLine.substring$1(toColumn));
    }
    else {
      buf.add$1(textLine);
    }
    var i = 0;
    for (; i < column; i++) {
      buf.add$1(' ');
    }
    if ($globals.options.useColors) buf.add$1($globals._RED_COLOR);
    for (; i < toColumn; i++) {
      buf.add$1('^');
    }
    if ($globals.options.useColors) buf.add$1($globals._NO_COLOR);
  }
  return buf.toString$0();
}
SourceFile.prototype.compareTo = function(other) {
  if (this.orderInLibrary != null && other.orderInLibrary != null) {
    return this.orderInLibrary - other.orderInLibrary;
  }
  else {
    return this.filename.compareTo(other.filename);
  }
}
SourceFile.prototype.compareTo$1 = SourceFile.prototype.compareTo;
SourceFile.prototype.getColumn$2 = SourceFile.prototype.getColumn;
SourceFile.prototype.getLine$1 = SourceFile.prototype.getLine;
// ********** Code for SourceSpan **************
function SourceSpan(file, start, end) {
  this.file = file;
  this.start = start;
  this.end = end;
  // Initializers done
}
SourceSpan.prototype.get$file = function() { return this.file; };
SourceSpan.prototype.get$start = function() { return this.start; };
SourceSpan.prototype.get$end = function() { return this.end; };
SourceSpan.prototype.get$text = function() {
  return this.file.get$text().substring(this.start, this.end);
}
SourceSpan.prototype.toMessageString = function(message) {
  return this.file.getLocationMessage(message, this.start, this.end, true);
}
SourceSpan.prototype.get$locationText = function() {
  var line = this.file.getLine(this.start);
  var column = this.file.getColumn(line, this.start);
  return ('' + this.file.filename + ':' + (line + 1) + ':' + (column + 1));
}
SourceSpan.prototype.compareTo = function(other) {
  if ($eq(this.file, other.file)) {
    var d = this.start - other.start;
    return d == 0 ? (this.end - other.end) : d;
  }
  return this.file.compareTo(other.file);
}
SourceSpan.prototype.compareTo$1 = SourceSpan.prototype.compareTo;
SourceSpan.prototype.end$0 = function() {
  return this.end();
};
SourceSpan.prototype.start$0 = function() {
  return this.start();
};
// ********** Code for InterpStack **************
function InterpStack(previous, quote, isMultiline) {
  this.previous = previous;
  this.quote = quote;
  this.isMultiline = isMultiline;
  this.depth = -1;
  // Initializers done
}
InterpStack.prototype.get$previous = function() { return this.previous; };
InterpStack.prototype.set$previous = function(value) { return this.previous = value; };
InterpStack.prototype.get$quote = function() { return this.quote; };
InterpStack.prototype.get$isMultiline = function() { return this.isMultiline; };
InterpStack.prototype.get$depth = function() { return this.depth; };
InterpStack.prototype.set$depth = function(value) { return this.depth = value; };
InterpStack.prototype.pop = function() {
  return this.previous;
}
InterpStack.push = function(stack, quote, isMultiline) {
  var newStack = new InterpStack(stack, quote, isMultiline);
  if (stack != null) newStack.set$previous(stack);
  return newStack;
}
InterpStack.prototype.next$0 = function() {
  return this.next();
};
// ********** Code for TokenizerBase **************
function TokenizerBase(_source, _skipWhitespace, index) {
  this._source = _source;
  this._skipWhitespace = _skipWhitespace;
  this._index = index;
  // Initializers done
  TokenizerHelpers.call(this);
  this._text = this._source.get$text();
}
$inherits(TokenizerBase, TokenizerHelpers);
TokenizerBase.prototype._nextChar = function() {
  if (this._index < this._text.length) {
    return this._text.charCodeAt(this._index++);
  }
  else {
    return 0;
  }
}
TokenizerBase.prototype._peekChar = function() {
  if (this._index < this._text.length) {
    return this._text.charCodeAt(this._index);
  }
  else {
    return 0;
  }
}
TokenizerBase.prototype._maybeEatChar = function(ch) {
  if (this._index < this._text.length) {
    if (this._text.charCodeAt(this._index) == ch) {
      this._index++;
      return true;
    }
    else {
      return false;
    }
  }
  else {
    return false;
  }
}
TokenizerBase.prototype._finishToken = function(kind) {
  return new Token(kind, this._source, this._startIndex, this._index);
}
TokenizerBase.prototype._errorToken = function(message) {
  return new ErrorToken(65/*TokenKind.ERROR*/, this._source, this._startIndex, this._index, message);
}
TokenizerBase.prototype.finishWhitespace = function() {
  this._index--;
  while (this._index < this._text.length) {
    var ch = this._text.charCodeAt(this._index++);
    if (ch == 32 || ch == 9 || ch == 13) {
    }
    else if (ch == 10) {
      if (!this._skipWhitespace) {
        return this._finishToken(63/*TokenKind.WHITESPACE*/);
      }
    }
    else {
      this._index--;
      if (this._skipWhitespace) {
        return this.next();
      }
      else {
        return this._finishToken(63/*TokenKind.WHITESPACE*/);
      }
    }
  }
  return this._finishToken(1/*TokenKind.END_OF_FILE*/);
}
TokenizerBase.prototype.finishHashBang = function() {
  while (true) {
    var ch = this._nextChar();
    if (ch == 0 || ch == 10 || ch == 13) {
      return this._finishToken(13/*TokenKind.HASHBANG*/);
    }
  }
}
TokenizerBase.prototype.finishSingleLineComment = function() {
  while (true) {
    var ch = this._nextChar();
    if (ch == 0 || ch == 10 || ch == 13) {
      if (this._skipWhitespace) {
        return this.next();
      }
      else {
        return this._finishToken(64/*TokenKind.COMMENT*/);
      }
    }
  }
}
TokenizerBase.prototype.finishMultiLineComment = function() {
  while (true) {
    var ch = this._nextChar();
    if (ch == 0) {
      return this._finishToken(67/*TokenKind.INCOMPLETE_COMMENT*/);
    }
    else if (ch == 42) {
      if (this._maybeEatChar(47)) {
        if (this._skipWhitespace) {
          return this.next();
        }
        else {
          return this._finishToken(64/*TokenKind.COMMENT*/);
        }
      }
    }
  }
  return this._errorToken();
}
TokenizerBase.prototype.eatDigits = function() {
  while (this._index < this._text.length) {
    if (TokenizerHelpers.isDigit(this._text.charCodeAt(this._index))) {
      this._index++;
    }
    else {
      return;
    }
  }
}
TokenizerBase.prototype.eatHexDigits = function() {
  while (this._index < this._text.length) {
    if (TokenizerHelpers.isHexDigit(this._text.charCodeAt(this._index))) {
      this._index++;
    }
    else {
      return;
    }
  }
}
TokenizerBase.prototype.maybeEatHexDigit = function() {
  if (this._index < this._text.length && TokenizerHelpers.isHexDigit(this._text.charCodeAt(this._index))) {
    this._index++;
    return true;
  }
  return false;
}
TokenizerBase.prototype.finishHex = function() {
  this.eatHexDigits();
  return this._finishToken(61/*TokenKind.HEX_INTEGER*/);
}
TokenizerBase.prototype.finishNumber = function() {
  this.eatDigits();
  if (this._peekChar() == 46) {
    this._nextChar();
    if (TokenizerHelpers.isDigit(this._peekChar())) {
      this.eatDigits();
      return this.finishNumberExtra(62/*TokenKind.DOUBLE*/);
    }
    else {
      this._index--;
    }
  }
  return this.finishNumberExtra(60/*TokenKind.INTEGER*/);
}
TokenizerBase.prototype.finishNumberExtra = function(kind) {
  if (this._maybeEatChar(101) || this._maybeEatChar(69)) {
    kind = 62/*TokenKind.DOUBLE*/;
    this._maybeEatChar(45);
    this._maybeEatChar(43);
    this.eatDigits();
  }
  if (this._peekChar() != 0 && TokenizerHelpers.isIdentifierStart(this._peekChar())) {
    this._nextChar();
    return this._errorToken("illegal character in number");
  }
  return this._finishToken(kind);
}
TokenizerBase.prototype.finishMultilineString = function(quote) {
  while (true) {
    var ch = this._nextChar();
    if (ch == 0) {
      var kind = quote == 34 ? 68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/ : 69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/;
      return this._finishToken(kind);
    }
    else if (ch == quote) {
      if (this._maybeEatChar(quote)) {
        if (this._maybeEatChar(quote)) {
          return this._finishToken(58/*TokenKind.STRING*/);
        }
      }
    }
    else if (ch == 36) {
      this._interpStack = InterpStack.push(this._interpStack, quote, true);
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
    else if (ch == 92) {
      if (!this.eatEscapeSequence()) {
        return this._errorToken("invalid hex escape sequence");
      }
    }
  }
}
TokenizerBase.prototype._finishOpenBrace = function() {
  var $0;
  if (this._interpStack != null) {
    if (this._interpStack.depth == -1) {
      this._interpStack.depth = 1;
    }
    else {
      ($0 = this._interpStack).depth = $0.depth + 1;
    }
  }
  return this._finishToken(6/*TokenKind.LBRACE*/);
}
TokenizerBase.prototype._finishCloseBrace = function() {
  var $0;
  if (this._interpStack != null) {
    ($0 = this._interpStack).depth = $0.depth - 1;
  }
  return this._finishToken(7/*TokenKind.RBRACE*/);
}
TokenizerBase.prototype.finishString = function(quote) {
  if (this._maybeEatChar(quote)) {
    if (this._maybeEatChar(quote)) {
      return this.finishMultilineString(quote);
    }
    else {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
  }
  return this.finishStringBody(quote);
}
TokenizerBase.prototype.finishRawString = function(quote) {
  if (this._maybeEatChar(quote)) {
    if (this._maybeEatChar(quote)) {
      return this.finishMultilineRawString(quote);
    }
    else {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
  }
  while (true) {
    var ch = this._nextChar();
    if (ch == quote) {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
    else if (ch == 0) {
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
  }
}
TokenizerBase.prototype.finishMultilineRawString = function(quote) {
  while (true) {
    var ch = this._nextChar();
    if (ch == 0) {
      var kind = quote == 34 ? 68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/ : 69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/;
      return this._finishToken(kind);
    }
    else if (ch == quote && this._maybeEatChar(quote) && this._maybeEatChar(quote)) {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
  }
}
TokenizerBase.prototype.finishStringBody = function(quote) {
  while (true) {
    var ch = this._nextChar();
    if (ch == quote) {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
    else if (ch == 36) {
      this._interpStack = InterpStack.push(this._interpStack, quote, false);
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
    else if (ch == 0) {
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
    else if (ch == 92) {
      if (!this.eatEscapeSequence()) {
        return this._errorToken("invalid hex escape sequence");
      }
    }
  }
}
TokenizerBase.prototype.eatEscapeSequence = function() {
  var hex;
  switch (this._nextChar()) {
    case 120:

      return this.maybeEatHexDigit() && this.maybeEatHexDigit();

    case 117:

      if (this._maybeEatChar(123)) {
        var start = this._index;
        this.eatHexDigits();
        var chars = this._index - start;
        if (chars > 0 && chars <= 6 && this._maybeEatChar(125)) {
          hex = this._text.substring(start, start + chars);
          break;
        }
        else {
          return false;
        }
      }
      else {
        if (this.maybeEatHexDigit() && this.maybeEatHexDigit() && this.maybeEatHexDigit() && this.maybeEatHexDigit()) {
          hex = this._text.substring(this._index - 4, this._index);
          break;
        }
        else {
          return false;
        }
      }

    default:

      return true;

  }
  var n = Parser.parseHex(hex);
  return n < 0xD800 || n > 0xDFFF && n <= 0x10FFFF;
}
TokenizerBase.prototype.finishDot = function() {
  if (TokenizerHelpers.isDigit(this._peekChar())) {
    this.eatDigits();
    return this.finishNumberExtra(62/*TokenKind.DOUBLE*/);
  }
  else {
    return this._finishToken(14/*TokenKind.DOT*/);
  }
}
TokenizerBase.prototype.finishIdentifier = function(ch) {
  if (this._interpStack != null && this._interpStack.depth == -1) {
    this._interpStack.depth = 0;
    if (ch == 36) {
      return this._errorToken("illegal character after $ in string interpolation");
    }
    while (this._index < this._text.length) {
      if (!TokenizerHelpers.isInterpIdentifierPart(this._text.charCodeAt(this._index++))) {
        this._index--;
        break;
      }
    }
  }
  else {
    while (this._index < this._text.length) {
      if (!TokenizerHelpers.isIdentifierPart(this._text.charCodeAt(this._index++))) {
        this._index--;
        break;
      }
    }
  }
  var kind = this.getIdentifierKind();
  if (kind == 70/*TokenKind.IDENTIFIER*/) {
    return this._finishToken(70/*TokenKind.IDENTIFIER*/);
  }
  else {
    return this._finishToken(kind);
  }
}
TokenizerBase.prototype.next$0 = TokenizerBase.prototype.next;
// ********** Code for Tokenizer **************
function Tokenizer(source, skipWhitespace, index) {
  // Initializers done
  TokenizerBase.call(this, source, skipWhitespace, index);
}
$inherits(Tokenizer, TokenizerBase);
Tokenizer.prototype.next = function() {
  this._startIndex = this._index;
  if (this._interpStack != null && this._interpStack.depth == 0) {
    var istack = this._interpStack;
    this._interpStack = this._interpStack.pop();
    if (istack.get$isMultiline()) {
      return this.finishMultilineString(istack.get$quote());
    }
    else {
      return this.finishStringBody(istack.get$quote());
    }
  }
  var ch;
  ch = this._nextChar();
  switch (ch) {
    case 0:

      return this._finishToken(1/*TokenKind.END_OF_FILE*/);

    case 32:
    case 9:
    case 10:
    case 13:

      return this.finishWhitespace();

    case 33:

      if (this._maybeEatChar(61)) {
        if (this._maybeEatChar(61)) {
          return this._finishToken(51/*TokenKind.NE_STRICT*/);
        }
        else {
          return this._finishToken(49/*TokenKind.NE*/);
        }
      }
      else {
        return this._finishToken(19/*TokenKind.NOT*/);
      }

    case 34:

      return this.finishString(34);

    case 35:

      if (this._maybeEatChar(33)) {
        return this.finishHashBang();
      }
      else {
        return this._finishToken(12/*TokenKind.HASH*/);
      }

    case 36:

      if (this._maybeEatChar(34)) {
        return this.finishString(34);
      }
      else if (this._maybeEatChar(39)) {
        return this.finishString(39);
      }
      else {
        return this.finishIdentifier(36);
      }

    case 37:

      if (this._maybeEatChar(61)) {
        return this._finishToken(32/*TokenKind.ASSIGN_MOD*/);
      }
      else {
        return this._finishToken(47/*TokenKind.MOD*/);
      }

    case 38:

      if (this._maybeEatChar(38)) {
        return this._finishToken(35/*TokenKind.AND*/);
      }
      else if (this._maybeEatChar(61)) {
        return this._finishToken(23/*TokenKind.ASSIGN_AND*/);
      }
      else {
        return this._finishToken(38/*TokenKind.BIT_AND*/);
      }

    case 39:

      return this.finishString(39);

    case 40:

      return this._finishToken(2/*TokenKind.LPAREN*/);

    case 41:

      return this._finishToken(3/*TokenKind.RPAREN*/);

    case 42:

      if (this._maybeEatChar(61)) {
        return this._finishToken(29/*TokenKind.ASSIGN_MUL*/);
      }
      else {
        return this._finishToken(44/*TokenKind.MUL*/);
      }

    case 43:

      if (this._maybeEatChar(43)) {
        return this._finishToken(16/*TokenKind.INCR*/);
      }
      else if (this._maybeEatChar(61)) {
        return this._finishToken(27/*TokenKind.ASSIGN_ADD*/);
      }
      else {
        return this._finishToken(42/*TokenKind.ADD*/);
      }

    case 44:

      return this._finishToken(11/*TokenKind.COMMA*/);

    case 45:

      if (this._maybeEatChar(45)) {
        return this._finishToken(17/*TokenKind.DECR*/);
      }
      else if (this._maybeEatChar(61)) {
        return this._finishToken(28/*TokenKind.ASSIGN_SUB*/);
      }
      else {
        return this._finishToken(43/*TokenKind.SUB*/);
      }

    case 46:

      if (this._maybeEatChar(46)) {
        if (this._maybeEatChar(46)) {
          return this._finishToken(15/*TokenKind.ELLIPSIS*/);
        }
        else {
          return this._errorToken();
        }
      }
      else {
        return this.finishDot();
      }

    case 47:

      if (this._maybeEatChar(42)) {
        return this.finishMultiLineComment();
      }
      else if (this._maybeEatChar(47)) {
        return this.finishSingleLineComment();
      }
      else if (this._maybeEatChar(61)) {
        return this._finishToken(30/*TokenKind.ASSIGN_DIV*/);
      }
      else {
        return this._finishToken(45/*TokenKind.DIV*/);
      }

    case 48:

      if (this._maybeEatChar(88)) {
        return this.finishHex();
      }
      else if (this._maybeEatChar(120)) {
        return this.finishHex();
      }
      else {
        return this.finishNumber();
      }

    case 58:

      return this._finishToken(8/*TokenKind.COLON*/);

    case 59:

      return this._finishToken(10/*TokenKind.SEMICOLON*/);

    case 60:

      if (this._maybeEatChar(60)) {
        if (this._maybeEatChar(61)) {
          return this._finishToken(24/*TokenKind.ASSIGN_SHL*/);
        }
        else {
          return this._finishToken(39/*TokenKind.SHL*/);
        }
      }
      else if (this._maybeEatChar(61)) {
        return this._finishToken(54/*TokenKind.LTE*/);
      }
      else {
        return this._finishToken(52/*TokenKind.LT*/);
      }

    case 61:

      if (this._maybeEatChar(61)) {
        if (this._maybeEatChar(61)) {
          return this._finishToken(50/*TokenKind.EQ_STRICT*/);
        }
        else {
          return this._finishToken(48/*TokenKind.EQ*/);
        }
      }
      else if (this._maybeEatChar(62)) {
        return this._finishToken(9/*TokenKind.ARROW*/);
      }
      else {
        return this._finishToken(20/*TokenKind.ASSIGN*/);
      }

    case 62:

      if (this._maybeEatChar(61)) {
        return this._finishToken(55/*TokenKind.GTE*/);
      }
      else if (this._maybeEatChar(62)) {
        if (this._maybeEatChar(61)) {
          return this._finishToken(25/*TokenKind.ASSIGN_SAR*/);
        }
        else if (this._maybeEatChar(62)) {
          if (this._maybeEatChar(61)) {
            return this._finishToken(26/*TokenKind.ASSIGN_SHR*/);
          }
          else {
            return this._finishToken(41/*TokenKind.SHR*/);
          }
        }
        else {
          return this._finishToken(40/*TokenKind.SAR*/);
        }
      }
      else {
        return this._finishToken(53/*TokenKind.GT*/);
      }

    case 63:

      return this._finishToken(33/*TokenKind.CONDITIONAL*/);

    case 64:

      if (this._maybeEatChar(34)) {
        return this.finishRawString(34);
      }
      else if (this._maybeEatChar(39)) {
        return this.finishRawString(39);
      }
      else {
        return this._errorToken();
      }

    case 91:

      if (this._maybeEatChar(93)) {
        if (this._maybeEatChar(61)) {
          return this._finishToken(57/*TokenKind.SETINDEX*/);
        }
        else {
          return this._finishToken(56/*TokenKind.INDEX*/);
        }
      }
      else {
        return this._finishToken(4/*TokenKind.LBRACK*/);
      }

    case 93:

      return this._finishToken(5/*TokenKind.RBRACK*/);

    case 94:

      if (this._maybeEatChar(61)) {
        return this._finishToken(22/*TokenKind.ASSIGN_XOR*/);
      }
      else {
        return this._finishToken(37/*TokenKind.BIT_XOR*/);
      }

    case 123:

      return this._finishOpenBrace();

    case 124:

      if (this._maybeEatChar(61)) {
        return this._finishToken(21/*TokenKind.ASSIGN_OR*/);
      }
      else if (this._maybeEatChar(124)) {
        return this._finishToken(34/*TokenKind.OR*/);
      }
      else {
        return this._finishToken(36/*TokenKind.BIT_OR*/);
      }

    case 125:

      return this._finishCloseBrace();

    case 126:

      if (this._maybeEatChar(47)) {
        if (this._maybeEatChar(61)) {
          return this._finishToken(31/*TokenKind.ASSIGN_TRUNCDIV*/);
        }
        else {
          return this._finishToken(46/*TokenKind.TRUNCDIV*/);
        }
      }
      else {
        return this._finishToken(18/*TokenKind.BIT_NOT*/);
      }

    default:

      if (TokenizerHelpers.isIdentifierStart(ch)) {
        return this.finishIdentifier(ch);
      }
      else if (TokenizerHelpers.isDigit(ch)) {
        return this.finishNumber();
      }
      else {
        return this._errorToken();
      }

  }
}
Tokenizer.prototype.getIdentifierKind = function() {
  var i0 = this._startIndex;
  switch (this._index - i0) {
    case 2:

      if (this._text.charCodeAt(i0) == 100) {
        if (this._text.charCodeAt(i0 + 1) == 111) return 95/*TokenKind.DO*/;
      }
      else if (this._text.charCodeAt(i0) == 105) {
        if (this._text.charCodeAt(i0 + 1) == 102) {
          return 101/*TokenKind.IF*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 110) {
          return 102/*TokenKind.IN*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 115) {
          return 103/*TokenKind.IS*/;
        }
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 3:

      if (this._text.charCodeAt(i0) == 102) {
        if (this._text.charCodeAt(i0 + 1) == 111 && this._text.charCodeAt(i0 + 2) == 114) return 100/*TokenKind.FOR*/;
      }
      else if (this._text.charCodeAt(i0) == 103) {
        if (this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 116) return 76/*TokenKind.GET*/;
      }
      else if (this._text.charCodeAt(i0) == 110) {
        if (this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 119) return 104/*TokenKind.NEW*/;
      }
      else if (this._text.charCodeAt(i0) == 115) {
        if (this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 116) return 84/*TokenKind.SET*/;
      }
      else if (this._text.charCodeAt(i0) == 116) {
        if (this._text.charCodeAt(i0 + 1) == 114 && this._text.charCodeAt(i0 + 2) == 121) return 112/*TokenKind.TRY*/;
      }
      else if (this._text.charCodeAt(i0) == 118) {
        if (this._text.charCodeAt(i0 + 1) == 97 && this._text.charCodeAt(i0 + 2) == 114) return 113/*TokenKind.VAR*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 4:

      if (this._text.charCodeAt(i0) == 99) {
        if (this._text.charCodeAt(i0 + 1) == 97 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 101) return 90/*TokenKind.CASE*/;
      }
      else if (this._text.charCodeAt(i0) == 101) {
        if (this._text.charCodeAt(i0 + 1) == 108 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 101) return 96/*TokenKind.ELSE*/;
      }
      else if (this._text.charCodeAt(i0) == 110) {
        if (this._text.charCodeAt(i0 + 1) == 117 && this._text.charCodeAt(i0 + 2) == 108 && this._text.charCodeAt(i0 + 3) == 108) return 105/*TokenKind.NULL*/;
      }
      else if (this._text.charCodeAt(i0) == 116) {
        if (this._text.charCodeAt(i0 + 1) == 104) {
          if (this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 115) return 109/*TokenKind.THIS*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 114) {
          if (this._text.charCodeAt(i0 + 2) == 117 && this._text.charCodeAt(i0 + 3) == 101) return 111/*TokenKind.TRUE*/;
        }
      }
      else if (this._text.charCodeAt(i0) == 118) {
        if (this._text.charCodeAt(i0 + 1) == 111 && this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 100) return 114/*TokenKind.VOID*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 5:

      if (this._text.charCodeAt(i0) == 97) {
        if (this._text.charCodeAt(i0 + 1) == 119 && this._text.charCodeAt(i0 + 2) == 97 && this._text.charCodeAt(i0 + 3) == 105 && this._text.charCodeAt(i0 + 4) == 116) return 88/*TokenKind.AWAIT*/;
      }
      else if (this._text.charCodeAt(i0) == 98) {
        if (this._text.charCodeAt(i0 + 1) == 114 && this._text.charCodeAt(i0 + 2) == 101 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 107) return 89/*TokenKind.BREAK*/;
      }
      else if (this._text.charCodeAt(i0) == 99) {
        if (this._text.charCodeAt(i0 + 1) == 97) {
          if (this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 99 && this._text.charCodeAt(i0 + 4) == 104) return 91/*TokenKind.CATCH*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 108) {
          if (this._text.charCodeAt(i0 + 2) == 97 && this._text.charCodeAt(i0 + 3) == 115 && this._text.charCodeAt(i0 + 4) == 115) return 73/*TokenKind.CLASS*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 111) {
          if (this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 115 && this._text.charCodeAt(i0 + 4) == 116) return 92/*TokenKind.CONST*/;
        }
      }
      else if (this._text.charCodeAt(i0) == 102) {
        if (this._text.charCodeAt(i0 + 1) == 97) {
          if (this._text.charCodeAt(i0 + 2) == 108 && this._text.charCodeAt(i0 + 3) == 115 && this._text.charCodeAt(i0 + 4) == 101) return 97/*TokenKind.FALSE*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 105) {
          if (this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 108) return 98/*TokenKind.FINAL*/;
        }
      }
      else if (this._text.charCodeAt(i0) == 115) {
        if (this._text.charCodeAt(i0 + 1) == 117 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 114) return 107/*TokenKind.SUPER*/;
      }
      else if (this._text.charCodeAt(i0) == 116) {
        if (this._text.charCodeAt(i0 + 1) == 104 && this._text.charCodeAt(i0 + 2) == 114 && this._text.charCodeAt(i0 + 3) == 111 && this._text.charCodeAt(i0 + 4) == 119) return 110/*TokenKind.THROW*/;
      }
      else if (this._text.charCodeAt(i0) == 119) {
        if (this._text.charCodeAt(i0 + 1) == 104 && this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 108 && this._text.charCodeAt(i0 + 4) == 101) return 115/*TokenKind.WHILE*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 6:

      if (this._text.charCodeAt(i0) == 97) {
        if (this._text.charCodeAt(i0 + 1) == 115 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 116) return 72/*TokenKind.ASSERT*/;
      }
      else if (this._text.charCodeAt(i0) == 105) {
        if (this._text.charCodeAt(i0 + 1) == 109 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 111 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 116) return 78/*TokenKind.IMPORT*/;
      }
      else if (this._text.charCodeAt(i0) == 110) {
        if (this._text.charCodeAt(i0 + 1) == 97) {
          if (this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 105 && this._text.charCodeAt(i0 + 4) == 118 && this._text.charCodeAt(i0 + 5) == 101) return 81/*TokenKind.NATIVE*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 101) {
          if (this._text.charCodeAt(i0 + 2) == 103 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 116 && this._text.charCodeAt(i0 + 5) == 101) return 82/*TokenKind.NEGATE*/;
        }
      }
      else if (this._text.charCodeAt(i0) == 114) {
        if (this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 117 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 110) return 106/*TokenKind.RETURN*/;
      }
      else if (this._text.charCodeAt(i0) == 115) {
        if (this._text.charCodeAt(i0 + 1) == 111) {
          if (this._text.charCodeAt(i0 + 2) == 117 && this._text.charCodeAt(i0 + 3) == 114 && this._text.charCodeAt(i0 + 4) == 99 && this._text.charCodeAt(i0 + 5) == 101) return 85/*TokenKind.SOURCE*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 116) {
          if (this._text.charCodeAt(i0 + 2) == 97 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 105 && this._text.charCodeAt(i0 + 5) == 99) return 86/*TokenKind.STATIC*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 119) {
          if (this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 99 && this._text.charCodeAt(i0 + 5) == 104) return 108/*TokenKind.SWITCH*/;
        }
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 7:

      if (this._text.charCodeAt(i0) == 100) {
        if (this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 102 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 117 && this._text.charCodeAt(i0 + 5) == 108 && this._text.charCodeAt(i0 + 6) == 116) return 94/*TokenKind.DEFAULT*/;
      }
      else if (this._text.charCodeAt(i0) == 101) {
        if (this._text.charCodeAt(i0 + 1) == 120 && this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 110 && this._text.charCodeAt(i0 + 5) == 100 && this._text.charCodeAt(i0 + 6) == 115) return 74/*TokenKind.EXTENDS*/;
      }
      else if (this._text.charCodeAt(i0) == 102) {
        if (this._text.charCodeAt(i0 + 1) == 97) {
          if (this._text.charCodeAt(i0 + 2) == 99 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 111 && this._text.charCodeAt(i0 + 5) == 114 && this._text.charCodeAt(i0 + 6) == 121) return 75/*TokenKind.FACTORY*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 105) {
          if (this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 108 && this._text.charCodeAt(i0 + 5) == 108 && this._text.charCodeAt(i0 + 6) == 121) return 99/*TokenKind.FINALLY*/;
        }
      }
      else if (this._text.charCodeAt(i0) == 108) {
        if (this._text.charCodeAt(i0 + 1) == 105 && this._text.charCodeAt(i0 + 2) == 98 && this._text.charCodeAt(i0 + 3) == 114 && this._text.charCodeAt(i0 + 4) == 97 && this._text.charCodeAt(i0 + 5) == 114 && this._text.charCodeAt(i0 + 6) == 121) return 80/*TokenKind.LIBRARY*/;
      }
      else if (this._text.charCodeAt(i0) == 116) {
        if (this._text.charCodeAt(i0 + 1) == 121 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 100 && this._text.charCodeAt(i0 + 5) == 101 && this._text.charCodeAt(i0 + 6) == 102) return 87/*TokenKind.TYPEDEF*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 8:

      if (this._text.charCodeAt(i0) == 97) {
        if (this._text.charCodeAt(i0 + 1) == 98 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 97 && this._text.charCodeAt(i0 + 6) == 99 && this._text.charCodeAt(i0 + 7) == 116) return 71/*TokenKind.ABSTRACT*/;
      }
      else if (this._text.charCodeAt(i0) == 99) {
        if (this._text.charCodeAt(i0 + 1) == 111 && this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 105 && this._text.charCodeAt(i0 + 5) == 110 && this._text.charCodeAt(i0 + 6) == 117 && this._text.charCodeAt(i0 + 7) == 101) return 93/*TokenKind.CONTINUE*/;
      }
      else if (this._text.charCodeAt(i0) == 111) {
        if (this._text.charCodeAt(i0 + 1) == 112 && this._text.charCodeAt(i0 + 2) == 101 && this._text.charCodeAt(i0 + 3) == 114 && this._text.charCodeAt(i0 + 4) == 97 && this._text.charCodeAt(i0 + 5) == 116 && this._text.charCodeAt(i0 + 6) == 111 && this._text.charCodeAt(i0 + 7) == 114) return 83/*TokenKind.OPERATOR*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 9:

      if (this._text.charCodeAt(i0) == 105 && this._text.charCodeAt(i0 + 1) == 110 && this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 102 && this._text.charCodeAt(i0 + 6) == 97 && this._text.charCodeAt(i0 + 7) == 99 && this._text.charCodeAt(i0 + 8) == 101) return 79/*TokenKind.INTERFACE*/;
      return 70/*TokenKind.IDENTIFIER*/;

    case 10:

      if (this._text.charCodeAt(i0) == 105 && this._text.charCodeAt(i0 + 1) == 109 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 108 && this._text.charCodeAt(i0 + 4) == 101 && this._text.charCodeAt(i0 + 5) == 109 && this._text.charCodeAt(i0 + 6) == 101 && this._text.charCodeAt(i0 + 7) == 110 && this._text.charCodeAt(i0 + 8) == 116 && this._text.charCodeAt(i0 + 9) == 115) return 77/*TokenKind.IMPLEMENTS*/;
      return 70/*TokenKind.IDENTIFIER*/;

    default:

      return 70/*TokenKind.IDENTIFIER*/;

  }
}
Tokenizer.prototype.next$0 = Tokenizer.prototype.next;
// ********** Code for TokenizerHelpers **************
function TokenizerHelpers() {
  // Initializers done
}
TokenizerHelpers.isIdentifierStart = function(c) {
  return ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || c == 95);
}
TokenizerHelpers.isDigit = function(c) {
  return (c >= 48 && c <= 57);
}
TokenizerHelpers.isHexDigit = function(c) {
  return (TokenizerHelpers.isDigit(c) || (c >= 97 && c <= 102) || (c >= 65 && c <= 70));
}
TokenizerHelpers.isIdentifierPart = function(c) {
  return (TokenizerHelpers.isIdentifierStart(c) || TokenizerHelpers.isDigit(c) || c == 36);
}
TokenizerHelpers.isInterpIdentifierPart = function(c) {
  return (TokenizerHelpers.isIdentifierStart(c) || TokenizerHelpers.isDigit(c));
}
// ********** Code for TokenKind **************
function TokenKind() {}
TokenKind.kindToString = function(kind) {
  switch (kind) {
    case 1/*TokenKind.END_OF_FILE*/:

      return "end of file";

    case 2/*TokenKind.LPAREN*/:

      return "(";

    case 3/*TokenKind.RPAREN*/:

      return ")";

    case 4/*TokenKind.LBRACK*/:

      return "[";

    case 5/*TokenKind.RBRACK*/:

      return "]";

    case 6/*TokenKind.LBRACE*/:

      return "{";

    case 7/*TokenKind.RBRACE*/:

      return "}";

    case 8/*TokenKind.COLON*/:

      return ":";

    case 9/*TokenKind.ARROW*/:

      return "=>";

    case 10/*TokenKind.SEMICOLON*/:

      return ";";

    case 11/*TokenKind.COMMA*/:

      return ",";

    case 12/*TokenKind.HASH*/:

      return "#";

    case 13/*TokenKind.HASHBANG*/:

      return "#!";

    case 14/*TokenKind.DOT*/:

      return ".";

    case 15/*TokenKind.ELLIPSIS*/:

      return "...";

    case 16/*TokenKind.INCR*/:

      return "++";

    case 17/*TokenKind.DECR*/:

      return "--";

    case 18/*TokenKind.BIT_NOT*/:

      return "~";

    case 19/*TokenKind.NOT*/:

      return "!";

    case 20/*TokenKind.ASSIGN*/:

      return "=";

    case 21/*TokenKind.ASSIGN_OR*/:

      return "|=";

    case 22/*TokenKind.ASSIGN_XOR*/:

      return "^=";

    case 23/*TokenKind.ASSIGN_AND*/:

      return "&=";

    case 24/*TokenKind.ASSIGN_SHL*/:

      return "<<=";

    case 25/*TokenKind.ASSIGN_SAR*/:

      return ">>=";

    case 26/*TokenKind.ASSIGN_SHR*/:

      return ">>>=";

    case 27/*TokenKind.ASSIGN_ADD*/:

      return "+=";

    case 28/*TokenKind.ASSIGN_SUB*/:

      return "-=";

    case 29/*TokenKind.ASSIGN_MUL*/:

      return "*=";

    case 30/*TokenKind.ASSIGN_DIV*/:

      return "/=";

    case 31/*TokenKind.ASSIGN_TRUNCDIV*/:

      return "~/=";

    case 32/*TokenKind.ASSIGN_MOD*/:

      return "%=";

    case 33/*TokenKind.CONDITIONAL*/:

      return "?";

    case 34/*TokenKind.OR*/:

      return "||";

    case 35/*TokenKind.AND*/:

      return "&&";

    case 36/*TokenKind.BIT_OR*/:

      return "|";

    case 37/*TokenKind.BIT_XOR*/:

      return "^";

    case 38/*TokenKind.BIT_AND*/:

      return "&";

    case 39/*TokenKind.SHL*/:

      return "<<";

    case 40/*TokenKind.SAR*/:

      return ">>";

    case 41/*TokenKind.SHR*/:

      return ">>>";

    case 42/*TokenKind.ADD*/:

      return "+";

    case 43/*TokenKind.SUB*/:

      return "-";

    case 44/*TokenKind.MUL*/:

      return "*";

    case 45/*TokenKind.DIV*/:

      return "/";

    case 46/*TokenKind.TRUNCDIV*/:

      return "~/";

    case 47/*TokenKind.MOD*/:

      return "%";

    case 48/*TokenKind.EQ*/:

      return "==";

    case 49/*TokenKind.NE*/:

      return "!=";

    case 50/*TokenKind.EQ_STRICT*/:

      return "===";

    case 51/*TokenKind.NE_STRICT*/:

      return "!==";

    case 52/*TokenKind.LT*/:

      return "<";

    case 53/*TokenKind.GT*/:

      return ">";

    case 54/*TokenKind.LTE*/:

      return "<=";

    case 55/*TokenKind.GTE*/:

      return ">=";

    case 56/*TokenKind.INDEX*/:

      return "[]";

    case 57/*TokenKind.SETINDEX*/:

      return "[]=";

    case 58/*TokenKind.STRING*/:

      return "string";

    case 59/*TokenKind.STRING_PART*/:

      return "string part";

    case 60/*TokenKind.INTEGER*/:

      return "integer";

    case 61/*TokenKind.HEX_INTEGER*/:

      return "hex integer";

    case 62/*TokenKind.DOUBLE*/:

      return "double";

    case 63/*TokenKind.WHITESPACE*/:

      return "whitespace";

    case 64/*TokenKind.COMMENT*/:

      return "comment";

    case 65/*TokenKind.ERROR*/:

      return "error";

    case 66/*TokenKind.INCOMPLETE_STRING*/:

      return "incomplete string";

    case 67/*TokenKind.INCOMPLETE_COMMENT*/:

      return "incomplete comment";

    case 68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/:

      return "incomplete multiline string dq";

    case 69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/:

      return "incomplete multiline string sq";

    case 70/*TokenKind.IDENTIFIER*/:

      return "identifier";

    case 71/*TokenKind.ABSTRACT*/:

      return "pseudo-keyword 'abstract'";

    case 72/*TokenKind.ASSERT*/:

      return "pseudo-keyword 'assert'";

    case 73/*TokenKind.CLASS*/:

      return "pseudo-keyword 'class'";

    case 74/*TokenKind.EXTENDS*/:

      return "pseudo-keyword 'extends'";

    case 75/*TokenKind.FACTORY*/:

      return "pseudo-keyword 'factory'";

    case 76/*TokenKind.GET*/:

      return "pseudo-keyword 'get'";

    case 77/*TokenKind.IMPLEMENTS*/:

      return "pseudo-keyword 'implements'";

    case 78/*TokenKind.IMPORT*/:

      return "pseudo-keyword 'import'";

    case 79/*TokenKind.INTERFACE*/:

      return "pseudo-keyword 'interface'";

    case 80/*TokenKind.LIBRARY*/:

      return "pseudo-keyword 'library'";

    case 81/*TokenKind.NATIVE*/:

      return "pseudo-keyword 'native'";

    case 82/*TokenKind.NEGATE*/:

      return "pseudo-keyword 'negate'";

    case 83/*TokenKind.OPERATOR*/:

      return "pseudo-keyword 'operator'";

    case 84/*TokenKind.SET*/:

      return "pseudo-keyword 'set'";

    case 85/*TokenKind.SOURCE*/:

      return "pseudo-keyword 'source'";

    case 86/*TokenKind.STATIC*/:

      return "pseudo-keyword 'static'";

    case 87/*TokenKind.TYPEDEF*/:

      return "pseudo-keyword 'typedef'";

    case 88/*TokenKind.AWAIT*/:

      return "keyword 'await'";

    case 89/*TokenKind.BREAK*/:

      return "keyword 'break'";

    case 90/*TokenKind.CASE*/:

      return "keyword 'case'";

    case 91/*TokenKind.CATCH*/:

      return "keyword 'catch'";

    case 92/*TokenKind.CONST*/:

      return "keyword 'const'";

    case 93/*TokenKind.CONTINUE*/:

      return "keyword 'continue'";

    case 94/*TokenKind.DEFAULT*/:

      return "keyword 'default'";

    case 95/*TokenKind.DO*/:

      return "keyword 'do'";

    case 96/*TokenKind.ELSE*/:

      return "keyword 'else'";

    case 97/*TokenKind.FALSE*/:

      return "keyword 'false'";

    case 98/*TokenKind.FINAL*/:

      return "keyword 'final'";

    case 99/*TokenKind.FINALLY*/:

      return "keyword 'finally'";

    case 100/*TokenKind.FOR*/:

      return "keyword 'for'";

    case 101/*TokenKind.IF*/:

      return "keyword 'if'";

    case 102/*TokenKind.IN*/:

      return "keyword 'in'";

    case 103/*TokenKind.IS*/:

      return "keyword 'is'";

    case 104/*TokenKind.NEW*/:

      return "keyword 'new'";

    case 105/*TokenKind.NULL*/:

      return "keyword 'null'";

    case 106/*TokenKind.RETURN*/:

      return "keyword 'return'";

    case 107/*TokenKind.SUPER*/:

      return "keyword 'super'";

    case 108/*TokenKind.SWITCH*/:

      return "keyword 'switch'";

    case 109/*TokenKind.THIS*/:

      return "keyword 'this'";

    case 110/*TokenKind.THROW*/:

      return "keyword 'throw'";

    case 111/*TokenKind.TRUE*/:

      return "keyword 'true'";

    case 112/*TokenKind.TRY*/:

      return "keyword 'try'";

    case 113/*TokenKind.VAR*/:

      return "keyword 'var'";

    case 114/*TokenKind.VOID*/:

      return "keyword 'void'";

    case 115/*TokenKind.WHILE*/:

      return "keyword 'while'";

    default:

      return "TokenKind(" + kind.toString() + ")";

  }
}
TokenKind.isIdentifier = function(kind) {
  return kind >= 70/*TokenKind.IDENTIFIER*/ && kind < 88/*TokenKind.AWAIT*/;
}
TokenKind.infixPrecedence = function(kind) {
  switch (kind) {
    case 20/*TokenKind.ASSIGN*/:

      return 2;

    case 21/*TokenKind.ASSIGN_OR*/:

      return 2;

    case 22/*TokenKind.ASSIGN_XOR*/:

      return 2;

    case 23/*TokenKind.ASSIGN_AND*/:

      return 2;

    case 24/*TokenKind.ASSIGN_SHL*/:

      return 2;

    case 25/*TokenKind.ASSIGN_SAR*/:

      return 2;

    case 26/*TokenKind.ASSIGN_SHR*/:

      return 2;

    case 27/*TokenKind.ASSIGN_ADD*/:

      return 2;

    case 28/*TokenKind.ASSIGN_SUB*/:

      return 2;

    case 29/*TokenKind.ASSIGN_MUL*/:

      return 2;

    case 30/*TokenKind.ASSIGN_DIV*/:

      return 2;

    case 31/*TokenKind.ASSIGN_TRUNCDIV*/:

      return 2;

    case 32/*TokenKind.ASSIGN_MOD*/:

      return 2;

    case 33/*TokenKind.CONDITIONAL*/:

      return 3;

    case 34/*TokenKind.OR*/:

      return 4;

    case 35/*TokenKind.AND*/:

      return 5;

    case 36/*TokenKind.BIT_OR*/:

      return 6;

    case 37/*TokenKind.BIT_XOR*/:

      return 7;

    case 38/*TokenKind.BIT_AND*/:

      return 8;

    case 39/*TokenKind.SHL*/:

      return 11;

    case 40/*TokenKind.SAR*/:

      return 11;

    case 41/*TokenKind.SHR*/:

      return 11;

    case 42/*TokenKind.ADD*/:

      return 12;

    case 43/*TokenKind.SUB*/:

      return 12;

    case 44/*TokenKind.MUL*/:

      return 13;

    case 45/*TokenKind.DIV*/:

      return 13;

    case 46/*TokenKind.TRUNCDIV*/:

      return 13;

    case 47/*TokenKind.MOD*/:

      return 13;

    case 48/*TokenKind.EQ*/:

      return 9;

    case 49/*TokenKind.NE*/:

      return 9;

    case 50/*TokenKind.EQ_STRICT*/:

      return 9;

    case 51/*TokenKind.NE_STRICT*/:

      return 9;

    case 52/*TokenKind.LT*/:

      return 10;

    case 53/*TokenKind.GT*/:

      return 10;

    case 54/*TokenKind.LTE*/:

      return 10;

    case 55/*TokenKind.GTE*/:

      return 10;

    case 103/*TokenKind.IS*/:

      return 10;

    default:

      return -1;

  }
}
TokenKind.rawOperatorFromMethod = function(name) {
  switch (name) {
    case ':bit_not':

      return '~';

    case ':bit_or':

      return '|';

    case ':bit_xor':

      return '^';

    case ':bit_and':

      return '&';

    case ':shl':

      return '<<';

    case ':sar':

      return '>>';

    case ':shr':

      return '>>>';

    case ':add':

      return '+';

    case ':sub':

      return '-';

    case ':mul':

      return '*';

    case ':div':

      return '/';

    case ':truncdiv':

      return '~/';

    case ':mod':

      return '%';

    case ':eq':

      return '==';

    case ':lt':

      return '<';

    case ':gt':

      return '>';

    case ':lte':

      return '<=';

    case ':gte':

      return '>=';

    case ':index':

      return '[]';

    case ':setindex':

      return '[]=';

    case ':ne':

      return '!=';

  }
}
TokenKind.binaryMethodName = function(kind) {
  switch (kind) {
    case 18/*TokenKind.BIT_NOT*/:

      return ':bit_not';

    case 36/*TokenKind.BIT_OR*/:

      return ':bit_or';

    case 37/*TokenKind.BIT_XOR*/:

      return ':bit_xor';

    case 38/*TokenKind.BIT_AND*/:

      return ':bit_and';

    case 39/*TokenKind.SHL*/:

      return ':shl';

    case 40/*TokenKind.SAR*/:

      return ':sar';

    case 41/*TokenKind.SHR*/:

      return ':shr';

    case 42/*TokenKind.ADD*/:

      return ':add';

    case 43/*TokenKind.SUB*/:

      return ':sub';

    case 44/*TokenKind.MUL*/:

      return ':mul';

    case 45/*TokenKind.DIV*/:

      return ':div';

    case 46/*TokenKind.TRUNCDIV*/:

      return ':truncdiv';

    case 47/*TokenKind.MOD*/:

      return ':mod';

    case 48/*TokenKind.EQ*/:

      return ':eq';

    case 52/*TokenKind.LT*/:

      return ':lt';

    case 53/*TokenKind.GT*/:

      return ':gt';

    case 54/*TokenKind.LTE*/:

      return ':lte';

    case 55/*TokenKind.GTE*/:

      return ':gte';

    case 56/*TokenKind.INDEX*/:

      return ':index';

    case 57/*TokenKind.SETINDEX*/:

      return ':setindex';

  }
}
TokenKind.kindFromAssign = function(kind) {
  if (kind == 20/*TokenKind.ASSIGN*/) return 0;
  if (kind > 20/*TokenKind.ASSIGN*/ && kind <= 32/*TokenKind.ASSIGN_MOD*/) {
    return kind + (15)/*(ADD - ASSIGN_ADD)*/;
  }
  return -1;
}
// ********** Code for Parser **************
function Parser(source, diet, throwOnIncomplete, optionalSemicolons, startOffset) {
  this._inhibitLambda = false
  this._afterParensIndex = 0
  this._recover = false
  this.source = source;
  this.diet = diet;
  this.throwOnIncomplete = throwOnIncomplete;
  this.optionalSemicolons = optionalSemicolons;
  // Initializers done
  this.tokenizer = new Tokenizer(this.source, true, startOffset);
  this._peekToken = this.tokenizer.next();
  this._afterParens = [];
}
Parser.prototype.get$enableAwait = function() {
  return $globals.experimentalAwaitPhase != null;
}
Parser.prototype.isPrematureEndOfFile = function() {
  if (this.throwOnIncomplete && this._maybeEat(1/*TokenKind.END_OF_FILE*/) || this._maybeEat(68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/) || this._maybeEat(69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/)) {
    $throw(new IncompleteSourceException(this._previousToken));
  }
  else if (this._maybeEat(1/*TokenKind.END_OF_FILE*/)) {
    this._error('unexpected end of file', this._peekToken.get$span());
    return true;
  }
  else {
    return false;
  }
}
Parser.prototype._recoverTo = function(kind1, kind2, kind3) {
  while (!this.isPrematureEndOfFile()) {
    var kind = this._peek();
    if (kind == kind1 || kind == kind2 || kind == kind3) {
      this._recover = false;
      return true;
    }
    this._next();
  }
  return false;
}
Parser.prototype._peek = function() {
  return this._peekToken.kind;
}
Parser.prototype._next = function() {
  this._previousToken = this._peekToken;
  this._peekToken = this.tokenizer.next();
  return this._previousToken;
}
Parser.prototype._peekKind = function(kind) {
  return this._peekToken.kind == kind;
}
Parser.prototype._peekIdentifier = function() {
  return this._isIdentifier(this._peekToken.kind);
}
Parser.prototype._isIdentifier = function(kind) {
  return TokenKind.isIdentifier(kind) || (!this.get$enableAwait() && $eq(kind, 88/*TokenKind.AWAIT*/));
}
Parser.prototype._maybeEat = function(kind) {
  if (this._peekToken.kind == kind) {
    this._previousToken = this._peekToken;
    this._peekToken = this.tokenizer.next();
    return true;
  }
  else {
    return false;
  }
}
Parser.prototype._eat = function(kind) {
  if (!this._maybeEat(kind)) {
    this._errorExpected(TokenKind.kindToString(kind));
  }
}
Parser.prototype._eatSemicolon = function() {
  if (this.optionalSemicolons && this._peekKind(1/*TokenKind.END_OF_FILE*/)) return;
  this._eat(10/*TokenKind.SEMICOLON*/);
}
Parser.prototype._errorExpected = function(expected) {
  if (this.throwOnIncomplete) this.isPrematureEndOfFile();
  var tok = this._next();
  if ((tok instanceof ErrorToken) && tok.get$message() != null) {
    this._error(tok.get$message(), tok.get$span());
  }
  else {
    this._error(('expected ' + expected + ', but found ' + tok), tok.get$span());
  }
}
Parser.prototype._error = function(message, location) {
  if (this._recover) return;
  if (location == null) {
    location = this._peekToken.get$span();
  }
  $globals.world.fatal(message, location);
  this._recover = true;
}
Parser.prototype._skipBlock = function() {
  var depth = 1;
  this._eat(6/*TokenKind.LBRACE*/);
  while (true) {
    var tok = this._next();
    if ($eq(tok.get$kind(), 6/*TokenKind.LBRACE*/)) {
      depth += 1;
    }
    else if ($eq(tok.get$kind(), 7/*TokenKind.RBRACE*/)) {
      depth -= 1;
      if (depth == 0) return;
    }
    else if ($eq(tok.get$kind(), 1/*TokenKind.END_OF_FILE*/)) {
      this._error('unexpected end of file during diet parse', tok.get$span());
      return;
    }
  }
}
Parser.prototype._makeSpan = function(start) {
  return new SourceSpan(this.source, start, this._previousToken.end);
}
Parser.prototype.compilationUnit = function() {
  var ret = [];
  this._maybeEat(13/*TokenKind.HASHBANG*/);
  while (this._peekKind(12/*TokenKind.HASH*/)) {
    ret.add$1(this.directive());
  }
  this._recover = false;
  while (!this._maybeEat(1/*TokenKind.END_OF_FILE*/)) {
    ret.add$1(this.topLevelDefinition());
  }
  this._recover = false;
  return ret;
}
Parser.prototype.directive = function() {
  var start = this._peekToken.start;
  this._eat(12/*TokenKind.HASH*/);
  var name = this.identifier();
  var args = this.arguments();
  this._eatSemicolon();
  return new DirectiveDefinition(name, args, this._makeSpan(start));
}
Parser.prototype.topLevelDefinition = function() {
  switch (this._peek()) {
    case 73/*TokenKind.CLASS*/:

      return this.classDefinition(73/*TokenKind.CLASS*/);

    case 79/*TokenKind.INTERFACE*/:

      return this.classDefinition(79/*TokenKind.INTERFACE*/);

    case 87/*TokenKind.TYPEDEF*/:

      return this.functionTypeAlias();

    default:

      return this.declaration(true);

  }
}
Parser.prototype.classDefinition = function(kind) {
  var start = this._peekToken.start;
  this._eat(kind);
  var name = this.identifier();
  var typeParams = null;
  if (this._peekKind(52/*TokenKind.LT*/)) {
    typeParams = this.typeParameters();
  }
  var _extends = null;
  if (this._maybeEat(74/*TokenKind.EXTENDS*/)) {
    _extends = this.typeList();
  }
  var _implements = null;
  if (this._maybeEat(77/*TokenKind.IMPLEMENTS*/)) {
    _implements = this.typeList();
  }
  var _native = null;
  if (this._maybeEat(81/*TokenKind.NATIVE*/)) {
    _native = this.maybeStringLiteral();
    if (_native != null) _native = new NativeType(_native);
  }
  var _factory = null;
  if (this._maybeEat(75/*TokenKind.FACTORY*/)) {
    _factory = this.nameTypeReference();
    if (this._peekKind(52/*TokenKind.LT*/)) {
      this.typeParameters();
    }
  }
  var body = [];
  if (this._maybeEat(6/*TokenKind.LBRACE*/)) {
    while (!this._maybeEat(7/*TokenKind.RBRACE*/)) {
      body.add$1(this.declaration(true));
      if (this._recover) {
        if (!this._recoverTo(7/*TokenKind.RBRACE*/, 10/*TokenKind.SEMICOLON*/)) break;
        this._maybeEat(10/*TokenKind.SEMICOLON*/);
      }
    }
  }
  else {
    this._errorExpected('block starting with "{" or ";"');
  }
  return new TypeDefinition(kind == 73/*TokenKind.CLASS*/, name, typeParams, _extends, _implements, _native, _factory, body, this._makeSpan(start));
}
Parser.prototype.functionTypeAlias = function() {
  var start = this._peekToken.start;
  this._eat(87/*TokenKind.TYPEDEF*/);
  var di = this.declaredIdentifier(false);
  var typeParams = null;
  if (this._peekKind(52/*TokenKind.LT*/)) {
    typeParams = this.typeParameters();
  }
  var formals = this.formalParameterList();
  this._eatSemicolon();
  var func = new FunctionDefinition(null, di.get$type(), di.get$name(), formals, null, null, null, null, this._makeSpan(start));
  return new FunctionTypeDefinition(func, typeParams, this._makeSpan(start));
}
Parser.prototype.initializers = function() {
  this._inhibitLambda = true;
  var ret = [];
  do {
    ret.add$1(this.expression());
  }
  while (this._maybeEat(11/*TokenKind.COMMA*/))
  this._inhibitLambda = false;
  return ret;
}
Parser.prototype.get$initializers = function() {
  return Parser.prototype.initializers.bind(this);
}
Parser.prototype.functionBody = function(inExpression) {
  var start = this._peekToken.start;
  if (this._maybeEat(9/*TokenKind.ARROW*/)) {
    var expr = this.expression();
    if (!inExpression) {
      this._eatSemicolon();
    }
    return new ReturnStatement(expr, this._makeSpan(start));
  }
  else if (this._peekKind(6/*TokenKind.LBRACE*/)) {
    if (this.diet) {
      this._skipBlock();
      return new DietStatement(this._makeSpan(start));
    }
    else {
      return this.block();
    }
  }
  else if (!inExpression) {
    if (this._maybeEat(10/*TokenKind.SEMICOLON*/)) {
      return null;
    }
  }
  this._error('Expected function body (neither { nor => found)');
}
Parser.prototype.finishField = function(start, modifiers, typeParams, type, name, value) {
  if (typeParams != null) {
    $globals.world.internalError('trying to create a generic field', this._makeSpan(start));
  }
  var names = [name];
  var values = [value];
  while (this._maybeEat(11/*TokenKind.COMMA*/)) {
    names.add$1(this.identifier());
    if (this._maybeEat(20/*TokenKind.ASSIGN*/)) {
      values.add$1(this.expression());
    }
    else {
      values.add$1();
    }
  }
  this._eatSemicolon();
  return new VariableDefinition(modifiers, type, names, values, this._makeSpan(start));
}
Parser.prototype.finishDefinition = function(start, modifiers, di, typeParams) {
  switch (this._peek()) {
    case 2/*TokenKind.LPAREN*/:

      var formals = this.formalParameterList();
      var inits = null, native_ = null;
      if (this._maybeEat(8/*TokenKind.COLON*/)) {
        inits = this.initializers();
      }
      if (this._maybeEat(81/*TokenKind.NATIVE*/)) {
        native_ = this.maybeStringLiteral();
        if (native_ == null) native_ = '';
      }
      var body = this.functionBody(false);
      if (di.get$name() == null) {
        di.set$name(di.get$type().get$name());
      }
      return new FunctionDefinition(modifiers, di.get$type(), di.get$name(), formals, typeParams, inits, native_, body, this._makeSpan(start));

    case 20/*TokenKind.ASSIGN*/:

      this._eat(20/*TokenKind.ASSIGN*/);
      var value = this.expression();
      return this.finishField(start, modifiers, typeParams, di.get$type(), di.get$name(), value);

    case 11/*TokenKind.COMMA*/:
    case 10/*TokenKind.SEMICOLON*/:

      return this.finishField(start, modifiers, typeParams, di.get$type(), di.get$name(), null);

    default:

      this._errorExpected('declaration');
      return null;

  }
}
Parser.prototype.declaration = function(includeOperators) {
  var start = this._peekToken.start;
  if (this._peekKind(75/*TokenKind.FACTORY*/)) {
    return this.factoryConstructorDeclaration();
  }
  var modifiers = this._readModifiers();
  return this.finishDefinition(start, modifiers, this.declaredIdentifier(includeOperators), null);
}
Parser.prototype.factoryConstructorDeclaration = function() {
  var start = this._peekToken.start;
  var factoryToken = this._next();
  var names = [this.identifier()];
  while (this._maybeEat(14/*TokenKind.DOT*/)) {
    names.add$1(this.identifier());
  }
  var typeParams = null;
  if (this._peekKind(52/*TokenKind.LT*/)) {
    typeParams = this.typeParameters();
  }
  var name = null;
  var type = null;
  if (this._maybeEat(14/*TokenKind.DOT*/)) {
    name = this.identifier();
  }
  else if (typeParams == null) {
    if (names.length > 1) {
      name = names.removeLast$0();
    }
    else {
      name = new Identifier('', names.$index(0).get$span());
    }
  }
  else {
    name = new Identifier('', names.$index(0).get$span());
  }
  if (names.length > 1) {
    this._error('unsupported qualified name for factory', names.$index(0).get$span());
  }
  type = new NameTypeReference(false, names.$index(0), null, names.$index(0).get$span());
  var di = new DeclaredIdentifier(type, name, this._makeSpan(start));
  return this.finishDefinition(start, [factoryToken], di, typeParams);
}
Parser.prototype.statement = function() {
  switch (this._peek()) {
    case 89/*TokenKind.BREAK*/:

      return this.breakStatement();

    case 93/*TokenKind.CONTINUE*/:

      return this.continueStatement();

    case 106/*TokenKind.RETURN*/:

      return this.returnStatement();

    case 110/*TokenKind.THROW*/:

      return this.throwStatement();

    case 72/*TokenKind.ASSERT*/:

      return this.assertStatement();

    case 115/*TokenKind.WHILE*/:

      return this.whileStatement();

    case 95/*TokenKind.DO*/:

      return this.doStatement();

    case 100/*TokenKind.FOR*/:

      return this.forStatement();

    case 101/*TokenKind.IF*/:

      return this.ifStatement();

    case 108/*TokenKind.SWITCH*/:

      return this.switchStatement();

    case 112/*TokenKind.TRY*/:

      return this.tryStatement();

    case 6/*TokenKind.LBRACE*/:

      return this.block();

    case 10/*TokenKind.SEMICOLON*/:

      return this.emptyStatement();

    case 98/*TokenKind.FINAL*/:

      return this.declaration(false);

    case 113/*TokenKind.VAR*/:

      return this.declaration(false);

    default:

      return this.finishExpressionAsStatement(this.expression());

  }
}
Parser.prototype.finishExpressionAsStatement = function(expr) {
  var start = expr.get$span().get$start();
  if (this._maybeEat(8/*TokenKind.COLON*/)) {
    var label = this._makeLabel(expr);
    return new LabeledStatement(label, this.statement(), this._makeSpan(start));
  }
  if ((expr instanceof LambdaExpression)) {
    if (!(expr.get$func().get$body() instanceof BlockStatement)) {
      this._eatSemicolon();
      expr.get$func().set$span(this._makeSpan(start));
    }
    return expr.get$func();
  }
  else if ((expr instanceof DeclaredIdentifier)) {
    var value = null;
    if (this._maybeEat(20/*TokenKind.ASSIGN*/)) {
      value = this.expression();
    }
    return this.finishField(start, null, null, expr.get$type(), expr.get$name(), value);
  }
  else if (this._isBin(expr, 20/*TokenKind.ASSIGN*/) && ((expr.get$x() instanceof DeclaredIdentifier))) {
    var di = expr.get$x();
    return this.finishField(start, null, null, di.type, di.name, expr.get$y());
  }
  else if (this._isBin(expr, 52/*TokenKind.LT*/) && this._maybeEat(11/*TokenKind.COMMA*/)) {
    var baseType = this._makeType(expr.get$x());
    var typeArgs = [this._makeType(expr.get$y())];
    var gt = this._finishTypeArguments(baseType, 0, typeArgs);
    var name = this.identifier();
    var value = null;
    if (this._maybeEat(20/*TokenKind.ASSIGN*/)) {
      value = this.expression();
    }
    return this.finishField(expr.get$span().get$start(), null, null, gt, name, value);
  }
  else {
    this._eatSemicolon();
    return new ExpressionStatement(expr, this._makeSpan(expr.get$span().get$start()));
  }
}
Parser.prototype.testCondition = function() {
  this._eatLeftParen();
  var ret = this.expression();
  this._eat(3/*TokenKind.RPAREN*/);
  return ret;
}
Parser.prototype.block = function() {
  var start = this._peekToken.start;
  this._eat(6/*TokenKind.LBRACE*/);
  var stmts = [];
  while (!this._maybeEat(7/*TokenKind.RBRACE*/)) {
    stmts.add$1(this.statement());
    if (this._recover && !this._recoverTo(7/*TokenKind.RBRACE*/, 10/*TokenKind.SEMICOLON*/)) break;
  }
  this._recover = false;
  return new BlockStatement(stmts, this._makeSpan(start));
}
Parser.prototype.emptyStatement = function() {
  var start = this._peekToken.start;
  this._eat(10/*TokenKind.SEMICOLON*/);
  return new EmptyStatement(this._makeSpan(start));
}
Parser.prototype.ifStatement = function() {
  var start = this._peekToken.start;
  this._eat(101/*TokenKind.IF*/);
  var test = this.testCondition();
  var trueBranch = this.statement();
  var falseBranch = null;
  if (this._maybeEat(96/*TokenKind.ELSE*/)) {
    falseBranch = this.statement();
  }
  return new IfStatement(test, trueBranch, falseBranch, this._makeSpan(start));
}
Parser.prototype.whileStatement = function() {
  var start = this._peekToken.start;
  this._eat(115/*TokenKind.WHILE*/);
  var test = this.testCondition();
  var body = this.statement();
  return new WhileStatement(test, body, this._makeSpan(start));
}
Parser.prototype.doStatement = function() {
  var start = this._peekToken.start;
  this._eat(95/*TokenKind.DO*/);
  var body = this.statement();
  this._eat(115/*TokenKind.WHILE*/);
  var test = this.testCondition();
  this._eatSemicolon();
  return new DoStatement(body, test, this._makeSpan(start));
}
Parser.prototype.forStatement = function() {
  var start = this._peekToken.start;
  this._eat(100/*TokenKind.FOR*/);
  this._eatLeftParen();
  var init = this.forInitializerStatement(start);
  if ((init instanceof ForInStatement)) {
    return init;
  }
  var test = null;
  if (!this._maybeEat(10/*TokenKind.SEMICOLON*/)) {
    test = this.expression();
    this._eatSemicolon();
  }
  var step = [];
  if (!this._maybeEat(3/*TokenKind.RPAREN*/)) {
    step.add$1(this.expression());
    while (this._maybeEat(11/*TokenKind.COMMA*/)) {
      step.add$1(this.expression());
    }
    this._eat(3/*TokenKind.RPAREN*/);
  }
  var body = this.statement();
  return new ForStatement(init, test, step, body, this._makeSpan(start));
}
Parser.prototype.forInitializerStatement = function(start) {
  if (this._maybeEat(10/*TokenKind.SEMICOLON*/)) {
    return null;
  }
  else {
    var init = this.expression();
    if (this._peekKind(11/*TokenKind.COMMA*/) && this._isBin(init, 52/*TokenKind.LT*/)) {
      this._eat(11/*TokenKind.COMMA*/);
      var baseType = this._makeType(init.get$x());
      var typeArgs = [this._makeType(init.get$y())];
      var gt = this._finishTypeArguments(baseType, 0, typeArgs);
      var name = this.identifier();
      init = new DeclaredIdentifier(gt, name, this._makeSpan(init.get$span().get$start()));
    }
    if (this._maybeEat(102/*TokenKind.IN*/)) {
      return this._finishForIn(start, this._makeDeclaredIdentifier(init));
    }
    else {
      return this.finishExpressionAsStatement(init);
    }
  }
}
Parser.prototype._finishForIn = function(start, di) {
  var expr = this.expression();
  this._eat(3/*TokenKind.RPAREN*/);
  var body = this.statement();
  return new ForInStatement(di, expr, body, this._makeSpan(start));
}
Parser.prototype.tryStatement = function() {
  var start = this._peekToken.start;
  this._eat(112/*TokenKind.TRY*/);
  var body = this.block();
  var catches = [];
  while (this._peekKind(91/*TokenKind.CATCH*/)) {
    catches.add$1(this.catchNode());
  }
  var finallyBlock = null;
  if (this._maybeEat(99/*TokenKind.FINALLY*/)) {
    finallyBlock = this.block();
  }
  return new TryStatement(body, catches, finallyBlock, this._makeSpan(start));
}
Parser.prototype.catchNode = function() {
  var start = this._peekToken.start;
  this._eat(91/*TokenKind.CATCH*/);
  this._eatLeftParen();
  var exc = this.declaredIdentifier(false);
  var trace = null;
  if (this._maybeEat(11/*TokenKind.COMMA*/)) {
    trace = this.declaredIdentifier(false);
  }
  this._eat(3/*TokenKind.RPAREN*/);
  var body = this.block();
  return new CatchNode(exc, trace, body, this._makeSpan(start));
}
Parser.prototype.switchStatement = function() {
  var start = this._peekToken.start;
  this._eat(108/*TokenKind.SWITCH*/);
  var test = this.testCondition();
  var cases = [];
  this._eat(6/*TokenKind.LBRACE*/);
  while (!this._maybeEat(7/*TokenKind.RBRACE*/)) {
    cases.add$1(this.caseNode());
  }
  return new SwitchStatement(test, cases, this._makeSpan(start));
}
Parser.prototype._peekCaseEnd = function() {
  var kind = this._peek();
  return $eq(kind, 7/*TokenKind.RBRACE*/) || $eq(kind, 90/*TokenKind.CASE*/) || $eq(kind, 94/*TokenKind.DEFAULT*/);
}
Parser.prototype.caseNode = function() {
  var start = this._peekToken.start;
  var label = null;
  if (this._peekIdentifier()) {
    label = this.identifier();
    this._eat(8/*TokenKind.COLON*/);
  }
  var cases = [];
  while (true) {
    if (this._maybeEat(90/*TokenKind.CASE*/)) {
      cases.add$1(this.expression());
      this._eat(8/*TokenKind.COLON*/);
    }
    else if (this._maybeEat(94/*TokenKind.DEFAULT*/)) {
      cases.add$1();
      this._eat(8/*TokenKind.COLON*/);
    }
    else {
      break;
    }
  }
  if ($eq(cases.length, 0)) {
    this._error('case or default');
  }
  var stmts = [];
  while (!this._peekCaseEnd()) {
    stmts.add$1(this.statement());
    if (this._recover && !this._recoverTo(7/*TokenKind.RBRACE*/, 90/*TokenKind.CASE*/, 94/*TokenKind.DEFAULT*/)) {
      break;
    }
  }
  return new CaseNode(label, cases, stmts, this._makeSpan(start));
}
Parser.prototype.returnStatement = function() {
  var start = this._peekToken.start;
  this._eat(106/*TokenKind.RETURN*/);
  var expr;
  if (this._maybeEat(10/*TokenKind.SEMICOLON*/)) {
    expr = null;
  }
  else {
    expr = this.expression();
    this._eatSemicolon();
  }
  return new ReturnStatement(expr, this._makeSpan(start));
}
Parser.prototype.throwStatement = function() {
  var start = this._peekToken.start;
  this._eat(110/*TokenKind.THROW*/);
  var expr;
  if (this._maybeEat(10/*TokenKind.SEMICOLON*/)) {
    expr = null;
  }
  else {
    expr = this.expression();
    this._eatSemicolon();
  }
  return new ThrowStatement(expr, this._makeSpan(start));
}
Parser.prototype.assertStatement = function() {
  var start = this._peekToken.start;
  this._eat(72/*TokenKind.ASSERT*/);
  this._eatLeftParen();
  var expr = this.expression();
  this._eat(3/*TokenKind.RPAREN*/);
  this._eatSemicolon();
  return new AssertStatement(expr, this._makeSpan(start));
}
Parser.prototype.breakStatement = function() {
  var start = this._peekToken.start;
  this._eat(89/*TokenKind.BREAK*/);
  var name = null;
  if (this._peekIdentifier()) {
    name = this.identifier();
  }
  this._eatSemicolon();
  return new BreakStatement(name, this._makeSpan(start));
}
Parser.prototype.continueStatement = function() {
  var start = this._peekToken.start;
  this._eat(93/*TokenKind.CONTINUE*/);
  var name = null;
  if (this._peekIdentifier()) {
    name = this.identifier();
  }
  this._eatSemicolon();
  return new ContinueStatement(name, this._makeSpan(start));
}
Parser.prototype.expression = function() {
  return this.infixExpression(0);
}
Parser.prototype._makeType = function(expr) {
  if ((expr instanceof VarExpression)) {
    return new NameTypeReference(false, expr.get$name(), null, expr.get$span());
  }
  else if ((expr instanceof DotExpression)) {
    var type = this._makeType(expr.get$self());
    if (type.get$names() == null) {
      type.set$names([expr.get$name()]);
    }
    else {
      type.get$names().add$1(expr.get$name());
    }
    type.set$span(expr.get$span());
    return type;
  }
  else {
    this._error('expected type reference');
    return null;
  }
}
Parser.prototype.infixExpression = function(precedence) {
  return this.finishInfixExpression(this.unaryExpression(), precedence);
}
Parser.prototype._finishDeclaredId = function(type) {
  var name = this.identifier();
  return this.finishPostfixExpression(new DeclaredIdentifier(type, name, this._makeSpan(type.get$span().get$start())));
}
Parser.prototype._fixAsType = function(x) {
  if (this._maybeEat(53/*TokenKind.GT*/)) {
    var base = this._makeType(x.x);
    var typeParam = this._makeType(x.y);
    var type = new GenericTypeReference(base, [typeParam], 0, this._makeSpan(x.span.start));
    return this._finishDeclaredId(type);
  }
  else {
    var base = this._makeType(x.x);
    var paramBase = this._makeType(x.y);
    var firstParam = this.addTypeArguments(paramBase, 1);
    var type;
    if (firstParam.get$depth() <= 0) {
      type = new GenericTypeReference(base, [firstParam], 0, this._makeSpan(x.span.start));
    }
    else if (this._maybeEat(11/*TokenKind.COMMA*/)) {
      type = this._finishTypeArguments(base, 0, [firstParam]);
    }
    else {
      this._eat(53/*TokenKind.GT*/);
      type = new GenericTypeReference(base, [firstParam], 0, this._makeSpan(x.span.start));
    }
    return this._finishDeclaredId(type);
  }
}
Parser.prototype.finishInfixExpression = function(x, precedence) {
  while (true) {
    var kind = this._peek();
    var prec = TokenKind.infixPrecedence(this._peek());
    if (prec >= precedence) {
      if (kind == 52/*TokenKind.LT*/ || kind == 53/*TokenKind.GT*/) {
        if (this._isBin(x, 52/*TokenKind.LT*/)) {
          return this._fixAsType(x);
        }
      }
      var op = this._next();
      if ($eq(op.get$kind(), 103/*TokenKind.IS*/)) {
        var isTrue = !this._maybeEat(19/*TokenKind.NOT*/);
        var typeRef = this.type(0);
        x = new IsExpression(isTrue, x, typeRef, this._makeSpan(x.span.start));
        continue;
      }
      var y = this.infixExpression($eq(prec, 2) ? prec : prec + 1);
      if ($eq(op.get$kind(), 33/*TokenKind.CONDITIONAL*/)) {
        this._eat(8/*TokenKind.COLON*/);
        var z = this.infixExpression(prec);
        x = new ConditionalExpression(x, y, z, this._makeSpan(x.span.start));
      }
      else {
        x = new BinaryExpression(op, x, y, this._makeSpan(x.span.start));
      }
    }
    else {
      break;
    }
  }
  return x;
}
Parser.prototype._isPrefixUnaryOperator = function(kind) {
  switch (kind) {
    case 42/*TokenKind.ADD*/:
    case 43/*TokenKind.SUB*/:
    case 19/*TokenKind.NOT*/:
    case 18/*TokenKind.BIT_NOT*/:
    case 16/*TokenKind.INCR*/:
    case 17/*TokenKind.DECR*/:

      return true;

    default:

      return false;

  }
}
Parser.prototype.unaryExpression = function() {
  var start = this._peekToken.start;
  if (this._isPrefixUnaryOperator(this._peek())) {
    var tok = this._next();
    var expr = this.unaryExpression();
    return new UnaryExpression(tok, expr, this._makeSpan(start));
  }
  else if (this.get$enableAwait() && this._maybeEat(88/*TokenKind.AWAIT*/)) {
    var expr = this.unaryExpression();
    return new AwaitExpression(expr, this._makeSpan(start));
  }
  return this.finishPostfixExpression(this.primary());
}
Parser.prototype.argument = function() {
  var start = this._peekToken.start;
  var expr;
  var label = null;
  if (this._maybeEat(15/*TokenKind.ELLIPSIS*/)) {
    label = new Identifier('...', this._makeSpan(start));
  }
  expr = this.expression();
  if (label == null && this._maybeEat(8/*TokenKind.COLON*/)) {
    label = this._makeLabel(expr);
    expr = this.expression();
  }
  return new ArgumentNode(label, expr, this._makeSpan(start));
}
Parser.prototype.arguments = function() {
  var args = [];
  this._eatLeftParen();
  var saved = this._inhibitLambda;
  this._inhibitLambda = false;
  if (!this._maybeEat(3/*TokenKind.RPAREN*/)) {
    do {
      args.add$1(this.argument());
    }
    while (this._maybeEat(11/*TokenKind.COMMA*/))
    this._eat(3/*TokenKind.RPAREN*/);
  }
  this._inhibitLambda = saved;
  return args;
}
Parser.prototype.get$arguments = function() {
  return Parser.prototype.arguments.bind(this);
}
Parser.prototype.finishPostfixExpression = function(expr) {
  switch (this._peek()) {
    case 2/*TokenKind.LPAREN*/:

      return this.finishCallOrLambdaExpression(expr);

    case 4/*TokenKind.LBRACK*/:

      this._eat(4/*TokenKind.LBRACK*/);
      var index = this.expression();
      this._eat(5/*TokenKind.RBRACK*/);
      return this.finishPostfixExpression(new IndexExpression(expr, index, this._makeSpan(expr.get$span().get$start())));

    case 14/*TokenKind.DOT*/:

      this._eat(14/*TokenKind.DOT*/);
      var name = this.identifier();
      var ret = new DotExpression(expr, name, this._makeSpan(expr.get$span().get$start()));
      return this.finishPostfixExpression(ret);

    case 16/*TokenKind.INCR*/:
    case 17/*TokenKind.DECR*/:

      var tok = this._next();
      return new PostfixExpression(expr, tok, this._makeSpan(expr.get$span().get$start()));

    case 9/*TokenKind.ARROW*/:
    case 6/*TokenKind.LBRACE*/:

      return expr;

    default:

      if (this._peekIdentifier()) {
        return this.finishPostfixExpression(new DeclaredIdentifier(this._makeType(expr), this.identifier(), this._makeSpan(expr.get$span().get$start())));
      }
      else {
        return expr;
      }

  }
}
Parser.prototype.finishCallOrLambdaExpression = function(expr) {
  if (this._atClosureParameters()) {
    var formals = this.formalParameterList();
    var body = this.functionBody(true);
    return this._makeFunction(expr, formals, body);
  }
  else {
    if ((expr instanceof DeclaredIdentifier)) {
      this._error('illegal target for call, did you mean to declare a function?', expr.get$span());
    }
    var args = this.arguments();
    return this.finishPostfixExpression(new CallExpression(expr, args, this._makeSpan(expr.get$span().get$start())));
  }
}
Parser.prototype._isBin = function(expr, kind) {
  return (expr instanceof BinaryExpression) && $eq(expr.get$op().get$kind(), kind);
}
Parser.prototype._boolTypeRef = function(span) {
  return new TypeReference(span, $globals.world.nonNullBool);
}
Parser.prototype._intTypeRef = function(span) {
  return new TypeReference(span, $globals.world.intType);
}
Parser.prototype._doubleTypeRef = function(span) {
  return new TypeReference(span, $globals.world.doubleType);
}
Parser.prototype._stringTypeRef = function(span) {
  return new TypeReference(span, $globals.world.stringType);
}
Parser.prototype.primary = function() {
  var start = this._peekToken.start;
  switch (this._peek()) {
    case 109/*TokenKind.THIS*/:

      this._eat(109/*TokenKind.THIS*/);
      return new ThisExpression(this._makeSpan(start));

    case 107/*TokenKind.SUPER*/:

      this._eat(107/*TokenKind.SUPER*/);
      return new SuperExpression(this._makeSpan(start));

    case 92/*TokenKind.CONST*/:

      this._eat(92/*TokenKind.CONST*/);
      if (this._peekKind(4/*TokenKind.LBRACK*/) || this._peekKind(56/*TokenKind.INDEX*/)) {
        return this.finishListLiteral(start, true, null);
      }
      else if (this._peekKind(6/*TokenKind.LBRACE*/)) {
        return this.finishMapLiteral(start, true, null);
      }
      else if (this._peekKind(52/*TokenKind.LT*/)) {
        return this.finishTypedLiteral(start, true);
      }
      else {
        return this.finishNewExpression(start, true);
      }

    case 104/*TokenKind.NEW*/:

      this._eat(104/*TokenKind.NEW*/);
      return this.finishNewExpression(start, false);

    case 2/*TokenKind.LPAREN*/:

      return this._parenOrLambda();

    case 4/*TokenKind.LBRACK*/:
    case 56/*TokenKind.INDEX*/:

      return this.finishListLiteral(start, false, null);

    case 6/*TokenKind.LBRACE*/:

      return this.finishMapLiteral(start, false, null);

    case 105/*TokenKind.NULL*/:

      this._eat(105/*TokenKind.NULL*/);
      return new NullExpression(this._makeSpan(start));

    case 111/*TokenKind.TRUE*/:

      this._eat(111/*TokenKind.TRUE*/);
      return new LiteralExpression(true, this._boolTypeRef(this._makeSpan(start)), 'true', this._makeSpan(start));

    case 97/*TokenKind.FALSE*/:

      this._eat(97/*TokenKind.FALSE*/);
      return new LiteralExpression(false, this._boolTypeRef(this._makeSpan(start)), 'false', this._makeSpan(start));

    case 61/*TokenKind.HEX_INTEGER*/:

      var t = this._next();
      return new LiteralExpression(Parser.parseHex(t.get$text().substring$1(2)), this._intTypeRef(this._makeSpan(start)), t.get$text(), this._makeSpan(start));

    case 60/*TokenKind.INTEGER*/:

      var t = this._next();
      return new LiteralExpression(Math.parseInt(t.get$text()), this._intTypeRef(this._makeSpan(start)), t.get$text(), this._makeSpan(start));

    case 62/*TokenKind.DOUBLE*/:

      var t = this._next();
      return new LiteralExpression(Math.parseDouble(t.get$text()), this._doubleTypeRef(this._makeSpan(start)), t.get$text(), this._makeSpan(start));

    case 58/*TokenKind.STRING*/:

      return this.stringLiteralExpr();

    case 66/*TokenKind.INCOMPLETE_STRING*/:

      return this.stringInterpolation();

    case 52/*TokenKind.LT*/:

      return this.finishTypedLiteral(start, false);

    case 114/*TokenKind.VOID*/:
    case 113/*TokenKind.VAR*/:
    case 98/*TokenKind.FINAL*/:

      return this.declaredIdentifier(false);

    default:

      if (!this._peekIdentifier()) {
        this._errorExpected('expression');
      }
      return new VarExpression(this.identifier(), this._makeSpan(start));

  }
}
Parser.prototype.stringInterpolation = function() {
  var start = this._peekToken.start;
  var lits = [];
  var startQuote = null, endQuote = null;
  while (this._peekKind(66/*TokenKind.INCOMPLETE_STRING*/)) {
    var token = this._next();
    var text = token.get$text();
    if (startQuote == null) {
      if (isMultilineString(text)) {
        endQuote = text.substring$2(0, 3);
        startQuote = endQuote + '\n';
      }
      else {
        startQuote = endQuote = text.$index(0);
      }
      text = text.substring$2(0, text.length - 1) + endQuote;
    }
    else {
      text = startQuote + text.substring$2(0, text.length - 1) + endQuote;
    }
    lits.add$1(this.makeStringLiteral(text, token.get$span()));
    if (this._maybeEat(6/*TokenKind.LBRACE*/)) {
      lits.add$1(this.expression());
      this._eat(7/*TokenKind.RBRACE*/);
    }
    else if (this._maybeEat(109/*TokenKind.THIS*/)) {
      lits.add$1(new ThisExpression(this._previousToken.get$span()));
    }
    else {
      var id = this.identifier();
      lits.add$1(new VarExpression(id, id.get$span()));
    }
  }
  var tok = this._next();
  if ($ne(tok.get$kind(), 58/*TokenKind.STRING*/)) {
    this._errorExpected('interpolated string');
  }
  var text = startQuote + tok.get$text();
  lits.add$1(this.makeStringLiteral(text, tok.get$span()));
  var span = this._makeSpan(start);
  return new LiteralExpression(lits, this._stringTypeRef(span), '\$\$\$', span);
}
Parser.prototype.makeStringLiteral = function(text, span) {
  return new LiteralExpression(text, this._stringTypeRef(span), text, span);
}
Parser.prototype.stringLiteralExpr = function() {
  var token = this._next();
  return this.makeStringLiteral(token.get$text(), token.get$span());
}
Parser.prototype.maybeStringLiteral = function() {
  var kind = this._peek();
  if ($eq(kind, 58/*TokenKind.STRING*/)) {
    return parseStringLiteral(this._next().get$text());
  }
  else if ($eq(kind, 59/*TokenKind.STRING_PART*/)) {
    this._next();
    this._errorExpected('string literal, but found interpolated string start');
  }
  else if ($eq(kind, 66/*TokenKind.INCOMPLETE_STRING*/)) {
    this._next();
    this._errorExpected('string literal, but found incomplete string');
  }
  return null;
}
Parser.prototype._parenOrLambda = function() {
  var start = this._peekToken.start;
  if (this._atClosureParameters()) {
    var formals = this.formalParameterList();
    var body = this.functionBody(true);
    var func = new FunctionDefinition(null, null, null, formals, null, null, null, body, this._makeSpan(start));
    return new LambdaExpression(func, func.get$span());
  }
  else {
    this._eatLeftParen();
    var saved = this._inhibitLambda;
    this._inhibitLambda = false;
    var expr = this.expression();
    this._eat(3/*TokenKind.RPAREN*/);
    this._inhibitLambda = saved;
    return new ParenExpression(expr, this._makeSpan(start));
  }
}
Parser.prototype._atClosureParameters = function() {
  if (this._inhibitLambda) return false;
  var after = this._peekAfterCloseParen();
  return after.kind == 9/*TokenKind.ARROW*/ || after.kind == 6/*TokenKind.LBRACE*/;
}
Parser.prototype._eatLeftParen = function() {
  this._eat(2/*TokenKind.LPAREN*/);
  this._afterParensIndex++;
}
Parser.prototype._peekAfterCloseParen = function() {
  if (this._afterParensIndex < this._afterParens.length) {
    return this._afterParens.$index(this._afterParensIndex);
  }
  this._afterParensIndex = 0;
  this._afterParens.clear();
  var tokens = [this._next()];
  this._lookaheadAfterParens(tokens);
  var after = this._peekToken;
  tokens.add$1(after);
  this.tokenizer = new DivertedTokenSource(tokens, this, this.tokenizer);
  this._next();
  return after;
}
Parser.prototype._lookaheadAfterParens = function(tokens) {
  var saved = this._afterParens.length;
  this._afterParens.add(null);
  while (true) {
    var token = this._next();
    tokens.add(token);
    var kind = token.kind;
    if (kind == 3/*TokenKind.RPAREN*/ || kind == 1/*TokenKind.END_OF_FILE*/) {
      this._afterParens.$setindex(saved, this._peekToken);
      return;
    }
    else if (kind == 2/*TokenKind.LPAREN*/) {
      this._lookaheadAfterParens(tokens);
    }
  }
}
Parser.prototype._typeAsIdentifier = function(type) {
  return type.get$name();
}
Parser.prototype._specialIdentifier = function(includeOperators) {
  var start = this._peekToken.start;
  var name;
  switch (this._peek()) {
    case 15/*TokenKind.ELLIPSIS*/:

      this._eat(15/*TokenKind.ELLIPSIS*/);
      this._error('rest no longer supported', this._previousToken.get$span());
      name = this.identifier().get$name();
      break;

    case 109/*TokenKind.THIS*/:

      this._eat(109/*TokenKind.THIS*/);
      this._eat(14/*TokenKind.DOT*/);
      name = ('this.' + this.identifier().get$name());
      break;

    case 76/*TokenKind.GET*/:

      if (!includeOperators) return null;
      this._eat(76/*TokenKind.GET*/);
      if (this._peekIdentifier()) {
        name = ('get:' + this.identifier().get$name());
      }
      else {
        name = 'get';
      }
      break;

    case 84/*TokenKind.SET*/:

      if (!includeOperators) return null;
      this._eat(84/*TokenKind.SET*/);
      if (this._peekIdentifier()) {
        name = ('set:' + this.identifier().get$name());
      }
      else {
        name = 'set';
      }
      break;

    case 83/*TokenKind.OPERATOR*/:

      if (!includeOperators) return null;
      this._eat(83/*TokenKind.OPERATOR*/);
      var kind = this._peek();
      if ($eq(kind, 82/*TokenKind.NEGATE*/)) {
        name = ':negate';
        this._next();
      }
      else {
        name = TokenKind.binaryMethodName(kind);
        if (name == null) {
          name = 'operator';
        }
        else {
          this._next();
        }
      }
      break;

    default:

      return null;

  }
  return new Identifier(name, this._makeSpan(start));
}
Parser.prototype.declaredIdentifier = function(includeOperators) {
  var start = this._peekToken.start;
  var myType = null;
  var name = this._specialIdentifier(includeOperators);
  if (name == null) {
    myType = this.type(0);
    name = this._specialIdentifier(includeOperators);
    if (name == null) {
      if (this._peekIdentifier()) {
        name = this.identifier();
      }
      else if ((myType instanceof NameTypeReference) && myType.get$names() == null) {
        name = this._typeAsIdentifier(myType);
        myType = null;
      }
      else {
      }
    }
  }
  return new DeclaredIdentifier(myType, name, this._makeSpan(start));
}
Parser._hexDigit = function(c) {
  if (c >= 48 && c <= 57) {
    return c - 48;
  }
  else if (c >= 97 && c <= 102) {
    return c - 87;
  }
  else if (c >= 65 && c <= 70) {
    return c - 55;
  }
  else {
    return -1;
  }
}
Parser.parseHex = function(hex) {
  var result = 0;
  for (var i = 0;
   i < hex.length; i++) {
    var digit = Parser._hexDigit(hex.charCodeAt(i));
    result = (result * 16) + digit;
  }
  return result;
}
Parser.prototype.finishNewExpression = function(start, isConst) {
  var type = this.type(0);
  var name = null;
  if (this._maybeEat(14/*TokenKind.DOT*/)) {
    name = this.identifier();
  }
  var args = this.arguments();
  return new NewExpression(isConst, type, name, args, this._makeSpan(start));
}
Parser.prototype.finishListLiteral = function(start, isConst, type) {
  if (this._maybeEat(56/*TokenKind.INDEX*/)) {
    return new ListExpression(isConst, type, [], this._makeSpan(start));
  }
  var values = [];
  this._eat(4/*TokenKind.LBRACK*/);
  while (!this._maybeEat(5/*TokenKind.RBRACK*/)) {
    values.add$1(this.expression());
    if (this._recover && !this._recoverTo(5/*TokenKind.RBRACK*/, 11/*TokenKind.COMMA*/)) break;
    if (!this._maybeEat(11/*TokenKind.COMMA*/)) {
      this._eat(5/*TokenKind.RBRACK*/);
      break;
    }
  }
  return new ListExpression(isConst, type, values, this._makeSpan(start));
}
Parser.prototype.finishMapLiteral = function(start, isConst, type) {
  var items = [];
  this._eat(6/*TokenKind.LBRACE*/);
  while (!this._maybeEat(7/*TokenKind.RBRACE*/)) {
    items.add$1(this.expression());
    this._eat(8/*TokenKind.COLON*/);
    items.add$1(this.expression());
    if (this._recover && !this._recoverTo(7/*TokenKind.RBRACE*/, 11/*TokenKind.COMMA*/)) break;
    if (!this._maybeEat(11/*TokenKind.COMMA*/)) {
      this._eat(7/*TokenKind.RBRACE*/);
      break;
    }
  }
  return new MapExpression(isConst, type, items, this._makeSpan(start));
}
Parser.prototype.finishTypedLiteral = function(start, isConst) {
  var span = this._makeSpan(start);
  var typeToBeNamedLater = new NameTypeReference(false, null, null, span);
  var genericType = this.addTypeArguments(typeToBeNamedLater, 0);
  if (this._peekKind(4/*TokenKind.LBRACK*/) || this._peekKind(56/*TokenKind.INDEX*/)) {
    genericType.set$baseType(new TypeReference(span, $globals.world.listType));
    return this.finishListLiteral(start, isConst, genericType);
  }
  else if (this._peekKind(6/*TokenKind.LBRACE*/)) {
    genericType.set$baseType(new TypeReference(span, $globals.world.mapType));
    if ($eq(genericType.get$typeArguments().length, 1)) {
      genericType.set$typeArguments([new TypeReference(span, $globals.world.stringType), genericType.get$typeArguments().$index(0)]);
    }
    else if ($eq(genericType.get$typeArguments().length, 2)) {
      var keyType = genericType.get$typeArguments().$index(0);
      if (!(keyType instanceof NameTypeReference) || $ne(keyType.get$name().get$name(), "String")) {
        $globals.world.error('the key type of a map literal is implicitly "String"', keyType.get$span());
      }
      else {
        $globals.world.warning('a map literal takes one type argument specifying the value type', keyType.get$span());
      }
    }
    return this.finishMapLiteral(start, isConst, genericType);
  }
  else {
    this._errorExpected('array or map literal');
  }
}
Parser.prototype._readModifiers = function() {
  var modifiers = null;
  while (true) {
    switch (this._peek()) {
      case 86/*TokenKind.STATIC*/:
      case 98/*TokenKind.FINAL*/:
      case 92/*TokenKind.CONST*/:
      case 71/*TokenKind.ABSTRACT*/:
      case 75/*TokenKind.FACTORY*/:

        if (modifiers == null) modifiers = [];
        modifiers.add$1(this._next());
        break;

      default:

        return modifiers;

    }
  }
  return null;
}
Parser.prototype.typeParameter = function() {
  var start = this._peekToken.start;
  var name = this.identifier();
  var myType = null;
  if (this._maybeEat(74/*TokenKind.EXTENDS*/)) {
    myType = this.type(1);
  }
  var tp = new TypeParameter(name, myType, this._makeSpan(start));
  return new ParameterType(name.get$name(), tp);
}
Parser.prototype.get$typeParameter = function() {
  return Parser.prototype.typeParameter.bind(this);
}
Parser.prototype.typeParameters = function() {
  this._eat(52/*TokenKind.LT*/);
  var closed = false;
  var ret = [];
  do {
    var tp = this.typeParameter();
    ret.add$1(tp);
    if ((tp.get$typeParameter().get$extendsType() instanceof GenericTypeReference) && $eq(tp.get$typeParameter().get$extendsType().get$depth(), 0)) {
      closed = true;
      break;
    }
  }
  while (this._maybeEat(11/*TokenKind.COMMA*/))
  if (!closed) {
    this._eat(53/*TokenKind.GT*/);
  }
  return ret;
}
Parser.prototype.get$typeParameters = function() {
  return Parser.prototype.typeParameters.bind(this);
}
Parser.prototype._eatClosingAngle = function(depth) {
  if (this._maybeEat(53/*TokenKind.GT*/)) {
    return depth;
  }
  else if (depth > 0 && this._maybeEat(40/*TokenKind.SAR*/)) {
    return depth - 1;
  }
  else if (depth > 1 && this._maybeEat(41/*TokenKind.SHR*/)) {
    return depth - 2;
  }
  else {
    this._errorExpected('>');
    return depth;
  }
}
Parser.prototype.addTypeArguments = function(baseType, depth) {
  this._eat(52/*TokenKind.LT*/);
  return this._finishTypeArguments(baseType, depth, []);
}
Parser.prototype._finishTypeArguments = function(baseType, depth, types) {
  var delta = -1;
  do {
    var myType = this.type(depth + 1);
    types.add$1(myType);
    if ((myType instanceof GenericTypeReference) && myType.get$depth() <= depth) {
      delta = depth - myType.get$depth();
      break;
    }
  }
  while (this._maybeEat(11/*TokenKind.COMMA*/))
  if (delta >= 0) {
    depth = depth - delta;
  }
  else {
    depth = this._eatClosingAngle(depth);
  }
  var span = this._makeSpan(baseType.span.start);
  return new GenericTypeReference(baseType, types, depth, span);
}
Parser.prototype.typeList = function() {
  var types = [];
  do {
    types.add$1(this.type(0));
  }
  while (this._maybeEat(11/*TokenKind.COMMA*/))
  return types;
}
Parser.prototype.nameTypeReference = function() {
  var start = this._peekToken.start;
  var name;
  var names = null;
  var typeArgs = null;
  var isFinal = false;
  switch (this._peek()) {
    case 114/*TokenKind.VOID*/:

      return new TypeReference(this._next().get$span(), $globals.world.voidType);

    case 113/*TokenKind.VAR*/:

      return new TypeReference(this._next().get$span(), $globals.world.varType);

    case 98/*TokenKind.FINAL*/:

      this._eat(98/*TokenKind.FINAL*/);
      isFinal = true;
      name = this.identifier();
      break;

    default:

      name = this.identifier();
      break;

  }
  while (this._maybeEat(14/*TokenKind.DOT*/)) {
    if (names == null) names = [];
    names.add$1(this.identifier());
  }
  return new NameTypeReference(isFinal, name, names, this._makeSpan(start));
}
Parser.prototype.type = function(depth) {
  var typeRef = this.nameTypeReference();
  if (this._peekKind(52/*TokenKind.LT*/)) {
    return this.addTypeArguments(typeRef, depth);
  }
  else {
    return typeRef;
  }
}
Parser.prototype.get$type = function() {
  return Parser.prototype.type.bind(this);
}
Parser.prototype.formalParameter = function(inOptionalBlock) {
  var start = this._peekToken.start;
  var isThis = false;
  var isRest = false;
  var di = this.declaredIdentifier(false);
  var type = di.get$type();
  var name = di.get$name();
  var value = null;
  if (this._maybeEat(20/*TokenKind.ASSIGN*/)) {
    if (!inOptionalBlock) {
      this._error('default values only allowed inside [optional] section');
    }
    value = this.expression();
  }
  else if (this._peekKind(2/*TokenKind.LPAREN*/)) {
    var formals = this.formalParameterList();
    var func = new FunctionDefinition(null, type, name, formals, null, null, null, null, this._makeSpan(start));
    type = new FunctionTypeReference(false, func, func.get$span());
  }
  if (inOptionalBlock && value == null) {
    value = new NullExpression(this._makeSpan(start));
  }
  return new FormalNode(isThis, isRest, type, name, value, this._makeSpan(start));
}
Parser.prototype.formalParameterList = function() {
  this._eatLeftParen();
  var formals = [];
  var inOptionalBlock = false;
  if (!this._maybeEat(3/*TokenKind.RPAREN*/)) {
    if (this._maybeEat(4/*TokenKind.LBRACK*/)) {
      inOptionalBlock = true;
    }
    formals.add$1(this.formalParameter(inOptionalBlock));
    while (this._maybeEat(11/*TokenKind.COMMA*/)) {
      if (this._maybeEat(4/*TokenKind.LBRACK*/)) {
        if (inOptionalBlock) {
          this._error('already inside an optional block', this._previousToken.get$span());
        }
        inOptionalBlock = true;
      }
      formals.add$1(this.formalParameter(inOptionalBlock));
    }
    if (inOptionalBlock) {
      this._eat(5/*TokenKind.RBRACK*/);
    }
    this._eat(3/*TokenKind.RPAREN*/);
  }
  return formals;
}
Parser.prototype.identifier = function() {
  var tok = this._next();
  if (!this._isIdentifier(tok.get$kind())) {
    this._error(('expected identifier, but found ' + tok), tok.get$span());
  }
  return new Identifier(tok.get$text(), this._makeSpan(tok.get$start()));
}
Parser.prototype._makeFunction = function(expr, formals, body) {
  var name, type;
  if ((expr instanceof VarExpression)) {
    name = expr.get$name();
    type = null;
  }
  else if ((expr instanceof DeclaredIdentifier)) {
    name = expr.get$name();
    type = expr.get$type();
  }
  else {
    this._error('bad function body', expr.get$span());
  }
  var span = new SourceSpan(expr.get$span().get$file(), expr.get$span().get$start(), body.get$span().get$end());
  var func = new FunctionDefinition(null, type, name, formals, null, null, null, body, span);
  return new LambdaExpression(func, func.get$span());
}
Parser.prototype._makeDeclaredIdentifier = function(e) {
  if ((e instanceof VarExpression)) {
    return new DeclaredIdentifier(null, e.get$name(), e.get$span());
  }
  else if ((e instanceof DeclaredIdentifier)) {
    return e;
  }
  else {
    this._error('expected declared identifier');
    return new DeclaredIdentifier(null, null, e.get$span());
  }
}
Parser.prototype._makeLabel = function(expr) {
  if ((expr instanceof VarExpression)) {
    return expr.get$name();
  }
  else {
    this._errorExpected('label');
    return null;
  }
}
Parser.prototype.block$0 = Parser.prototype.block;
// ********** Code for IncompleteSourceException **************
function IncompleteSourceException(token) {
  this.token = token;
  // Initializers done
}
IncompleteSourceException.prototype.toString = function() {
  if (this.token.get$span() == null) return ('Unexpected ' + this.token);
  return this.token.get$span().toMessageString(('Unexpected ' + this.token));
}
IncompleteSourceException.prototype.toString$0 = IncompleteSourceException.prototype.toString;
// ********** Code for DivertedTokenSource **************
function DivertedTokenSource(tokens, parser, previousTokenizer) {
  this._pos = 0
  this.tokens = tokens;
  this.parser = parser;
  this.previousTokenizer = previousTokenizer;
  // Initializers done
}
DivertedTokenSource.prototype.next = function() {
  var token = this.tokens.$index(this._pos);
  ++this._pos;
  if (this._pos == this.tokens.length) {
    this.parser.tokenizer = this.previousTokenizer;
  }
  return token;
}
DivertedTokenSource.prototype.next$0 = DivertedTokenSource.prototype.next;
// ********** Code for Node **************
function Node(span) {
  this.span = span;
  // Initializers done
}
Node.prototype.get$span = function() { return this.span; };
Node.prototype.set$span = function(value) { return this.span = value; };
Node.prototype.visit$1 = Node.prototype.visit;
// ********** Code for Definition **************
function Definition(span) {
  // Initializers done
  Statement.call(this, span);
}
$inherits(Definition, Statement);
Definition.prototype.get$typeParameters = function() {
  return null;
}
Definition.prototype.get$nativeType = function() {
  return null;
}
// ********** Code for Statement **************
function Statement(span) {
  // Initializers done
  Node.call(this, span);
}
$inherits(Statement, Node);
// ********** Code for Expression **************
function Expression(span) {
  // Initializers done
  Node.call(this, span);
}
$inherits(Expression, Node);
// ********** Code for TypeReference **************
function TypeReference(span, type) {
  this.type = type;
  // Initializers done
  Node.call(this, span);
}
$inherits(TypeReference, Node);
TypeReference.prototype.get$type = function() { return this.type; };
TypeReference.prototype.set$type = function(value) { return this.type = value; };
TypeReference.prototype.visit = function(visitor) {
  return visitor.visitTypeReference(this);
}
TypeReference.prototype.get$isFinal = function() {
  return false;
}
TypeReference.prototype.visit$1 = TypeReference.prototype.visit;
// ********** Code for DirectiveDefinition **************
function DirectiveDefinition(name, arguments, span) {
  this.name = name;
  this.arguments = arguments;
  // Initializers done
  Definition.call(this, span);
}
$inherits(DirectiveDefinition, Definition);
DirectiveDefinition.prototype.get$name = function() { return this.name; };
DirectiveDefinition.prototype.set$name = function(value) { return this.name = value; };
DirectiveDefinition.prototype.get$arguments = function() { return this.arguments; };
DirectiveDefinition.prototype.set$arguments = function(value) { return this.arguments = value; };
DirectiveDefinition.prototype.visit = function(visitor) {
  return visitor.visitDirectiveDefinition(this);
}
DirectiveDefinition.prototype.visit$1 = DirectiveDefinition.prototype.visit;
// ********** Code for TypeDefinition **************
function TypeDefinition(isClass, name, typeParameters, extendsTypes, implementsTypes, nativeType, factoryType, body, span) {
  this.isClass = isClass;
  this.name = name;
  this.typeParameters = typeParameters;
  this.extendsTypes = extendsTypes;
  this.implementsTypes = implementsTypes;
  this.nativeType = nativeType;
  this.factoryType = factoryType;
  this.body = body;
  // Initializers done
  Definition.call(this, span);
}
$inherits(TypeDefinition, Definition);
TypeDefinition.prototype.get$isClass = function() { return this.isClass; };
TypeDefinition.prototype.set$isClass = function(value) { return this.isClass = value; };
TypeDefinition.prototype.get$name = function() { return this.name; };
TypeDefinition.prototype.set$name = function(value) { return this.name = value; };
TypeDefinition.prototype.get$typeParameters = function() { return this.typeParameters; };
TypeDefinition.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
TypeDefinition.prototype.get$nativeType = function() { return this.nativeType; };
TypeDefinition.prototype.set$nativeType = function(value) { return this.nativeType = value; };
TypeDefinition.prototype.get$body = function() { return this.body; };
TypeDefinition.prototype.set$body = function(value) { return this.body = value; };
TypeDefinition.prototype.visit = function(visitor) {
  return visitor.visitTypeDefinition(this);
}
TypeDefinition.prototype.visit$1 = TypeDefinition.prototype.visit;
// ********** Code for FunctionTypeDefinition **************
function FunctionTypeDefinition(func, typeParameters, span) {
  this.func = func;
  this.typeParameters = typeParameters;
  // Initializers done
  Definition.call(this, span);
}
$inherits(FunctionTypeDefinition, Definition);
FunctionTypeDefinition.prototype.get$func = function() { return this.func; };
FunctionTypeDefinition.prototype.set$func = function(value) { return this.func = value; };
FunctionTypeDefinition.prototype.get$typeParameters = function() { return this.typeParameters; };
FunctionTypeDefinition.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
FunctionTypeDefinition.prototype.visit = function(visitor) {
  return visitor.visitFunctionTypeDefinition(this);
}
FunctionTypeDefinition.prototype.visit$1 = FunctionTypeDefinition.prototype.visit;
// ********** Code for VariableDefinition **************
function VariableDefinition(modifiers, type, names, values, span) {
  this.modifiers = modifiers;
  this.type = type;
  this.names = names;
  this.values = values;
  // Initializers done
  Definition.call(this, span);
}
$inherits(VariableDefinition, Definition);
VariableDefinition.prototype.get$type = function() { return this.type; };
VariableDefinition.prototype.set$type = function(value) { return this.type = value; };
VariableDefinition.prototype.get$names = function() { return this.names; };
VariableDefinition.prototype.set$names = function(value) { return this.names = value; };
VariableDefinition.prototype.get$values = function() { return this.values; };
VariableDefinition.prototype.set$values = function(value) { return this.values = value; };
VariableDefinition.prototype.visit = function(visitor) {
  return visitor.visitVariableDefinition(this);
}
VariableDefinition.prototype.visit$1 = VariableDefinition.prototype.visit;
// ********** Code for FunctionDefinition **************
function FunctionDefinition(modifiers, returnType, name, formals, typeParameters, initializers, nativeBody, body, span) {
  this.modifiers = modifiers;
  this.returnType = returnType;
  this.name = name;
  this.formals = formals;
  this.typeParameters = typeParameters;
  this.initializers = initializers;
  this.nativeBody = nativeBody;
  this.body = body;
  // Initializers done
  Definition.call(this, span);
}
$inherits(FunctionDefinition, Definition);
FunctionDefinition.prototype.get$returnType = function() { return this.returnType; };
FunctionDefinition.prototype.set$returnType = function(value) { return this.returnType = value; };
FunctionDefinition.prototype.get$name = function() { return this.name; };
FunctionDefinition.prototype.set$name = function(value) { return this.name = value; };
FunctionDefinition.prototype.get$typeParameters = function() { return this.typeParameters; };
FunctionDefinition.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
FunctionDefinition.prototype.get$initializers = function() { return this.initializers; };
FunctionDefinition.prototype.set$initializers = function(value) { return this.initializers = value; };
FunctionDefinition.prototype.get$nativeBody = function() { return this.nativeBody; };
FunctionDefinition.prototype.set$nativeBody = function(value) { return this.nativeBody = value; };
FunctionDefinition.prototype.get$body = function() { return this.body; };
FunctionDefinition.prototype.set$body = function(value) { return this.body = value; };
FunctionDefinition.prototype.visit = function(visitor) {
  return visitor.visitFunctionDefinition(this);
}
FunctionDefinition.prototype.visit$1 = FunctionDefinition.prototype.visit;
// ********** Code for ReturnStatement **************
function ReturnStatement(value, span) {
  this.value = value;
  // Initializers done
  Statement.call(this, span);
}
$inherits(ReturnStatement, Statement);
ReturnStatement.prototype.get$value = function() { return this.value; };
ReturnStatement.prototype.set$value = function(value) { return this.value = value; };
ReturnStatement.prototype.visit = function(visitor) {
  return visitor.visitReturnStatement(this);
}
ReturnStatement.prototype.visit$1 = ReturnStatement.prototype.visit;
// ********** Code for ThrowStatement **************
function ThrowStatement(value, span) {
  this.value = value;
  // Initializers done
  Statement.call(this, span);
}
$inherits(ThrowStatement, Statement);
ThrowStatement.prototype.get$value = function() { return this.value; };
ThrowStatement.prototype.set$value = function(value) { return this.value = value; };
ThrowStatement.prototype.visit = function(visitor) {
  return visitor.visitThrowStatement(this);
}
ThrowStatement.prototype.visit$1 = ThrowStatement.prototype.visit;
// ********** Code for AssertStatement **************
function AssertStatement(test, span) {
  this.test = test;
  // Initializers done
  Statement.call(this, span);
}
$inherits(AssertStatement, Statement);
AssertStatement.prototype.visit = function(visitor) {
  return visitor.visitAssertStatement(this);
}
AssertStatement.prototype.visit$1 = AssertStatement.prototype.visit;
// ********** Code for BreakStatement **************
function BreakStatement(label, span) {
  this.label = label;
  // Initializers done
  Statement.call(this, span);
}
$inherits(BreakStatement, Statement);
BreakStatement.prototype.get$label = function() { return this.label; };
BreakStatement.prototype.set$label = function(value) { return this.label = value; };
BreakStatement.prototype.visit = function(visitor) {
  return visitor.visitBreakStatement(this);
}
BreakStatement.prototype.visit$1 = BreakStatement.prototype.visit;
// ********** Code for ContinueStatement **************
function ContinueStatement(label, span) {
  this.label = label;
  // Initializers done
  Statement.call(this, span);
}
$inherits(ContinueStatement, Statement);
ContinueStatement.prototype.get$label = function() { return this.label; };
ContinueStatement.prototype.set$label = function(value) { return this.label = value; };
ContinueStatement.prototype.visit = function(visitor) {
  return visitor.visitContinueStatement(this);
}
ContinueStatement.prototype.visit$1 = ContinueStatement.prototype.visit;
// ********** Code for IfStatement **************
function IfStatement(test, trueBranch, falseBranch, span) {
  this.test = test;
  this.trueBranch = trueBranch;
  this.falseBranch = falseBranch;
  // Initializers done
  Statement.call(this, span);
}
$inherits(IfStatement, Statement);
IfStatement.prototype.visit = function(visitor) {
  return visitor.visitIfStatement(this);
}
IfStatement.prototype.visit$1 = IfStatement.prototype.visit;
// ********** Code for WhileStatement **************
function WhileStatement(test, body, span) {
  this.test = test;
  this.body = body;
  // Initializers done
  Statement.call(this, span);
}
$inherits(WhileStatement, Statement);
WhileStatement.prototype.get$body = function() { return this.body; };
WhileStatement.prototype.set$body = function(value) { return this.body = value; };
WhileStatement.prototype.visit = function(visitor) {
  return visitor.visitWhileStatement(this);
}
WhileStatement.prototype.visit$1 = WhileStatement.prototype.visit;
// ********** Code for DoStatement **************
function DoStatement(body, test, span) {
  this.body = body;
  this.test = test;
  // Initializers done
  Statement.call(this, span);
}
$inherits(DoStatement, Statement);
DoStatement.prototype.get$body = function() { return this.body; };
DoStatement.prototype.set$body = function(value) { return this.body = value; };
DoStatement.prototype.visit = function(visitor) {
  return visitor.visitDoStatement(this);
}
DoStatement.prototype.visit$1 = DoStatement.prototype.visit;
// ********** Code for ForStatement **************
function ForStatement(init, test, step, body, span) {
  this.init = init;
  this.test = test;
  this.step = step;
  this.body = body;
  // Initializers done
  Statement.call(this, span);
}
$inherits(ForStatement, Statement);
ForStatement.prototype.get$body = function() { return this.body; };
ForStatement.prototype.set$body = function(value) { return this.body = value; };
ForStatement.prototype.visit = function(visitor) {
  return visitor.visitForStatement(this);
}
ForStatement.prototype.visit$1 = ForStatement.prototype.visit;
// ********** Code for ForInStatement **************
function ForInStatement(item, list, body, span) {
  this.item = item;
  this.list = list;
  this.body = body;
  // Initializers done
  Statement.call(this, span);
}
$inherits(ForInStatement, Statement);
ForInStatement.prototype.get$body = function() { return this.body; };
ForInStatement.prototype.set$body = function(value) { return this.body = value; };
ForInStatement.prototype.visit = function(visitor) {
  return visitor.visitForInStatement(this);
}
ForInStatement.prototype.visit$1 = ForInStatement.prototype.visit;
// ********** Code for TryStatement **************
function TryStatement(body, catches, finallyBlock, span) {
  this.body = body;
  this.catches = catches;
  this.finallyBlock = finallyBlock;
  // Initializers done
  Statement.call(this, span);
}
$inherits(TryStatement, Statement);
TryStatement.prototype.get$body = function() { return this.body; };
TryStatement.prototype.set$body = function(value) { return this.body = value; };
TryStatement.prototype.visit = function(visitor) {
  return visitor.visitTryStatement(this);
}
TryStatement.prototype.visit$1 = TryStatement.prototype.visit;
// ********** Code for SwitchStatement **************
function SwitchStatement(test, cases, span) {
  this.test = test;
  this.cases = cases;
  // Initializers done
  Statement.call(this, span);
}
$inherits(SwitchStatement, Statement);
SwitchStatement.prototype.get$cases = function() { return this.cases; };
SwitchStatement.prototype.set$cases = function(value) { return this.cases = value; };
SwitchStatement.prototype.visit = function(visitor) {
  return visitor.visitSwitchStatement(this);
}
SwitchStatement.prototype.visit$1 = SwitchStatement.prototype.visit;
// ********** Code for BlockStatement **************
function BlockStatement(body, span) {
  this.body = body;
  // Initializers done
  Statement.call(this, span);
}
$inherits(BlockStatement, Statement);
BlockStatement.prototype.get$body = function() { return this.body; };
BlockStatement.prototype.set$body = function(value) { return this.body = value; };
BlockStatement.prototype.visit = function(visitor) {
  return visitor.visitBlockStatement(this);
}
BlockStatement.prototype.visit$1 = BlockStatement.prototype.visit;
// ********** Code for LabeledStatement **************
function LabeledStatement(name, body, span) {
  this.name = name;
  this.body = body;
  // Initializers done
  Statement.call(this, span);
}
$inherits(LabeledStatement, Statement);
LabeledStatement.prototype.get$name = function() { return this.name; };
LabeledStatement.prototype.set$name = function(value) { return this.name = value; };
LabeledStatement.prototype.get$body = function() { return this.body; };
LabeledStatement.prototype.set$body = function(value) { return this.body = value; };
LabeledStatement.prototype.visit = function(visitor) {
  return visitor.visitLabeledStatement(this);
}
LabeledStatement.prototype.visit$1 = LabeledStatement.prototype.visit;
// ********** Code for ExpressionStatement **************
function ExpressionStatement(body, span) {
  this.body = body;
  // Initializers done
  Statement.call(this, span);
}
$inherits(ExpressionStatement, Statement);
ExpressionStatement.prototype.get$body = function() { return this.body; };
ExpressionStatement.prototype.set$body = function(value) { return this.body = value; };
ExpressionStatement.prototype.visit = function(visitor) {
  return visitor.visitExpressionStatement(this);
}
ExpressionStatement.prototype.visit$1 = ExpressionStatement.prototype.visit;
// ********** Code for EmptyStatement **************
function EmptyStatement(span) {
  // Initializers done
  Statement.call(this, span);
}
$inherits(EmptyStatement, Statement);
EmptyStatement.prototype.visit = function(visitor) {
  return visitor.visitEmptyStatement(this);
}
EmptyStatement.prototype.visit$1 = EmptyStatement.prototype.visit;
// ********** Code for DietStatement **************
function DietStatement(span) {
  // Initializers done
  Statement.call(this, span);
}
$inherits(DietStatement, Statement);
DietStatement.prototype.visit = function(visitor) {
  return visitor.visitDietStatement(this);
}
DietStatement.prototype.visit$1 = DietStatement.prototype.visit;
// ********** Code for LambdaExpression **************
function LambdaExpression(func, span) {
  this.func = func;
  // Initializers done
  Expression.call(this, span);
}
$inherits(LambdaExpression, Expression);
LambdaExpression.prototype.get$func = function() { return this.func; };
LambdaExpression.prototype.set$func = function(value) { return this.func = value; };
LambdaExpression.prototype.visit = function(visitor) {
  return visitor.visitLambdaExpression(this);
}
LambdaExpression.prototype.visit$1 = LambdaExpression.prototype.visit;
// ********** Code for CallExpression **************
function CallExpression(target, arguments, span) {
  this.target = target;
  this.arguments = arguments;
  // Initializers done
  Expression.call(this, span);
}
$inherits(CallExpression, Expression);
CallExpression.prototype.get$target = function() { return this.target; };
CallExpression.prototype.set$target = function(value) { return this.target = value; };
CallExpression.prototype.get$arguments = function() { return this.arguments; };
CallExpression.prototype.set$arguments = function(value) { return this.arguments = value; };
CallExpression.prototype.visit = function(visitor) {
  return visitor.visitCallExpression(this);
}
CallExpression.prototype.visit$1 = CallExpression.prototype.visit;
// ********** Code for IndexExpression **************
function IndexExpression(target, index, span) {
  this.target = target;
  this.index = index;
  // Initializers done
  Expression.call(this, span);
}
$inherits(IndexExpression, Expression);
IndexExpression.prototype.get$target = function() { return this.target; };
IndexExpression.prototype.set$target = function(value) { return this.target = value; };
IndexExpression.prototype.visit = function(visitor) {
  return visitor.visitIndexExpression(this);
}
IndexExpression.prototype.visit$1 = IndexExpression.prototype.visit;
// ********** Code for BinaryExpression **************
function BinaryExpression(op, x, y, span) {
  this.op = op;
  this.x = x;
  this.y = y;
  // Initializers done
  Expression.call(this, span);
}
$inherits(BinaryExpression, Expression);
BinaryExpression.prototype.get$op = function() { return this.op; };
BinaryExpression.prototype.set$op = function(value) { return this.op = value; };
BinaryExpression.prototype.get$x = function() { return this.x; };
BinaryExpression.prototype.set$x = function(value) { return this.x = value; };
BinaryExpression.prototype.get$y = function() { return this.y; };
BinaryExpression.prototype.set$y = function(value) { return this.y = value; };
BinaryExpression.prototype.visit = function(visitor) {
  return visitor.visitBinaryExpression$1(this);
}
BinaryExpression.prototype.visit$1 = BinaryExpression.prototype.visit;
// ********** Code for UnaryExpression **************
function UnaryExpression(op, self, span) {
  this.op = op;
  this.self = self;
  // Initializers done
  Expression.call(this, span);
}
$inherits(UnaryExpression, Expression);
UnaryExpression.prototype.get$op = function() { return this.op; };
UnaryExpression.prototype.set$op = function(value) { return this.op = value; };
UnaryExpression.prototype.get$self = function() { return this.self; };
UnaryExpression.prototype.set$self = function(value) { return this.self = value; };
UnaryExpression.prototype.visit = function(visitor) {
  return visitor.visitUnaryExpression(this);
}
UnaryExpression.prototype.visit$1 = UnaryExpression.prototype.visit;
// ********** Code for PostfixExpression **************
function PostfixExpression(body, op, span) {
  this.body = body;
  this.op = op;
  // Initializers done
  Expression.call(this, span);
}
$inherits(PostfixExpression, Expression);
PostfixExpression.prototype.get$body = function() { return this.body; };
PostfixExpression.prototype.set$body = function(value) { return this.body = value; };
PostfixExpression.prototype.get$op = function() { return this.op; };
PostfixExpression.prototype.set$op = function(value) { return this.op = value; };
PostfixExpression.prototype.visit = function(visitor) {
  return visitor.visitPostfixExpression$1(this);
}
PostfixExpression.prototype.visit$1 = PostfixExpression.prototype.visit;
// ********** Code for NewExpression **************
function NewExpression(isConst, type, name, arguments, span) {
  this.isConst = isConst;
  this.type = type;
  this.name = name;
  this.arguments = arguments;
  // Initializers done
  Expression.call(this, span);
}
$inherits(NewExpression, Expression);
NewExpression.prototype.get$isConst = function() { return this.isConst; };
NewExpression.prototype.set$isConst = function(value) { return this.isConst = value; };
NewExpression.prototype.get$type = function() { return this.type; };
NewExpression.prototype.set$type = function(value) { return this.type = value; };
NewExpression.prototype.get$name = function() { return this.name; };
NewExpression.prototype.set$name = function(value) { return this.name = value; };
NewExpression.prototype.get$arguments = function() { return this.arguments; };
NewExpression.prototype.set$arguments = function(value) { return this.arguments = value; };
NewExpression.prototype.visit = function(visitor) {
  return visitor.visitNewExpression(this);
}
NewExpression.prototype.visit$1 = NewExpression.prototype.visit;
// ********** Code for ListExpression **************
function ListExpression(isConst, type, values, span) {
  this.isConst = isConst;
  this.type = type;
  this.values = values;
  // Initializers done
  Expression.call(this, span);
}
$inherits(ListExpression, Expression);
ListExpression.prototype.get$isConst = function() { return this.isConst; };
ListExpression.prototype.set$isConst = function(value) { return this.isConst = value; };
ListExpression.prototype.get$type = function() { return this.type; };
ListExpression.prototype.set$type = function(value) { return this.type = value; };
ListExpression.prototype.get$values = function() { return this.values; };
ListExpression.prototype.set$values = function(value) { return this.values = value; };
ListExpression.prototype.visit = function(visitor) {
  return visitor.visitListExpression(this);
}
ListExpression.prototype.visit$1 = ListExpression.prototype.visit;
// ********** Code for MapExpression **************
function MapExpression(isConst, type, items, span) {
  this.isConst = isConst;
  this.type = type;
  this.items = items;
  // Initializers done
  Expression.call(this, span);
}
$inherits(MapExpression, Expression);
MapExpression.prototype.get$isConst = function() { return this.isConst; };
MapExpression.prototype.set$isConst = function(value) { return this.isConst = value; };
MapExpression.prototype.get$type = function() { return this.type; };
MapExpression.prototype.set$type = function(value) { return this.type = value; };
MapExpression.prototype.visit = function(visitor) {
  return visitor.visitMapExpression(this);
}
MapExpression.prototype.visit$1 = MapExpression.prototype.visit;
// ********** Code for ConditionalExpression **************
function ConditionalExpression(test, trueBranch, falseBranch, span) {
  this.test = test;
  this.trueBranch = trueBranch;
  this.falseBranch = falseBranch;
  // Initializers done
  Expression.call(this, span);
}
$inherits(ConditionalExpression, Expression);
ConditionalExpression.prototype.visit = function(visitor) {
  return visitor.visitConditionalExpression(this);
}
ConditionalExpression.prototype.visit$1 = ConditionalExpression.prototype.visit;
// ********** Code for IsExpression **************
function IsExpression(isTrue, x, type, span) {
  this.isTrue = isTrue;
  this.x = x;
  this.type = type;
  // Initializers done
  Expression.call(this, span);
}
$inherits(IsExpression, Expression);
IsExpression.prototype.get$x = function() { return this.x; };
IsExpression.prototype.set$x = function(value) { return this.x = value; };
IsExpression.prototype.get$type = function() { return this.type; };
IsExpression.prototype.set$type = function(value) { return this.type = value; };
IsExpression.prototype.visit = function(visitor) {
  return visitor.visitIsExpression(this);
}
IsExpression.prototype.visit$1 = IsExpression.prototype.visit;
// ********** Code for ParenExpression **************
function ParenExpression(body, span) {
  this.body = body;
  // Initializers done
  Expression.call(this, span);
}
$inherits(ParenExpression, Expression);
ParenExpression.prototype.get$body = function() { return this.body; };
ParenExpression.prototype.set$body = function(value) { return this.body = value; };
ParenExpression.prototype.visit = function(visitor) {
  return visitor.visitParenExpression(this);
}
ParenExpression.prototype.visit$1 = ParenExpression.prototype.visit;
// ********** Code for AwaitExpression **************
function AwaitExpression(body, span) {
  this.body = body;
  // Initializers done
  Expression.call(this, span);
}
$inherits(AwaitExpression, Expression);
AwaitExpression.prototype.get$body = function() { return this.body; };
AwaitExpression.prototype.set$body = function(value) { return this.body = value; };
AwaitExpression.prototype.visit = function(visitor) {
  return visitor.visitAwaitExpression(this);
}
AwaitExpression.prototype.visit$1 = AwaitExpression.prototype.visit;
// ********** Code for DotExpression **************
function DotExpression(self, name, span) {
  this.self = self;
  this.name = name;
  // Initializers done
  Expression.call(this, span);
}
$inherits(DotExpression, Expression);
DotExpression.prototype.get$self = function() { return this.self; };
DotExpression.prototype.set$self = function(value) { return this.self = value; };
DotExpression.prototype.get$name = function() { return this.name; };
DotExpression.prototype.set$name = function(value) { return this.name = value; };
DotExpression.prototype.visit = function(visitor) {
  return visitor.visitDotExpression(this);
}
DotExpression.prototype.visit$1 = DotExpression.prototype.visit;
// ********** Code for VarExpression **************
function VarExpression(name, span) {
  this.name = name;
  // Initializers done
  Expression.call(this, span);
}
$inherits(VarExpression, Expression);
VarExpression.prototype.get$name = function() { return this.name; };
VarExpression.prototype.set$name = function(value) { return this.name = value; };
VarExpression.prototype.visit = function(visitor) {
  return visitor.visitVarExpression(this);
}
VarExpression.prototype.visit$1 = VarExpression.prototype.visit;
// ********** Code for ThisExpression **************
function ThisExpression(span) {
  // Initializers done
  Expression.call(this, span);
}
$inherits(ThisExpression, Expression);
ThisExpression.prototype.visit = function(visitor) {
  return visitor.visitThisExpression(this);
}
ThisExpression.prototype.visit$1 = ThisExpression.prototype.visit;
// ********** Code for SuperExpression **************
function SuperExpression(span) {
  // Initializers done
  Expression.call(this, span);
}
$inherits(SuperExpression, Expression);
SuperExpression.prototype.visit = function(visitor) {
  return visitor.visitSuperExpression(this);
}
SuperExpression.prototype.visit$1 = SuperExpression.prototype.visit;
// ********** Code for NullExpression **************
function NullExpression(span) {
  // Initializers done
  Expression.call(this, span);
}
$inherits(NullExpression, Expression);
NullExpression.prototype.visit = function(visitor) {
  return visitor.visitNullExpression(this);
}
NullExpression.prototype.visit$1 = NullExpression.prototype.visit;
// ********** Code for LiteralExpression **************
function LiteralExpression(value, type, text, span) {
  this.value = value;
  this.type = type;
  this.text = text;
  // Initializers done
  Expression.call(this, span);
}
$inherits(LiteralExpression, Expression);
LiteralExpression.prototype.get$value = function() { return this.value; };
LiteralExpression.prototype.set$value = function(value) { return this.value = value; };
LiteralExpression.prototype.get$type = function() { return this.type; };
LiteralExpression.prototype.set$type = function(value) { return this.type = value; };
LiteralExpression.prototype.get$text = function() { return this.text; };
LiteralExpression.prototype.set$text = function(value) { return this.text = value; };
LiteralExpression.prototype.visit = function(visitor) {
  return visitor.visitLiteralExpression(this);
}
LiteralExpression.prototype.visit$1 = LiteralExpression.prototype.visit;
// ********** Code for NameTypeReference **************
function NameTypeReference(isFinal, name, names, span) {
  this.isFinal = isFinal;
  this.name = name;
  this.names = names;
  // Initializers done
  TypeReference.call(this, span);
}
$inherits(NameTypeReference, TypeReference);
NameTypeReference.prototype.get$isFinal = function() { return this.isFinal; };
NameTypeReference.prototype.set$isFinal = function(value) { return this.isFinal = value; };
NameTypeReference.prototype.get$name = function() { return this.name; };
NameTypeReference.prototype.set$name = function(value) { return this.name = value; };
NameTypeReference.prototype.get$names = function() { return this.names; };
NameTypeReference.prototype.set$names = function(value) { return this.names = value; };
NameTypeReference.prototype.visit = function(visitor) {
  return visitor.visitNameTypeReference(this);
}
NameTypeReference.prototype.visit$1 = NameTypeReference.prototype.visit;
// ********** Code for GenericTypeReference **************
function GenericTypeReference(baseType, typeArguments, depth, span) {
  this.baseType = baseType;
  this.typeArguments = typeArguments;
  this.depth = depth;
  // Initializers done
  TypeReference.call(this, span);
}
$inherits(GenericTypeReference, TypeReference);
GenericTypeReference.prototype.get$baseType = function() { return this.baseType; };
GenericTypeReference.prototype.set$baseType = function(value) { return this.baseType = value; };
GenericTypeReference.prototype.get$typeArguments = function() { return this.typeArguments; };
GenericTypeReference.prototype.set$typeArguments = function(value) { return this.typeArguments = value; };
GenericTypeReference.prototype.get$depth = function() { return this.depth; };
GenericTypeReference.prototype.set$depth = function(value) { return this.depth = value; };
GenericTypeReference.prototype.visit = function(visitor) {
  return visitor.visitGenericTypeReference(this);
}
GenericTypeReference.prototype.visit$1 = GenericTypeReference.prototype.visit;
// ********** Code for FunctionTypeReference **************
function FunctionTypeReference(isFinal, func, span) {
  this.isFinal = isFinal;
  this.func = func;
  // Initializers done
  TypeReference.call(this, span);
}
$inherits(FunctionTypeReference, TypeReference);
FunctionTypeReference.prototype.get$isFinal = function() { return this.isFinal; };
FunctionTypeReference.prototype.set$isFinal = function(value) { return this.isFinal = value; };
FunctionTypeReference.prototype.get$func = function() { return this.func; };
FunctionTypeReference.prototype.set$func = function(value) { return this.func = value; };
FunctionTypeReference.prototype.visit = function(visitor) {
  return visitor.visitFunctionTypeReference(this);
}
FunctionTypeReference.prototype.visit$1 = FunctionTypeReference.prototype.visit;
// ********** Code for ArgumentNode **************
function ArgumentNode(label, value, span) {
  this.label = label;
  this.value = value;
  // Initializers done
  Node.call(this, span);
}
$inherits(ArgumentNode, Node);
ArgumentNode.prototype.get$label = function() { return this.label; };
ArgumentNode.prototype.set$label = function(value) { return this.label = value; };
ArgumentNode.prototype.get$value = function() { return this.value; };
ArgumentNode.prototype.set$value = function(value) { return this.value = value; };
ArgumentNode.prototype.visit = function(visitor) {
  return visitor.visitArgumentNode(this);
}
ArgumentNode.prototype.visit$1 = ArgumentNode.prototype.visit;
// ********** Code for FormalNode **************
function FormalNode(isThis, isRest, type, name, value, span) {
  this.isThis = isThis;
  this.isRest = isRest;
  this.type = type;
  this.name = name;
  this.value = value;
  // Initializers done
  Node.call(this, span);
}
$inherits(FormalNode, Node);
FormalNode.prototype.get$type = function() { return this.type; };
FormalNode.prototype.set$type = function(value) { return this.type = value; };
FormalNode.prototype.get$name = function() { return this.name; };
FormalNode.prototype.set$name = function(value) { return this.name = value; };
FormalNode.prototype.get$value = function() { return this.value; };
FormalNode.prototype.set$value = function(value) { return this.value = value; };
FormalNode.prototype.visit = function(visitor) {
  return visitor.visitFormalNode(this);
}
FormalNode.prototype.visit$1 = FormalNode.prototype.visit;
// ********** Code for CatchNode **************
function CatchNode(exception, trace, body, span) {
  this.exception = exception;
  this.trace = trace;
  this.body = body;
  // Initializers done
  Node.call(this, span);
}
$inherits(CatchNode, Node);
CatchNode.prototype.get$exception = function() { return this.exception; };
CatchNode.prototype.set$exception = function(value) { return this.exception = value; };
CatchNode.prototype.get$trace = function() { return this.trace; };
CatchNode.prototype.set$trace = function(value) { return this.trace = value; };
CatchNode.prototype.get$body = function() { return this.body; };
CatchNode.prototype.set$body = function(value) { return this.body = value; };
CatchNode.prototype.visit = function(visitor) {
  return visitor.visitCatchNode(this);
}
CatchNode.prototype.visit$1 = CatchNode.prototype.visit;
// ********** Code for CaseNode **************
function CaseNode(label, cases, statements, span) {
  this.label = label;
  this.cases = cases;
  this.statements = statements;
  // Initializers done
  Node.call(this, span);
}
$inherits(CaseNode, Node);
CaseNode.prototype.get$label = function() { return this.label; };
CaseNode.prototype.set$label = function(value) { return this.label = value; };
CaseNode.prototype.get$cases = function() { return this.cases; };
CaseNode.prototype.set$cases = function(value) { return this.cases = value; };
CaseNode.prototype.get$statements = function() { return this.statements; };
CaseNode.prototype.set$statements = function(value) { return this.statements = value; };
CaseNode.prototype.visit = function(visitor) {
  return visitor.visitCaseNode(this);
}
CaseNode.prototype.visit$1 = CaseNode.prototype.visit;
// ********** Code for TypeParameter **************
function TypeParameter(name, extendsType, span) {
  this.name = name;
  this.extendsType = extendsType;
  // Initializers done
  Node.call(this, span);
}
$inherits(TypeParameter, Node);
TypeParameter.prototype.get$name = function() { return this.name; };
TypeParameter.prototype.set$name = function(value) { return this.name = value; };
TypeParameter.prototype.get$extendsType = function() { return this.extendsType; };
TypeParameter.prototype.set$extendsType = function(value) { return this.extendsType = value; };
TypeParameter.prototype.visit = function(visitor) {
  return visitor.visitTypeParameter(this);
}
TypeParameter.prototype.visit$1 = TypeParameter.prototype.visit;
// ********** Code for Identifier **************
function Identifier(name, span) {
  this.name = name;
  // Initializers done
  Node.call(this, span);
}
$inherits(Identifier, Node);
Identifier.prototype.get$name = function() { return this.name; };
Identifier.prototype.set$name = function(value) { return this.name = value; };
Identifier.prototype.visit = function(visitor) {
  return visitor.visitIdentifier(this);
}
Identifier.prototype.visit$1 = Identifier.prototype.visit;
// ********** Code for DeclaredIdentifier **************
function DeclaredIdentifier(type, name, span) {
  this.type = type;
  this.name = name;
  // Initializers done
  Expression.call(this, span);
}
$inherits(DeclaredIdentifier, Expression);
DeclaredIdentifier.prototype.get$type = function() { return this.type; };
DeclaredIdentifier.prototype.set$type = function(value) { return this.type = value; };
DeclaredIdentifier.prototype.get$name = function() { return this.name; };
DeclaredIdentifier.prototype.set$name = function(value) { return this.name = value; };
DeclaredIdentifier.prototype.visit = function(visitor) {
  return visitor.visitDeclaredIdentifier(this);
}
DeclaredIdentifier.prototype.visit$1 = DeclaredIdentifier.prototype.visit;
// ********** Code for Type **************
function Type(name) {
  this.isTested = false
  this.isChecked = false
  this._resolvedMembers = new HashMapImplementation();
  this.varStubs = new HashMapImplementation();
  // Initializers done
  Element.call(this, name, null);
}
$inherits(Type, Element);
Type.prototype.get$isTested = function() { return this.isTested; };
Type.prototype.set$isTested = function(value) { return this.isTested = value; };
Type.prototype.get$typeCheckCode = function() { return this.typeCheckCode; };
Type.prototype.set$typeCheckCode = function(value) { return this.typeCheckCode = value; };
Type.prototype.get$varStubs = function() { return this.varStubs; };
Type.prototype.set$varStubs = function(value) { return this.varStubs = value; };
Type.prototype.markUsed = function() {

}
Type.prototype.get$typeMember = function() {
  if (this._typeMember == null) {
    this._typeMember = new TypeMember(this);
  }
  return this._typeMember;
}
Type.prototype.getMember = function(name) {
  return null;
}
Type.prototype.get$subtypes = function() {
  return null;
}
Type.prototype.get$isVar = function() {
  return false;
}
Type.prototype.get$isTop = function() {
  return false;
}
Type.prototype.get$isObject = function() {
  return false;
}
Type.prototype.get$isString = function() {
  return false;
}
Type.prototype.get$isBool = function() {
  return false;
}
Type.prototype.get$isFunction = function() {
  return false;
}
Type.prototype.get$isList = function() {
  return false;
}
Type.prototype.get$isNum = function() {
  return false;
}
Type.prototype.get$isVoid = function() {
  return false;
}
Type.prototype.get$isNullable = function() {
  return true;
}
Type.prototype.get$isVarOrFunction = function() {
  return this.get$isVar() || this.get$isFunction();
}
Type.prototype.get$isVarOrObject = function() {
  return this.get$isVar() || this.get$isObject();
}
Type.prototype.getCallMethod = function() {
  return null;
}
Type.prototype.get$isClosed = function() {
  return this.get$isString() || this.get$isBool() || this.get$isNum() || this.get$isFunction() || this.get$isVar();
}
Type.prototype.get$isUsed = function() {
  return false;
}
Type.prototype.get$isGeneric = function() {
  return false;
}
Type.prototype.get$nativeType = function() {
  return null;
}
Type.prototype.get$isHiddenNativeType = function() {
  return (this.get$nativeType() != null && this.get$nativeType().isConstructorHidden);
}
Type.prototype.get$isSingletonNative = function() {
  return (this.get$nativeType() != null && this.get$nativeType().isSingleton);
}
Type.prototype.get$isJsGlobalObject = function() {
  return (this.get$nativeType() != null && this.get$nativeType().isJsGlobalObject);
}
Type.prototype.get$hasTypeParams = function() {
  return false;
}
Type.prototype.get$typeofName = function() {
  return null;
}
Type.prototype.get$members = function() {
  return null;
}
Type.prototype.get$definition = function() {
  return null;
}
Type.prototype.get$factories = function() {
  return null;
}
Type.prototype.get$typeArgsInOrder = function() {
  return null;
}
Type.prototype.get$genericType = function() {
  return this;
}
Type.prototype.get$interfaces = function() {
  return null;
}
Type.prototype.get$parent = function() {
  return null;
}
Type.prototype.getAllMembers = function() {
  return new HashMapImplementation();
}
Type.prototype.get$hasNativeSubtypes = function() {
  if (this._hasNativeSubtypes == null) {
    this._hasNativeSubtypes = this.get$subtypes().some((function (t) {
      return t.get$isNative();
    })
    );
  }
  return this._hasNativeSubtypes;
}
Type.prototype._checkExtends = function() {
  var typeParams = this.get$genericType().typeParameters;
  if (typeParams != null && this.get$typeArgsInOrder() != null) {
    var args = this.get$typeArgsInOrder().iterator$0();
    var params = typeParams.iterator$0();
    while (args.hasNext$0() && params.hasNext$0()) {
      var typeParam = params.next$0();
      var typeArg = args.next$0();
      if (typeParam.get$extendsType() != null && typeArg != null) {
        typeArg.ensureSubtypeOf$3(typeParam.get$extendsType(), typeParam.get$span(), true);
      }
    }
  }
  if (this.get$interfaces() != null) {
    var $$list = this.get$interfaces();
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var i = $$list.$index($$i);
      i._checkExtends$0();
    }
  }
}
Type.prototype._checkOverride = function(member) {
  var parentMember = this._getMemberInParents(member.name);
  if (parentMember != null) {
    if (!member.get$isPrivate() || $eq(member.get$library(), parentMember.get$library())) {
      member.override(parentMember);
    }
  }
}
Type.prototype._createNotEqualMember = function() {
  var eq = this.get$members().$index(':eq');
  if (eq == null) {
    return;
  }
  var ne = new MethodMember(':ne', this, eq.definition);
  ne.isGenerated = true;
  ne.returnType = eq.returnType;
  ne.parameters = eq.parameters;
  ne.isStatic = eq.isStatic;
  ne.isAbstract = eq.isAbstract;
  this.get$members().$setindex(':ne', ne);
}
Type.prototype._getMemberInParents = function(memberName) {
  if (this.get$isClass()) {
    if (this.get$parent() != null) {
      return this.get$parent().getMember(memberName);
    }
    else {
      return null;
    }
  }
  else {
    if (this.get$interfaces() != null && this.get$interfaces().length > 0) {
      var $$list = this.get$interfaces();
      for (var $$i = 0;$$i < $$list.length; $$i++) {
        var i = $$list.$index($$i);
        var ret = i.getMember$1(memberName);
        if (ret != null) {
          return ret;
        }
      }
    }
    return $globals.world.objectType.getMember(memberName);
  }
}
Type.prototype.resolveMember = function(memberName) {
  var ret = this._resolvedMembers.$index(memberName);
  if (ret != null) return ret;
  var member = this.getMember(memberName);
  if (member == null) {
    return null;
  }
  ret = new MemberSet(member, false);
  this._resolvedMembers.$setindex(memberName, ret);
  if (member.get$isStatic()) {
    return ret;
  }
  else {
    var $$list = this.get$subtypes();
    for (var $$i = this.get$subtypes().iterator(); $$i.hasNext$0(); ) {
      var t = $$i.next$0();
      if (!this.get$isClass() && t.get$isClass()) {
        var m = t.getMember$1(memberName);
        if (m != null && ret.members.indexOf(m) == -1) {
          ret.add(m);
        }
      }
      else {
        var m = t.get$members().$index(memberName);
        if (m != null) ret.add(m);
      }
    }
    return ret;
  }
}
Type.prototype.ensureSubtypeOf = function(other, span, typeErrors) {
  if (!this.isSubtypeOf(other)) {
    var msg = ('type ' + this.name + ' is not a subtype of ' + other.name);
    if (typeErrors) {
      $globals.world.error(msg, span);
    }
    else {
      $globals.world.warning(msg, span);
    }
  }
}
Type.prototype.needsVarCall = function(args) {
  if (this.get$isVarOrFunction()) {
    return true;
  }
  var call = this.getCallMethod();
  if (call != null) {
    if (args.get$length() != call.get$parameters().length || !call.namesInOrder$1(args)) {
      return true;
    }
  }
  return false;
}
Type.union = function(x, y) {
  if ($eq(x, y)) return x;
  if (x.get$isNum() && y.get$isNum()) return $globals.world.numType;
  if (x.get$isString() && y.get$isString()) return $globals.world.stringType;
  return $globals.world.varType;
}
Type.prototype.isAssignable = function(other) {
  return this.isSubtypeOf(other) || other.isSubtypeOf(this);
}
Type.prototype._isDirectSupertypeOf = function(other) {
  var $this = this; // closure support
  if (other.get$isClass()) {
    return $eq(other.get$parent(), this) || this.get$isObject() && other.get$parent() == null;
  }
  else {
    if (other.get$interfaces() == null || other.get$interfaces().isEmpty()) {
      return this.get$isObject();
    }
    else {
      return other.get$interfaces().some((function (i) {
        return $eq(i, $this);
      })
      );
    }
  }
}
Type.prototype.isSubtypeOf = function(other) {
  if ((other instanceof ParameterType)) {
    return true;
  }
  if ($eq(this, other)) return true;
  if (this.get$isVar()) return true;
  if (other.get$isVar()) return true;
  if (other._isDirectSupertypeOf(this)) return true;
  var call = this.getCallMethod();
  var otherCall = other.getCallMethod();
  if (call != null && otherCall != null) {
    return Type._isFunctionSubtypeOf(call, otherCall);
  }
  if ($eq(this.get$genericType(), other.get$genericType()) && this.get$typeArgsInOrder() != null && other.get$typeArgsInOrder() != null && $eq(this.get$typeArgsInOrder().length, other.get$typeArgsInOrder().length)) {
    var t = this.get$typeArgsInOrder().iterator$0();
    var s = other.get$typeArgsInOrder().iterator$0();
    while (t.hasNext$0()) {
      if (!t.next$0().isSubtypeOf$1(s.next$0())) return false;
    }
    return true;
  }
  if (this.get$parent() != null && this.get$parent().isSubtypeOf(other)) {
    return true;
  }
  if (this.get$interfaces() != null && this.get$interfaces().some((function (i) {
    return i.isSubtypeOf$1(other);
  })
  )) {
    return true;
  }
  return false;
}
Type.prototype.hashCode = function() {
  var libraryCode = this.get$library() == null ? 1 : this.get$library().hashCode();
  var nameCode = this.name == null ? 1 : this.name.hashCode();
  return (libraryCode << 4) ^ nameCode;
}
Type.prototype.$eq = function(other) {
  return (other instanceof Type) && $eq(other.get$name(), this.name) && $eq(this.get$library(), other.get$library());
}
Type._isFunctionSubtypeOf = function(t, s) {
  if (!s.returnType.get$isVoid() && !s.returnType.isAssignable(t.returnType)) {
    return false;
  }
  var tp = t.parameters;
  var sp = s.parameters;
  if (tp.length < sp.length) return false;
  for (var i = 0;
   i < sp.length; i++) {
    if ($ne(tp.$index(i).get$isOptional(), sp.$index(i).get$isOptional())) return false;
    if (tp.$index(i).get$isOptional() && $ne(tp.$index(i).get$name(), sp.$index(i).get$name())) return false;
    if (!tp.$index(i).get$type().isAssignable$1(sp.$index(i).get$type())) return false;
  }
  if (tp.length > sp.length && !tp.$index(sp.length).get$isOptional()) return false;
  return true;
}
Type.prototype._checkExtends$0 = Type.prototype._checkExtends;
Type.prototype.addDirectSubtype$1 = Type.prototype.addDirectSubtype;
Type.prototype.ensureSubtypeOf$3 = Type.prototype.ensureSubtypeOf;
Type.prototype.getConstructor$1 = Type.prototype.getConstructor;
Type.prototype.getFactory$2 = Type.prototype.getFactory;
Type.prototype.getMember$1 = Type.prototype.getMember;
Type.prototype.getOrMakeConcreteType$1 = Type.prototype.getOrMakeConcreteType;
Type.prototype.hashCode$0 = Type.prototype.hashCode;
Type.prototype.isAssignable$1 = Type.prototype.isAssignable;
Type.prototype.isSubtypeOf$1 = Type.prototype.isSubtypeOf;
Type.prototype.markUsed$0 = Type.prototype.markUsed;
Type.prototype.resolveTypeParams$1 = Type.prototype.resolveTypeParams;
// ********** Code for ParameterType **************
function ParameterType(name, typeParameter) {
  this.typeParameter = typeParameter;
  // Initializers done
  Type.call(this, name);
}
$inherits(ParameterType, Type);
ParameterType.prototype.get$typeParameter = function() { return this.typeParameter; };
ParameterType.prototype.set$typeParameter = function(value) { return this.typeParameter = value; };
ParameterType.prototype.get$extendsType = function() { return this.extendsType; };
ParameterType.prototype.set$extendsType = function(value) { return this.extendsType = value; };
ParameterType.prototype.get$isClass = function() {
  return false;
}
ParameterType.prototype.get$library = function() {
  return null;
}
ParameterType.prototype.get$span = function() {
  return this.typeParameter.span;
}
ParameterType.prototype.get$constructors = function() {
  $globals.world.internalError('no constructors on type parameters yet');
}
ParameterType.prototype.getCallMethod = function() {
  return this.extendsType.getCallMethod();
}
ParameterType.prototype.genMethod = function(method) {
  this.extendsType.genMethod(method);
}
ParameterType.prototype.isSubtypeOf = function(other) {
  return true;
}
ParameterType.prototype.resolveMember = function(memberName) {
  return this.extendsType.resolveMember(memberName);
}
ParameterType.prototype.getConstructor = function(constructorName) {
  $globals.world.internalError('no constructors on type parameters yet');
}
ParameterType.prototype.getOrMakeConcreteType = function(typeArgs) {
  $globals.world.internalError('no concrete types of type parameters yet', this.get$span());
}
ParameterType.prototype.resolveTypeParams = function(inType) {
  return inType.typeArguments.$index(this.name);
}
ParameterType.prototype.addDirectSubtype = function(type) {
  $globals.world.internalError('no subtypes of type parameters yet', this.get$span());
}
ParameterType.prototype.resolve = function() {
  if (this.typeParameter.extendsType != null) {
    this.extendsType = this.get$enclosingElement().resolveType(this.typeParameter.extendsType, true);
  }
  else {
    this.extendsType = $globals.world.objectType;
  }
}
ParameterType.prototype.addDirectSubtype$1 = ParameterType.prototype.addDirectSubtype;
ParameterType.prototype.getConstructor$1 = ParameterType.prototype.getConstructor;
ParameterType.prototype.getOrMakeConcreteType$1 = ParameterType.prototype.getOrMakeConcreteType;
ParameterType.prototype.isSubtypeOf$1 = ParameterType.prototype.isSubtypeOf;
ParameterType.prototype.resolve$0 = ParameterType.prototype.resolve;
ParameterType.prototype.resolveTypeParams$1 = ParameterType.prototype.resolveTypeParams;
// ********** Code for NonNullableType **************
function NonNullableType(type) {
  this.type = type;
  // Initializers done
  Type.call(this, type.name);
}
$inherits(NonNullableType, Type);
NonNullableType.prototype.get$type = function() { return this.type; };
NonNullableType.prototype.get$isNullable = function() {
  return false;
}
NonNullableType.prototype.get$isBool = function() {
  return this.type.get$isBool();
}
NonNullableType.prototype.get$isUsed = function() {
  return false;
}
NonNullableType.prototype.isSubtypeOf = function(other) {
  return $eq(this, other) || $eq(this.type, other) || this.type.isSubtypeOf(other);
}
NonNullableType.prototype.resolveType = function(node, isRequired) {
  return this.type.resolveType(node, isRequired);
}
NonNullableType.prototype.resolveTypeParams = function(inType) {
  return this.type.resolveTypeParams(inType);
}
NonNullableType.prototype.addDirectSubtype = function(subtype) {
  this.type.addDirectSubtype(subtype);
}
NonNullableType.prototype.markUsed = function() {
  this.type.markUsed();
}
NonNullableType.prototype.genMethod = function(method) {
  this.type.genMethod(method);
}
NonNullableType.prototype.get$span = function() {
  return this.type.get$span();
}
NonNullableType.prototype.resolveMember = function(name) {
  return this.type.resolveMember(name);
}
NonNullableType.prototype.getMember = function(name) {
  return this.type.getMember(name);
}
NonNullableType.prototype.getConstructor = function(name) {
  return this.type.getConstructor(name);
}
NonNullableType.prototype.getFactory = function(t, name) {
  return this.type.getFactory(t, name);
}
NonNullableType.prototype.getOrMakeConcreteType = function(typeArgs) {
  return this.type.getOrMakeConcreteType(typeArgs);
}
NonNullableType.prototype.get$constructors = function() {
  return this.type.get$constructors();
}
NonNullableType.prototype.get$isClass = function() {
  return this.type.get$isClass();
}
NonNullableType.prototype.get$library = function() {
  return this.type.get$library();
}
NonNullableType.prototype.getCallMethod = function() {
  return this.type.getCallMethod();
}
NonNullableType.prototype.get$isGeneric = function() {
  return this.type.get$isGeneric();
}
NonNullableType.prototype.get$hasTypeParams = function() {
  return this.type.get$hasTypeParams();
}
NonNullableType.prototype.get$typeofName = function() {
  return this.type.get$typeofName();
}
NonNullableType.prototype.get$jsname = function() {
  return this.type.get$jsname();
}
NonNullableType.prototype.get$members = function() {
  return this.type.get$members();
}
NonNullableType.prototype.get$definition = function() {
  return this.type.get$definition();
}
NonNullableType.prototype.get$factories = function() {
  return this.type.get$factories();
}
NonNullableType.prototype.get$typeArgsInOrder = function() {
  return this.type.get$typeArgsInOrder();
}
NonNullableType.prototype.get$genericType = function() {
  return this.type.get$genericType();
}
NonNullableType.prototype.get$interfaces = function() {
  return this.type.get$interfaces();
}
NonNullableType.prototype.get$parent = function() {
  return this.type.get$parent();
}
NonNullableType.prototype.getAllMembers = function() {
  return this.type.getAllMembers();
}
NonNullableType.prototype.get$isNative = function() {
  return this.type.get$isNative();
}
NonNullableType.prototype.addDirectSubtype$1 = NonNullableType.prototype.addDirectSubtype;
NonNullableType.prototype.getConstructor$1 = NonNullableType.prototype.getConstructor;
NonNullableType.prototype.getFactory$2 = NonNullableType.prototype.getFactory;
NonNullableType.prototype.getMember$1 = NonNullableType.prototype.getMember;
NonNullableType.prototype.getOrMakeConcreteType$1 = NonNullableType.prototype.getOrMakeConcreteType;
NonNullableType.prototype.isSubtypeOf$1 = NonNullableType.prototype.isSubtypeOf;
NonNullableType.prototype.markUsed$0 = NonNullableType.prototype.markUsed;
NonNullableType.prototype.resolveTypeParams$1 = NonNullableType.prototype.resolveTypeParams;
// ********** Code for ConcreteType **************
function ConcreteType(name, genericType, typeArguments, typeArgsInOrder) {
  this.isUsed = false
  this.genericType = genericType;
  this.typeArguments = typeArguments;
  this.typeArgsInOrder = typeArgsInOrder;
  this.constructors = new HashMapImplementation();
  this.members = new HashMapImplementation();
  this.factories = new FactoryMap();
  // Initializers done
  Type.call(this, name);
}
$inherits(ConcreteType, Type);
ConcreteType.prototype.get$genericType = function() { return this.genericType; };
ConcreteType.prototype.get$typeArguments = function() { return this.typeArguments; };
ConcreteType.prototype.set$typeArguments = function(value) { return this.typeArguments = value; };
ConcreteType.prototype.get$_parent = function() { return this._parent; };
ConcreteType.prototype.set$_parent = function(value) { return this._parent = value; };
ConcreteType.prototype.get$typeArgsInOrder = function() { return this.typeArgsInOrder; };
ConcreteType.prototype.set$typeArgsInOrder = function(value) { return this.typeArgsInOrder = value; };
ConcreteType.prototype.get$isList = function() {
  return this.genericType.get$isList();
}
ConcreteType.prototype.get$isClass = function() {
  return this.genericType.isClass;
}
ConcreteType.prototype.get$library = function() {
  return this.genericType.library;
}
ConcreteType.prototype.get$span = function() {
  return this.genericType.get$span();
}
ConcreteType.prototype.get$hasTypeParams = function() {
  return this.typeArguments.getValues().some$1((function (e) {
    return (e instanceof ParameterType);
  })
  );
}
ConcreteType.prototype.get$isUsed = function() { return this.isUsed; };
ConcreteType.prototype.set$isUsed = function(value) { return this.isUsed = value; };
ConcreteType.prototype.get$members = function() { return this.members; };
ConcreteType.prototype.set$members = function(value) { return this.members = value; };
ConcreteType.prototype.get$constructors = function() { return this.constructors; };
ConcreteType.prototype.set$constructors = function(value) { return this.constructors = value; };
ConcreteType.prototype.get$factories = function() { return this.factories; };
ConcreteType.prototype.set$factories = function(value) { return this.factories = value; };
ConcreteType.prototype.resolveTypeParams = function(inType) {
  var newTypeArgs = [];
  var needsNewType = false;
  var $$list = this.typeArgsInOrder;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var t = $$list.$index($$i);
    var newType = t.resolveTypeParams$1(inType);
    if ($ne(newType, t)) needsNewType = true;
    newTypeArgs.add$1(newType);
  }
  if (!needsNewType) return this;
  return this.genericType.getOrMakeConcreteType(newTypeArgs);
}
ConcreteType.prototype.getOrMakeConcreteType = function(typeArgs) {
  return this.genericType.getOrMakeConcreteType(typeArgs);
}
ConcreteType.prototype.get$parent = function() {
  if (this._parent == null && this.genericType.get$parent() != null) {
    this._parent = this.genericType.get$parent().resolveTypeParams(this);
  }
  return this._parent;
}
ConcreteType.prototype.get$interfaces = function() {
  if (this._interfaces == null && this.genericType.interfaces != null) {
    this._interfaces = [];
    var $$list = this.genericType.interfaces;
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var i = $$list.$index($$i);
      this._interfaces.add(i.resolveTypeParams$1(this));
    }
  }
  return this._interfaces;
}
ConcreteType.prototype.get$subtypes = function() {
  if (this._subtypes == null) {
    this._subtypes = new HashSetImplementation();
    var $$list = this.genericType.get$subtypes();
    for (var $$i = this.genericType.get$subtypes().iterator(); $$i.hasNext$0(); ) {
      var s = $$i.next$0();
      this._subtypes.add(s.resolveTypeParams$1(this));
    }
  }
  return this._subtypes;
}
ConcreteType.prototype.getCallMethod = function() {
  return this.genericType.getCallMethod();
}
ConcreteType.prototype.getAllMembers = function() {
  var result = this.genericType.getAllMembers();
  var $$list = result.getKeys$0();
  for (var $$i = result.getKeys$0().iterator$0(); $$i.hasNext$0(); ) {
    var memberName = $$i.next$0();
    var myMember = this.members.$index(memberName);
    if (myMember != null) {
      result.$setindex(memberName, myMember);
    }
  }
  return result;
}
ConcreteType.prototype.markUsed = function() {
  if (this.isUsed) return;
  this.isUsed = true;
  this._checkExtends();
  this.genericType.markUsed();
}
ConcreteType.prototype.genMethod = function(method) {
  return this.genericType.genMethod(method);
}
ConcreteType.prototype.getFactory = function(type, constructorName) {
  return this.genericType.getFactory(type, constructorName);
}
ConcreteType.prototype.getConstructor = function(constructorName) {
  var ret = this.constructors.$index(constructorName);
  if (ret != null) return ret;
  ret = this.factories.getFactory(this.name, constructorName);
  if (ret != null) return ret;
  var genericMember = this.genericType.getConstructor(constructorName);
  if (genericMember == null) return null;
  if ($ne(genericMember.get$declaringType(), this.genericType)) {
    if (!genericMember.get$declaringType().get$isGeneric()) return genericMember;
    var newDeclaringType = genericMember.get$declaringType().getOrMakeConcreteType$1(this.typeArgsInOrder);
    var factory = newDeclaringType.getFactory$2(this.genericType, constructorName);
    if (factory != null) return factory;
    return newDeclaringType.getConstructor$1(constructorName);
  }
  if (genericMember.get$isFactory()) {
    ret = new ConcreteMember(genericMember.get$name(), this, genericMember);
    this.factories.addFactory(this.name, constructorName, ret);
  }
  else {
    ret = new ConcreteMember(this.name, this, genericMember);
    this.constructors.$setindex(constructorName, ret);
  }
  return ret;
}
ConcreteType.prototype.getMember = function(memberName) {
  var member = this.members.$index(memberName);
  if (member != null) {
    this._checkOverride(member);
    return member;
  }
  var genericMember = this.genericType.members.$index(memberName);
  if (genericMember != null) {
    member = new ConcreteMember(genericMember.get$name(), this, genericMember);
    this.members.$setindex(memberName, member);
    return member;
  }
  return this._getMemberInParents(memberName);
}
ConcreteType.prototype.resolveType = function(node, isRequired) {
  var ret = this.genericType.resolveType(node, isRequired);
  return ret;
}
ConcreteType.prototype.addDirectSubtype = function(type) {
  this.genericType.addDirectSubtype(type);
}
ConcreteType.prototype.addDirectSubtype$1 = ConcreteType.prototype.addDirectSubtype;
ConcreteType.prototype.getConstructor$1 = ConcreteType.prototype.getConstructor;
ConcreteType.prototype.getFactory$2 = ConcreteType.prototype.getFactory;
ConcreteType.prototype.getMember$1 = ConcreteType.prototype.getMember;
ConcreteType.prototype.getOrMakeConcreteType$1 = ConcreteType.prototype.getOrMakeConcreteType;
ConcreteType.prototype.markUsed$0 = ConcreteType.prototype.markUsed;
ConcreteType.prototype.resolveTypeParams$1 = ConcreteType.prototype.resolveTypeParams;
// ********** Code for DefinedType **************
function DefinedType(name, library, definition, isClass) {
  this.isUsed = false
  this.isNative = false
  this.library = library;
  this.isClass = isClass;
  this.directSubtypes = new HashSetImplementation();
  this.constructors = new HashMapImplementation();
  this.members = new HashMapImplementation();
  this.factories = new FactoryMap();
  // Initializers done
  Type.call(this, name);
  this.setDefinition(definition);
}
$inherits(DefinedType, Type);
DefinedType.prototype.get$definition = function() { return this.definition; };
DefinedType.prototype.set$definition = function(value) { return this.definition = value; };
DefinedType.prototype.get$library = function() { return this.library; };
DefinedType.prototype.get$isClass = function() { return this.isClass; };
DefinedType.prototype.get$_parent = function() { return this._parent; };
DefinedType.prototype.set$_parent = function(value) { return this._parent = value; };
DefinedType.prototype.get$parent = function() {
  return this._parent;
}
DefinedType.prototype.set$parent = function(p) {
  this._parent = p;
}
DefinedType.prototype.get$interfaces = function() { return this.interfaces; };
DefinedType.prototype.set$interfaces = function(value) { return this.interfaces = value; };
DefinedType.prototype.get$typeParameters = function() { return this.typeParameters; };
DefinedType.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
DefinedType.prototype.get$constructors = function() { return this.constructors; };
DefinedType.prototype.set$constructors = function(value) { return this.constructors = value; };
DefinedType.prototype.get$members = function() { return this.members; };
DefinedType.prototype.set$members = function(value) { return this.members = value; };
DefinedType.prototype.get$factories = function() { return this.factories; };
DefinedType.prototype.set$factories = function(value) { return this.factories = value; };
DefinedType.prototype.get$_concreteTypes = function() { return this._concreteTypes; };
DefinedType.prototype.set$_concreteTypes = function(value) { return this._concreteTypes = value; };
DefinedType.prototype.get$isUsed = function() { return this.isUsed; };
DefinedType.prototype.set$isUsed = function(value) { return this.isUsed = value; };
DefinedType.prototype.get$isNative = function() { return this.isNative; };
DefinedType.prototype.set$isNative = function(value) { return this.isNative = value; };
DefinedType.prototype.setDefinition = function(def) {
  this.definition = def;
  if ((this.definition instanceof TypeDefinition) && this.definition.get$nativeType() != null) {
    this.isNative = true;
  }
  if (this.definition != null && this.definition.get$typeParameters() != null) {
    this._concreteTypes = new HashMapImplementation();
    this.typeParameters = this.definition.get$typeParameters();
  }
}
DefinedType.prototype.get$nativeType = function() {
  return (this.definition != null ? this.definition.get$nativeType() : null);
}
DefinedType.prototype.get$typeArgsInOrder = function() {
  if (this.typeParameters == null) return null;
  if (this._typeArgsInOrder == null) {
    this._typeArgsInOrder = new FixedCollection_Type($globals.world.varType, this.typeParameters.length);
  }
  return this._typeArgsInOrder;
}
DefinedType.prototype.get$isVar = function() {
  return $eq(this, $globals.world.varType);
}
DefinedType.prototype.get$isVoid = function() {
  return $eq(this, $globals.world.voidType);
}
DefinedType.prototype.get$isTop = function() {
  return this.name == null;
}
DefinedType.prototype.get$isObject = function() {
  return this.library.get$isCore() && this.name == 'Object';
}
DefinedType.prototype.get$isString = function() {
  return this.library.get$isCore() && this.name == 'String' || this.library.get$isCoreImpl() && this.name == 'StringImplementation';
}
DefinedType.prototype.get$isBool = function() {
  return this.library.get$isCore() && this.name == 'bool';
}
DefinedType.prototype.get$isFunction = function() {
  return this.library.get$isCore() && this.name == 'Function';
}
DefinedType.prototype.get$isList = function() {
  return this.library.get$isCore() && this.name == 'List';
}
DefinedType.prototype.get$isGeneric = function() {
  return this.typeParameters != null;
}
DefinedType.prototype.get$span = function() {
  return this.definition == null ? null : this.definition.span;
}
DefinedType.prototype.get$typeofName = function() {
  if (!this.library.get$isCore()) return null;
  if (this.get$isBool()) return 'boolean';
  else if (this.get$isNum()) return 'number';
  else if (this.get$isString()) return 'string';
  else if (this.get$isFunction()) return 'function';
  else return null;
}
DefinedType.prototype.get$isNum = function() {
  return this.library != null && this.library.get$isCore() && (this.name == 'num' || this.name == 'int' || this.name == 'double');
}
DefinedType.prototype.getCallMethod = function() {
  return this.members.$index(':call');
}
DefinedType.prototype.getAllMembers = function() {
  return HashMapImplementation.HashMapImplementation$from$factory(this.members);
}
DefinedType.prototype.markUsed = function() {
  if (this.isUsed) return;
  this.isUsed = true;
  this._checkExtends();
  if (this._lazyGenMethods != null) {
    var $$list = orderValuesByKeys(this._lazyGenMethods);
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var method = $$list.$index($$i);
      $globals.world.gen.genMethod(method);
    }
    this._lazyGenMethods = null;
  }
  if (this.get$parent() != null) this.get$parent().markUsed();
}
DefinedType.prototype.genMethod = function(method) {
  if (this.isUsed) {
    $globals.world.gen.genMethod(method);
  }
  else if (this.isClass) {
    if (this._lazyGenMethods == null) this._lazyGenMethods = new HashMapImplementation();
    this._lazyGenMethods.$setindex(method.name, method);
  }
}
DefinedType.prototype._resolveInterfaces = function(types) {
  if (types == null) return [];
  var interfaces = [];
  for (var $$i = 0;$$i < types.length; $$i++) {
    var type = types.$index($$i);
    var resolvedInterface = this.resolveType(type, true);
    if (resolvedInterface.get$isClosed() && !(this.library.get$isCore() || this.library.get$isCoreImpl())) {
      $globals.world.error(('can not implement "' + resolvedInterface.get$name() + '": ') + 'only native implementation allowed', type.get$span());
    }
    resolvedInterface.addDirectSubtype$1(this);
    interfaces.add$1(resolvedInterface);
  }
  return interfaces;
}
DefinedType.prototype.addDirectSubtype = function(type) {
  this.directSubtypes.add(type);
}
DefinedType.prototype.get$subtypes = function() {
  if (this._subtypes == null) {
    this._subtypes = new HashSetImplementation();
    var $$list = this.directSubtypes;
    for (var $$i = this.directSubtypes.iterator(); $$i.hasNext$0(); ) {
      var st = $$i.next$0();
      this._subtypes.add(st);
      this._subtypes.addAll(st.get$subtypes());
    }
  }
  return this._subtypes;
}
DefinedType.prototype._cycleInClassExtends = function() {
  var seen = new HashSetImplementation();
  seen.add(this);
  var ancestor = this.get$parent();
  while (ancestor != null) {
    if (ancestor === this) {
      return true;
    }
    if (seen.contains(ancestor)) {
      return false;
    }
    seen.add(ancestor);
    ancestor = ancestor.get$parent();
  }
  return false;
}
DefinedType.prototype._cycleInInterfaceExtends = function() {
  var $this = this; // closure support
  var seen = new HashSetImplementation();
  seen.add(this);
  function _helper(ancestor) {
    if (ancestor == null) return false;
    if (ancestor === $this) return true;
    if (seen.contains(ancestor)) {
      return false;
    }
    seen.add(ancestor);
    if (ancestor.get$interfaces() != null) {
      var $$list = ancestor.get$interfaces();
      for (var $$i = ancestor.get$interfaces().iterator$0(); $$i.hasNext$0(); ) {
        var parent = $$i.next$0();
        if (_helper(parent)) return true;
      }
    }
    return false;
  }
  for (var i = 0;
   i < this.interfaces.length; i++) {
    if (_helper(this.interfaces.$index(i))) return i;
  }
  return -1;
}
DefinedType.prototype.resolve = function() {
  if ((this.definition instanceof TypeDefinition)) {
    var typeDef = this.definition;
    if (this.isClass) {
      if (typeDef.extendsTypes != null && typeDef.extendsTypes.length > 0) {
        if (typeDef.extendsTypes.length > 1) {
          $globals.world.error('more than one base class', typeDef.extendsTypes.$index(1).get$span());
        }
        var extendsTypeRef = typeDef.extendsTypes.$index(0);
        if ((extendsTypeRef instanceof GenericTypeReference)) {
          var g = extendsTypeRef;
          this.set$parent(this.resolveType(g.baseType, true));
        }
        this.set$parent(this.resolveType(extendsTypeRef, true));
        if (!this.get$parent().get$isClass()) {
          $globals.world.error('class may not extend an interface - use implements', typeDef.extendsTypes.$index(0).get$span());
        }
        this.get$parent().addDirectSubtype(this);
        if (this._cycleInClassExtends()) {
          $globals.world.error(('class "' + this.name + '" has a cycle in its inheritance chain'), extendsTypeRef.get$span());
        }
      }
      else {
        if (!this.get$isObject()) {
          this.set$parent($globals.world.objectType);
          this.get$parent().addDirectSubtype(this);
        }
      }
      this.interfaces = this._resolveInterfaces(typeDef.implementsTypes);
      if (typeDef.factoryType != null) {
        $globals.world.error('factory not allowed on classes', typeDef.factoryType.span);
      }
    }
    else {
      if (typeDef.implementsTypes != null && typeDef.implementsTypes.length > 0) {
        $globals.world.error('implements not allowed on interfaces (use extends)', typeDef.implementsTypes.$index(0).get$span());
      }
      this.interfaces = this._resolveInterfaces(typeDef.extendsTypes);
      var res = this._cycleInInterfaceExtends();
      if (res >= 0) {
        $globals.world.error(('interface "' + this.name + '" has a cycle in its inheritance chain'), typeDef.extendsTypes.$index(res).get$span());
      }
      if (typeDef.factoryType != null) {
        this.factory_ = this.resolveType(typeDef.factoryType, true);
        if (this.factory_ == null) {
          $globals.world.warning('unresolved factory', typeDef.factoryType.span);
        }
      }
    }
  }
  else if ((this.definition instanceof FunctionTypeDefinition)) {
    this.interfaces = [$globals.world.functionType];
  }
  if (this.typeParameters != null) {
    var $$list = this.typeParameters;
    for (var $$i = 0;$$i < $$list.length; $$i++) {
      var tp = $$list.$index($$i);
      tp.set$enclosingElement(this);
      tp.resolve$0();
    }
  }
  if (this.get$isObject()) this._createNotEqualMember();
  $globals.world._addType(this);
  var $$list = this.constructors.getValues();
  for (var $$i = this.constructors.getValues().iterator$0(); $$i.hasNext$0(); ) {
    var c = $$i.next$0();
    c.resolve$0();
  }
  var $list0 = this.members.getValues();
  for (var $$i = this.members.getValues().iterator$0(); $$i.hasNext$0(); ) {
    var m = $$i.next$0();
    m.resolve$0();
  }
  this.factories.forEach((function (f) {
    return f.resolve$0();
  })
  );
  if (this.get$isJsGlobalObject()) {
    var $list1 = this.members.getValues();
    for (var $$i = this.members.getValues().iterator$0(); $$i.hasNext$0(); ) {
      var m0 = $$i.next$0();
      if (!m0.get$isStatic()) $globals.world._addTopName(m0);
    }
  }
}
DefinedType.prototype.addMethod = function(methodName, definition) {
  if (methodName == null) methodName = definition.name.name;
  var method = new MethodMember(methodName, this, definition);
  if (method.get$isConstructor()) {
    if (this.constructors.containsKey(method.get$constructorName())) {
      $globals.world.error(('duplicate constructor definition of ' + method.get$name()), definition.span);
      return;
    }
    this.constructors.$setindex(method.get$constructorName(), method);
    return;
  }
  if (definition.modifiers != null && definition.modifiers.length == 1 && $eq(definition.modifiers.$index(0).get$kind(), 75/*TokenKind.FACTORY*/)) {
    if (this.factories.getFactory(method.get$constructorName(), method.get$name()) != null) {
      $globals.world.error(('duplicate factory definition of "' + method.get$name() + '"'), definition.span);
      return;
    }
    this.factories.addFactory(method.get$constructorName(), method.get$name(), method);
    return;
  }
  if (methodName.startsWith('get:') || methodName.startsWith('set:')) {
    var propName = methodName.substring(4);
    var prop = this.members.$index(propName);
    if (prop == null) {
      prop = new PropertyMember(propName, this);
      this.members.$setindex(propName, prop);
    }
    if (!(prop instanceof PropertyMember)) {
      $globals.world.error(('property conflicts with field "' + propName + '"'), definition.span);
      return;
    }
    if (methodName[0] == 'g') {
      if (prop.get$getter() != null) {
        $globals.world.error(('duplicate getter definition for "' + propName + '"'), definition.span);
      }
      prop.set$getter(method);
    }
    else {
      if (prop.get$setter() != null) {
        $globals.world.error(('duplicate setter definition for "' + propName + '"'), definition.span);
      }
      prop.set$setter(method);
    }
    return;
  }
  if (this.members.containsKey(methodName)) {
    $globals.world.error(('duplicate method definition of "' + method.get$name() + '"'), definition.span);
    return;
  }
  this.members.$setindex(methodName, method);
}
DefinedType.prototype.addField = function(definition) {
  for (var i = 0;
   i < definition.names.length; i++) {
    var name = definition.names.$index(i).get$name();
    if (this.members.containsKey(name)) {
      $globals.world.error(('duplicate field definition of "' + name + '"'), definition.span);
      return;
    }
    var value = null;
    if (definition.values != null) {
      value = definition.values.$index(i);
    }
    var field = new FieldMember(name, this, definition, value);
    this.members.$setindex(name, field);
    if (this.isNative) {
      field.set$isNative(true);
    }
  }
}
DefinedType.prototype.getFactory = function(type, constructorName) {
  var ret = this.factories.getFactory(type.name, constructorName);
  if (ret != null) return ret;
  ret = this.factories.getFactory(this.name, constructorName);
  if (ret != null) return ret;
  ret = this.constructors.$index(constructorName);
  if (ret != null) return ret;
  return this._tryCreateDefaultConstructor(constructorName);
}
DefinedType.prototype.getConstructor = function(constructorName) {
  var ret = this.constructors.$index(constructorName);
  if (ret != null) {
    if (this.factory_ != null) {
      return this.factory_.getFactory(this, constructorName);
    }
    return ret;
  }
  ret = this.factories.getFactory(this.name, constructorName);
  if (ret != null) return ret;
  return this._tryCreateDefaultConstructor(constructorName);
}
DefinedType.prototype._tryCreateDefaultConstructor = function(name) {
  if (name == '' && this.definition != null && this.isClass && this.constructors.get$length() == 0) {
    var span = this.definition.span;
    var inits = null, native_ = null, body = null;
    if (this.isNative) {
      native_ = '';
      inits = null;
    }
    else {
      body = null;
      inits = [new CallExpression(new SuperExpression(span), [], span)];
    }
    var typeDef = this.definition;
    var c = new FunctionDefinition(null, null, typeDef.name, [], null, inits, native_, body, span);
    this.addMethod(null, c);
    this.constructors.$index('').resolve$0();
    return this.constructors.$index('');
  }
  return null;
}
DefinedType.prototype.getMember = function(memberName) {
  var member = this.members.$index(memberName);
  if (member != null) {
    this._checkOverride(member);
    return member;
  }
  if (this.get$isTop()) {
    var libType = this.library.findTypeByName(memberName);
    if (libType != null) {
      return libType.get$typeMember();
    }
  }
  return this._getMemberInParents(memberName);
}
DefinedType.prototype.resolveTypeParams = function(inType) {
  return this;
}
DefinedType.prototype.getOrMakeConcreteType = function(typeArgs) {
  var jsnames = [];
  var names = [];
  var typeMap = new HashMapImplementation();
  for (var i = 0;
   i < typeArgs.length; i++) {
    var paramName = this.typeParameters.$index(i).get$name();
    typeMap.$setindex(paramName, typeArgs.$index(i));
    names.add$1(typeArgs.$index(i).get$name());
    jsnames.add$1(typeArgs.$index(i).get$jsname());
  }
  var jsname = ('' + this.get$jsname() + '_' + Strings.join(jsnames, '\$'));
  var simpleName = ('' + this.name + '<' + Strings.join(names, ', ') + '>');
  var key = Strings.join(names, '\$');
  var ret = this._concreteTypes.$index(key);
  if (ret == null) {
    ret = new ConcreteType(simpleName, this, typeMap, typeArgs);
    ret.set$_jsname(jsname);
    this._concreteTypes.$setindex(key, ret);
  }
  return ret;
}
DefinedType.prototype.getCallStub = function(args) {
  var name = _getCallStubName('call', args);
  var stub = this.varStubs.$index(name);
  if (stub == null) {
    stub = new VarFunctionStub(name, args);
    this.varStubs.$setindex(name, stub);
  }
  return stub;
}
DefinedType.prototype.addDirectSubtype$1 = DefinedType.prototype.addDirectSubtype;
DefinedType.prototype.addMethod$2 = DefinedType.prototype.addMethod;
DefinedType.prototype.getConstructor$1 = DefinedType.prototype.getConstructor;
DefinedType.prototype.getFactory$2 = DefinedType.prototype.getFactory;
DefinedType.prototype.getMember$1 = DefinedType.prototype.getMember;
DefinedType.prototype.getOrMakeConcreteType$1 = DefinedType.prototype.getOrMakeConcreteType;
DefinedType.prototype.markUsed$0 = DefinedType.prototype.markUsed;
DefinedType.prototype.resolve$0 = DefinedType.prototype.resolve;
DefinedType.prototype.resolveTypeParams$1 = DefinedType.prototype.resolveTypeParams;
DefinedType.prototype.setDefinition$1 = DefinedType.prototype.setDefinition;
// ********** Code for NativeType **************
function NativeType(name) {
  this.isConstructorHidden = false
  this.isJsGlobalObject = false
  this.isSingleton = false
  this.name = name;
  // Initializers done
  if (this.name.contains('@')) {
    this.name = this.name.replaceAll('@', '');
    this.isJsGlobalObject = true;
  }
  if (this.name.contains('*')) {
    this.name = this.name.replaceAll('*', '');
    this.isConstructorHidden = true;
  }
  if (this.name.contains('=')) {
    this.name = this.name.replaceAll('=', '');
    this.isSingleton = true;
  }
}
NativeType.prototype.get$name = function() { return this.name; };
NativeType.prototype.set$name = function(value) { return this.name = value; };
// ********** Code for FixedCollection **************
function FixedCollection(value, length) {
  this.value = value;
  this.length = length;
  // Initializers done
}
FixedCollection.prototype.get$value = function() { return this.value; };
FixedCollection.prototype.iterator = function() {
  return new FixedIterator_E(this.value, this.length);
}
FixedCollection.prototype.forEach = function(f) {
  Collections.forEach(this, f);
}
FixedCollection.prototype.filter = function(f) {
  return Collections.filter(this, new ListFactory(), f);
}
FixedCollection.prototype.every = function(f) {
  return Collections.every(this, f);
}
FixedCollection.prototype.some = function(f) {
  return Collections.some(this, f);
}
FixedCollection.prototype.isEmpty = function() {
  return this.length == 0;
}
FixedCollection.prototype.every$1 = function($0) {
  return this.every(to$call$1($0));
};
FixedCollection.prototype.filter$1 = function($0) {
  return this.filter(to$call$1($0));
};
FixedCollection.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$1($0));
};
FixedCollection.prototype.isEmpty$0 = FixedCollection.prototype.isEmpty;
FixedCollection.prototype.iterator$0 = FixedCollection.prototype.iterator;
FixedCollection.prototype.some$1 = function($0) {
  return this.some(to$call$1($0));
};
// ********** Code for FixedCollection_Type **************
function FixedCollection_Type(value, length) {
  this.value = value;
  this.length = length;
  // Initializers done
}
$inherits(FixedCollection_Type, FixedCollection);
// ********** Code for FixedIterator **************
function FixedIterator(value, length) {
  this._index = 0
  this.value = value;
  this.length = length;
  // Initializers done
}
FixedIterator.prototype.get$value = function() { return this.value; };
FixedIterator.prototype.hasNext = function() {
  return this._index < this.length;
}
FixedIterator.prototype.next = function() {
  this._index++;
  return this.value;
}
FixedIterator.prototype.hasNext$0 = FixedIterator.prototype.hasNext;
FixedIterator.prototype.next$0 = FixedIterator.prototype.next;
// ********** Code for FixedIterator_E **************
function FixedIterator_E(value, length) {
  this._index = 0
  this.value = value;
  this.length = length;
  // Initializers done
}
$inherits(FixedIterator_E, FixedIterator);
// ********** Code for Value **************
function Value(_type, code, span, needsTemp) {
  this.isSuper = false
  this.isType = false
  this.isInitializerTarget = false
  this.isFinal = false
  this._type = _type;
  this.code = code;
  this.span = span;
  this.needsTemp = needsTemp;
  // Initializers done
  if (this._type == null) $globals.world.internalError('type passed as null', this.span);
}
Value.type$ctor = function(_type, span) {
  this.isSuper = false
  this.isType = false
  this.isInitializerTarget = false
  this.isFinal = false
  this._type = _type;
  this.span = span;
  this.code = null;
  this.needsTemp = false;
  this.isType = true;
  // Initializers done
  if (this._type == null) $globals.world.internalError('type passed as null', this.span);
}
Value.type$ctor.prototype = Value.prototype;
Value.prototype.get$code = function() { return this.code; };
Value.prototype.set$code = function(value) { return this.code = value; };
Value.prototype.get$span = function() { return this.span; };
Value.prototype.set$span = function(value) { return this.span = value; };
Value.prototype.get$isSuper = function() { return this.isSuper; };
Value.prototype.set$isSuper = function(value) { return this.isSuper = value; };
Value.prototype.get$isType = function() { return this.isType; };
Value.prototype.set$isType = function(value) { return this.isType = value; };
Value.prototype.get$isInitializerTarget = function() { return this.isInitializerTarget; };
Value.prototype.set$isInitializerTarget = function(value) { return this.isInitializerTarget = value; };
Value.prototype.get$isFinal = function() { return this.isFinal; };
Value.prototype.set$isFinal = function(value) { return this.isFinal = value; };
Value.prototype.get$needsTemp = function() { return this.needsTemp; };
Value.prototype.set$needsTemp = function(value) { return this.needsTemp = value; };
Value.prototype.get$_typeIsVarOrParameterType = function() {
  return this.get$type().get$isVar() || (this.get$type() instanceof ParameterType);
}
Value.prototype.get$type = function() {
  if (!$globals.options.forceDynamic || this.isType || this.isSuper || this.isInitializerTarget || this.get$isConst()) {
    return this._type;
  }
  else {
    return $globals.world.varType;
  }
}
Value.prototype.get$isConst = function() {
  return false;
}
Value.prototype.get$canonicalCode = function() {
  return null;
}
Value.prototype.get_ = function(context, name, node) {
  var member = this._resolveMember(context, name, node, false);
  if (member != null) {
    return member._get$3(context, node, this);
  }
  else {
    return this.invokeNoSuchMethod(context, ('get:' + name), node);
  }
}
Value.prototype.set_ = function(context, name, node, value, isDynamic) {
  var member = this._resolveMember(context, name, node, isDynamic);
  if (member != null) {
    return member._set$5(context, node, this, value, isDynamic);
  }
  else {
    return this.invokeNoSuchMethod(context, ('set:' + name), node, new Arguments(null, [value]));
  }
}
Value.prototype.invoke = function(context, name, node, args, isDynamic) {
  if (name == ':call') {
    if (this.isType) {
      $globals.world.error('must use "new" or "const" to construct a new instance', node.span);
    }
    if (this.get$type().needsVarCall(args)) {
      return this._varCall(context, args);
    }
  }
  var member = this._resolveMember(context, name, node, isDynamic);
  if (member == null) {
    return this.invokeNoSuchMethod(context, name, node, args);
  }
  else {
    return member.invoke$5(context, node, this, args, isDynamic);
  }
}
Value.prototype.canInvoke = function(context, name, args) {
  if (this.get$type().get$isVarOrFunction() && name == ':call') {
    return true;
  }
  var member = this._resolveMember(context, name, null, true);
  return member != null && member.canInvoke$2(context, args);
}
Value.prototype._hasOverriddenNoSuchMethod = function() {
  if (this.isSuper) {
    var m = this.get$type().getMember('noSuchMethod');
    return m != null && !m.get$declaringType().get$isObject();
  }
  else {
    var m = this.get$type().resolveMember('noSuchMethod');
    return m != null && m.get$members().length > 1;
  }
}
Value.prototype._tryResolveMember = function(context, name) {
  if (this.isSuper) {
    return this.get$type().getMember(name);
  }
  else {
    return this.get$type().resolveMember(name);
  }
}
Value.prototype._resolveMember = function(context, name, node, isDynamic) {
  var member;
  if (!this.get$_typeIsVarOrParameterType()) {
    member = this._tryResolveMember(context, name);
    if (member != null && this.isType && !member.get$isStatic()) {
      if (!isDynamic) {
        $globals.world.error('can not refer to instance member as static', node.span);
      }
      return null;
    }
    if (member == null && !isDynamic && !this._hasOverriddenNoSuchMethod()) {
      var typeName = this.get$type().name == null ? this.get$type().get$library().name : this.get$type().name;
      var message = ('can not resolve "' + name + '" on "' + typeName + '"');
      if (this.isType) {
        $globals.world.error(message, node.span);
      }
      else {
        $globals.world.warning(message, node.span);
      }
    }
  }
  if (member == null && !this.isSuper && !this.isType) {
    member = context.findMembers(name);
    if (member == null && !isDynamic) {
      var where = 'the world';
      if (name.startsWith('_')) {
        where = ('library "' + context.get$library().name + '"');
      }
      $globals.world.warning(('' + name + ' is not defined anywhere in ' + where + '.'), node.span);
    }
  }
  return member;
}
Value.prototype.checkFirstClass = function(span) {
  if (this.isType) {
    $globals.world.error('Types are not first class', span);
  }
}
Value.prototype._varCall = function(context, args) {
  var stub = $globals.world.functionType.getCallStub(args);
  return new Value($globals.world.varType, ('' + this.code + '.' + stub.get$name() + '(' + args.getCode() + ')'), this.span, true);
}
Value.prototype.needsConversion = function(toType) {
  var callMethod = toType.getCallMethod();
  if (callMethod != null) {
    var arity = callMethod.get$parameters().length;
    var myCall = this.get$type().getCallMethod();
    if (myCall == null || $ne(myCall.get$parameters().length, arity)) {
      return true;
    }
  }
  if ($globals.options.enableTypeChecks) {
    var fromType = this.get$type();
    if (this.get$type().get$isVar() && (this.code != 'null' || !toType.get$isNullable())) {
      fromType = $globals.world.objectType;
    }
    var bothNum = this.get$type().get$isNum() && toType.get$isNum();
    return !(fromType.isSubtypeOf(toType) || bothNum);
  }
  return false;
}
Value.prototype.convertTo = function(context, toType, node, isDynamic) {
  var checked = !isDynamic;
  var callMethod = toType.getCallMethod();
  if (callMethod != null) {
    if (checked && !toType.isAssignable(this.get$type())) {
      this.convertWarning(toType, node);
    }
    var arity = callMethod.get$parameters().length;
    var myCall = this.get$type().getCallMethod();
    if (myCall == null || $ne(myCall.get$parameters().length, arity)) {
      var stub = $globals.world.functionType.getCallStub(Arguments.Arguments$bare$factory(arity));
      var val = new Value(toType, ('to\$' + stub.name + '(' + this.code + ')'), node.span, true);
      return this._isDomCallback(toType) && !this._isDomCallback(this.get$type()) ? val._wrapDomCallback$2(toType, arity) : val;
    }
    else if (this._isDomCallback(toType) && !this._isDomCallback(this.get$type())) {
      return this._wrapDomCallback(toType, arity);
    }
  }
  var fromType = this.get$type();
  if (this.get$type().get$isVar() && (this.code != 'null' || !toType.get$isNullable())) {
    fromType = $globals.world.objectType;
  }
  var bothNum = this.get$type().get$isNum() && toType.get$isNum();
  if (fromType.isSubtypeOf(toType) || bothNum) {
    return this;
  }
  if (checked && !toType.isSubtypeOf(this.get$type())) {
    this.convertWarning(toType, node);
  }
  if ($globals.options.enableTypeChecks) {
    return this._typeAssert(context, toType, node, isDynamic);
  }
  else {
    return this;
  }
}
Value.prototype._isDomCallback = function(toType) {
  return ((toType.get$definition() instanceof FunctionTypeDefinition) && $eq(toType.get$library(), $globals.world.get$dom()));
}
Value.prototype._wrapDomCallback = function(toType, arity) {
  if (arity == 0) {
    $globals.world.gen.corejs.useWrap0 = true;
  }
  else {
    $globals.world.gen.corejs.useWrap1 = true;
  }
  return new Value(toType, ('\$wrap_call\$' + arity + '(' + this.code + ')'), this.span, true);
}
Value.prototype._typeAssert = function(context, toType, node, isDynamic) {
  if ((toType instanceof ParameterType)) {
    var p = toType;
    toType = p.extendsType;
  }
  if (toType.get$isObject() || toType.get$isVar()) {
    $globals.world.internalError(('We thought ' + this.get$type().name + ' is not a subtype of ' + toType.name + '?'));
  }
  function throwTypeError(paramName) {
    return $globals.world.withoutForceDynamic((function () {
      var typeError = $globals.world.corelib.types.$index('TypeError');
      var typeErrorCtor = typeError.getConstructor$1('_internal');
      $globals.world.gen.corejs.ensureTypeNameOf();
      var result = typeErrorCtor.invoke$5(context, node, new Value.type$ctor(typeError, null), new Arguments(null, [new Value($globals.world.objectType, paramName, null, true), new Value($globals.world.stringType, ('"' + toType.name + '"'), null, true)]), isDynamic);
      $globals.world.gen.corejs.useThrow = true;
      return ('\$throw(' + result.get$code() + ')');
    })
    );
  }
  if (toType.get$isNum()) toType = $globals.world.numType;
  var check;
  if (toType.get$isVoid()) {
    check = ('\$assert_void(' + this.code + ')');
    if (toType.typeCheckCode == null) {
      toType.typeCheckCode = ("function $assert_void(x) {\n  if (x == null) return null;\n  " + throwTypeError("x") + "\n}");
    }
  }
  else if ($eq(toType, $globals.world.nonNullBool)) {
    $globals.world.gen.corejs.useNotNullBool = true;
    check = ('\$notnull_bool(' + this.code + ')');
  }
  else if (toType.get$library().get$isCore() && toType.get$typeofName() != null) {
    check = ('\$assert_' + toType.name + '(' + this.code + ')');
    if (toType.typeCheckCode == null) {
      toType.typeCheckCode = ("function $assert_" + toType.name + "(x) {\n  if (x == null || typeof(x) == \"" + toType.get$typeofName() + "\") return x;\n  " + throwTypeError("x") + "\n}");
    }
  }
  else {
    toType.isChecked = true;
    var checkName = 'assert\$' + toType.get$jsname();
    var temp = context.getTemp(this);
    check = ('(' + context.assignTemp(temp, this).code + ' == null ? null :');
    check = check + (' ' + temp.get$code() + '.' + checkName + '())');
    if ($ne(this, temp)) context.freeTemp(temp);
    if (!$globals.world.objectType.varStubs.containsKey(checkName)) {
      $globals.world.objectType.varStubs.$setindex(checkName, new VarMethodStub(checkName, null, Arguments.get$EMPTY(), throwTypeError('this')));
    }
  }
  return new Value(toType, check, this.span, true);
}
Value.prototype.instanceOf = function(context, toType, span, isTrue, forceCheck) {
  if (toType.get$isVar()) {
    $globals.world.error('can not resolve type', span);
  }
  var testCode = null;
  if (toType.get$isVar() || toType.get$isObject() || (toType instanceof ParameterType)) {
    if (this.needsTemp) {
      return new Value($globals.world.nonNullBool, ('(' + this.code + ', true)'), span, true);
    }
    else {
      return EvaluatedValue.EvaluatedValue$factory($globals.world.nonNullBool, true, 'true', null);
    }
  }
  if (toType.get$library().get$isCore()) {
    var typeofName = toType.get$typeofName();
    if (typeofName != null) {
      testCode = ("(typeof(" + this.code + ") " + (isTrue ? '==' : '!=') + " '" + typeofName + "')");
    }
  }
  if (toType.get$isClass() && !(toType instanceof ConcreteType) && !toType.get$isHiddenNativeType()) {
    toType.markUsed();
    testCode = ('(' + this.code + ' instanceof ' + toType.get$jsname() + ')');
    if (!isTrue) {
      testCode = '!' + testCode;
    }
  }
  if (testCode == null) {
    toType.isTested = true;
    var temp = context.getTemp(this);
    var checkName = ('is\$' + toType.get$jsname());
    testCode = ('(' + context.assignTemp(temp, this).code + ' &&');
    testCode = testCode + (' ' + temp.get$code() + '.' + checkName + '())');
    if (isTrue) {
      testCode = '!!' + testCode;
    }
    else {
      testCode = '!' + testCode;
    }
    if ($ne(this, temp)) context.freeTemp(temp);
    if (!$globals.world.objectType.varStubs.containsKey(checkName)) {
      $globals.world.objectType.varStubs.$setindex(checkName, new VarMethodStub(checkName, null, Arguments.get$EMPTY(), 'return false'));
    }
  }
  return new Value($globals.world.nonNullBool, testCode, span, true);
}
Value.prototype.convertWarning = function(toType, node) {
  $globals.world.warning(('type "' + this.get$type().name + '" is not assignable to "' + toType.name + '"'), node.span);
}
Value.prototype.invokeNoSuchMethod = function(context, name, node, args) {
  var pos = '';
  if (args != null) {
    var argsCode = [];
    for (var i = 0;
     i < args.get$length(); i++) {
      argsCode.add$1(args.values.$index(i).get$code());
    }
    pos = Strings.join(argsCode, ", ");
  }
  var noSuchArgs = [new Value($globals.world.stringType, ('"' + name + '"'), node.span, true), new Value($globals.world.listType, ('[' + pos + ']'), node.span, true)];
  return this._resolveMember(context, 'noSuchMethod', node, false).invoke$4(context, node, this, new Arguments(null, noSuchArgs));
}
Value.prototype._wrapDomCallback$2 = Value.prototype._wrapDomCallback;
Value.prototype.checkFirstClass$1 = Value.prototype.checkFirstClass;
Value.prototype.convertTo$3 = function($0, $1, $2) {
  return this.convertTo($0, $1, $2, false);
};
Value.prototype.convertTo$4 = Value.prototype.convertTo;
Value.prototype.get_$3 = Value.prototype.get_;
Value.prototype.instanceOf$3$isTrue$forceCheck = Value.prototype.instanceOf;
Value.prototype.instanceOf$4 = function($0, $1, $2, $3) {
  return this.instanceOf($0, $1, $2, $3, false);
};
Value.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke($0, $1, $2, $3, false);
};
Value.prototype.invoke$4$isDynamic = Value.prototype.invoke;
Value.prototype.invoke$5 = Value.prototype.invoke;
Value.prototype.needsConversion$1 = Value.prototype.needsConversion;
Value.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.set_($0, $1, $2, $3, false);
};
// ********** Code for EvaluatedValue **************
function EvaluatedValue() {}
EvaluatedValue._internal$ctor = function(type, actualValue, canonicalCode, span, code) {
  this.actualValue = actualValue;
  this.canonicalCode = canonicalCode;
  // Initializers done
  Value.call(this, type, code, span, false);
}
EvaluatedValue._internal$ctor.prototype = EvaluatedValue.prototype;
$inherits(EvaluatedValue, Value);
EvaluatedValue.EvaluatedValue$factory = function(type, actualValue, canonicalCode, span) {
  return new EvaluatedValue._internal$ctor(type, actualValue, canonicalCode, span, EvaluatedValue.codeWithComments(canonicalCode, span));
}
EvaluatedValue.prototype.get$actualValue = function() { return this.actualValue; };
EvaluatedValue.prototype.set$actualValue = function(value) { return this.actualValue = value; };
EvaluatedValue.prototype.get$isConst = function() {
  return true;
}
EvaluatedValue.prototype.get$canonicalCode = function() { return this.canonicalCode; };
EvaluatedValue.prototype.set$canonicalCode = function(value) { return this.canonicalCode = value; };
EvaluatedValue.codeWithComments = function(canonicalCode, span) {
  return (span != null && span.get$text() != canonicalCode) ? ('' + canonicalCode + '/*' + _escapeForComment(span.get$text()) + '*/') : canonicalCode;
}
// ********** Code for ConstListValue **************
function ConstListValue() {}
ConstListValue._internal$ctor = function(type, values, actualValue, canonicalCode, span, code) {
  this.values = values;
  // Initializers done
  EvaluatedValue._internal$ctor.call(this, type, actualValue, canonicalCode, span, code);
}
ConstListValue._internal$ctor.prototype = ConstListValue.prototype;
$inherits(ConstListValue, EvaluatedValue);
ConstListValue.ConstListValue$factory = function(type, values, actualValue, canonicalCode, span) {
  return new ConstListValue._internal$ctor(type, values, actualValue, canonicalCode, span, EvaluatedValue.codeWithComments(canonicalCode, span));
}
ConstListValue.prototype.get$values = function() { return this.values; };
ConstListValue.prototype.set$values = function(value) { return this.values = value; };
// ********** Code for ConstMapValue **************
function ConstMapValue() {}
ConstMapValue._internal$ctor = function(type, values, actualValue, canonicalCode, span, code) {
  this.values = values;
  // Initializers done
  EvaluatedValue._internal$ctor.call(this, type, actualValue, canonicalCode, span, code);
}
ConstMapValue._internal$ctor.prototype = ConstMapValue.prototype;
$inherits(ConstMapValue, EvaluatedValue);
ConstMapValue.ConstMapValue$factory = function(type, keyValuePairs, actualValue, canonicalCode, span) {
  var values = new HashMapImplementation();
  for (var i = 0;
   i < keyValuePairs.length; i += 2) {
    values.$setindex(keyValuePairs.$index(i).get$actualValue(), keyValuePairs.$index(i + 1));
  }
  return new ConstMapValue._internal$ctor(type, values, actualValue, canonicalCode, span, EvaluatedValue.codeWithComments(canonicalCode, span));
}
ConstMapValue.prototype.get$values = function() { return this.values; };
ConstMapValue.prototype.set$values = function(value) { return this.values = value; };
// ********** Code for ConstObjectValue **************
function ConstObjectValue() {}
ConstObjectValue._internal$ctor = function(type, fields, actualValue, canonicalCode, span, code) {
  this.fields = fields;
  // Initializers done
  EvaluatedValue._internal$ctor.call(this, type, actualValue, canonicalCode, span, code);
}
ConstObjectValue._internal$ctor.prototype = ConstObjectValue.prototype;
$inherits(ConstObjectValue, EvaluatedValue);
ConstObjectValue.ConstObjectValue$factory = function(type, fields, canonicalCode, span) {
  var fieldValues = [];
  var $$list = fields.getKeys();
  for (var $$i = fields.getKeys().iterator$0(); $$i.hasNext$0(); ) {
    var f = $$i.next$0();
    fieldValues.add(('' + f + ' = ' + fields.$index(f).get$actualValue()));
  }
  fieldValues.sort((function (a, b) {
    return a.compareTo$1(b);
  })
  );
  var actualValue = ('const ' + type.get$jsname() + ' [') + Strings.join(fieldValues, ',') + ']';
  return new ConstObjectValue._internal$ctor(type, fields, actualValue, canonicalCode, span, EvaluatedValue.codeWithComments(canonicalCode, span));
}
ConstObjectValue.prototype.get$fields = function() { return this.fields; };
ConstObjectValue.prototype.set$fields = function(value) { return this.fields = value; };
// ********** Code for GlobalValue **************
function GlobalValue(type, code, isConst, field, name, exp, canonicalCode, span, _dependencies) {
  this.field = field;
  this.name = name;
  this.exp = exp;
  this.canonicalCode = canonicalCode;
  this.dependencies = [];
  // Initializers done
  Value.call(this, type, code, span, !isConst);
  for (var $$i = 0;$$i < _dependencies.length; $$i++) {
    var dep = _dependencies.$index($$i);
    this.dependencies.add(dep);
    this.dependencies.addAll(dep.get$dependencies());
  }
}
$inherits(GlobalValue, Value);
GlobalValue.GlobalValue$fromStatic$factory = function(field, exp, dependencies) {
  var code = (exp.get$isConst() ? exp.get$canonicalCode() : exp.code);
  var codeWithComment = ('' + code + '/*' + field.get$declaringType().get$name() + '.' + field.get$name() + '*/');
  return new GlobalValue(exp.get$type(), codeWithComment, field.get$isFinal(), field, null, exp, code, exp.span, dependencies.filter$1((function (d) {
    return (d instanceof GlobalValue);
  })
  ));
}
GlobalValue.GlobalValue$fromConst$factory = function(uniqueId, exp, dependencies) {
  var name = ("const\$" + uniqueId);
  var codeWithComment = ("" + name + "/*" + _escapeForComment(exp.span.get$text()) + "*/");
  return new GlobalValue(exp.get$type(), codeWithComment, true, null, name, exp, name, exp.span, dependencies.filter$1((function (d) {
    return (d instanceof GlobalValue);
  })
  ));
}
GlobalValue.prototype.get$field = function() { return this.field; };
GlobalValue.prototype.set$field = function(value) { return this.field = value; };
GlobalValue.prototype.get$name = function() { return this.name; };
GlobalValue.prototype.set$name = function(value) { return this.name = value; };
GlobalValue.prototype.get$exp = function() { return this.exp; };
GlobalValue.prototype.set$exp = function(value) { return this.exp = value; };
GlobalValue.prototype.get$canonicalCode = function() { return this.canonicalCode; };
GlobalValue.prototype.set$canonicalCode = function(value) { return this.canonicalCode = value; };
GlobalValue.prototype.get$isConst = function() {
  return this.exp.get$isConst() && (this.field == null || this.field.isFinal);
}
GlobalValue.prototype.get$actualValue = function() {
  return this.exp.get$dynamic().get$actualValue();
}
GlobalValue.prototype.get$dependencies = function() { return this.dependencies; };
GlobalValue.prototype.set$dependencies = function(value) { return this.dependencies = value; };
GlobalValue.prototype.compareTo = function(other) {
  if ($eq(other, this)) {
    return 0;
  }
  else if (this.dependencies.indexOf(other) >= 0) {
    return 1;
  }
  else if (other.dependencies.indexOf(this) >= 0) {
    return -1;
  }
  else if (this.dependencies.length > other.dependencies.length) {
    return 1;
  }
  else if (this.dependencies.length < other.dependencies.length) {
    return -1;
  }
  else if (this.name == null && other.name != null) {
    return 1;
  }
  else if (this.name != null && other.name == null) {
    return -1;
  }
  else if (this.name != null) {
    return this.name.compareTo(other.name);
  }
  else {
    return this.field.name.compareTo(other.field.name);
  }
}
GlobalValue.prototype.compareTo$1 = GlobalValue.prototype.compareTo;
// ********** Code for BareValue **************
function BareValue(home, outermost, span) {
  this.home = home;
  // Initializers done
  Value.call(this, outermost.method.declaringType, null, span, false);
  this.isType = outermost.get$isStatic();
}
$inherits(BareValue, Value);
BareValue.prototype.get$type = function() {
  return this._type;
}
BareValue.prototype._ensureCode = function() {
  if (this.code != null) return;
  if (this.isType) {
    this.code = this.get$type().get$jsname();
  }
  else {
    this.code = this.home._makeThisCode();
  }
}
BareValue.prototype._tryResolveMember = function(context, name) {
  var member = this.get$type().resolveMember(name);
  if (member != null) {
    if ($globals.options.forceDynamic && !member.get$isStatic()) {
      member = context.findMembers(name);
    }
    this._ensureCode();
    return member;
  }
  member = this.home.get$library().lookup(name, this.span);
  if (member != null) {
    return member;
  }
  this._ensureCode();
  return null;
}
// ********** Code for CompilerException **************
function CompilerException(_message, _location) {
  this._message = _message;
  this._location = _location;
  // Initializers done
}
CompilerException.prototype.toString = function() {
  if (this._location != null) {
    return ('CompilerException: ' + this._location.toMessageString(this._message));
  }
  else {
    return ('CompilerException: ' + this._message);
  }
}
CompilerException.prototype.toString$0 = CompilerException.prototype.toString;
// ********** Code for World **************
function World(files) {
  this.errors = 0
  this.warnings = 0
  this.dartBytesRead = 0
  this.jsBytesWritten = 0
  this.seenFatal = false
  this.files = files;
  this.libraries = new HashMapImplementation();
  this._todo = [];
  this._members = new HashMapImplementation();
  this._topNames = new HashMapImplementation();
  this.reader = new LibraryReader();
  // Initializers done
}
World.prototype.get$coreimpl = function() {
  return this.libraries.$index('dart:coreimpl');
}
World.prototype.get$dom = function() {
  return this.libraries.$index('dart:dom');
}
World.prototype.get$functionType = function() { return this.functionType; };
World.prototype.set$functionType = function(value) { return this.functionType = value; };
World.prototype.init = function() {
  this.corelib = new Library(this.readFile('dart:core'));
  this.libraries.$setindex('dart:core', this.corelib);
  this._todo.add(this.corelib);
  this.voidType = this._addToCoreLib('void', false);
  this.dynamicType = this._addToCoreLib('Dynamic', false);
  this.varType = this.dynamicType;
  this.objectType = this._addToCoreLib('Object', true);
  this.numType = this._addToCoreLib('num', false);
  this.intType = this._addToCoreLib('int', false);
  this.doubleType = this._addToCoreLib('double', false);
  this.boolType = this._addToCoreLib('bool', false);
  this.stringType = this._addToCoreLib('String', false);
  this.listType = this._addToCoreLib('List', false);
  this.mapType = this._addToCoreLib('Map', false);
  this.functionType = this._addToCoreLib('Function', false);
  this.nonNullBool = new NonNullableType(this.boolType);
}
World.prototype._addMember = function(member) {
  if (member.get$isStatic()) {
    if (member.declaringType.get$isTop()) {
      this._addTopName(member);
    }
    return;
  }
  var mset = this._members.$index(member.name);
  if (mset == null) {
    mset = new MemberSet(member, true);
    this._members.$setindex(mset.get$name(), mset);
  }
  else {
    mset.get$members().add$1(member);
  }
}
World.prototype._addTopName = function(named) {
  var existing = this._topNames.$index(named.get$jsname());
  if (existing != null) {
    this.info(('mangling matching top level name "' + named.get$jsname() + '" in ') + ('both "' + named.get$library().get$jsname() + '" and "' + existing.get$library().get$jsname() + '"'));
    if (named.get$isNative()) {
      if (existing.get$isNative()) {
        $globals.world.internalError(('conflicting native names "' + named.get$jsname() + '" ') + ('(already defined in ' + existing.get$span().get$locationText() + ')'), named.get$span());
      }
      else {
        this._topNames.$setindex(named.get$jsname(), named);
        this._addJavascriptTopName(existing);
      }
    }
    else if (named.get$library().get$isCore()) {
      if (existing.get$library().get$isCore()) {
        $globals.world.internalError(('conflicting top-level names in core "' + named.get$jsname() + '" ') + ('(previously defined in ' + existing.get$span().get$locationText() + ')'), named.get$span());
      }
      else {
        this._topNames.$setindex(named.get$jsname(), named);
        this._addJavascriptTopName(existing);
      }
    }
    else {
      this._addJavascriptTopName(named);
    }
  }
  else {
    this._topNames.$setindex(named.get$jsname(), named);
  }
}
World.prototype._addJavascriptTopName = function(named) {
  named._jsname = ('' + named.get$library().get$jsname() + '_' + named.get$jsname());
  var existing = this._topNames.$index(named.get$jsname());
  if (existing != null && $ne(existing, named)) {
    $globals.world.internalError(('name mangling failed for "' + named.get$jsname() + '" ') + ('("' + named.get$jsname() + '" defined also in ' + existing.get$span().get$locationText() + ')'), named.get$span());
  }
  this._topNames.$setindex(named.get$jsname(), named);
}
World.prototype._addType = function(type) {
  if (!type.get$isTop()) this._addTopName(type);
}
World.prototype._addToCoreLib = function(name, isClass) {
  var ret = new DefinedType(name, this.corelib, null, isClass);
  this.corelib.types.$setindex(name, ret);
  return ret;
}
World.prototype.toJsIdentifier = function(name) {
  if (name == null) return null;
  if (this._jsKeywords == null) {
    this._jsKeywords = HashSetImplementation.HashSetImplementation$from$factory(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof', 'new', 'return', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'class', 'enum', 'export', 'extends', 'import', 'super', 'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield', 'native']);
  }
  if (this._jsKeywords.contains(name)) {
    return name + '_';
  }
  else {
    return name.replaceAll("$", "$$").replaceAll(':', "$");
  }
}
World.prototype.compile = function() {
  if ($globals.options.dartScript == null) {
    this.fatal('no script provided to compile');
    return false;
  }
  try {
    this.info(('compiling ' + $globals.options.dartScript + ' with corelib ' + this.corelib));
    if (!this.runLeg()) this.runCompilationPhases();
  } catch (exc) {
    exc = _toDartException(exc);
    if (this.get$hasErrors() && !$globals.options.throwOnErrors) {
    }
    else {
      throw exc;
    }
  }
  this.printStatus();
  return !this.get$hasErrors();
}
World.prototype.runLeg = function() {
  var $this = this; // closure support
  if (!$globals.options.enableLeg) return false;
  if ($globals.legCompile == null) {
    this.fatal('requested leg enabled, but no leg compiler available');
  }
  var res = this.withTiming('try leg compile', (function () {
    return $globals.legCompile($this);
  })
  );
  if (!res && $globals.options.legOnly) {
    this.fatal(("Leg could not compile " + $globals.options.dartScript));
    return true;
  }
  return res;
}
World.prototype.runCompilationPhases = function() {
  var $this = this; // closure support
  var lib = this.withTiming('first pass', (function () {
    return $this.processDartScript();
  })
  );
  this.withTiming('resolve top level', this.get$resolveAll());
  if ($globals.experimentalAwaitPhase != null) {
    this.withTiming('await translation', to$call$0($globals.experimentalAwaitPhase));
  }
  this.withTiming('generate code', (function () {
    $this.generateCode(lib);
  })
  );
}
World.prototype.getGeneratedCode = function() {
  if (this.legCode != null) {
    return this.legCode;
  }
  else {
    return this.gen.writer.get$text();
  }
}
World.prototype.readFile = function(filename) {
  try {
    var sourceFile = this.reader.readFile(filename);
    this.dartBytesRead += sourceFile.get$text().length;
    return sourceFile;
  } catch (e) {
    e = _toDartException(e);
    this.warning(('Error reading file: ' + filename));
    return new SourceFile(filename, '');
  }
}
World.prototype.getOrAddLibrary = function(filename) {
  var library = this.libraries.$index(filename);
  if (library == null) {
    library = new Library(this.readFile(filename));
    this.info(('read library ' + filename));
    if (!library.get$isCore() && !library.imports.some((function (li) {
      return li.get$library().get$isCore();
    })
    )) {
      library.imports.add(new LibraryImport(this.corelib));
    }
    this.libraries.$setindex(filename, library);
    this._todo.add(library);
  }
  return library;
}
World.prototype.process = function() {
  while (this._todo.length > 0) {
    var todo = this._todo;
    this._todo = [];
    for (var $$i = 0;$$i < todo.length; $$i++) {
      var lib = todo.$index($$i);
      lib.visitSources$0();
    }
  }
}
World.prototype.processDartScript = function(script) {
  if (script == null) script = $globals.options.dartScript;
  var library = this.getOrAddLibrary(script);
  this.process();
  return library;
}
World.prototype.resolveAll = function() {
  var $$list = this.libraries.getValues();
  for (var $$i = this.libraries.getValues().iterator$0(); $$i.hasNext$0(); ) {
    var lib = $$i.next$0();
    lib.resolve$0();
  }
}
World.prototype.get$resolveAll = function() {
  return World.prototype.resolveAll.bind(this);
}
World.prototype.generateCode = function(lib) {
  var mainMembers = lib.topType.resolveMember('main');
  var main = null;
  if (mainMembers == null || $eq(mainMembers.get$members().length, 0)) {
    this.fatal('no main method specified');
  }
  else if (mainMembers.get$members().length > 1) {
    var $$list = mainMembers.get$members();
    for (var $$i = mainMembers.get$members().iterator$0(); $$i.hasNext$0(); ) {
      var m = $$i.next$0();
      main = m;
      this.error('more than one main member (using last?)', main.get$span());
    }
  }
  else {
    main = mainMembers.get$members().$index(0);
  }
  var codeWriter = new CodeWriter();
  this.gen = new WorldGenerator(main, codeWriter);
  this.gen.run();
  this.jsBytesWritten = codeWriter.get$text().length;
}
World.prototype._message = function(color, prefix, message, span, span1, span2, throwing) {
  if (this.messageHandler != null) {
    this.messageHandler(prefix, message, span);
    if (span1 != null) {
      this.messageHandler(prefix, message, span1);
    }
    if (span2 != null) {
      this.messageHandler(prefix, message, span2);
    }
  }
  var messageWithPrefix = $globals.options.useColors ? (color + prefix + $globals._NO_COLOR + message) : (prefix + message);
  var text = messageWithPrefix;
  if (span != null) {
    text = span.toMessageString(messageWithPrefix);
  }
  print(text);
  if (span1 != null) {
    print(span1.toMessageString(messageWithPrefix));
  }
  if (span2 != null) {
    print(span2.toMessageString(messageWithPrefix));
  }
  if (throwing) {
    $throw(new CompilerException(messageWithPrefix, span));
  }
}
World.prototype.error = function(message, span, span1, span2) {
  this.errors++;
  this._message($globals._RED_COLOR, 'error: ', message, span, span1, span2, $globals.options.throwOnErrors);
}
World.prototype.warning = function(message, span, span1, span2) {
  if ($globals.options.warningsAsErrors) {
    this.error(message, span, span1, span2);
    return;
  }
  this.warnings++;
  if ($globals.options.showWarnings) {
    this._message($globals._MAGENTA_COLOR, 'warning: ', message, span, span1, span2, $globals.options.throwOnWarnings);
  }
}
World.prototype.fatal = function(message, span, span1, span2) {
  this.errors++;
  this.seenFatal = true;
  this._message($globals._RED_COLOR, 'fatal: ', message, span, span1, span2, $globals.options.throwOnFatal || $globals.options.throwOnErrors);
}
World.prototype.internalError = function(message, span, span1, span2) {
  this._message($globals._NO_COLOR, 'We are sorry, but...', message, span, span1, span2, true);
}
World.prototype.info = function(message, span, span1, span2) {
  if ($globals.options.showInfo) {
    this._message($globals._GREEN_COLOR, 'info: ', message, span, span1, span2, false);
  }
}
World.prototype.withoutForceDynamic = function(fn) {
  var oldForceDynamic = $globals.options.forceDynamic;
  $globals.options.forceDynamic = false;
  try {
    return fn();
  } finally {
    $globals.options.forceDynamic = oldForceDynamic;
  }
}
World.prototype.get$hasErrors = function() {
  return this.errors > 0;
}
World.prototype.printStatus = function() {
  this.info(('compiled ' + this.dartBytesRead + ' bytes Dart -> ' + this.jsBytesWritten + ' bytes JS'));
  if (this.get$hasErrors()) {
    print(('compilation failed with ' + this.errors + ' errors'));
  }
  else {
    if (this.warnings > 0) {
      this.info(('compilation completed successfully with ' + this.warnings + ' warnings'));
    }
    else {
      this.info('compilation completed sucessfully');
    }
  }
}
World.prototype.withTiming = function(name, f) {
  var sw = new StopwatchImplementation();
  sw.start();
  var result = f();
  sw.stop();
  this.info(('' + name + ' in ' + sw.elapsedInMs() + 'msec'));
  return result;
}
// ********** Code for FrogOptions **************
function FrogOptions(homedir, args, files) {
  this.config = 'dev'
  this.enableLeg = false
  this.legOnly = false
  this.enableAsserts = false
  this.enableTypeChecks = false
  this.warningsAsErrors = false
  this.verifyImplements = false
  this.compileAll = false
  this.forceDynamic = false
  this.dietParse = false
  this.compileOnly = false
  this.throwOnErrors = false
  this.throwOnWarnings = false
  this.throwOnFatal = false
  this.showInfo = false
  this.showWarnings = true
  this.useColors = true
  // Initializers done
  if ($eq(this.config, 'dev')) {
    this.libDir = joinPaths(homedir, '/lib');
  }
  else if ($eq(this.config, 'sdk')) {
    this.libDir = joinPaths(homedir, '/../lib');
  }
  else {
    $globals.world.error(('Invalid configuration ' + this.config));
    $throw(('Invalid configuration'));
  }
  var ignoreUnrecognizedFlags = false;
  var passedLibDir = false;
  this.childArgs = [];
  loop:
  for (var i = 2;
   i < args.length; i++) {
    var arg = args.$index(i);
    switch (arg) {
      case '--enable_leg':

        this.enableLeg = true;
        break;

      case '--leg_only':

        this.enableLeg = true;
        this.legOnly = true;
        break;

      case '--enable_asserts':

        this.enableAsserts = true;
        break;

      case '--enable_type_checks':

        this.enableTypeChecks = true;
        this.enableAsserts = true;
        break;

      case '--verify_implements':

        this.verifyImplements = true;
        break;

      case '--compile_all':

        this.compileAll = true;
        break;

      case '--diet-parse':

        this.dietParse = true;
        break;

      case '--ignore-unrecognized-flags':

        ignoreUnrecognizedFlags = true;
        break;

      case '--verbose':

        this.showInfo = true;
        break;

      case '--suppress_warnings':

        this.showWarnings = false;
        break;

      case '--warnings_as_errors':

        this.warningsAsErrors = true;
        break;

      case '--throw_on_errors':

        this.throwOnErrors = true;
        break;

      case '--throw_on_warnings':

        this.throwOnWarnings = true;
        break;

      case '--compile-only':

        this.compileOnly = true;
        break;

      case '--force_dynamic':

        this.forceDynamic = true;
        break;

      case '--no_colors':

        this.useColors = false;
        break;

      default:

        if (arg.endsWith$1('.dart')) {
          this.dartScript = arg;
          this.childArgs = args.getRange(i + 1, args.length - i - 1);
          break loop;
        }
        else if (arg.startsWith$1('--out=')) {
          this.outfile = arg.substring$1('--out='.length);
        }
        else if (arg.startsWith$1('--libdir=')) {
          this.libDir = arg.substring$1('--libdir='.length);
          passedLibDir = true;
        }
        else {
          if (!ignoreUnrecognizedFlags) {
            print(('unrecognized flag: "' + arg + '"'));
          }
        }

    }
  }
  if (!passedLibDir && $eq(this.config, 'dev') && !files.fileExists(this.libDir)) {
    var temp = 'frog/lib';
    if (files.fileExists(temp)) {
      this.libDir = temp;
    }
    else {
      this.libDir = 'lib';
    }
  }
}
// ********** Code for LibraryReader **************
function LibraryReader() {
  // Initializers done
  if ($eq($globals.options.config, 'dev')) {
    this._specialLibs = _map(['dart:core', joinPaths($globals.options.libDir, 'corelib.dart'), 'dart:coreimpl', joinPaths($globals.options.libDir, 'corelib_impl.dart'), 'dart:html', joinPaths($globals.options.libDir, '../../client/html/release/html.dart'), 'dart:htmlimpl', joinPaths($globals.options.libDir, '../../client/html/release/htmlimpl.dart'), 'dart:dom', joinPaths($globals.options.libDir, '../../client/dom/frog/frog_dom.dart'), 'dart:json', joinPaths($globals.options.libDir, 'json.dart')]);
  }
  else if ($eq($globals.options.config, 'sdk')) {
    this._specialLibs = _map(['dart:core', joinPaths($globals.options.libDir, 'core/core_frog.dart'), 'dart:coreimpl', joinPaths($globals.options.libDir, 'coreimpl/coreimpl_frog.dart'), 'dart:html', joinPaths($globals.options.libDir, 'html/html.dart'), 'dart:htmlimpl', joinPaths($globals.options.libDir, 'htmlimpl/htmlimpl.dart'), 'dart:dom', joinPaths($globals.options.libDir, 'dom/frog/frog_dom.dart'), 'dart:json', joinPaths($globals.options.libDir, 'json/json_frog.dart')]);
  }
  else {
    $globals.world.error(('Invalid configuration ' + $globals.options.config));
  }
}
LibraryReader.prototype.readFile = function(fullname) {
  var filename = this._specialLibs.$index(fullname);
  if (filename == null) {
    filename = fullname;
  }
  if ($globals.world.files.fileExists(filename)) {
    return new SourceFile(filename, $globals.world.files.readAll(filename));
  }
  else {
    $globals.world.error(('File not found: ' + filename));
    return new SourceFile(filename, '');
  }
}
// ********** Code for VarMember **************
function VarMember(name) {
  this.name = name;
  // Initializers done
}
VarMember.prototype.get$name = function() { return this.name; };
VarMember.prototype.get$returnType = function() {
  return $globals.world.varType;
}
VarMember.prototype.invoke = function(context, node, target, args) {
  return new Value(this.get$returnType(), ('' + target.code + '.' + this.name + '(' + args.getCode() + ')'), node.span, true);
}
VarMember.prototype.generate$1 = VarMember.prototype.generate;
VarMember.prototype.invoke$4 = VarMember.prototype.invoke;
// ********** Code for VarFunctionStub **************
function VarFunctionStub(name, callArgs) {
  this.args = callArgs.toCallStubArgs();
  // Initializers done
  VarMember.call(this, name);
  $globals.world.gen.corejs.useGenStub = true;
}
$inherits(VarFunctionStub, VarMember);
VarFunctionStub.prototype.generate = function(code) {
  if (this.args.get$hasNames()) {
    this.generateNamed(code);
  }
  else {
    this.generatePositional(code);
  }
}
VarFunctionStub.prototype.generatePositional = function(w) {
  var arity = this.args.get$length();
  w.enterBlock(('Function.prototype.to\$' + this.name + ' = function() {'));
  w.writeln(('this.' + this.name + ' = this.\$genStub(' + arity + ');'));
  w.writeln(('this.to\$' + this.name + ' = function() { return this.' + this.name + '; };'));
  w.writeln(('return this.' + this.name + ';'));
  w.exitBlock('};');
  var argsCode = this.args.getCode();
  w.enterBlock(('Function.prototype.' + this.name + ' = function(' + argsCode + ') {'));
  w.writeln(('return this.to\$' + this.name + '()(' + argsCode + ');'));
  w.exitBlock('};');
  w.writeln(('function to\$' + this.name + '(f) { return f && f.to\$' + this.name + '(); }'));
}
VarFunctionStub.prototype.generateNamed = function(w) {
  var named = Strings.join(this.args.getNames(), '", "');
  var argsCode = this.args.getCode();
  w.enterBlock(('Function.prototype.' + this.name + ' = function(' + argsCode + ') {'));
  w.writeln(('this.' + this.name + ' = this.\$genStub(' + this.args.get$length() + ', ["' + named + '"]);'));
  w.writeln(('return this.' + this.name + '(' + argsCode + ');'));
  w.exitBlock('}');
}
VarFunctionStub.prototype.generate$1 = VarFunctionStub.prototype.generate;
// ********** Code for VarMethodStub **************
function VarMethodStub(name, member, args, body) {
  this.member = member;
  this.args = args;
  this.body = body;
  // Initializers done
  VarMember.call(this, name);
}
$inherits(VarMethodStub, VarMember);
VarMethodStub.prototype.get$body = function() { return this.body; };
VarMethodStub.prototype.get$isHidden = function() {
  return this.member != null ? this.member.declaringType.get$isHiddenNativeType() : false;
}
VarMethodStub.prototype.get$returnType = function() {
  return this.member != null ? this.member.get$returnType() : $globals.world.varType;
}
VarMethodStub.prototype.get$declaringType = function() {
  return this.member != null ? this.member.declaringType : $globals.world.objectType;
}
VarMethodStub.prototype.generate = function(code) {
  code.write($globals.world.gen._prototypeOf(this.get$declaringType(), this.name) + ' = ');
  if (!this.get$isHidden() && this._useDirectCall(this.args)) {
    code.writeln($globals.world.gen._prototypeOf(this.get$declaringType(), this.member.get$jsname()) + ';');
  }
  else if (this._needsExactTypeCheck()) {
    code.enterBlock(('function(' + this.args.getCode() + ') {'));
    code.enterBlock(('if (Object.getPrototypeOf(this).hasOwnProperty("' + this.name + '")) {'));
    code.writeln(('' + this.body + ';'));
    code.exitBlock('}');
    var argsCode = this.args.getCode();
    if (argsCode != '') argsCode = ', ' + argsCode;
    code.writeln(('return Object.prototype.' + this.name + '.call(this' + argsCode + ');'));
    code.exitBlock('};');
  }
  else {
    code.enterBlock(('function(' + this.args.getCode() + ') {'));
    code.writeln(('' + this.body + ';'));
    code.exitBlock('};');
  }
}
VarMethodStub.prototype._needsExactTypeCheck = function() {
  var $this = this; // closure support
  if (this.member == null || this.member.declaringType.get$isObject()) return false;
  var members = this.member.declaringType.resolveMember(this.member.name).members;
  return members.filter$1((function (m) {
    return $ne(m, $this.member) && m.get$declaringType().get$isHiddenNativeType();
  })
  ).length >= 1;
}
VarMethodStub.prototype._useDirectCall = function(args) {
  if ((this.member instanceof MethodMember) && !this.member.declaringType.get$hasNativeSubtypes()) {
    var method = this.member;
    if (method.needsArgumentConversion(args)) {
      return false;
    }
    for (var i = args.get$length();
     i < method.parameters.length; i++) {
      if ($ne(method.parameters.$index(i).get$value().get$code(), 'null')) {
        return false;
      }
    }
    return method.namesInOrder(args);
  }
  else {
    return false;
  }
}
VarMethodStub.prototype.generate$1 = VarMethodStub.prototype.generate;
// ********** Code for VarMethodSet **************
function VarMethodSet(baseName, name, members, callArgs, returnType) {
  this.invoked = false
  this.baseName = baseName;
  this.members = members;
  this.returnType = returnType;
  this.args = callArgs.toCallStubArgs();
  // Initializers done
  VarMember.call(this, name);
}
$inherits(VarMethodSet, VarMember);
VarMethodSet.prototype.get$members = function() { return this.members; };
VarMethodSet.prototype.get$returnType = function() { return this.returnType; };
VarMethodSet.prototype.invoke = function(context, node, target, args) {
  this._invokeMembers(context, node);
  return VarMember.prototype.invoke.call(this, context, node, target, args);
}
VarMethodSet.prototype._invokeMembers = function(context, node) {
  if (this.invoked) return;
  this.invoked = true;
  var hasObjectType = false;
  var $$list = this.members;
  for (var $$i = 0;$$i < $$list.length; $$i++) {
    var member = $$list.$index($$i);
    var type = member.get$declaringType();
    var target = new Value(type, 'this', node.span, true);
    var result = member.invoke$4$isDynamic(context, node, target, this.args, true);
    var stub = new VarMethodStub(this.name, member, this.args, 'return ' + result.get$code());
    type.get$varStubs().$setindex(stub.get$name(), stub);
    if (type.get$isObject()) hasObjectType = true;
  }
  if (!hasObjectType) {
    var target = new Value($globals.world.objectType, 'this', node.span, true);
    var result = target.invokeNoSuchMethod(context, this.baseName, node, this.args);
    var stub = new VarMethodStub(this.name, null, this.args, 'return ' + result.get$code());
    $globals.world.objectType.varStubs.$setindex(stub.get$name(), stub);
  }
}
VarMethodSet.prototype.generate = function(code) {

}
VarMethodSet.prototype.generate$1 = VarMethodSet.prototype.generate;
VarMethodSet.prototype.invoke$4 = VarMethodSet.prototype.invoke;
// ********** Code for top level **************
function map(source, mapper) {
  var result = new ListFactory();
  if (!!(source && source.is$List())) {
    var list = source;
    result.length = list.length;
    for (var i = 0;
     i < list.length; i++) {
      result.$setindex(i, mapper(list.$index(i)));
    }
  }
  else {
    for (var $$i = source.iterator(); $$i.hasNext$0(); ) {
      var item = $$i.next$0();
      result.add(mapper(item));
    }
  }
  return result;
}
function reduce(source, callback, initialValue) {
  var i = source.iterator();
  var current = initialValue;
  if (current == null && i.hasNext$0()) {
    current = i.next$0();
  }
  while (i.hasNext$0()) {
    current = callback.call$2(current, i.next$0());
  }
  return current;
}
function orderValuesByKeys(map) {
  var keys = map.getKeys();
  keys.sort((function (x, y) {
    return x.compareTo$1(y);
  })
  );
  var values = [];
  for (var $$i = 0;$$i < keys.length; $$i++) {
    var k = keys.$index($$i);
    values.add(map.$index(k));
  }
  return values;
}
function isMultilineString(text) {
  return text.startsWith('"""') || text.startsWith("'''");
}
function isRawMultilineString(text) {
  return text.startsWith('@"""') || text.startsWith("@'''");
}
function toDoubleQuote(s) {
  return s.replaceAll('"', '\\"').replaceAll("\\'", "'");
}
function parseStringLiteral(lit) {
  if (lit.startsWith('@')) {
    if (isRawMultilineString(lit)) {
      return stripLeadingNewline(lit.substring(4, lit.length - 3));
    }
    else {
      return lit.substring(2, lit.length - 1);
    }
  }
  else if (isMultilineString(lit)) {
    lit = lit.substring(3, lit.length - 3).replaceAll('\\\$', '\$');
    return stripLeadingNewline(lit);
  }
  else {
    return lit.substring(1, lit.length - 1).replaceAll('\\\$', '\$');
  }
}
function stripLeadingNewline(text) {
  if (text.startsWith('\n')) {
    return text.substring(1);
  }
  else if (text.startsWith('\r')) {
    if (text.startsWith('\r\n')) {
      return text.substring(2);
    }
    else {
      return text.substring(1);
    }
  }
  else {
    return text;
  }
}
function _escapeForComment(text) {
  return text.replaceAll('/*', '/ *').replaceAll('*/', '* /');
}
var world;
var experimentalAwaitPhase;
var legCompile;
function initializeWorld(files) {
  $globals.world = new World(files);
  $globals.world.init();
}
function compile(homedir, args, files) {
  parseOptions(homedir, args, files);
  initializeWorld(files);
  var success = $globals.world.compile();
  if ($globals.options.outfile != null) {
    if (success) {
      var code = $globals.world.getGeneratedCode();
      if (!$globals.options.outfile.endsWith('.js')) {
        code = '#!/usr/bin/env node\n' + code;
      }
      $globals.world.files.writeString($globals.options.outfile, code);
    }
    else {
      $globals.world.files.writeString($globals.options.outfile, "throw 'Sorry, but I could not generate reasonable code to run.\\n';");
    }
  }
  return success;
}
var options;
function parseOptions(homedir, args, files) {
  $globals.options = new FrogOptions(homedir, args, files);
}
function _getCallStubName(name, args) {
  var nameBuilder = new StringBufferImpl(('' + name + '\$' + args.get$bareCount()));
  for (var i = args.get$bareCount();
   i < args.get$length(); i++) {
    nameBuilder.add('\$').add(args.getName(i));
  }
  return nameBuilder.toString();
}
//  ********** Library minfrog **************
// ********** Code for top level **************
function main() {
  var homedir = path.dirname(fs.realpathSync(process.argv.$index(1)));
  var argv = ListFactory.ListFactory$from$factory(process.argv);
  if (compile(homedir, argv, new NodeFileSystem())) {
    var code = $globals.world.getGeneratedCode();
    if ($globals.options.compileOnly) {
      if ($globals.options.outfile != null) {
        print(('Compilation succeded. Code generated in: ' + $globals.options.outfile));
      }
      else {
        print('Compilation succeded.');
      }
    }
    else {
      process.argv = [argv.$index(0), argv.$index(1)];
      process.argv.addAll($globals.options.childArgs);
      vm.runInNewContext(code, createSandbox());
    }
  }
  else {
    process.exit(1);
  }
}
// ********** Generic Type Inheritance **************
/** Implements extends for generic types. */
function $inheritsMembers(child, parent) {
  child = child.prototype;
  parent = parent.prototype;
  Object.getOwnPropertyNames(parent).forEach(function(name) {
    if (typeof(child[name]) == 'undefined') child[name] = parent[name];
  });
}
$inheritsMembers(_DoubleLinkedQueueEntrySentinel_E, DoubleLinkedQueueEntry_E);
$inheritsMembers(_DoubleLinkedQueueEntrySentinel_KeyValuePair_K$V, DoubleLinkedQueueEntry_KeyValuePair_K$V);
//  ********** Globals **************
function $static_init(){
  $globals._GREEN_COLOR = '\u001b[32m';
  $globals._MAGENTA_COLOR = '\u001b[35m';
  $globals._NO_COLOR = '\u001b[0m';
  $globals._RED_COLOR = '\u001b[31m';
}
var const$0 = new NoMoreElementsException()/*const NoMoreElementsException()*/;
var const$2 = new EmptyQueueException()/*const EmptyQueueException()*/;
var const$3 = new _DeletedKeySentinel()/*const _DeletedKeySentinel()*/;
var $globals = {};
$static_init();
main();
