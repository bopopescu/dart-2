#!/usr/bin/env node
//  ********** Library dart:core **************
//  ********** Natives core.js **************
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jimhug): Completeness - see tests/corelib

/** Implements extends for dart classes on javascript prototypes. */
function $inherits(child, parent) {
  if (child.prototype.__proto__) {
    child.prototype.__proto__ = parent.prototype;
  } else {
    function tmp() {};
    tmp.prototype = parent.prototype;
    child.prototype = new tmp();
    child.prototype.constructor = child;
  }
}

// Note: we do $add(x, y) instead of x.$add(y) so it doesn't box.
// Same idea for the other methods.
function $add(x, y) {
  return ((typeof(x) == 'number' && typeof(y) == 'number') ||
          (typeof(x) == 'string' && typeof(y) == 'string'))
    ? x + y : x.$add(y);
}

function $bit_not(x) {
  return (typeof(x) == 'number') ? ~x : x.$bit_not();
}

function $negate(x) {
  return (typeof(x) == 'number') ? -x : x.$negate();
}

function $ne(x, y) {
  if (x == null) return y != null;
  return (typeof(x) == 'number' && typeof(y) == 'number') ||
         (typeof(x) == 'boolean' && typeof(y) == 'boolean') ||
         (typeof(x) == 'string' && typeof(y) == 'string')
    ? x != y : !x.$eq(y);
}

function $eq(x, y) {
  if (x == null) return y == null;
  return (typeof(x) == 'number' && typeof(y) == 'number') ||
         (typeof(x) == 'boolean' && typeof(y) == 'boolean') ||
         (typeof(x) == 'string' && typeof(y) == 'string')
    ? x == y : x.$eq(y);
}

function $truncdiv(x, y) {
  if (typeof(x) == 'number' && typeof(y) == 'number') {
    if (y == 0) throw new IntegerDivisionByZeroException();
    var tmp = x / y;
    return (tmp < 0) ? Math.ceil(tmp) : Math.floor(tmp);
  } else {
    return x.$truncdiv(y);
  }
}


function $bit_or(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x | y : x.$bit_or(y);
}
function $bit_xor(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x ^ y : x.$bit_xor(y);
}
function $bit_and(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x & y : x.$bit_and(y);
}
function $shl(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x << y : x.$shl(y);
}
function $sar(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x >> y : x.$sar(y);
}
function $shr(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x >>> y : x.$shr(y);
}
function $sub(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x - y : x.$sub(y);
}
function $mul(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x * y : x.$mul(y);
}
function $div(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x / y : x.$div(y);
}

function $mod(x, y) {
  if (typeof(x) == 'number' && typeof(y) == 'number') {
    var result = x % y;
    if (result == 0) {
      return 0;  // Make sure we don't return -0.0.
    } else if (result < 0) {
      if (y < 0) {
        return result - y;
      } else {
        return result + y;
      }
    }
    return result;
  } else {
    return x.$mod(y);
  }
}

function $lt(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x < y : x.$lt(y);
}
function $gt(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x > y : x.$gt(y);
}
function $lte(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x <= y : x.$lte(y);
}
function $gte(x, y) {
  return (typeof(x) == 'number' && typeof(y) == 'number')
    ? x >= y : x.$gte(y);
}

// TODO(jimhug): Test perf - idea is this speeds up primitives and
//  semi-elegantly handles null - currently unused...
function $toString(o) {
  if (o == null) return 'null';
  var t = typeof(o);
  if (t == 'object') { return o.toString(); }
  else if (t == 'string') { return o; }
  else if (t == 'bool') { return ''+o; }
  else if (t == 'number') { return ''+o; }
  else return o.toString();
}


// If not overridden, $index and $setindex fall back to JS [] and []= accessors
// TODO(jimhug): This fallback could be very confusing in a few cases -
// because of the bizare default [] rules in JS.  We need to revisit this
// to get the right errors - at least in checked mode (once we have that).
Object.prototype.$index = function(i) { return this[i]; }
Object.prototype.$setindex = function(i, value) { return this[i] = value; }

// TODO(jmesserly): do perf analysis, figure out if this is worth it and what
// the cost of $index $setindex is on all browsers
Array.prototype.$index = function(i) { return this[i]; }
Array.prototype.$setindex = function(i, value) { return this[i] = value; }
String.prototype.$index = function(i) { return this[i]; }


// TODO(jimhug): Should this or should it not match equals?
Object.prototype.$eq = function(other) { return this === other; }

function $map(items) {
  var ret = new HashMapImplementation();
  for (var i=0; i < items.length;) {
    ret.$setindex(items[i++], items[i++]);
  }
  return ret;
}

function $assert(test, text, url, line, column) {
  if (typeof test == 'function') test = test();
  if (!test) $throw(new AssertError(text, url, line, column));
}

function $notnull_bool(test) {
  if (test == null || typeof(test) != 'boolean') {
    $throw(new TypeError('must be "true" or "false"'));
  }
  return test === true;
}

function $throw(e) {
  // If e is not a value, we can use V8's captureStackTrace utility method.
  // TODO(jmesserly): capture the stack trace on other JS engines.
  if (e && (typeof e == "object") && Error.captureStackTrace) {
    // TODO(jmesserly): this will clobber the e.stack property
    Error.captureStackTrace(e, $throw);
  }
  throw e;
}

function $stackTraceOf(e) {
  // TODO(jmesserly): we shouldn't be relying on the e.stack property.
  // Need to mangle it.
  return e.stack ? e.stack : null;
}

// Translate a JavaScript exception to a Dart exception
// TODO(jmesserly): cross browser support. This is Chrome specific.
function $toDartException(e) {
  if (e instanceof TypeError) {
    switch(e.type) {
    case "property_not_function":
    case "called_non_callable":
      if (e.arguments[0] == "undefined") {
        return new NullPointerException();
      }
      return new ObjectNotClosureException();
    case "non_object_property_call":
    case "non_object_property_load":
      return new NullPointerException();
    case "undefined_method":
      if (e.arguments[0] == "call" || e.arguments[0] == "apply") {
        return new ObjectNotClosureException();
      }
      // TODO(jmesserly): can this ever happen?
      return new NoSuchMethodException("", e.arguments[0], []);
    }
  } else if (e instanceof RangeError) {
    if (e.message.indexOf('call stack') >= 0) {
      return new StackOverflowException();
    }
  }
  return e;
}

// TODO(jimhug): I can't figure out the quoting rules to put this in
//   StringImplementation correctly <frown>.
function $regexpAllFromString(s) {
  return new RegExp(s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'g');
}

/* TODO(jimhug): Add array bounds checking in checked mode
function $inlineArrayIndexCheck(array, index) {
  if (index >= 0 && index < array.length) {
    return index;
  }
  native__ArrayJsUtil__throwIndexOutOfRangeException(index);
}
*/

/**
 * Generates a dynamic call stub for a function.
 * Our goal is to create a stub method like this on-the-fly:
 *   function($0, $1, capture) { this($0, $1, true, capture); }
 *
 * This stub then replaces the dynamic one on Function, with one that is
 * specialized for that particular function, taking into account its default
 * arguments.
 */
Function.prototype.$genStub = function(argsLength, names) {
  // TODO(jmesserly): only emit $genStub if actually needed

  // Fast path: if no named arguments and arg count matches
  if (this.length == argsLength && !names) {
    return this;
  }

  function $throwArgMismatch() {
    // TODO(jmesserly): better error message
    $throw(new ClosureArgumentMismatchException());
  }

  var paramsNamed = this.$optional ? (this.$optional.length / 2) : 0;
  var paramsBare = this.length - paramsNamed;
  var argsNamed = names ? names.length : 0;
  var argsBare = argsLength - argsNamed;

  // Check we got the right number of arguments
  if (argsBare < paramsBare || argsLength > this.length ||
      argsNamed > paramsNamed) {
    return $throwArgMismatch;
  }

  // First, fill in all of the default values
  var p = new Array(paramsBare);
  if (paramsNamed) {
    p = p.concat(this.$optional.slice(paramsNamed));
  }
  // Fill in positional args
  var a = new Array(argsLength);
  for (var i = 0; i < argsBare; i++) {
    p[i] = a[i] = '$' + i;
  }
  // Then overwrite with supplied values for optional args
  var lastParameterIndex;
  var namesInOrder = true;
  for (var i = 0; i < argsNamed; i++) {
    var name = names[i];
    a[i + argsBare] = name;
    var j = this.$optional.indexOf(name, 0);
    if (j < 0 || j >= paramsNamed) {
      return $throwArgMismatch;
    } else if (lastParameterIndex && lastParameterIndex > j) {
      namesInOrder = false;
    }
    p[j + paramsBare] = name;
    lastParameterIndex = j;
  }

  if (this.length == argsLength && namesInOrder) {
    // Fast path #2: named arguments, but they're in order.
    return this;
  }

  // Note: using Function instead of "eval" to get a clean scope.
  // TODO(jmesserly): evaluate the performance of these stubs.
  var f = 'function(' + a.join(',') + '){return $f(' + p.join(',') + ');}';
  return new Function('$f', 'return ' + f + '').call(null, this);
}

function $varMethod(name, methods) {
  Object.prototype[name] = function() {
    $patchMethod(this, name, methods);
    this[name].apply(this, Array.prototype.slice.call(arguments));
  };
}

Object.prototype.get$typeName = function() {
  // TODO(vsm): how can we make this go down the fast path for Chrome?
  //(for Chrome: return this.constructor.name;)
  var str = Object.prototype.toString.call(this);
  return str.substring(8, str.length - 1);
}

function $patchMethod(obj, name, methods) {
  // Get the prototype to patch.
  // Don't overwrite an existing stub, like the one on Object.prototype
  var proto = Object.getPrototypeOf(obj);
  if (!proto || proto.hasOwnProperty(name)) proto = obj;
  var method;
  while (obj && !(method = methods[obj.get$typeName()])) {
    obj = Object.getPrototypeOf(obj);
  }
  Object.defineProperty(proto, name, {value: method || methods['Object']});
}
// ********** Code for Clock **************
function Clock() {}
Clock.now = function() {
  return new Date().getTime();
}
Clock.frequency = function() {
  return 1000;
}
// ********** Code for AssertError **************
function AssertError(failedAssertion, url, line, column) {
  this.failedAssertion = failedAssertion;
  this.url = url;
  this.line = line;
  this.column = column;
  // Initializers done
}
AssertError.prototype.toString = function() {
  return ("Failed assertion: '" + this.failedAssertion + "' is not true ") + ("in " + this.url + " at line " + this.line + ", column " + this.column + ".");
}
// ********** Code for Object **************
Object.prototype.get$dynamic = function() {
  return this;
}
Object.prototype.noSuchMethod = function(name, args) {
  $throw(new NoSuchMethodException(this, name, args));
}
Object.prototype.forEach$1 = function($0) {
  return this.noSuchMethod("forEach", [$0]);
}
;
Object.prototype.get_$3 = function($0, $1, $2) {
  return this.noSuchMethod("get_", [$0, $1, $2]);
}
;
Object.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("invoke", [$0, $1, $2, $3]);
}
;
Object.prototype.printOn$1 = function($0) {
  return this.noSuchMethod("printOn", [$0]);
}
;
Object.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("set_", [$0, $1, $2, $3]);
}
;
Object.prototype.visitPostfixExpression$1 = function($0) {
  return this.noSuchMethod("visitPostfixExpression", [$0]);
}
;
function $assert_bool(x) {
  if (x == null || typeof(x) == "boolean") return x;
  throw new TypeError("'" + x + "' is not a bool.");
}
// ********** Code for IllegalAccessException **************
function IllegalAccessException() {
  // Initializers done
}
IllegalAccessException.prototype.toString = function() {
  return "Attempt to modify an immutable object";
}
// ********** Code for NoSuchMethodException **************
function NoSuchMethodException(_receiver, _functionName, _arguments) {
  this._receiver = _receiver;
  this._functionName = _functionName;
  this._arguments = _arguments;
  // Initializers done
}
NoSuchMethodException.prototype.toString = function() {
  var sb = new StringBufferImpl("");
  for (var i = 0;
   $notnull_bool(i < this._arguments.length); i++) {
    if ($notnull_bool(i > 0)) {
      sb.add(", ");
    }
    sb.add(this._arguments.$index(i));
  }
  sb.add("]");
  return ("NoSuchMethodException - receiver: '" + this._receiver + "' ") + ("function name: '" + this._functionName + "' arguments: [" + sb + "]");
}
// ********** Code for ObjectNotClosureException **************
function ObjectNotClosureException() {}
ObjectNotClosureException.prototype.toString = function() {
  return "Object is not closure";
}
// ********** Code for StackOverflowException **************
function StackOverflowException() {}
StackOverflowException.prototype.toString = function() {
  return "Stack Overflow";
}
// ********** Code for BadNumberFormatException **************
function BadNumberFormatException() {}
BadNumberFormatException.prototype.toString = function() {
  return ("BadNumberFormatException: '" + this._s + "'");
}
// ********** Code for NullPointerException **************
function NullPointerException() {}
NullPointerException.prototype.toString = function() {
  return "NullPointerException";
}
// ********** Code for NoMoreElementsException **************
function NoMoreElementsException() {
  // Initializers done
}
NoMoreElementsException.prototype.toString = function() {
  return "NoMoreElementsException";
}
// ********** Code for EmptyQueueException **************
function EmptyQueueException() {
  // Initializers done
}
EmptyQueueException.prototype.toString = function() {
  return "EmptyQueueException";
}
// ********** Code for Math **************
Math.parseInt = function(str) {
  var ret = parseInt(str);
    if (isNaN(ret)) $throw(new BadNumberFormatException(str));
    return ret;
}
Math.parseDouble = function(str) {
  var ret = parseFloat(str);
    if (isNaN(ret) && str != 'NaN') $throw(new BadNumberFormatException(str));
    return ret;
}
Math.min = function(a, b) {
  if (a == b) return a;
    if (a < b) {
      if (isNaN(b)) return b;
      else return a;
    }
    if (isNaN(a)) return a;
    else return b;
}
function $assert_num(x) {
  if (x == null || typeof(x) == "number") return x;
  throw new TypeError("'" + x + "' is not a num.");
}
function $assert_String(x) {
  if (x == null || typeof(x) == "string") return x;
  throw new TypeError("'" + x + "' is not a String.");
}
// ********** Code for Strings **************
function Strings() {}
Strings.String$fromCharCodes$factory = function(charCodes) {
  return StringBase.createFromCharCodes(charCodes);
}
Strings.join = function(strings, separator) {
  return StringBase.join(strings, separator);
}
// ********** Code for top level **************
function print(obj) {
  if (typeof console == 'object') {
    if (obj) obj = obj.toString();
    console.log(obj);
  } else {
    write(obj);
    write('\n');
  }
}
//  ********** Library dart:coreimpl **************
// ********** Code for ListFactory **************
ListFactory = Array;
ListFactory.prototype.is$List = function(){return this;};
ListFactory.prototype.is$List$ArgumentNode = function(){return this;};
ListFactory.prototype.is$List$EvaluatedValue = function(){return this;};
ListFactory.prototype.is$List$String = function(){return this;};
ListFactory.prototype.is$List$T = function(){return this;};
ListFactory.prototype.is$List$Value = function(){return this;};
ListFactory.prototype.is$List$int = function(){return this;};
ListFactory.prototype.is$Iterable = function(){return this;};
ListFactory.ListFactory$from$factory = function(other) {
  var $0;
  var list = [];
  for (var $i = other.iterator(); $i.hasNext(); ) {
    var e = $i.next();
    list.add(e);
  }
  return list;
}
ListFactory.prototype.add = function(value) {
  this.push(value);
}
ListFactory.prototype.addLast = function(value) {
  this.push(value);
}
ListFactory.prototype.addAll = function(collection) {
  var $0;
  for (var $i = collection.iterator(); $i.hasNext(); ) {
    var item = $i.next();
    this.add(item);
  }
}
ListFactory.prototype.clear = function() {
  this.length = 0;
}
ListFactory.prototype.removeLast = function() {
  return this.pop();
}
ListFactory.prototype.last = function() {
  return this[this.length - 1];
}
ListFactory.prototype.getRange = function(start, length) {
  return this.slice(start, start + length);
}
ListFactory.prototype.isEmpty = function() {
  return this.length == 0;
}
ListFactory.prototype.iterator = function() {
  return new ListIterator(this);
}
ListFactory.prototype.forEach$1 = ListFactory.prototype.forEach;
ListFactory$DoubleLinkedQueueEntry$KeyValuePair$K$V = ListFactory;
ListFactory$DoubleLinkedQueueEntry$KeyValuePair$String$Keyword = ListFactory;
ListFactory$E = ListFactory;
ListFactory$Element = ListFactory;
ListFactory$EvaluatedValue = ListFactory;
ListFactory$HInstruction = ListFactory;
ListFactory$K = ListFactory;
ListFactory$KeywordState = ListFactory;
ListFactory$String = ListFactory;
ListFactory$T = ListFactory;
ListFactory$Type = ListFactory;
ListFactory$V = ListFactory;
// ********** Code for ListIterator **************
function ListIterator(array) {
  this._array = array;
  this._pos = 0;
  // Initializers done
}
ListIterator.prototype.hasNext = function() {
  return this._array.length > this._pos;
}
ListIterator.prototype.next = function() {
  if ($notnull_bool(!this.hasNext())) {
    $throw(const$0/*const NoMoreElementsException()*/);
  }
  return this._array.$index(this._pos++);
}
// ********** Code for ImmutableList **************
function ImmutableList(length0) {
  this._length = length0;
  ListFactory$E.call(this, length0);
  // Initializers done
}
$inherits(ImmutableList, ListFactory$E);
ImmutableList.ImmutableList$from$factory = function(other) {
  var list = new ImmutableList(other.length);
  for (var i = 0;
   $notnull_bool(i < other.length); i++) {
    list._setindex(i, other.$index(i));
  }
  return list;
}
ImmutableList.prototype.get$length = function() {
  return this._length;
}
ImmutableList.prototype.set$length = function(length0) {
  $throw(const$221/*const IllegalAccessException()*/);
}
Object.defineProperty(ImmutableList.prototype, "length", {
  get: ImmutableList.prototype.get$length,
  set: ImmutableList.prototype.set$length
});
ImmutableList.prototype._setindex = function(index, value) {
  return this[index] = value;
}
ImmutableList.prototype.$setindex = function(index, value) {
  $throw(const$221/*const IllegalAccessException()*/);
}
ImmutableList.prototype.sort = function(compare) {
  $throw(const$221/*const IllegalAccessException()*/);
}
ImmutableList.prototype.add = function(element) {
  $throw(const$221/*const IllegalAccessException()*/);
}
ImmutableList.prototype.addLast = function(element) {
  $throw(const$221/*const IllegalAccessException()*/);
}
ImmutableList.prototype.addAll = function(elements) {
  $throw(const$221/*const IllegalAccessException()*/);
}
ImmutableList.prototype.clear = function() {
  $throw(const$221/*const IllegalAccessException()*/);
}
ImmutableList.prototype.removeLast = function() {
  $throw(const$221/*const IllegalAccessException()*/);
}
// ********** Code for ImmutableMap **************
function ImmutableMap(keyValuePairs) {
  this._internal = $map([]);
  // Initializers done
  for (var i = 0;
   $notnull_bool(i < keyValuePairs.length); i += 2) {
    this._internal.$setindex(keyValuePairs.$index(i), keyValuePairs.$index(i + 1));
  }
}
ImmutableMap.prototype.is$Map = function(){return this;};
ImmutableMap.prototype.$index = function(key) {
  return this._internal.$index(key);
}
ImmutableMap.prototype.isEmpty = function() {
  return this._internal.isEmpty();
}
ImmutableMap.prototype.get$length = function() {
  return this._internal.get$length();
}
Object.defineProperty(ImmutableMap.prototype, "length", {
  get: ImmutableMap.prototype.get$length,
});
ImmutableMap.prototype.forEach = function(f) {
  this._internal.forEach(f);
}
ImmutableMap.prototype.getKeys = function() {
  return this._internal.getKeys();
}
ImmutableMap.prototype.getValues = function() {
  return this._internal.getValues();
}
ImmutableMap.prototype.containsKey = function(key) {
  return this._internal.containsKey(key);
}
ImmutableMap.prototype.$setindex = function(key, value) {
  $throw(const$221/*const IllegalAccessException()*/);
}
ImmutableMap.prototype.clear = function() {
  $throw(const$221/*const IllegalAccessException()*/);
}
ImmutableMap.prototype.forEach$1 = ImmutableMap.prototype.forEach;
// ********** Code for MatchImplementation **************
function MatchImplementation() {}
MatchImplementation.prototype.$index = function(group0) {
  return this._groups.$index(group0);
}
// ********** Code for NumImplementation **************
NumImplementation = Number;
NumImplementation.prototype.isNaN = function() {
  return isNaN(this);
}
NumImplementation.prototype.isNegative = function() {
  return this == 0 ? (1 / this) < 0 : this < 0;
}
NumImplementation.prototype.hashCode = function() {
  return this & 0xFFFFFFF;
}
NumImplementation.prototype.toInt = function() {
  if (isNaN(this)) throw new BadNumberFormatException("NaN");
    if ((this == Infinity) || (this == -Infinity)) {
      throw new BadNumberFormatException("Infinity");
    }
    var truncated = (this < 0) ? Math.ceil(this) : Math.floor(this);

    if (truncated == -0.0) return 0;
    return truncated;
}
NumImplementation.prototype.toDouble = function() {
  return this + 0;
}
NumImplementation.prototype.compareTo = function(other) {
  var thisValue = this.toDouble();
  if ($notnull_bool(thisValue < other)) {
    return -1;
  }
  else if ($notnull_bool(thisValue > other)) {
    return 1;
  }
  else if ($notnull_bool(thisValue == other)) {
    if ($notnull_bool(thisValue == 0)) {
      var thisIsNegative = this.isNegative();
      var otherIsNegative = other.isNegative();
      if ($notnull_bool($eq(thisIsNegative, otherIsNegative))) return 0;
      if ($notnull_bool(thisIsNegative)) return -1;
      return 1;
    }
    return 0;
  }
  else if ($notnull_bool(this.isNaN())) {
    if ($notnull_bool(other.isNaN())) {
      return 0;
    }
    return 1;
  }
  else {
    return -1;
  }
}
// ********** Code for ExceptionImplementation **************
function ExceptionImplementation(_msg) {
  this._msg = _msg;
  // Initializers done
}
ExceptionImplementation.prototype.toString = function() {
  return $notnull_bool((this._msg == null)) ? "Exception" : ("Exception: " + this._msg + "");
}
// ********** Code for HashMapImplementation **************
function HashMapImplementation() {
  // Initializers done
  if ($notnull_bool(HashMapImplementation._deletedKey == null)) {
    HashMapImplementation._deletedKey = new Object();
  }
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory$V(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
HashMapImplementation.prototype.is$Map = function(){return this;};
HashMapImplementation.HashMapImplementation$from$factory = function(other) {
  var result = new HashMapImplementation();
  other.forEach((function (key, value) {
    result.$setindex(key, value);
  })
  );
  return result;
}
HashMapImplementation._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
HashMapImplementation._firstProbe = function(hashCode, length0) {
  return hashCode & (length0 - 1);
}
HashMapImplementation._nextProbe = function(currentProbe, numberOfProbes, length0) {
  return (currentProbe + numberOfProbes) & (length0 - 1);
}
HashMapImplementation.prototype._probeForAdding = function(key) {
  var hash = HashMapImplementation._firstProbe($assert_num(key.hashCode()), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  var insertionIndex = -1;
  while ($notnull_bool(true)) {
    var existingKey = this._keys.$index(hash);
    if ($notnull_bool(existingKey == null)) {
      if ($notnull_bool(insertionIndex < 0)) return hash;
      return insertionIndex;
    }
    else if ($notnull_bool($eq(existingKey, key))) {
      return hash;
    }
    else if ($notnull_bool((insertionIndex < 0) && (HashMapImplementation._deletedKey === existingKey))) {
      insertionIndex = hash;
    }
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation.prototype._probeForLookup = function(key) {
  var hash = HashMapImplementation._firstProbe($assert_num(key.hashCode()), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  while ($notnull_bool(true)) {
    var existingKey = this._keys.$index(hash);
    if ($notnull_bool(existingKey == null)) return -1;
    if ($notnull_bool($eq(existingKey, key))) return hash;
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation.prototype._ensureCapacity = function() {
  var newNumberOfEntries = this._numberOfEntries + 1;
  if ($notnull_bool(newNumberOfEntries >= this._loadLimit)) {
    this._grow(this._keys.length * 2);
    return;
  }
  var capacity = this._keys.length;
  var numberOfFreeOrDeleted = capacity - newNumberOfEntries;
  var numberOfFree = numberOfFreeOrDeleted - this._numberOfDeleted;
  if ($notnull_bool(this._numberOfDeleted > numberOfFree)) {
    this._grow(this._keys.length);
  }
}
HashMapImplementation._isPowerOfTwo = function(x) {
  return ((x & (x - 1)) == 0);
}
HashMapImplementation.prototype._grow = function(newCapacity) {
  $assert(HashMapImplementation._isPowerOfTwo(newCapacity), "_isPowerOfTwo(newCapacity)", "/Users/jimhug/dartfrog/dart/corelib/src/implementation/hash_map_set.dart", 153, 12);
  var capacity = this._keys.length;
  this._loadLimit = HashMapImplementation._computeLoadLimit(newCapacity);
  var oldKeys = this._keys;
  var oldValues = this._values;
  this._keys = new ListFactory(newCapacity);
  this._values = new ListFactory$V(newCapacity);
  for (var i = 0;
   $notnull_bool(i < capacity); i++) {
    var key = oldKeys.$index(i);
    if ($notnull_bool(key == null || key === HashMapImplementation._deletedKey)) {
      continue;
    }
    var value = oldValues.$index(i);
    var newIndex = this._probeForAdding(key);
    this._keys.$setindex(newIndex, key);
    this._values.$setindex(newIndex, value);
  }
  this._numberOfDeleted = 0;
}
HashMapImplementation.prototype.clear = function() {
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  var length0 = this._keys.length;
  for (var i = 0;
   $notnull_bool(i < length0); i++) {
    this._keys.$setindex(i);
    this._values.$setindex(i);
  }
}
HashMapImplementation.prototype.$setindex = function(key, value) {
  this._ensureCapacity();
  var index = this._probeForAdding(key);
  if ($notnull_bool((this._keys.$index(index) == null) || (this._keys.$index(index) === HashMapImplementation._deletedKey))) {
    this._numberOfEntries++;
  }
  this._keys.$setindex(index, key);
  this._values.$setindex(index, value);
}
HashMapImplementation.prototype.$index = function(key) {
  var index = this._probeForLookup(key);
  if ($notnull_bool(index < 0)) return null;
  return this._values.$index(index);
}
HashMapImplementation.prototype.remove = function(key) {
  var index = this._probeForLookup(key);
  if ($notnull_bool(index >= 0)) {
    this._numberOfEntries--;
    var value = this._values.$index(index);
    this._values.$setindex(index);
    this._keys.$setindex(index, HashMapImplementation._deletedKey);
    this._numberOfDeleted++;
    return value;
  }
  return null;
}
HashMapImplementation.prototype.isEmpty = function() {
  return this._numberOfEntries == 0;
}
HashMapImplementation.prototype.get$length = function() {
  return this._numberOfEntries;
}
Object.defineProperty(HashMapImplementation.prototype, "length", {
  get: HashMapImplementation.prototype.get$length,
});
HashMapImplementation.prototype.forEach = function(f) {
  var length0 = this._keys.length;
  for (var i = 0;
   $notnull_bool(i < length0); i++) {
    if ($notnull_bool((this._keys.$index(i) != null) && (this._keys.$index(i) !== HashMapImplementation._deletedKey))) {
      f(this._keys.$index(i), this._values.$index(i));
    }
  }
}
HashMapImplementation.prototype.getKeys = function() {
  var list = new ListFactory$K(this.get$length());
  var i = 0;
  this.forEach(function _(key, value) {
    list.$setindex(i++, key);
  }
  );
  return list;
}
HashMapImplementation.prototype.getValues = function() {
  var list = new ListFactory$V(this.get$length());
  var i = 0;
  this.forEach(function _(key, value) {
    list.$setindex(i++, value);
  }
  );
  return list;
}
HashMapImplementation.prototype.containsKey = function(key) {
  return (this._probeForLookup(key) != -1);
}
HashMapImplementation.prototype.forEach$1 = HashMapImplementation.prototype.forEach;
// ********** Code for HashMapImplementation$E$E **************
function HashMapImplementation$E$E() {
  // Initializers done
  if ($notnull_bool(HashMapImplementation._deletedKey == null)) {
    HashMapImplementation._deletedKey = new Object();
  }
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory$E(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
$inherits(HashMapImplementation$E$E, HashMapImplementation);
HashMapImplementation$E$E.prototype.is$Map = function(){return this;};
HashMapImplementation$E$E._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
HashMapImplementation$E$E._firstProbe = function(hashCode, length0) {
  return hashCode & (length0 - 1);
}
HashMapImplementation$E$E._nextProbe = function(currentProbe, numberOfProbes, length0) {
  return (currentProbe + numberOfProbes) & (length0 - 1);
}
HashMapImplementation$E$E.prototype._probeForAdding = function(key) {
  var hash = HashMapImplementation._firstProbe($assert_num(key.hashCode()), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  var insertionIndex = -1;
  while ($notnull_bool(true)) {
    var existingKey = this._keys.$index(hash);
    if ($notnull_bool(existingKey == null)) {
      if ($notnull_bool(insertionIndex < 0)) return hash;
      return insertionIndex;
    }
    else if ($notnull_bool($eq(existingKey, key))) {
      return hash;
    }
    else if ($notnull_bool((insertionIndex < 0) && (HashMapImplementation._deletedKey === existingKey))) {
      insertionIndex = hash;
    }
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation$E$E.prototype._probeForLookup = function(key) {
  var hash = HashMapImplementation._firstProbe($assert_num(key.hashCode()), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  while ($notnull_bool(true)) {
    var existingKey = this._keys.$index(hash);
    if ($notnull_bool(existingKey == null)) return -1;
    if ($notnull_bool($eq(existingKey, key))) return hash;
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation$E$E.prototype._ensureCapacity = function() {
  var newNumberOfEntries = this._numberOfEntries + 1;
  if ($notnull_bool(newNumberOfEntries >= this._loadLimit)) {
    this._grow(this._keys.length * 2);
    return;
  }
  var capacity = this._keys.length;
  var numberOfFreeOrDeleted = capacity - newNumberOfEntries;
  var numberOfFree = numberOfFreeOrDeleted - this._numberOfDeleted;
  if ($notnull_bool(this._numberOfDeleted > numberOfFree)) {
    this._grow(this._keys.length);
  }
}
HashMapImplementation$E$E._isPowerOfTwo = function(x) {
  return ((x & (x - 1)) == 0);
}
HashMapImplementation$E$E.prototype._grow = function(newCapacity) {
  $assert(HashMapImplementation._isPowerOfTwo(newCapacity), "_isPowerOfTwo(newCapacity)", "/Users/jimhug/dartfrog/dart/corelib/src/implementation/hash_map_set.dart", 153, 12);
  var capacity = this._keys.length;
  this._loadLimit = HashMapImplementation._computeLoadLimit(newCapacity);
  var oldKeys = this._keys;
  var oldValues = this._values;
  this._keys = new ListFactory(newCapacity);
  this._values = new ListFactory$E(newCapacity);
  for (var i = 0;
   $notnull_bool(i < capacity); i++) {
    var key = oldKeys.$index(i);
    if ($notnull_bool(key == null || key === HashMapImplementation._deletedKey)) {
      continue;
    }
    var value = oldValues.$index(i);
    var newIndex = this._probeForAdding(key);
    this._keys.$setindex(newIndex, key);
    this._values.$setindex(newIndex, value);
  }
  this._numberOfDeleted = 0;
}
HashMapImplementation$E$E.prototype.$setindex = function(key, value) {
  this._ensureCapacity();
  var index = this._probeForAdding(key);
  if ($notnull_bool((this._keys.$index(index) == null) || (this._keys.$index(index) === HashMapImplementation._deletedKey))) {
    this._numberOfEntries++;
  }
  this._keys.$setindex(index, key);
  this._values.$setindex(index, value);
}
HashMapImplementation$E$E.prototype.remove = function(key) {
  var index = this._probeForLookup(key);
  if ($notnull_bool(index >= 0)) {
    this._numberOfEntries--;
    var value = this._values.$index(index);
    this._values.$setindex(index);
    this._keys.$setindex(index, HashMapImplementation._deletedKey);
    this._numberOfDeleted++;
    return value;
  }
  return null;
}
HashMapImplementation$E$E.prototype.isEmpty = function() {
  return this._numberOfEntries == 0;
}
HashMapImplementation$E$E.prototype.forEach = function(f) {
  var length0 = this._keys.length;
  for (var i = 0;
   $notnull_bool(i < length0); i++) {
    if ($notnull_bool((this._keys.$index(i) != null) && (this._keys.$index(i) !== HashMapImplementation._deletedKey))) {
      f(this._keys.$index(i), this._values.$index(i));
    }
  }
}
HashMapImplementation$E$E.prototype.getKeys = function() {
  var list = new ListFactory$E(this.get$length());
  var i = 0;
  this.forEach(function _(key, value) {
    list.$setindex(i++, key);
  }
  );
  return list;
}
HashMapImplementation$E$E.prototype.containsKey = function(key) {
  return (this._probeForLookup(key) != -1);
}
// ********** Code for HashMapImplementation$HInstruction$HInstruction **************
function HashMapImplementation$HInstruction$HInstruction() {
  // Initializers done
  if ($notnull_bool(HashMapImplementation._deletedKey == null)) {
    HashMapImplementation._deletedKey = new Object();
  }
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory$HInstruction(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
$inherits(HashMapImplementation$HInstruction$HInstruction, HashMapImplementation);
HashMapImplementation$HInstruction$HInstruction.prototype.is$Map = function(){return this;};
HashMapImplementation$HInstruction$HInstruction._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
// ********** Code for HashMapImplementation$K$DoubleLinkedQueueEntry$KeyValuePair$K$V **************
function HashMapImplementation$K$DoubleLinkedQueueEntry$KeyValuePair$K$V() {
  // Initializers done
  if ($notnull_bool(HashMapImplementation._deletedKey == null)) {
    HashMapImplementation._deletedKey = new Object();
  }
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory$DoubleLinkedQueueEntry$KeyValuePair$K$V(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
$inherits(HashMapImplementation$K$DoubleLinkedQueueEntry$KeyValuePair$K$V, HashMapImplementation);
HashMapImplementation$K$DoubleLinkedQueueEntry$KeyValuePair$K$V.prototype.is$Map = function(){return this;};
HashMapImplementation$K$DoubleLinkedQueueEntry$KeyValuePair$K$V._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
// ********** Code for HashMapImplementation$Node$Element **************
function HashMapImplementation$Node$Element() {
  // Initializers done
  if ($notnull_bool(HashMapImplementation._deletedKey == null)) {
    HashMapImplementation._deletedKey = new Object();
  }
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory$Element(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
$inherits(HashMapImplementation$Node$Element, HashMapImplementation);
HashMapImplementation$Node$Element.prototype.is$Map = function(){return this;};
HashMapImplementation$Node$Element._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
// ********** Code for HashMapImplementation$String$DoubleLinkedQueueEntry$KeyValuePair$String$Keyword **************
function HashMapImplementation$String$DoubleLinkedQueueEntry$KeyValuePair$String$Keyword() {
  // Initializers done
  if ($notnull_bool(HashMapImplementation._deletedKey == null)) {
    HashMapImplementation._deletedKey = new Object();
  }
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory$DoubleLinkedQueueEntry$KeyValuePair$String$Keyword(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
$inherits(HashMapImplementation$String$DoubleLinkedQueueEntry$KeyValuePair$String$Keyword, HashMapImplementation);
HashMapImplementation$String$DoubleLinkedQueueEntry$KeyValuePair$String$Keyword.prototype.is$Map = function(){return this;};
HashMapImplementation$String$DoubleLinkedQueueEntry$KeyValuePair$String$Keyword._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
// ********** Code for HashMapImplementation$String$EvaluatedValue **************
function HashMapImplementation$String$EvaluatedValue() {
  // Initializers done
  if ($notnull_bool(HashMapImplementation._deletedKey == null)) {
    HashMapImplementation._deletedKey = new Object();
  }
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory$EvaluatedValue(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
$inherits(HashMapImplementation$String$EvaluatedValue, HashMapImplementation);
HashMapImplementation$String$EvaluatedValue.prototype.is$Map = function(){return this;};
HashMapImplementation$String$EvaluatedValue._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
// ********** Code for HashMapImplementation$String$String **************
function HashMapImplementation$String$String() {
  // Initializers done
  if ($notnull_bool(HashMapImplementation._deletedKey == null)) {
    HashMapImplementation._deletedKey = new Object();
  }
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory$String(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
$inherits(HashMapImplementation$String$String, HashMapImplementation);
HashMapImplementation$String$String.prototype.is$Map = function(){return this;};
HashMapImplementation$String$String._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
// ********** Code for HashMapImplementation$Type$Type **************
function HashMapImplementation$Type$Type() {
  // Initializers done
  if ($notnull_bool(HashMapImplementation._deletedKey == null)) {
    HashMapImplementation._deletedKey = new Object();
  }
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory$Type(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
$inherits(HashMapImplementation$Type$Type, HashMapImplementation);
HashMapImplementation$Type$Type.prototype.is$Map = function(){return this;};
HashMapImplementation$Type$Type._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
// ********** Code for HashSetImplementation **************
function HashSetImplementation() {
  // Initializers done
  this._backingMap = new HashMapImplementation$E$E();
}
HashSetImplementation.prototype.is$Iterable = function(){return this;};
HashSetImplementation.HashSetImplementation$from$factory = function(other) {
  var $0;
  var set = new HashSetImplementation();
  for (var $i = other.iterator(); $i.hasNext(); ) {
    var e = $i.next();
    set.add(e);
  }
  return set;
}
HashSetImplementation.prototype.add = function(value) {
  this._backingMap.$setindex(value, value);
}
HashSetImplementation.prototype.contains = function(value) {
  return this._backingMap.containsKey(value);
}
HashSetImplementation.prototype.remove = function(value) {
  if ($notnull_bool(!this._backingMap.containsKey(value))) return false;
  this._backingMap.remove(value);
  return true;
}
HashSetImplementation.prototype.addAll = function(collection) {
  var $this = this; // closure support
  collection.forEach(function _(value) {
    $this.add(value);
  }
  );
}
HashSetImplementation.prototype.forEach = function(f) {
  this._backingMap.forEach(function _(key, value) {
    f(key);
  }
  );
}
HashSetImplementation.prototype.filter = function(f) {
  var result = new HashSetImplementation$E();
  this._backingMap.forEach(function _(key, value) {
    if ($notnull_bool(f(key))) result.add(key);
  }
  );
  return result;
}
HashSetImplementation.prototype.some = function(f) {
  var keys = this._backingMap.getKeys();
  return keys.some(f);
}
HashSetImplementation.prototype.isEmpty = function() {
  return this._backingMap.isEmpty();
}
HashSetImplementation.prototype.get$length = function() {
  return this._backingMap.get$length();
}
Object.defineProperty(HashSetImplementation.prototype, "length", {
  get: HashSetImplementation.prototype.get$length,
});
HashSetImplementation.prototype.iterator = function() {
  return new HashSetIterator$E(this);
}
HashSetImplementation.prototype.forEach$1 = HashSetImplementation.prototype.forEach;
// ********** Code for HashSetImplementation$E **************
function HashSetImplementation$E() {
  // Initializers done
  this._backingMap = new HashMapImplementation$E$E();
}
$inherits(HashSetImplementation$E, HashSetImplementation);
HashSetImplementation$E.prototype.is$Iterable = function(){return this;};
// ********** Code for HashSetImplementation$String **************
function HashSetImplementation$String() {
  // Initializers done
  this._backingMap = new HashMapImplementation$String$String();
}
$inherits(HashSetImplementation$String, HashSetImplementation);
HashSetImplementation$String.prototype.is$Iterable = function(){return this;};
// ********** Code for HashSetImplementation$Type **************
function HashSetImplementation$Type() {
  // Initializers done
  this._backingMap = new HashMapImplementation$Type$Type();
}
$inherits(HashSetImplementation$Type, HashSetImplementation);
HashSetImplementation$Type.prototype.is$Iterable = function(){return this;};
// ********** Code for HashSetIterator **************
function HashSetIterator(set_) {
  this._nextValidIndex = -1;
  this._entries = set_._backingMap._keys;
  // Initializers done
  this._advance();
}
HashSetIterator.prototype.hasNext = function() {
  if ($notnull_bool(this._nextValidIndex >= this._entries.length)) return false;
  if ($notnull_bool(this._entries.$index(this._nextValidIndex) === HashMapImplementation._deletedKey)) {
    this._advance();
  }
  return this._nextValidIndex < this._entries.length;
}
HashSetIterator.prototype.next = function() {
  if ($notnull_bool(!this.hasNext())) {
    $throw(const$0/*const NoMoreElementsException()*/);
  }
  var res = this._entries.$index(this._nextValidIndex);
  this._advance();
  return res;
}
HashSetIterator.prototype._advance = function() {
  var length = this._entries.length;
  var entry;
  var deletedKey = HashMapImplementation._deletedKey;
  do {
    if ($notnull_bool(++this._nextValidIndex >= length)) break;
    entry = this._entries.$index(this._nextValidIndex);
  }
  while ($notnull_bool((entry == null) || (entry === deletedKey)))
}
// ********** Code for HashSetIterator$E **************
function HashSetIterator$E(set_) {
  this._nextValidIndex = -1;
  this._entries = set_._backingMap._keys;
  // Initializers done
  this._advance();
}
$inherits(HashSetIterator$E, HashSetIterator);
HashSetIterator$E.prototype._advance = function() {
  var length = this._entries.length;
  var entry;
  var deletedKey = HashMapImplementation._deletedKey;
  do {
    if ($notnull_bool(++this._nextValidIndex >= length)) break;
    entry = this._entries.$index(this._nextValidIndex);
  }
  while ($notnull_bool((entry == null) || (entry === deletedKey)))
}
// ********** Code for KeyValuePair **************
function KeyValuePair(key, value) {
  this.key = key;
  this.value = value;
  // Initializers done
}
KeyValuePair.prototype.get$value = function() { return this.value; };
KeyValuePair.prototype.set$value = function(value) { return this.value = value; };
// ********** Code for KeyValuePair$K$V **************
function KeyValuePair$K$V(key, value) {
  this.key = key;
  this.value = value;
  // Initializers done
}
$inherits(KeyValuePair$K$V, KeyValuePair);
// ********** Code for KeyValuePair$String$Keyword **************
function KeyValuePair$String$Keyword() {}
$inherits(KeyValuePair$String$Keyword, KeyValuePair);
// ********** Code for LinkedHashMapImplementation **************
function LinkedHashMapImplementation() {
  // Initializers done
  this._map = new HashMapImplementation$K$DoubleLinkedQueueEntry$KeyValuePair$K$V();
  this._list = new DoubleLinkedQueue$KeyValuePair$K$V();
}
LinkedHashMapImplementation.prototype.is$Map = function(){return this;};
LinkedHashMapImplementation.prototype.$setindex = function(key, value) {
  if ($notnull_bool(this._map.containsKey(key))) {
    this._map.$index(key).get$element().value = value;
  }
  else {
    this._list.addLast(new KeyValuePair$K$V(key, value));
    this._map.$setindex(key, this._list.lastEntry());
  }
}
LinkedHashMapImplementation.prototype.$index = function(key) {
  var entry = this._map.$index(key);
  if ($notnull_bool(entry == null)) return null;
  return entry.get$element().get$value();
}
LinkedHashMapImplementation.prototype.getKeys = function() {
  var list = new ListFactory$K(this.get$length());
  var index = 0;
  this._list.forEach(function _(entry) {
    list.$setindex(index++, entry.key);
  }
  );
  $assert(index == this.get$length(), "index == length", "/Users/jimhug/dartfrog/dart/corelib/src/implementation/linked_hash_map.dart", 75, 12);
  return list;
}
LinkedHashMapImplementation.prototype.getValues = function() {
  var list = new ListFactory$V(this.get$length());
  var index = 0;
  this._list.forEach(function _(entry) {
    list.$setindex(index++, entry.value);
  }
  );
  $assert(index == this.get$length(), "index == length", "/Users/jimhug/dartfrog/dart/corelib/src/implementation/linked_hash_map.dart", 86, 12);
  return list;
}
LinkedHashMapImplementation.prototype.forEach = function(f) {
  this._list.forEach(function _(entry) {
    f(entry.key, entry.value);
  }
  );
}
LinkedHashMapImplementation.prototype.containsKey = function(key) {
  return this._map.containsKey(key);
}
LinkedHashMapImplementation.prototype.get$length = function() {
  return this._map.get$length();
}
Object.defineProperty(LinkedHashMapImplementation.prototype, "length", {
  get: LinkedHashMapImplementation.prototype.get$length,
});
LinkedHashMapImplementation.prototype.isEmpty = function() {
  return this.get$length() == 0;
}
LinkedHashMapImplementation.prototype.clear = function() {
  this._map.clear();
  this._list.clear();
}
LinkedHashMapImplementation.prototype.forEach$1 = LinkedHashMapImplementation.prototype.forEach;
// ********** Code for LinkedHashMapImplementation$String$Keyword **************
function LinkedHashMapImplementation$String$Keyword() {
  // Initializers done
  this._map = new HashMapImplementation$String$DoubleLinkedQueueEntry$KeyValuePair$String$Keyword();
  this._list = new DoubleLinkedQueue$KeyValuePair$String$Keyword();
}
$inherits(LinkedHashMapImplementation$String$Keyword, LinkedHashMapImplementation);
LinkedHashMapImplementation$String$Keyword.prototype.is$Map = function(){return this;};
// ********** Code for DoubleLinkedQueueEntry **************
function DoubleLinkedQueueEntry(e) {
  // Initializers done
  this._element = e;
}
DoubleLinkedQueueEntry.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
DoubleLinkedQueueEntry.prototype.prepend = function(e) {
  new DoubleLinkedQueueEntry$E(e)._link(this._previous, this);
}
DoubleLinkedQueueEntry.prototype.remove = function() {
  this._previous._next = this._next;
  this._next._previous = this._previous;
  this._next = null;
  this._previous = null;
  return this._element;
}
DoubleLinkedQueueEntry.prototype._asNonSentinelEntry = function() {
  return this;
}
DoubleLinkedQueueEntry.prototype.previousEntry = function() {
  return this._previous._asNonSentinelEntry();
}
DoubleLinkedQueueEntry.prototype.get$element = function() {
  return this._element;
}
// ********** Code for DoubleLinkedQueueEntry$E **************
function DoubleLinkedQueueEntry$E(e) {
  // Initializers done
  this._element = e;
}
$inherits(DoubleLinkedQueueEntry$E, DoubleLinkedQueueEntry);
DoubleLinkedQueueEntry$E.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
DoubleLinkedQueueEntry$E.prototype.prepend = function(e) {
  new DoubleLinkedQueueEntry$E(e)._link(this._previous, this);
}
DoubleLinkedQueueEntry$E.prototype.remove = function() {
  this._previous._next = this._next;
  this._next._previous = this._previous;
  this._next = null;
  this._previous = null;
  return this._element;
}
DoubleLinkedQueueEntry$E.prototype._asNonSentinelEntry = function() {
  return this;
}
DoubleLinkedQueueEntry$E.prototype.previousEntry = function() {
  return this._previous._asNonSentinelEntry();
}
// ********** Code for DoubleLinkedQueueEntry$KeyValuePair$K$V **************
function DoubleLinkedQueueEntry$KeyValuePair$K$V(e) {
  // Initializers done
  this._element = e;
}
$inherits(DoubleLinkedQueueEntry$KeyValuePair$K$V, DoubleLinkedQueueEntry);
DoubleLinkedQueueEntry$KeyValuePair$K$V.prototype._asNonSentinelEntry = function() {
  return this;
}
// ********** Code for DoubleLinkedQueueEntry$KeyValuePair$String$Keyword **************
function DoubleLinkedQueueEntry$KeyValuePair$String$Keyword() {}
$inherits(DoubleLinkedQueueEntry$KeyValuePair$String$Keyword, DoubleLinkedQueueEntry);
// ********** Code for _DoubleLinkedQueueEntrySentinel **************
function _DoubleLinkedQueueEntrySentinel() {
  DoubleLinkedQueueEntry$E.call(this, null);
  // Initializers done
  this._link(this, this);
}
$inherits(_DoubleLinkedQueueEntrySentinel, DoubleLinkedQueueEntry$E);
_DoubleLinkedQueueEntrySentinel.prototype.remove = function() {
  $throw(const$5/*const EmptyQueueException()*/);
}
_DoubleLinkedQueueEntrySentinel.prototype._asNonSentinelEntry = function() {
  return null;
}
_DoubleLinkedQueueEntrySentinel.prototype.get$element = function() {
  $throw(const$5/*const EmptyQueueException()*/);
}
// ********** Code for _DoubleLinkedQueueEntrySentinel$E **************
function _DoubleLinkedQueueEntrySentinel$E() {
  DoubleLinkedQueueEntry$E.call(this, null);
  // Initializers done
  this._link(this, this);
}
$inherits(_DoubleLinkedQueueEntrySentinel$E, _DoubleLinkedQueueEntrySentinel);
_DoubleLinkedQueueEntrySentinel$E.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
_DoubleLinkedQueueEntrySentinel$E.prototype.prepend = function(e) {
  new DoubleLinkedQueueEntry$E(e)._link(this._previous, this);
}
_DoubleLinkedQueueEntrySentinel$E.prototype.previousEntry = function() {
  return this._previous._asNonSentinelEntry();
}
// ********** Code for _DoubleLinkedQueueEntrySentinel$KeyValuePair$K$V **************
function _DoubleLinkedQueueEntrySentinel$KeyValuePair$K$V() {
  DoubleLinkedQueueEntry$E.call(this, null);
  // Initializers done
  this._link(this, this);
}
$inherits(_DoubleLinkedQueueEntrySentinel$KeyValuePair$K$V, _DoubleLinkedQueueEntrySentinel);
_DoubleLinkedQueueEntrySentinel$KeyValuePair$K$V.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
_DoubleLinkedQueueEntrySentinel$KeyValuePair$K$V.prototype.prepend = function(e) {
  new DoubleLinkedQueueEntry$KeyValuePair$K$V(e)._link(this._previous, this);
}
_DoubleLinkedQueueEntrySentinel$KeyValuePair$K$V.prototype.previousEntry = function() {
  return this._previous._asNonSentinelEntry();
}
// ********** Code for _DoubleLinkedQueueEntrySentinel$KeyValuePair$String$Keyword **************
function _DoubleLinkedQueueEntrySentinel$KeyValuePair$String$Keyword() {
  DoubleLinkedQueueEntry$E.call(this, null);
  // Initializers done
  this._link(this, this);
}
$inherits(_DoubleLinkedQueueEntrySentinel$KeyValuePair$String$Keyword, _DoubleLinkedQueueEntrySentinel);
_DoubleLinkedQueueEntrySentinel$KeyValuePair$String$Keyword.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
// ********** Code for DoubleLinkedQueue **************
function DoubleLinkedQueue() {
  // Initializers done
  this._sentinel = new _DoubleLinkedQueueEntrySentinel$E();
}
DoubleLinkedQueue.prototype.is$Iterable = function(){return this;};
DoubleLinkedQueue.DoubleLinkedQueue$from$factory = function(other) {
  var $0;
  var list = new DoubleLinkedQueue();
  for (var $i = other.iterator(); $i.hasNext(); ) {
    var e = $i.next();
    list.addLast(e);
  }
  return list;
}
DoubleLinkedQueue.prototype.addLast = function(value) {
  this._sentinel.prepend(value);
}
DoubleLinkedQueue.prototype.add = function(value) {
  this.addLast(value);
}
DoubleLinkedQueue.prototype.addAll = function(collection) {
  var $0;
  for (var $i = collection.iterator(); $i.hasNext(); ) {
    var e = $i.next();
    this.add(e);
  }
}
DoubleLinkedQueue.prototype.removeLast = function() {
  return this._sentinel._previous.remove();
}
DoubleLinkedQueue.prototype.last = function() {
  return this._sentinel._previous.get$element();
}
DoubleLinkedQueue.prototype.lastEntry = function() {
  return this._sentinel.previousEntry();
}
DoubleLinkedQueue.prototype.get$length = function() {
  var counter = 0;
  this.forEach(function _(element) {
    counter++;
  }
  );
  return counter;
}
Object.defineProperty(DoubleLinkedQueue.prototype, "length", {
  get: DoubleLinkedQueue.prototype.get$length,
});
DoubleLinkedQueue.prototype.isEmpty = function() {
  return (this._sentinel._next === this._sentinel);
}
DoubleLinkedQueue.prototype.clear = function() {
  this._sentinel._next = this._sentinel;
  this._sentinel._previous = this._sentinel;
}
DoubleLinkedQueue.prototype.forEach = function(f) {
  var entry = this._sentinel._next;
  while ($notnull_bool(entry !== this._sentinel)) {
    f(entry._element);
    entry = entry._next;
  }
}
DoubleLinkedQueue.prototype.some = function(f) {
  var entry = this._sentinel._next;
  while ($notnull_bool(entry !== this._sentinel)) {
    if ($notnull_bool(f(entry._element))) return true;
    entry = entry._next;
  }
  return false;
}
DoubleLinkedQueue.prototype.filter = function(f) {
  var other = new DoubleLinkedQueue$E();
  var entry = this._sentinel._next;
  while ($notnull_bool(entry !== this._sentinel)) {
    if ($notnull_bool(f(entry._element))) other.addLast(entry._element);
    entry = entry._next;
  }
  return other;
}
DoubleLinkedQueue.prototype.iterator = function() {
  return new _DoubleLinkedQueueIterator$E(this._sentinel);
}
DoubleLinkedQueue.prototype.forEach$1 = DoubleLinkedQueue.prototype.forEach;
// ********** Code for DoubleLinkedQueue$E **************
function DoubleLinkedQueue$E() {
  // Initializers done
  this._sentinel = new _DoubleLinkedQueueEntrySentinel$E();
}
$inherits(DoubleLinkedQueue$E, DoubleLinkedQueue);
DoubleLinkedQueue$E.prototype.is$Iterable = function(){return this;};
// ********** Code for DoubleLinkedQueue$KeyValuePair$K$V **************
function DoubleLinkedQueue$KeyValuePair$K$V() {
  // Initializers done
  this._sentinel = new _DoubleLinkedQueueEntrySentinel$KeyValuePair$K$V();
}
$inherits(DoubleLinkedQueue$KeyValuePair$K$V, DoubleLinkedQueue);
DoubleLinkedQueue$KeyValuePair$K$V.prototype.is$Iterable = function(){return this;};
DoubleLinkedQueue$KeyValuePair$K$V.prototype.addLast = function(value) {
  this._sentinel.prepend(value);
}
DoubleLinkedQueue$KeyValuePair$K$V.prototype.lastEntry = function() {
  return this._sentinel.previousEntry();
}
DoubleLinkedQueue$KeyValuePair$K$V.prototype.clear = function() {
  this._sentinel._next = this._sentinel;
  this._sentinel._previous = this._sentinel;
}
DoubleLinkedQueue$KeyValuePair$K$V.prototype.forEach = function(f) {
  var entry = this._sentinel._next;
  while ($notnull_bool(entry !== this._sentinel)) {
    f(entry._element);
    entry = entry._next;
  }
}
// ********** Code for DoubleLinkedQueue$KeyValuePair$String$Keyword **************
function DoubleLinkedQueue$KeyValuePair$String$Keyword() {
  // Initializers done
  this._sentinel = new _DoubleLinkedQueueEntrySentinel$KeyValuePair$String$Keyword();
}
$inherits(DoubleLinkedQueue$KeyValuePair$String$Keyword, DoubleLinkedQueue);
DoubleLinkedQueue$KeyValuePair$String$Keyword.prototype.is$Iterable = function(){return this;};
// ********** Code for DoubleLinkedQueue$SourceString **************
function DoubleLinkedQueue$SourceString() {}
$inherits(DoubleLinkedQueue$SourceString, DoubleLinkedQueue);
DoubleLinkedQueue$SourceString.prototype.is$Iterable = function(){return this;};
DoubleLinkedQueue$SourceString.DoubleLinkedQueue$from$factory = function(other) {
  var $0;
  var list = new DoubleLinkedQueue();
  for (var $i = other.iterator(); $i.hasNext(); ) {
    var e = $i.next();
    list.addLast(e);
  }
  return list;
}
// ********** Code for _DoubleLinkedQueueIterator **************
function _DoubleLinkedQueueIterator(_sentinel) {
  this._sentinel = _sentinel;
  // Initializers done
  this._currentEntry = this._sentinel;
}
_DoubleLinkedQueueIterator.prototype.hasNext = function() {
  return this._currentEntry._next !== this._sentinel;
}
_DoubleLinkedQueueIterator.prototype.next = function() {
  if ($notnull_bool(!this.hasNext())) {
    $throw(const$0/*const NoMoreElementsException()*/);
  }
  this._currentEntry = this._currentEntry._next;
  return this._currentEntry.get$element();
}
// ********** Code for _DoubleLinkedQueueIterator$E **************
function _DoubleLinkedQueueIterator$E(_sentinel) {
  this._sentinel = _sentinel;
  // Initializers done
  this._currentEntry = this._sentinel;
}
$inherits(_DoubleLinkedQueueIterator$E, _DoubleLinkedQueueIterator);
// ********** Code for StopWatchImplementation **************
function StopWatchImplementation() {
  this._start = null;
  this._stop = null;
  // Initializers done
}
StopWatchImplementation.prototype.start = function() {
  if ($notnull_bool(this._start == null)) {
    this._start = Clock.now();
  }
  else {
    if ($notnull_bool(this._stop == null)) {
      return;
    }
    this._start = Clock.now() - (this._stop - this._start);
  }
}
StopWatchImplementation.prototype.stop = function() {
  if ($notnull_bool(this._start == null)) {
    return;
  }
  this._stop = Clock.now();
}
StopWatchImplementation.prototype.elapsed = function() {
  if ($notnull_bool(this._start == null)) {
    return 0;
  }
  return $notnull_bool((this._stop == null)) ? (Clock.now() - this._start) : (this._stop - this._start);
}
StopWatchImplementation.prototype.elapsedInMs = function() {
  return $truncdiv((this.elapsed() * 1000), this.frequency());
}
StopWatchImplementation.prototype.frequency = function() {
  return Clock.frequency();
}
// ********** Code for StringBufferImpl **************
function StringBufferImpl(content) {
  // Initializers done
  this.clear();
  this.add(content);
}
StringBufferImpl.prototype.is$StringBuffer = function(){return this;};
StringBufferImpl.prototype.get$length = function() {
  return this._length;
}
Object.defineProperty(StringBufferImpl.prototype, "length", {
  get: StringBufferImpl.prototype.get$length,
});
StringBufferImpl.prototype.isEmpty = function() {
  return this._length == 0;
}
StringBufferImpl.prototype.add = function(obj) {
  var str = obj.toString();
  if ($notnull_bool(str == null || str.isEmpty())) return this;
  this._buffer.add(str);
  this._length += str.length;
  return this;
}
StringBufferImpl.prototype.addAll = function(objects) {
  var $0;
  for (var $i = objects.iterator(); $i.hasNext(); ) {
    var obj = $i.next();
    this.add(obj);
  }
  return this;
}
StringBufferImpl.prototype.clear = function() {
  this._buffer = new ListFactory$String();
  this._length = 0;
  return this;
}
StringBufferImpl.prototype.toString = function() {
  if ($notnull_bool(this._buffer.length == 0)) return "";
  if ($notnull_bool(this._buffer.length == 1)) return this._buffer.$index(0);
  var result = StringBase.concatAll(this._buffer);
  this._buffer.clear();
  this._buffer.add(result);
  return result;
}
// ********** Code for StringBase **************
function StringBase() {}
StringBase.createFromCharCodes = function(charCodes) {
  if (Object.getPrototypeOf(charCodes) !== Array.prototype) {
    var length = charCodes.length;
    var tmp = new Array(length);
    for (var i = 0; i < length; i++) {
      tmp[i] = charCodes.$index(i);
    }
    charCodes = tmp;
  }
  return String.fromCharCode.apply(null, charCodes);
}
StringBase.join = function(strings, separator) {
  if ($notnull_bool(strings.length == 0)) return '';
  var s = strings.$index(0);
  for (var i = 1;
   $notnull_bool(i < strings.length); i++) {
    s = s + separator + strings.$index(i);
  }
  return s;
}
StringBase.concatAll = function(strings) {
  return StringBase.join(strings, "");
}
// ********** Code for StringImplementation **************
StringImplementation = String;
StringImplementation.prototype.endsWith = function(other) {
  if (other.length > this.length) return false;
    return other == this.substring(this.length - other.length);
}
StringImplementation.prototype.startsWith = function(other) {
  if (other.length > this.length) return false;
    return other == this.substring(0, other.length);
}
StringImplementation.prototype.isEmpty = function() {
  return this.length == 0;
}
StringImplementation.prototype.replaceFirst = function(from, to) {
  return this.replace(from, to);
}
StringImplementation.prototype.replaceAll = function(from, to) {
  if (typeof(from) == 'string' || from instanceof String) {
      return this.replace($regexpAllFromString(from), to);
    } else {
      return this.replace(from, to);
    }
}
StringImplementation.prototype.hashCode = function() {
  if (this.hash_ === undefined) {
      for (var i = 0; i < this.length; i++) {
        var ch = this.charCodeAt(i);
        this.hash_ += ch;
        this.hash_ += this.hash_ << 10;
        this.hash_ ^= this.hash_ >> 6;
      }

      this.hash_ += this.hash_ << 3;
      this.hash_ ^= this.hash_ >> 11;
      this.hash_ += this.hash_ << 15;
      this.hash_ = this.hash_ & ((1 << 29) - 1);
    }
    return this.hash_;
}
StringImplementation.prototype.compareTo = function(other) {
  return this == other ? 0 : this < other ? -1 : 1;
}
// ********** Code for Collections **************
function Collections() {}
Collections.forEach = function(iterable, f) {
  var $0;
  for (var $i = iterable.iterator(); $i.hasNext(); ) {
    var e = $i.next();
    f(e);
  }
}
Collections.some = function(iterable, f) {
  var $0;
  for (var $i = iterable.iterator(); $i.hasNext(); ) {
    var e = $i.next();
    if ($notnull_bool(f(e))) return true;
  }
  return false;
}
Collections.filter = function(source, destination, f) {
  var $0;
  for (var $i = source.iterator(); $i.hasNext(); ) {
    var e = $i.next();
    if ($notnull_bool(f(e))) destination.add(e);
  }
  return destination;
}
// ********** Code for DateImplementation **************
function DateImplementation() {}
DateImplementation.fromEpoch$ctor = function(value, timeZone) {
  this.value = value;
  this.timeZone = timeZone;
  // Initializers done
}
DateImplementation.fromEpoch$ctor.prototype = DateImplementation.prototype;
DateImplementation.now$ctor = function() {
  this.timeZone = new TimeZoneImplementation.local$ctor();
  this.value = DateImplementation._now();
  // Initializers done
  this._asJs();
}
DateImplementation.now$ctor.prototype = DateImplementation.prototype;
DateImplementation.prototype.get$value = function() { return this.value; };
DateImplementation.prototype.$eq = function(other) {
  if ($notnull_bool(!((other instanceof DateImplementation)))) return false;
  return (this.value == other.get$value()) && ($eq(this.timeZone, other.timeZone));
}
DateImplementation.prototype.compareTo = function(other) {
  return this.value.compareTo(other.value);
}
DateImplementation.prototype.get$year = function() {
  return this.isUtc ? this._asJs().getUTCFullYear() :
      this._asJs().getFullYear();
}
DateImplementation.prototype.get$month = function() {
  return this.isUtc ? this._asJs().getMonth() + 1 :
        this._asJs().getMonth() + 1;
}
DateImplementation.prototype.get$day = function() {
  return this.isUtc ? this._asJs().getUTCDate() : this._asJs().getDate()
}
DateImplementation.prototype.get$hours = function() {
  return this.isUtc ? this._asJs().getUTCHours() : this._asJs().getHours()
}
DateImplementation.prototype.get$minutes = function() {
  return this.isUtc ? this._asJs().getUTCMinutes() : this._asJs().getMinutes()
}
DateImplementation.prototype.get$seconds = function() {
  return this.isUtc ? this._asJs().getUTCSeconds() : this._asJs().getSeconds()
}
DateImplementation.prototype.get$milliseconds = function() {
  return this.isUtc ? this._asJs().getUTCMilliseconds() :
      this._asJs().getMilliseconds();
}
DateImplementation.prototype.toString = function() {
  function threeDigits(n) {
    if ($notnull_bool(n >= 100)) return ("" + n + "");
    if ($notnull_bool(n > 10)) return ("0" + n + "");
    return ("00" + n + "");
  }
  function twoDigits(n) {
    if ($notnull_bool(n >= 10)) return ("" + n + "");
    return ("0" + n + "");
  }
  var m = twoDigits(this.get$month());
  var d = twoDigits(this.get$day());
  var h = twoDigits(this.get$hours());
  var min = twoDigits(this.get$minutes());
  var sec = twoDigits(this.get$seconds());
  var ms = threeDigits(this.get$milliseconds());
  if ($notnull_bool(this.timeZone.isUtc)) {
    return ("" + this.get$year() + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z");
  }
  else {
    return ("" + this.get$year() + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "");
  }
}
DateImplementation.prototype.add = function(duration) {
  return new DateImplementation.fromEpoch$ctor(this.value + duration.inMilliseconds, this.timeZone);
}
DateImplementation._now = function() {
  return new Date().valueOf();
}
DateImplementation.prototype._asJs = function() {
    if (!this.date) {
      this.date = new Date(this.value);
    }
    return this.date;
}
// ********** Code for TimeZoneImplementation **************
function TimeZoneImplementation() {}
TimeZoneImplementation.local$ctor = function() {
  this.isUtc = false;
  // Initializers done
}
TimeZoneImplementation.local$ctor.prototype = TimeZoneImplementation.prototype;
TimeZoneImplementation.prototype.$eq = function(other) {
  if ($notnull_bool(!((other instanceof TimeZoneImplementation)))) return false;
  return $eq(this.isUtc, other.isUtc);
}
TimeZoneImplementation.prototype.toString = function() {
  if ($notnull_bool(this.isUtc)) return "TimeZone (UTC)";
  return "TimeZone (Local)";
}
// ********** Code for top level **************
function MatchImplementation(pattern, str, _start, _end, _groups) {
  this.pattern = pattern;
  this.str = str;
  this._start = _start;
  this._end = _end;
  this._groups = _groups;
  // Initializers done
}
//  ********** Library node **************
//  ********** Natives io_node.js **************
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

function get$fs() {
  return require('fs');
}

function get$path() {
  return require('path');
}

function get$vm() {
  return require('vm');
}

function get$http() {
  return require('http');
}

function get$readline() {
  return require('readline');
}
// ********** Code for Process **************
// ********** Code for top level **************
function createSandbox() {
  return {'require': require, 'process': process, 'console': console};
}
//  ********** Library file_system **************
// ********** Code for top level **************
function joinPaths(path1, path2) {
  var pieces = path1.split('/');
  var $list = path2.split('/');
  for (var $i = 0;$i < $list.length; $i++) {
    var piece = $list.$index($i);
    if ($notnull_bool($eq(piece, '..') && pieces.length > 0 && $ne(pieces.last(), '.') && $ne(pieces.last(), '..'))) {
      pieces.removeLast();
    }
    else if ($notnull_bool($ne(piece, ''))) {
      if ($notnull_bool(pieces.length > 0 && $eq(pieces.last(), '.'))) {
        pieces.removeLast();
      }
      pieces.add(piece);
    }
  }
  return Strings.join((pieces && pieces.is$List$String()), '/');
}
function dirname(path) {
  var lastSlash = path.lastIndexOf('/', path.length);
  if ($notnull_bool(lastSlash == -1)) {
    return '.';
  }
  else {
    return path.substring(0, lastSlash);
  }
}
function basename(path) {
  var lastSlash = path.lastIndexOf('/', path.length);
  if ($notnull_bool(lastSlash == -1)) {
    return path;
  }
  else {
    return path.substring(lastSlash + 1);
  }
}
//  ********** Library file_system_node **************
// ********** Code for NodeFileSystem **************
function NodeFileSystem() {
  // Initializers done
}
NodeFileSystem.prototype.writeString = function(outfile, text) {
  get$fs().writeFileSync(outfile, text);
}
NodeFileSystem.prototype.readAll = function(filename) {
  return get$fs().readFileSync(filename, 'utf8');
}
NodeFileSystem.prototype.fileExists = function(filename) {
  return get$path().existsSync(filename);
}
// ********** Code for top level **************
//  ********** Library scanner_implementation **************
// ********** Code for ArrayBasedScanner **************
function ArrayBasedScanner() {
  this.charOffset = -1;
  this.tokenStart = -1;
  this.byteOffset = -1;
  this.tokens = new Token(0/*null.EOF_TOKEN*/, -1);
  // Initializers done
  this.tail = this.tokens;
}
$inherits(ArrayBasedScanner, AbstractScanner$S);
ArrayBasedScanner.prototype.get$charOffset = function() { return this.charOffset; };
ArrayBasedScanner.prototype.set$charOffset = function(value) { return this.charOffset = value; };
ArrayBasedScanner.prototype.get$tail = function() { return this.tail; };
ArrayBasedScanner.prototype.set$tail = function(value) { return this.tail = value; };
ArrayBasedScanner.prototype.get$byteOffset = function() { return this.byteOffset; };
ArrayBasedScanner.prototype.set$byteOffset = function(value) { return this.byteOffset = value; };
ArrayBasedScanner.prototype.advance = function() {
  var next = this.nextByte();
  this.charOffset++;
  return next;
}
ArrayBasedScanner.prototype.select = function(choice, yes, no) {
  var next = this.advance();
  if ($notnull_bool(next == choice)) {
    this.appendStringToken(1024/*null.UNKNOWN_TOKEN*/, yes);
    return this.advance();
  }
  else {
    this.appendStringToken(1024/*null.UNKNOWN_TOKEN*/, no);
    return next;
  }
}
ArrayBasedScanner.prototype.appendStringToken = function(kind, value) {
  this.tail.next = new StringToken(kind, value, this.tokenStart);
  this.tail = this.tail.next;
}
ArrayBasedScanner.prototype.appendKeywordToken = function(keyword) {
  this.tail.next = new KeywordToken(keyword, this.tokenStart);
  this.tail = this.tail.next;
}
ArrayBasedScanner.prototype.appendEofToken = function() {
  this.tail.next = new Token(0/*null.EOF_TOKEN*/, this.charOffset);
  this.tail = this.tail.next;
}
ArrayBasedScanner.prototype.beginToken = function() {
  this.tokenStart = this.charOffset;
}
ArrayBasedScanner.prototype.firstToken = function() {
  return this.tokens.next;
}
ArrayBasedScanner.prototype.addToCharOffset = function(offset) {
  this.charOffset += offset;
}
ArrayBasedScanner.prototype.appendWhiteSpace = function(next) {

}
// ********** Code for ArrayBasedScanner$String **************
function ArrayBasedScanner$String() {
  this.charOffset = -1;
  this.tokenStart = -1;
  this.byteOffset = -1;
  this.tokens = new Token(0/*null.EOF_TOKEN*/, -1);
  // Initializers done
  this.tail = this.tokens;
}
$inherits(ArrayBasedScanner$String, ArrayBasedScanner);
ArrayBasedScanner$String.prototype.advance = function() {
  var next = this.nextByte();
  this.charOffset++;
  return next;
}
ArrayBasedScanner$String.prototype.select = function(choice, yes, no) {
  var next = this.advance();
  if ($notnull_bool(next == choice)) {
    this.appendStringToken(1024/*null.UNKNOWN_TOKEN*/, yes);
    return this.advance();
  }
  else {
    this.appendStringToken(1024/*null.UNKNOWN_TOKEN*/, no);
    return next;
  }
}
ArrayBasedScanner$String.prototype.appendStringToken = function(kind, value) {
  this.tail.next = new StringToken(kind, value, this.tokenStart);
  this.tail = this.tail.next;
}
ArrayBasedScanner$String.prototype.appendKeywordToken = function(keyword) {
  this.tail.next = new KeywordToken(keyword, this.tokenStart);
  this.tail = this.tail.next;
}
ArrayBasedScanner$String.prototype.appendEofToken = function() {
  this.tail.next = new Token(0/*null.EOF_TOKEN*/, this.charOffset);
  this.tail = this.tail.next;
}
ArrayBasedScanner$String.prototype.beginToken = function() {
  this.tokenStart = this.charOffset;
}
ArrayBasedScanner$String.prototype.firstToken = function() {
  return this.tokens.next;
}
ArrayBasedScanner$String.prototype.addToCharOffset = function(offset) {
  this.charOffset += offset;
}
ArrayBasedScanner$String.prototype.appendWhiteSpace = function(next) {

}
ArrayBasedScanner$String.prototype.tokenize = function() {
  var next = this.advance();
  while ($notnull_bool(next != -1)) {
    next = this.bigSwitch(next);
  }
  this.appendEofToken();
  return this.firstToken();
}
ArrayBasedScanner$String.prototype.bigSwitch = function(next) {
  this.beginToken();
  switch (next) {
    case 9/*null.$TAB*/:
    case 10/*null.$LF*/:
    case 13/*null.$CR*/:
    case 32/*null.$SPACE*/:

      this.appendWhiteSpace(next);
      return this.advance();

    case 60/*null.$LT*/:

      return this.tokenizeLessThan(next);

    case 62/*null.$GT*/:

      return this.tokenizeGreaterThan(next);

    case 61/*null.$EQ*/:

      return this.tokenizeEquals(next);

    case 33/*null.$BANG*/:

      return this.tokenizeExclamation(next);

    case 43/*null.$PLUS*/:

      return this.tokenizePlus(next);

    case 45/*null.$MINUS*/:

      return this.tokenizeMinus(next);

    case 42/*null.$STAR*/:

      return this.tokenizeMultiply(next);

    case 37/*null.$PERCENT*/:

      return this.tokenizePercent(next);

    case 38/*null.$AMPERSAND*/:

      return this.tokenizeAmpersand(next);

    case 124/*null.$BAR*/:

      return this.tokenizeBar(next);

    case 94/*null.$CARET*/:

      return this.tokenizeCaret(next);

    case 91/*null.$LBRACKET*/:

      return this.tokenizeOpenBracket(next);

    case 126/*null.$TILDE*/:

      return this.tokenizeTilde(next);

    case 92/*null.$BACKSLASH*/:

      this.appendStringToken(92/*null.BACKSLASH_TOKEN*/, "\\");
      return this.advance();

    case 35/*null.$HASH*/:

      return this.tokenizeTag(next);

    case 40/*null.$LPAREN*/:

      this.appendStringToken(40/*null.LPAREN_TOKEN*/, "(");
      return this.advance();

    case 41/*null.$RPAREN*/:

      this.appendStringToken(41/*null.RPAREN_TOKEN*/, ")");
      return this.advance();

    case 44/*null.$COMMA*/:

      this.appendStringToken(44/*null.COMMA_TOKEN*/, ",");
      return this.advance();

    case 58/*null.$COLON*/:

      this.appendStringToken(58/*null.COLON_TOKEN*/, ":");
      return this.advance();

    case 59/*null.$SEMICOLON*/:

      this.appendStringToken(59/*null.SEMICOLON_TOKEN*/, ";");
      return this.advance();

    case 63/*null.$QUESTION*/:

      this.appendStringToken(63/*null.QUESTION_TOKEN*/, "?");
      return this.advance();

    case 93/*null.$RBRACKET*/:

      this.appendStringToken(93/*null.RBRACKET_TOKEN*/, "]");
      return this.advance();

    case 96/*null.$BACKPING*/:

      this.appendStringToken(96/*null.BACKPING_TOKEN*/, "`");
      return this.advance();

    case 123/*null.$LBRACE*/:

      this.appendStringToken(123/*null.LBRACE_TOKEN*/, "{");
      return this.advance();

    case 125/*null.$RBRACE*/:

      this.appendStringToken(125/*null.RBRACE_TOKEN*/, "}");
      return this.advance();

    case 47/*null.$SLASH*/:

      return this.tokenizeSlashOrComment(next);

    case 64/*null.$AT*/:

      return this.tokenizeRawString(next);

    case 34/*null.$DQ*/:
    case 39/*null.$SQ*/:

      return this.tokenizeString(next, this.byteOffset, false);

    case 46/*null.$PERIOD*/:

      return this.tokenizeDotOrNumber(next);

    case 48/*null.$0*/:

      return this.tokenizeHexOrNumber(next);

    case 49/*null.$1*/:
    case 50/*null.$2*/:
    case 51/*null.$3*/:
    case 52/*null.$4*/:
    case 53/*null.$5*/:
    case 54/*null.$6*/:
    case 55/*null.$7*/:
    case 56/*null.$8*/:
    case 57/*null.$9*/:

      return this.tokenizeNumber(next);

    case 36/*null.$DOLLAR*/:
    case 65/*null.$A*/:
    case 66/*null.$B*/:
    case 67/*null.$C*/:
    case 68/*null.$D*/:
    case 69/*null.$E*/:
    case 70/*null.$F*/:
    case 71/*null.$G*/:
    case 72/*null.$H*/:
    case 73/*null.$I*/:
    case 74/*null.$J*/:
    case 75/*null.$K*/:
    case 76/*null.$L*/:
    case 77/*null.$M*/:
    case 78/*null.$N*/:
    case 79/*null.$O*/:
    case 80/*null.$P*/:
    case 81/*null.$Q*/:
    case 82/*null.$R*/:
    case 83/*null.$S*/:
    case 84/*null.$T*/:
    case 85/*null.$U*/:
    case 86/*null.$V*/:
    case 87/*null.$W*/:
    case 88/*null.$X*/:
    case 89/*null.$Y*/:
    case 90/*null.$Z*/:
    case 95/*null.$_*/:
    case 97/*null.$a*/:
    case 98/*null.$b*/:
    case 99/*null.$c*/:
    case 100/*null.$d*/:
    case 101/*null.$e*/:
    case 102/*null.$f*/:
    case 103/*null.$g*/:
    case 104/*null.$h*/:
    case 105/*null.$i*/:
    case 106/*null.$j*/:
    case 107/*null.$k*/:
    case 108/*null.$l*/:
    case 109/*null.$m*/:
    case 110/*null.$n*/:
    case 111/*null.$o*/:
    case 112/*null.$p*/:
    case 113/*null.$q*/:
    case 114/*null.$r*/:
    case 115/*null.$s*/:
    case 116/*null.$t*/:
    case 117/*null.$u*/:
    case 118/*null.$v*/:
    case 119/*null.$w*/:
    case 120/*null.$x*/:
    case 121/*null.$y*/:
    case 122/*null.$z*/:

      return this.tokenizeIdentifier(next);

    default:

      if ($notnull_bool(next == -1)) {
        return -1;
      }
      if ($notnull_bool(next < 0x1f)) {
        $throw(new MalformedInputException(this.charOffset));
      }
      return this.tokenizeIdentifier(next);

  }
}
ArrayBasedScanner$String.prototype.tokenizeTag = function(next) {
  if ($notnull_bool(this.byteOffset == 0)) {
    if ($notnull_bool(this.peek() == 33/*null.$BANG*/)) {
      do {
        next = this.advance();
      }
      while ($notnull_bool(next != 10/*null.$LF*/ && next != 13/*null.$CR*/))
      return next;
    }
  }
  this.appendStringToken(35/*null.HASH_TOKEN*/, "#");
  return this.advance();
}
ArrayBasedScanner$String.prototype.tokenizeTilde = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 47/*null.$SLASH*/)) {
    return this.select(61/*null.$EQ*/, "~/=", "~/");
  }
  else {
    this.appendStringToken(126/*null.TILDE_TOKEN*/, "~");
    return next;
  }
}
ArrayBasedScanner$String.prototype.tokenizeOpenBracket = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 93/*null.$RBRACKET*/)) {
    return this.select(61/*null.$EQ*/, "[]=", "[]");
  }
  else {
    this.appendStringToken(93/*null.RBRACKET_TOKEN*/, "[");
    return next;
  }
}
ArrayBasedScanner$String.prototype.tokenizeCaret = function(next) {
  return this.select(61/*null.$EQ*/, "^=", "^");
}
ArrayBasedScanner$String.prototype.tokenizeBar = function(next) {
  next = this.advance();
  switch (next) {
    case 124/*null.$BAR*/:

      this.appendStringToken(124/*null.BAR_TOKEN*/, "||");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(124/*null.BAR_TOKEN*/, "|=");
      return this.advance();

    default:

      this.appendStringToken(124/*null.BAR_TOKEN*/, "|");
      return next;

  }
}
ArrayBasedScanner$String.prototype.tokenizeAmpersand = function(next) {
  next = this.advance();
  switch (next) {
    case 38/*null.$AMPERSAND*/:

      this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&&");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&=");
      return this.advance();

    default:

      this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&");
      return next;

  }
}
ArrayBasedScanner$String.prototype.tokenizePercent = function(next) {
  return this.select(61/*null.$EQ*/, "%=", "%");
}
ArrayBasedScanner$String.prototype.tokenizeMultiply = function(next) {
  return this.select(61/*null.$EQ*/, "*=", "*");
}
ArrayBasedScanner$String.prototype.tokenizeMinus = function(next) {
  next = this.advance();
  switch (next) {
    case 45/*null.$MINUS*/:

      this.appendStringToken(45/*null.MINUS_TOKEN*/, "--");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(45/*null.MINUS_TOKEN*/, "-=");
      return this.advance();

    default:

      this.appendStringToken(45/*null.MINUS_TOKEN*/, "-");
      return next;

  }
}
ArrayBasedScanner$String.prototype.tokenizePlus = function(next) {
  next = this.advance();
  switch (next) {
    case 43/*null.$PLUS*/:

      this.appendStringToken(43/*null.PLUS_TOKEN*/, "++");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(43/*null.PLUS_TOKEN*/, "+=");
      return this.advance();

    default:

      this.appendStringToken(43/*null.PLUS_TOKEN*/, "+");
      return next;

  }
}
ArrayBasedScanner$String.prototype.tokenizeExclamation = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 61/*null.$EQ*/)) {
    return this.select(61/*null.$EQ*/, "!==", "!=");
  }
  this.appendStringToken(33/*null.BANG_TOKEN*/, "!");
  return next;
}
ArrayBasedScanner$String.prototype.tokenizeEquals = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 61/*null.$EQ*/)) {
    return this.select(61/*null.$EQ*/, "===", "==");
  }
  this.appendStringToken(61/*null.EQ_TOKEN*/, "=");
  return next;
}
ArrayBasedScanner$String.prototype.tokenizeGreaterThan = function(next) {
  next = this.advance();
  switch (next) {
    case 61/*null.$EQ*/:

      this.appendStringToken(62/*null.GT_TOKEN*/, ">=");
      return this.advance();

    case 62/*null.$GT*/:

      next = this.advance();
      switch (next) {
        case 61/*null.$EQ*/:

          this.appendStringToken(62/*null.GT_TOKEN*/, ">>=");
          return this.advance();

        case 62/*null.$GT*/:

          return this.select(61/*null.$EQ*/, ">>>=", ">>>");

        default:

          this.appendStringToken(62/*null.GT_TOKEN*/, ">>");
          return next;

      }
      $throw(new FallThroughError());

    default:

      this.appendStringToken(62/*null.GT_TOKEN*/, ">");
      return next;

  }
}
ArrayBasedScanner$String.prototype.tokenizeLessThan = function(next) {
  next = this.advance();
  switch (next) {
    case 61/*null.$EQ*/:

      this.appendStringToken(60/*null.LT_TOKEN*/, "<=");
      return this.advance();

    case 60/*null.$LT*/:

      return this.select(61/*null.$EQ*/, "<<=", "<<");

    default:

      this.appendStringToken(60/*null.LT_TOKEN*/, "<");
      return next;

  }
}
ArrayBasedScanner$String.prototype.tokenizeNumber = function(next) {
  var start = this.byteOffset;
  while ($notnull_bool(true)) {
    next = this.advance();
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:

        break;

      case 46/*null.$PERIOD*/:

        return this.tokenizeFractionPart(this.advance(), start);

      case 101/*null.$e*/:
      case 69/*null.$E*/:
      case 100/*null.$d*/:
      case 68/*null.$D*/:

        return this.tokenizeFractionPart(next, start);

      default:

        this.appendByteStringToken(105/*null.INT_TOKEN*/, this.asciiString(start));
        return next;

    }
  }
}
ArrayBasedScanner$String.prototype.tokenizeHexOrNumber = function(next) {
  var x = this.peek();
  if ($notnull_bool(x == 120/*null.$x*/ || x == 88/*null.$X*/)) {
    this.advance();
    return this.tokenizeHex(x);
  }
  return this.tokenizeNumber(next);
}
ArrayBasedScanner$String.prototype.tokenizeHex = function(next) {
  var start = this.byteOffset;
  var hasDigits = false;
  while ($notnull_bool(true)) {
    next = this.advance();
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:
      case 65/*null.$A*/:
      case 66/*null.$B*/:
      case 67/*null.$C*/:
      case 68/*null.$D*/:
      case 69/*null.$E*/:
      case 70/*null.$F*/:
      case 97/*null.$a*/:
      case 98/*null.$b*/:
      case 99/*null.$c*/:
      case 100/*null.$d*/:
      case 101/*null.$e*/:
      case 102/*null.$f*/:

        hasDigits = true;
        break;

      default:

        if ($notnull_bool(!hasDigits)) {
          $throw(new MalformedInputException(this.charOffset));
        }
        this.appendByteStringToken(120/*null.HEXADECIMAL_TOKEN*/, this.asciiString(start));
        return next;

    }
  }
}
ArrayBasedScanner$String.prototype.tokenizeDotOrNumber = function(next) {
  var start = this.byteOffset;
  next = this.advance();
  switch (next) {
    case 48/*null.$0*/:
    case 49/*null.$1*/:
    case 50/*null.$2*/:
    case 51/*null.$3*/:
    case 52/*null.$4*/:
    case 53/*null.$5*/:
    case 54/*null.$6*/:
    case 55/*null.$7*/:
    case 56/*null.$8*/:
    case 57/*null.$9*/:

      {
        return this.tokenizeFractionPart(next, start);
      }

    case 46/*null.$PERIOD*/:

      return this.select(46/*null.$PERIOD*/, "...", "..");

    default:

      this.appendStringToken(46/*null.PERIOD_TOKEN*/, ".");
      return next;

  }
}
ArrayBasedScanner$String.prototype.tokenizeFractionPart = function(next, start) {
  var done = false;
  LOOP:
  while ($notnull_bool(!done)) {
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:

        break;

      case 101/*null.$e*/:
      case 69/*null.$E*/:

        next = this.tokenizeExponent(this.advance());
        done = true;
        continue LOOP;

      default:

        done = true;
        continue LOOP;

    }
    next = this.advance();
  }
  if ($notnull_bool(next == 100/*null.$d*/ || next == 68/*null.$D*/)) {
    next = this.advance();
  }
  this.appendByteStringToken(100/*null.DOUBLE_TOKEN*/, this.asciiString(start));
  return next;
}
ArrayBasedScanner$String.prototype.tokenizeExponent = function(next) {
  if ($notnull_bool(next == 43/*null.$PLUS*/ || next == 45/*null.$MINUS*/)) {
    next = this.advance();
  }
  var hasDigits = false;
  while ($notnull_bool(true)) {
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:

        hasDigits = true;
        break;

      default:

        if ($notnull_bool(!hasDigits)) {
          $throw(new MalformedInputException(this.charOffset));
        }
        return next;

    }
    next = this.advance();
  }
}
ArrayBasedScanner$String.prototype.tokenizeSlashOrComment = function(next) {
  next = this.advance();
  switch (next) {
    case 42/*null.$STAR*/:

      return this.tokenizeMultiLineComment(next);

    case 47/*null.$SLASH*/:

      return this.tokenizeSingleLineComment(next);

    case 61/*null.$EQ*/:

      this.appendStringToken(47/*null.SLASH_TOKEN*/, "/=");
      return this.advance();

    default:

      this.appendStringToken(47/*null.SLASH_TOKEN*/, "/");
      return next;

  }
}
ArrayBasedScanner$String.prototype.tokenizeSingleLineComment = function(next) {
  while ($notnull_bool(true)) {
    next = this.advance();
    switch (next) {
      case -1:
      case 10/*null.$LF*/:
      case 13/*null.$CR*/:

        return next;

    }
  }
}
ArrayBasedScanner$String.prototype.tokenizeMultiLineComment = function(next) {
  next = this.advance();
  while ($notnull_bool(true)) {
    switch (next) {
      case -1:

        return next;

      case 42/*null.$STAR*/:

        next = this.advance();
        if ($notnull_bool(next == 47/*null.$SLASH*/)) {
          return this.advance();
        }
        else if ($notnull_bool(next == -1)) {
          return next;
        }
        break;

      default:

        next = this.advance();
        break;

    }
  }
}
ArrayBasedScanner$String.prototype.tokenizeIdentifier = function(next) {
  var start = this.byteOffset;
  var state = null;
  if ($notnull_bool(97/*null.$a*/ <= next && next <= 122/*null.$z*/)) {
    state = KeywordState.get$KEYWORD_STATE().next(next);
    next = this.advance();
  }
  var isAscii = true;
  while ($notnull_bool(true)) {
    if ($notnull_bool(97/*null.$a*/ <= next && next <= 122/*null.$z*/)) {
      if ($notnull_bool(state != null)) {
        state = state.next(next);
      }
    }
    else if ($notnull_bool((48/*null.$0*/ <= next && next <= 57/*null.$9*/) || (65/*null.$A*/ <= next && next <= 90/*null.$Z*/) || next == 95/*null.$_*/ || next == 36/*null.$DOLLAR*/)) {
      state = null;
    }
    else if ($notnull_bool(next < 128)) {
      if ($notnull_bool(state != null && state.isLeaf())) {
        this.appendKeywordToken(state.get$keyword());
      }
      else if ($notnull_bool(isAscii)) {
        this.appendByteStringToken(97/*null.IDENTIFIER_TOKEN*/, this.asciiString(start));
      }
      else {
        this.appendByteStringToken(97/*null.IDENTIFIER_TOKEN*/, this.utf8String(start, -1));
      }
      return next;
    }
    else {
      var nonAsciiStart = this.byteOffset;
      do {
        next = this.nextByte();
      }
      while ($notnull_bool(next > 127))
      var string = this.utf8String(nonAsciiStart, -1).toString();
      isAscii = false;
      this.addToCharOffset(string.length);
      return next;
    }
    next = this.advance();
  }
}
ArrayBasedScanner$String.prototype.tokenizeRawString = function(next) {
  var start = this.byteOffset;
  next = this.advance();
  if ($notnull_bool(next == 34/*null.$DQ*/ || next == 39/*null.$SQ*/)) {
    return this.tokenizeString(next, start, true);
  }
  else {
    $throw(new MalformedInputException(this.charOffset));
  }
}
ArrayBasedScanner$String.prototype.tokenizeString = function(next, start, raw) {
  var q = next;
  next = this.advance();
  if ($notnull_bool(q == next)) {
    next = this.advance();
    if ($notnull_bool(q == next)) {
      return this.tokenizeMultiLineString(q, start, raw);
    }
    else {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, -1));
      return next;
    }
  }
  if ($notnull_bool(raw)) {
    return this.tokenizeSingleLineRawString(next, q, start);
  }
  else {
    return this.tokenizeSingleLineString(next, q, start);
  }
}
ArrayBasedScanner$String.prototype.tokenizeSingleLineString = function(next, q1, start) {
  while ($notnull_bool(next != -1)) {
    if ($notnull_bool(next == q1)) {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
      return this.advance();
    }
    else if ($notnull_bool(next == 92/*null.$BACKSLASH*/)) {
      next = this.advance();
      if ($notnull_bool(next == -1)) {
        $throw(new MalformedInputException(this.charOffset));
      }
    }
    else if ($notnull_bool(next == 10/*null.$LF*/ || next == 13/*null.$CR*/)) {
      $throw(new MalformedInputException(this.charOffset));
    }
    next = this.advance();
  }
  $throw(new MalformedInputException(this.charOffset));
}
ArrayBasedScanner$String.prototype.tokenizeSingleLineRawString = function(next, q1, start) {
  next = this.advance();
  while ($notnull_bool(next != -1)) {
    if ($notnull_bool(next == q1)) {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
      return this.advance();
    }
    else if ($notnull_bool(next == 10/*null.$LF*/ || next == 13/*null.$CR*/)) {
      $throw(new MalformedInputException(this.charOffset));
    }
    next = this.advance();
  }
  $throw(new MalformedInputException(this.charOffset));
}
ArrayBasedScanner$String.prototype.tokenizeMultiLineString = function(q, start, raw) {
  var next = this.advance();
  while ($notnull_bool(next != -1)) {
    if ($notnull_bool(next == q)) {
      next = this.advance();
      if ($notnull_bool(next == q)) {
        next = this.advance();
        if ($notnull_bool(next == q)) {
          this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
          return this.advance();
        }
      }
    }
    next = this.advance();
  }
  return next;
}
// ********** Code for top level **************
//  ********** Library util_implementation **************
// ********** Code for LinkFactory **************
function LinkFactory() {}
LinkFactory.Link$factory = function(head, tail) {
  var $0;
  return new LinkEntry(head, (($0 = $notnull_bool((tail == null)) ? const$227/*const EmptyLink<DeclarationBuilder>()*/ : tail) && $0.is$Link$T()));
}
// ********** Code for AbstractLink **************
function AbstractLink() {}
AbstractLink.prototype.is$Link = function(){return this;};
AbstractLink.prototype.is$Link$DeclarationBuilder = function(){return this;};
AbstractLink.prototype.is$Link$Element = function(){return this;};
AbstractLink.prototype.is$Link$Node = function(){return this;};
AbstractLink.prototype.is$Link$T = function(){return this;};
AbstractLink.prototype.is$Link$Type = function(){return this;};
AbstractLink.prototype.is$Iterable = function(){return this;};
AbstractLink.prototype.get$head = function() {
  $throw("bug");
}
AbstractLink.prototype.get$tail = function() {
  $throw("bug");
}
AbstractLink.prototype.prepend = function(element) {
  return LinkFactory.Link$factory(element, this);
}
AbstractLink.prototype.iterator = function() {
  return this.toList().iterator();
}
AbstractLink.prototype.printOn = function(buffer, separatedBy) {
  var $0;
  if ($notnull_bool(this.isEmpty())) return;
  buffer.add(this.get$head());
  for (var link = this.get$tail();
   $notnull_bool(!link.isEmpty()); link = (($0 = link.get$tail()) && $0.is$Link())) {
    buffer.add(separatedBy);
    buffer.add(link.get$head());
  }
}
AbstractLink.prototype.toString = function() {
  var buffer = new StringBufferImpl("");
  buffer.add('[ ');
  this.printOn(buffer, ', ');
  buffer.add(' ]');
  return buffer.toString();
}
AbstractLink.prototype.printOn$1 = function($0) {
  return this.printOn(($0 && $0.is$StringBuffer()), '');
}
;
// ********** Code for AbstractLink$T **************
function AbstractLink$T() {}
$inherits(AbstractLink$T, AbstractLink);
AbstractLink$T.prototype.is$Link = function(){return this;};
AbstractLink$T.prototype.is$Link$DeclarationBuilder = function(){return this;};
AbstractLink$T.prototype.is$Link$Element = function(){return this;};
AbstractLink$T.prototype.is$Link$Node = function(){return this;};
AbstractLink$T.prototype.is$Link$T = function(){return this;};
AbstractLink$T.prototype.is$Link$Type = function(){return this;};
AbstractLink$T.prototype.is$Iterable = function(){return this;};
AbstractLink$T.prototype.iterator = function() {
  return this.toList().iterator();
}
// ********** Code for LinkTail **************
function LinkTail() {
  // Initializers done
}
$inherits(LinkTail, AbstractLink$T);
LinkTail.prototype.is$Link = function(){return this;};
LinkTail.prototype.is$Link$DeclarationBuilder = function(){return this;};
LinkTail.prototype.is$Link$Element = function(){return this;};
LinkTail.prototype.is$Link$Node = function(){return this;};
LinkTail.prototype.is$Link$T = function(){return this;};
LinkTail.prototype.is$Link$Type = function(){return this;};
LinkTail.prototype.is$Iterable = function(){return this;};
LinkTail.prototype.get$head = function() {
  return null;
}
LinkTail.prototype.get$tail = function() {
  return null;
}
LinkTail.prototype.toList = function() {
  return const$226/*const []*/;
}
LinkTail.prototype.isEmpty = function() {
  return true;
}
// ********** Code for LinkTail$DeclarationBuilder **************
function LinkTail$DeclarationBuilder() {
  // Initializers done
}
$inherits(LinkTail$DeclarationBuilder, LinkTail);
LinkTail$DeclarationBuilder.prototype.is$Link = function(){return this;};
LinkTail$DeclarationBuilder.prototype.is$Link$DeclarationBuilder = function(){return this;};
LinkTail$DeclarationBuilder.prototype.is$Link$Element = function(){return this;};
LinkTail$DeclarationBuilder.prototype.is$Link$Node = function(){return this;};
LinkTail$DeclarationBuilder.prototype.is$Link$T = function(){return this;};
LinkTail$DeclarationBuilder.prototype.is$Link$Type = function(){return this;};
LinkTail$DeclarationBuilder.prototype.is$Iterable = function(){return this;};
// ********** Code for LinkTail$Element **************
function LinkTail$Element() {
  // Initializers done
}
$inherits(LinkTail$Element, LinkTail);
LinkTail$Element.prototype.is$Link = function(){return this;};
LinkTail$Element.prototype.is$Link$DeclarationBuilder = function(){return this;};
LinkTail$Element.prototype.is$Link$Element = function(){return this;};
LinkTail$Element.prototype.is$Link$Node = function(){return this;};
LinkTail$Element.prototype.is$Link$T = function(){return this;};
LinkTail$Element.prototype.is$Link$Type = function(){return this;};
LinkTail$Element.prototype.is$Iterable = function(){return this;};
// ********** Code for LinkTail$Node **************
function LinkTail$Node() {
  // Initializers done
}
$inherits(LinkTail$Node, LinkTail);
LinkTail$Node.prototype.is$Link = function(){return this;};
LinkTail$Node.prototype.is$Link$DeclarationBuilder = function(){return this;};
LinkTail$Node.prototype.is$Link$Element = function(){return this;};
LinkTail$Node.prototype.is$Link$Node = function(){return this;};
LinkTail$Node.prototype.is$Link$T = function(){return this;};
LinkTail$Node.prototype.is$Link$Type = function(){return this;};
LinkTail$Node.prototype.is$Iterable = function(){return this;};
// ********** Code for LinkEntry **************
function LinkEntry(head, realTail) {
  this.head = head;
  this.realTail = realTail;
  // Initializers done
}
$inherits(LinkEntry, AbstractLink$T);
LinkEntry.prototype.get$head = function() { return this.head; };
LinkEntry.prototype.get$tail = function() {
  return this.realTail;
}
LinkEntry.prototype.isEmpty = function() {
  return false;
}
LinkEntry.prototype.toList = function() {
  var $0;
  var list = new ListFactory$T();
  for (var link = this;
   $notnull_bool(!link.isEmpty()); link = (($0 = link.get$tail()) && $0.is$Link$T())) {
    list.addLast(link.get$head());
  }
  return list;
}
// ********** Code for LinkEntry$T **************
function LinkEntry$T(head, realTail) {
  this.head = head;
  this.realTail = realTail;
  // Initializers done
}
$inherits(LinkEntry$T, LinkEntry);
// ********** Code for LinkBuilderImplementation **************
function LinkBuilderImplementation() {
  this.head = null
  this.lastLink = null
  // Initializers done
}
LinkBuilderImplementation.prototype.get$head = function() { return this.head; };
LinkBuilderImplementation.prototype.set$head = function(value) { return this.head = value; };
LinkBuilderImplementation.prototype.toLink = function() {
  if ($notnull_bool(this.head == null)) return const$227/*const EmptyLink<DeclarationBuilder>()*/;
  this.lastLink.realTail = const$227/*const EmptyLink<DeclarationBuilder>()*/;
  var link = this.head;
  this.lastLink = null;
  this.head = null;
  return link;
}
LinkBuilderImplementation.prototype.addLast = function(t) {
  var entry = new LinkEntry$T(t, null);
  if ($notnull_bool(this.head == null)) {
    this.head = entry;
  }
  else {
    this.lastLink.realTail = entry;
  }
  this.lastLink = entry;
}
// ********** Code for LinkBuilderImplementation$Type **************
function LinkBuilderImplementation$Type() {
  this.head = null
  this.lastLink = null
  // Initializers done
}
$inherits(LinkBuilderImplementation$Type, LinkBuilderImplementation);
// ********** Code for top level **************
//  ********** Library util **************
// ********** Code for top level **************
//  ********** Library scanner **************
// ********** Code for AbstractScanner **************
function AbstractScanner() {}
AbstractScanner.prototype.tokenize = function() {
  var next = this.advance();
  while ($notnull_bool(next != -1)) {
    next = this.bigSwitch(next);
  }
  this.appendEofToken();
  return this.firstToken();
}
AbstractScanner.prototype.bigSwitch = function(next) {
  this.beginToken();
  switch (next) {
    case 9/*null.$TAB*/:
    case 10/*null.$LF*/:
    case 13/*null.$CR*/:
    case 32/*null.$SPACE*/:

      this.appendWhiteSpace(next);
      return this.advance();

    case 60/*null.$LT*/:

      return this.tokenizeLessThan(next);

    case 62/*null.$GT*/:

      return this.tokenizeGreaterThan(next);

    case 61/*null.$EQ*/:

      return this.tokenizeEquals(next);

    case 33/*null.$BANG*/:

      return this.tokenizeExclamation(next);

    case 43/*null.$PLUS*/:

      return this.tokenizePlus(next);

    case 45/*null.$MINUS*/:

      return this.tokenizeMinus(next);

    case 42/*null.$STAR*/:

      return this.tokenizeMultiply(next);

    case 37/*null.$PERCENT*/:

      return this.tokenizePercent(next);

    case 38/*null.$AMPERSAND*/:

      return this.tokenizeAmpersand(next);

    case 124/*null.$BAR*/:

      return this.tokenizeBar(next);

    case 94/*null.$CARET*/:

      return this.tokenizeCaret(next);

    case 91/*null.$LBRACKET*/:

      return this.tokenizeOpenBracket(next);

    case 126/*null.$TILDE*/:

      return this.tokenizeTilde(next);

    case 92/*null.$BACKSLASH*/:

      this.appendStringToken(92/*null.BACKSLASH_TOKEN*/, "\\");
      return this.advance();

    case 35/*null.$HASH*/:

      return this.tokenizeTag(next);

    case 40/*null.$LPAREN*/:

      this.appendStringToken(40/*null.LPAREN_TOKEN*/, "(");
      return this.advance();

    case 41/*null.$RPAREN*/:

      this.appendStringToken(41/*null.RPAREN_TOKEN*/, ")");
      return this.advance();

    case 44/*null.$COMMA*/:

      this.appendStringToken(44/*null.COMMA_TOKEN*/, ",");
      return this.advance();

    case 58/*null.$COLON*/:

      this.appendStringToken(58/*null.COLON_TOKEN*/, ":");
      return this.advance();

    case 59/*null.$SEMICOLON*/:

      this.appendStringToken(59/*null.SEMICOLON_TOKEN*/, ";");
      return this.advance();

    case 63/*null.$QUESTION*/:

      this.appendStringToken(63/*null.QUESTION_TOKEN*/, "?");
      return this.advance();

    case 93/*null.$RBRACKET*/:

      this.appendStringToken(93/*null.RBRACKET_TOKEN*/, "]");
      return this.advance();

    case 96/*null.$BACKPING*/:

      this.appendStringToken(96/*null.BACKPING_TOKEN*/, "`");
      return this.advance();

    case 123/*null.$LBRACE*/:

      this.appendStringToken(123/*null.LBRACE_TOKEN*/, "{");
      return this.advance();

    case 125/*null.$RBRACE*/:

      this.appendStringToken(125/*null.RBRACE_TOKEN*/, "}");
      return this.advance();

    case 47/*null.$SLASH*/:

      return this.tokenizeSlashOrComment(next);

    case 64/*null.$AT*/:

      return this.tokenizeRawString(next);

    case 34/*null.$DQ*/:
    case 39/*null.$SQ*/:

      return this.tokenizeString(next, this.get$byteOffset(), false);

    case 46/*null.$PERIOD*/:

      return this.tokenizeDotOrNumber(next);

    case 48/*null.$0*/:

      return this.tokenizeHexOrNumber(next);

    case 49/*null.$1*/:
    case 50/*null.$2*/:
    case 51/*null.$3*/:
    case 52/*null.$4*/:
    case 53/*null.$5*/:
    case 54/*null.$6*/:
    case 55/*null.$7*/:
    case 56/*null.$8*/:
    case 57/*null.$9*/:

      return this.tokenizeNumber(next);

    case 36/*null.$DOLLAR*/:
    case 65/*null.$A*/:
    case 66/*null.$B*/:
    case 67/*null.$C*/:
    case 68/*null.$D*/:
    case 69/*null.$E*/:
    case 70/*null.$F*/:
    case 71/*null.$G*/:
    case 72/*null.$H*/:
    case 73/*null.$I*/:
    case 74/*null.$J*/:
    case 75/*null.$K*/:
    case 76/*null.$L*/:
    case 77/*null.$M*/:
    case 78/*null.$N*/:
    case 79/*null.$O*/:
    case 80/*null.$P*/:
    case 81/*null.$Q*/:
    case 82/*null.$R*/:
    case 83/*null.$S*/:
    case 84/*null.$T*/:
    case 85/*null.$U*/:
    case 86/*null.$V*/:
    case 87/*null.$W*/:
    case 88/*null.$X*/:
    case 89/*null.$Y*/:
    case 90/*null.$Z*/:
    case 95/*null.$_*/:
    case 97/*null.$a*/:
    case 98/*null.$b*/:
    case 99/*null.$c*/:
    case 100/*null.$d*/:
    case 101/*null.$e*/:
    case 102/*null.$f*/:
    case 103/*null.$g*/:
    case 104/*null.$h*/:
    case 105/*null.$i*/:
    case 106/*null.$j*/:
    case 107/*null.$k*/:
    case 108/*null.$l*/:
    case 109/*null.$m*/:
    case 110/*null.$n*/:
    case 111/*null.$o*/:
    case 112/*null.$p*/:
    case 113/*null.$q*/:
    case 114/*null.$r*/:
    case 115/*null.$s*/:
    case 116/*null.$t*/:
    case 117/*null.$u*/:
    case 118/*null.$v*/:
    case 119/*null.$w*/:
    case 120/*null.$x*/:
    case 121/*null.$y*/:
    case 122/*null.$z*/:

      return this.tokenizeIdentifier(next);

    default:

      if ($notnull_bool(next == -1)) {
        return -1;
      }
      if ($notnull_bool(next < 0x1f)) {
        $throw(new MalformedInputException(this.get$charOffset()));
      }
      return this.tokenizeIdentifier(next);

  }
}
AbstractScanner.prototype.tokenizeTag = function(next) {
  if ($notnull_bool(this.get$byteOffset() == 0)) {
    if ($notnull_bool(this.peek() == 33/*null.$BANG*/)) {
      do {
        next = this.advance();
      }
      while ($notnull_bool(next != 10/*null.$LF*/ && next != 13/*null.$CR*/))
      return next;
    }
  }
  this.appendStringToken(35/*null.HASH_TOKEN*/, "#");
  return this.advance();
}
AbstractScanner.prototype.tokenizeTilde = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 47/*null.$SLASH*/)) {
    return this.select(61/*null.$EQ*/, "~/=", "~/");
  }
  else {
    this.appendStringToken(126/*null.TILDE_TOKEN*/, "~");
    return next;
  }
}
AbstractScanner.prototype.tokenizeOpenBracket = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 93/*null.$RBRACKET*/)) {
    return this.select(61/*null.$EQ*/, "[]=", "[]");
  }
  else {
    this.appendStringToken(93/*null.RBRACKET_TOKEN*/, "[");
    return next;
  }
}
AbstractScanner.prototype.tokenizeCaret = function(next) {
  return this.select(61/*null.$EQ*/, "^=", "^");
}
AbstractScanner.prototype.tokenizeBar = function(next) {
  next = this.advance();
  switch (next) {
    case 124/*null.$BAR*/:

      this.appendStringToken(124/*null.BAR_TOKEN*/, "||");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(124/*null.BAR_TOKEN*/, "|=");
      return this.advance();

    default:

      this.appendStringToken(124/*null.BAR_TOKEN*/, "|");
      return next;

  }
}
AbstractScanner.prototype.tokenizeAmpersand = function(next) {
  next = this.advance();
  switch (next) {
    case 38/*null.$AMPERSAND*/:

      this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&&");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&=");
      return this.advance();

    default:

      this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&");
      return next;

  }
}
AbstractScanner.prototype.tokenizePercent = function(next) {
  return this.select(61/*null.$EQ*/, "%=", "%");
}
AbstractScanner.prototype.tokenizeMultiply = function(next) {
  return this.select(61/*null.$EQ*/, "*=", "*");
}
AbstractScanner.prototype.tokenizeMinus = function(next) {
  next = this.advance();
  switch (next) {
    case 45/*null.$MINUS*/:

      this.appendStringToken(45/*null.MINUS_TOKEN*/, "--");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(45/*null.MINUS_TOKEN*/, "-=");
      return this.advance();

    default:

      this.appendStringToken(45/*null.MINUS_TOKEN*/, "-");
      return next;

  }
}
AbstractScanner.prototype.tokenizePlus = function(next) {
  next = this.advance();
  switch (next) {
    case 43/*null.$PLUS*/:

      this.appendStringToken(43/*null.PLUS_TOKEN*/, "++");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(43/*null.PLUS_TOKEN*/, "+=");
      return this.advance();

    default:

      this.appendStringToken(43/*null.PLUS_TOKEN*/, "+");
      return next;

  }
}
AbstractScanner.prototype.tokenizeExclamation = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 61/*null.$EQ*/)) {
    return this.select(61/*null.$EQ*/, "!==", "!=");
  }
  this.appendStringToken(33/*null.BANG_TOKEN*/, "!");
  return next;
}
AbstractScanner.prototype.tokenizeEquals = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 61/*null.$EQ*/)) {
    return this.select(61/*null.$EQ*/, "===", "==");
  }
  this.appendStringToken(61/*null.EQ_TOKEN*/, "=");
  return next;
}
AbstractScanner.prototype.tokenizeGreaterThan = function(next) {
  next = this.advance();
  switch (next) {
    case 61/*null.$EQ*/:

      this.appendStringToken(62/*null.GT_TOKEN*/, ">=");
      return this.advance();

    case 62/*null.$GT*/:

      next = this.advance();
      switch (next) {
        case 61/*null.$EQ*/:

          this.appendStringToken(62/*null.GT_TOKEN*/, ">>=");
          return this.advance();

        case 62/*null.$GT*/:

          return this.select(61/*null.$EQ*/, ">>>=", ">>>");

        default:

          this.appendStringToken(62/*null.GT_TOKEN*/, ">>");
          return next;

      }
      $throw(new FallThroughError());

    default:

      this.appendStringToken(62/*null.GT_TOKEN*/, ">");
      return next;

  }
}
AbstractScanner.prototype.tokenizeLessThan = function(next) {
  next = this.advance();
  switch (next) {
    case 61/*null.$EQ*/:

      this.appendStringToken(60/*null.LT_TOKEN*/, "<=");
      return this.advance();

    case 60/*null.$LT*/:

      return this.select(61/*null.$EQ*/, "<<=", "<<");

    default:

      this.appendStringToken(60/*null.LT_TOKEN*/, "<");
      return next;

  }
}
AbstractScanner.prototype.tokenizeNumber = function(next) {
  var start = this.get$byteOffset();
  while ($notnull_bool(true)) {
    next = this.advance();
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:

        break;

      case 46/*null.$PERIOD*/:

        return this.tokenizeFractionPart(this.advance(), start);

      case 101/*null.$e*/:
      case 69/*null.$E*/:
      case 100/*null.$d*/:
      case 68/*null.$D*/:

        return this.tokenizeFractionPart(next, start);

      default:

        this.appendByteStringToken(105/*null.INT_TOKEN*/, this.asciiString(start));
        return next;

    }
  }
}
AbstractScanner.prototype.tokenizeHexOrNumber = function(next) {
  var x = this.peek();
  if ($notnull_bool(x == 120/*null.$x*/ || x == 88/*null.$X*/)) {
    this.advance();
    return this.tokenizeHex(x);
  }
  return this.tokenizeNumber(next);
}
AbstractScanner.prototype.tokenizeHex = function(next) {
  var start = this.get$byteOffset();
  var hasDigits = false;
  while ($notnull_bool(true)) {
    next = this.advance();
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:
      case 65/*null.$A*/:
      case 66/*null.$B*/:
      case 67/*null.$C*/:
      case 68/*null.$D*/:
      case 69/*null.$E*/:
      case 70/*null.$F*/:
      case 97/*null.$a*/:
      case 98/*null.$b*/:
      case 99/*null.$c*/:
      case 100/*null.$d*/:
      case 101/*null.$e*/:
      case 102/*null.$f*/:

        hasDigits = true;
        break;

      default:

        if ($notnull_bool(!hasDigits)) {
          $throw(new MalformedInputException(this.get$charOffset()));
        }
        this.appendByteStringToken(120/*null.HEXADECIMAL_TOKEN*/, this.asciiString(start));
        return next;

    }
  }
}
AbstractScanner.prototype.tokenizeDotOrNumber = function(next) {
  var start = this.get$byteOffset();
  next = this.advance();
  switch (next) {
    case 48/*null.$0*/:
    case 49/*null.$1*/:
    case 50/*null.$2*/:
    case 51/*null.$3*/:
    case 52/*null.$4*/:
    case 53/*null.$5*/:
    case 54/*null.$6*/:
    case 55/*null.$7*/:
    case 56/*null.$8*/:
    case 57/*null.$9*/:

      {
        return this.tokenizeFractionPart(next, start);
      }

    case 46/*null.$PERIOD*/:

      return this.select(46/*null.$PERIOD*/, "...", "..");

    default:

      this.appendStringToken(46/*null.PERIOD_TOKEN*/, ".");
      return next;

  }
}
AbstractScanner.prototype.tokenizeFractionPart = function(next, start) {
  var done = false;
  LOOP:
  while ($notnull_bool(!done)) {
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:

        break;

      case 101/*null.$e*/:
      case 69/*null.$E*/:

        next = this.tokenizeExponent(this.advance());
        done = true;
        continue LOOP;

      default:

        done = true;
        continue LOOP;

    }
    next = this.advance();
  }
  if ($notnull_bool(next == 100/*null.$d*/ || next == 68/*null.$D*/)) {
    next = this.advance();
  }
  this.appendByteStringToken(100/*null.DOUBLE_TOKEN*/, this.asciiString(start));
  return next;
}
AbstractScanner.prototype.tokenizeExponent = function(next) {
  if ($notnull_bool(next == 43/*null.$PLUS*/ || next == 45/*null.$MINUS*/)) {
    next = this.advance();
  }
  var hasDigits = false;
  while ($notnull_bool(true)) {
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:

        hasDigits = true;
        break;

      default:

        if ($notnull_bool(!hasDigits)) {
          $throw(new MalformedInputException(this.get$charOffset()));
        }
        return next;

    }
    next = this.advance();
  }
}
AbstractScanner.prototype.tokenizeSlashOrComment = function(next) {
  next = this.advance();
  switch (next) {
    case 42/*null.$STAR*/:

      return this.tokenizeMultiLineComment(next);

    case 47/*null.$SLASH*/:

      return this.tokenizeSingleLineComment(next);

    case 61/*null.$EQ*/:

      this.appendStringToken(47/*null.SLASH_TOKEN*/, "/=");
      return this.advance();

    default:

      this.appendStringToken(47/*null.SLASH_TOKEN*/, "/");
      return next;

  }
}
AbstractScanner.prototype.tokenizeSingleLineComment = function(next) {
  while ($notnull_bool(true)) {
    next = this.advance();
    switch (next) {
      case -1:
      case 10/*null.$LF*/:
      case 13/*null.$CR*/:

        return next;

    }
  }
}
AbstractScanner.prototype.tokenizeMultiLineComment = function(next) {
  next = this.advance();
  while ($notnull_bool(true)) {
    switch (next) {
      case -1:

        return next;

      case 42/*null.$STAR*/:

        next = this.advance();
        if ($notnull_bool(next == 47/*null.$SLASH*/)) {
          return this.advance();
        }
        else if ($notnull_bool(next == -1)) {
          return next;
        }
        break;

      default:

        next = this.advance();
        break;

    }
  }
}
AbstractScanner.prototype.tokenizeIdentifier = function(next) {
  var start = this.get$byteOffset();
  var state = null;
  if ($notnull_bool(97/*null.$a*/ <= next && next <= 122/*null.$z*/)) {
    state = KeywordState.get$KEYWORD_STATE().next(next);
    next = this.advance();
  }
  var isAscii = true;
  while ($notnull_bool(true)) {
    if ($notnull_bool(97/*null.$a*/ <= next && next <= 122/*null.$z*/)) {
      if ($notnull_bool(state != null)) {
        state = state.next(next);
      }
    }
    else if ($notnull_bool((48/*null.$0*/ <= next && next <= 57/*null.$9*/) || (65/*null.$A*/ <= next && next <= 90/*null.$Z*/) || next == 95/*null.$_*/ || next == 36/*null.$DOLLAR*/)) {
      state = null;
    }
    else if ($notnull_bool(next < 128)) {
      if ($notnull_bool(state != null && state.isLeaf())) {
        this.appendKeywordToken(state.get$keyword());
      }
      else if ($notnull_bool(isAscii)) {
        this.appendByteStringToken(97/*null.IDENTIFIER_TOKEN*/, this.asciiString(start));
      }
      else {
        this.appendByteStringToken(97/*null.IDENTIFIER_TOKEN*/, this.utf8String(start, -1));
      }
      return next;
    }
    else {
      var nonAsciiStart = this.get$byteOffset();
      do {
        next = this.nextByte();
      }
      while ($notnull_bool(next > 127))
      var string = this.utf8String(nonAsciiStart, -1).toString();
      isAscii = false;
      this.addToCharOffset(string.length);
      return next;
    }
    next = this.advance();
  }
}
AbstractScanner.prototype.tokenizeRawString = function(next) {
  var start = this.get$byteOffset();
  next = this.advance();
  if ($notnull_bool(next == 34/*null.$DQ*/ || next == 39/*null.$SQ*/)) {
    return this.tokenizeString(next, start, true);
  }
  else {
    $throw(new MalformedInputException(this.get$charOffset()));
  }
}
AbstractScanner.prototype.tokenizeString = function(next, start, raw) {
  var q = next;
  next = this.advance();
  if ($notnull_bool(q == next)) {
    next = this.advance();
    if ($notnull_bool(q == next)) {
      return this.tokenizeMultiLineString(q, start, raw);
    }
    else {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, -1));
      return next;
    }
  }
  if ($notnull_bool(raw)) {
    return this.tokenizeSingleLineRawString(next, q, start);
  }
  else {
    return this.tokenizeSingleLineString(next, q, start);
  }
}
AbstractScanner.prototype.tokenizeSingleLineString = function(next, q1, start) {
  while ($notnull_bool(next != -1)) {
    if ($notnull_bool(next == q1)) {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
      return this.advance();
    }
    else if ($notnull_bool(next == 92/*null.$BACKSLASH*/)) {
      next = this.advance();
      if ($notnull_bool(next == -1)) {
        $throw(new MalformedInputException(this.get$charOffset()));
      }
    }
    else if ($notnull_bool(next == 10/*null.$LF*/ || next == 13/*null.$CR*/)) {
      $throw(new MalformedInputException(this.get$charOffset()));
    }
    next = this.advance();
  }
  $throw(new MalformedInputException(this.get$charOffset()));
}
AbstractScanner.prototype.tokenizeSingleLineRawString = function(next, q1, start) {
  next = this.advance();
  while ($notnull_bool(next != -1)) {
    if ($notnull_bool(next == q1)) {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
      return this.advance();
    }
    else if ($notnull_bool(next == 10/*null.$LF*/ || next == 13/*null.$CR*/)) {
      $throw(new MalformedInputException(this.get$charOffset()));
    }
    next = this.advance();
  }
  $throw(new MalformedInputException(this.get$charOffset()));
}
AbstractScanner.prototype.tokenizeMultiLineString = function(q, start, raw) {
  var next = this.advance();
  while ($notnull_bool(next != -1)) {
    if ($notnull_bool(next == q)) {
      next = this.advance();
      if ($notnull_bool(next == q)) {
        next = this.advance();
        if ($notnull_bool(next == q)) {
          this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
          return this.advance();
        }
      }
    }
    next = this.advance();
  }
  return next;
}
// ********** Code for AbstractScanner$S **************
function AbstractScanner$S() {}
$inherits(AbstractScanner$S, AbstractScanner);
AbstractScanner$S.prototype.tokenize = function() {
  var next = this.advance();
  while ($notnull_bool(next != -1)) {
    next = this.bigSwitch(next);
  }
  this.appendEofToken();
  return this.firstToken();
}
AbstractScanner$S.prototype.bigSwitch = function(next) {
  this.beginToken();
  switch (next) {
    case 9/*null.$TAB*/:
    case 10/*null.$LF*/:
    case 13/*null.$CR*/:
    case 32/*null.$SPACE*/:

      this.appendWhiteSpace(next);
      return this.advance();

    case 60/*null.$LT*/:

      return this.tokenizeLessThan(next);

    case 62/*null.$GT*/:

      return this.tokenizeGreaterThan(next);

    case 61/*null.$EQ*/:

      return this.tokenizeEquals(next);

    case 33/*null.$BANG*/:

      return this.tokenizeExclamation(next);

    case 43/*null.$PLUS*/:

      return this.tokenizePlus(next);

    case 45/*null.$MINUS*/:

      return this.tokenizeMinus(next);

    case 42/*null.$STAR*/:

      return this.tokenizeMultiply(next);

    case 37/*null.$PERCENT*/:

      return this.tokenizePercent(next);

    case 38/*null.$AMPERSAND*/:

      return this.tokenizeAmpersand(next);

    case 124/*null.$BAR*/:

      return this.tokenizeBar(next);

    case 94/*null.$CARET*/:

      return this.tokenizeCaret(next);

    case 91/*null.$LBRACKET*/:

      return this.tokenizeOpenBracket(next);

    case 126/*null.$TILDE*/:

      return this.tokenizeTilde(next);

    case 92/*null.$BACKSLASH*/:

      this.appendStringToken(92/*null.BACKSLASH_TOKEN*/, "\\");
      return this.advance();

    case 35/*null.$HASH*/:

      return this.tokenizeTag(next);

    case 40/*null.$LPAREN*/:

      this.appendStringToken(40/*null.LPAREN_TOKEN*/, "(");
      return this.advance();

    case 41/*null.$RPAREN*/:

      this.appendStringToken(41/*null.RPAREN_TOKEN*/, ")");
      return this.advance();

    case 44/*null.$COMMA*/:

      this.appendStringToken(44/*null.COMMA_TOKEN*/, ",");
      return this.advance();

    case 58/*null.$COLON*/:

      this.appendStringToken(58/*null.COLON_TOKEN*/, ":");
      return this.advance();

    case 59/*null.$SEMICOLON*/:

      this.appendStringToken(59/*null.SEMICOLON_TOKEN*/, ";");
      return this.advance();

    case 63/*null.$QUESTION*/:

      this.appendStringToken(63/*null.QUESTION_TOKEN*/, "?");
      return this.advance();

    case 93/*null.$RBRACKET*/:

      this.appendStringToken(93/*null.RBRACKET_TOKEN*/, "]");
      return this.advance();

    case 96/*null.$BACKPING*/:

      this.appendStringToken(96/*null.BACKPING_TOKEN*/, "`");
      return this.advance();

    case 123/*null.$LBRACE*/:

      this.appendStringToken(123/*null.LBRACE_TOKEN*/, "{");
      return this.advance();

    case 125/*null.$RBRACE*/:

      this.appendStringToken(125/*null.RBRACE_TOKEN*/, "}");
      return this.advance();

    case 47/*null.$SLASH*/:

      return this.tokenizeSlashOrComment(next);

    case 64/*null.$AT*/:

      return this.tokenizeRawString(next);

    case 34/*null.$DQ*/:
    case 39/*null.$SQ*/:

      return this.tokenizeString(next, this.get$byteOffset(), false);

    case 46/*null.$PERIOD*/:

      return this.tokenizeDotOrNumber(next);

    case 48/*null.$0*/:

      return this.tokenizeHexOrNumber(next);

    case 49/*null.$1*/:
    case 50/*null.$2*/:
    case 51/*null.$3*/:
    case 52/*null.$4*/:
    case 53/*null.$5*/:
    case 54/*null.$6*/:
    case 55/*null.$7*/:
    case 56/*null.$8*/:
    case 57/*null.$9*/:

      return this.tokenizeNumber(next);

    case 36/*null.$DOLLAR*/:
    case 65/*null.$A*/:
    case 66/*null.$B*/:
    case 67/*null.$C*/:
    case 68/*null.$D*/:
    case 69/*null.$E*/:
    case 70/*null.$F*/:
    case 71/*null.$G*/:
    case 72/*null.$H*/:
    case 73/*null.$I*/:
    case 74/*null.$J*/:
    case 75/*null.$K*/:
    case 76/*null.$L*/:
    case 77/*null.$M*/:
    case 78/*null.$N*/:
    case 79/*null.$O*/:
    case 80/*null.$P*/:
    case 81/*null.$Q*/:
    case 82/*null.$R*/:
    case 83/*null.$S*/:
    case 84/*null.$T*/:
    case 85/*null.$U*/:
    case 86/*null.$V*/:
    case 87/*null.$W*/:
    case 88/*null.$X*/:
    case 89/*null.$Y*/:
    case 90/*null.$Z*/:
    case 95/*null.$_*/:
    case 97/*null.$a*/:
    case 98/*null.$b*/:
    case 99/*null.$c*/:
    case 100/*null.$d*/:
    case 101/*null.$e*/:
    case 102/*null.$f*/:
    case 103/*null.$g*/:
    case 104/*null.$h*/:
    case 105/*null.$i*/:
    case 106/*null.$j*/:
    case 107/*null.$k*/:
    case 108/*null.$l*/:
    case 109/*null.$m*/:
    case 110/*null.$n*/:
    case 111/*null.$o*/:
    case 112/*null.$p*/:
    case 113/*null.$q*/:
    case 114/*null.$r*/:
    case 115/*null.$s*/:
    case 116/*null.$t*/:
    case 117/*null.$u*/:
    case 118/*null.$v*/:
    case 119/*null.$w*/:
    case 120/*null.$x*/:
    case 121/*null.$y*/:
    case 122/*null.$z*/:

      return this.tokenizeIdentifier(next);

    default:

      if ($notnull_bool(next == -1)) {
        return -1;
      }
      if ($notnull_bool(next < 0x1f)) {
        $throw(new MalformedInputException(this.get$charOffset()));
      }
      return this.tokenizeIdentifier(next);

  }
}
AbstractScanner$S.prototype.tokenizeTag = function(next) {
  if ($notnull_bool(this.get$byteOffset() == 0)) {
    if ($notnull_bool(this.peek() == 33/*null.$BANG*/)) {
      do {
        next = this.advance();
      }
      while ($notnull_bool(next != 10/*null.$LF*/ && next != 13/*null.$CR*/))
      return next;
    }
  }
  this.appendStringToken(35/*null.HASH_TOKEN*/, "#");
  return this.advance();
}
AbstractScanner$S.prototype.tokenizeTilde = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 47/*null.$SLASH*/)) {
    return this.select(61/*null.$EQ*/, "~/=", "~/");
  }
  else {
    this.appendStringToken(126/*null.TILDE_TOKEN*/, "~");
    return next;
  }
}
AbstractScanner$S.prototype.tokenizeOpenBracket = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 93/*null.$RBRACKET*/)) {
    return this.select(61/*null.$EQ*/, "[]=", "[]");
  }
  else {
    this.appendStringToken(93/*null.RBRACKET_TOKEN*/, "[");
    return next;
  }
}
AbstractScanner$S.prototype.tokenizeCaret = function(next) {
  return this.select(61/*null.$EQ*/, "^=", "^");
}
AbstractScanner$S.prototype.tokenizeBar = function(next) {
  next = this.advance();
  switch (next) {
    case 124/*null.$BAR*/:

      this.appendStringToken(124/*null.BAR_TOKEN*/, "||");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(124/*null.BAR_TOKEN*/, "|=");
      return this.advance();

    default:

      this.appendStringToken(124/*null.BAR_TOKEN*/, "|");
      return next;

  }
}
AbstractScanner$S.prototype.tokenizeAmpersand = function(next) {
  next = this.advance();
  switch (next) {
    case 38/*null.$AMPERSAND*/:

      this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&&");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&=");
      return this.advance();

    default:

      this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&");
      return next;

  }
}
AbstractScanner$S.prototype.tokenizePercent = function(next) {
  return this.select(61/*null.$EQ*/, "%=", "%");
}
AbstractScanner$S.prototype.tokenizeMultiply = function(next) {
  return this.select(61/*null.$EQ*/, "*=", "*");
}
AbstractScanner$S.prototype.tokenizeMinus = function(next) {
  next = this.advance();
  switch (next) {
    case 45/*null.$MINUS*/:

      this.appendStringToken(45/*null.MINUS_TOKEN*/, "--");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(45/*null.MINUS_TOKEN*/, "-=");
      return this.advance();

    default:

      this.appendStringToken(45/*null.MINUS_TOKEN*/, "-");
      return next;

  }
}
AbstractScanner$S.prototype.tokenizePlus = function(next) {
  next = this.advance();
  switch (next) {
    case 43/*null.$PLUS*/:

      this.appendStringToken(43/*null.PLUS_TOKEN*/, "++");
      return this.advance();

    case 61/*null.$EQ*/:

      this.appendStringToken(43/*null.PLUS_TOKEN*/, "+=");
      return this.advance();

    default:

      this.appendStringToken(43/*null.PLUS_TOKEN*/, "+");
      return next;

  }
}
AbstractScanner$S.prototype.tokenizeExclamation = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 61/*null.$EQ*/)) {
    return this.select(61/*null.$EQ*/, "!==", "!=");
  }
  this.appendStringToken(33/*null.BANG_TOKEN*/, "!");
  return next;
}
AbstractScanner$S.prototype.tokenizeEquals = function(next) {
  next = this.advance();
  if ($notnull_bool(next == 61/*null.$EQ*/)) {
    return this.select(61/*null.$EQ*/, "===", "==");
  }
  this.appendStringToken(61/*null.EQ_TOKEN*/, "=");
  return next;
}
AbstractScanner$S.prototype.tokenizeGreaterThan = function(next) {
  next = this.advance();
  switch (next) {
    case 61/*null.$EQ*/:

      this.appendStringToken(62/*null.GT_TOKEN*/, ">=");
      return this.advance();

    case 62/*null.$GT*/:

      next = this.advance();
      switch (next) {
        case 61/*null.$EQ*/:

          this.appendStringToken(62/*null.GT_TOKEN*/, ">>=");
          return this.advance();

        case 62/*null.$GT*/:

          return this.select(61/*null.$EQ*/, ">>>=", ">>>");

        default:

          this.appendStringToken(62/*null.GT_TOKEN*/, ">>");
          return next;

      }
      $throw(new FallThroughError());

    default:

      this.appendStringToken(62/*null.GT_TOKEN*/, ">");
      return next;

  }
}
AbstractScanner$S.prototype.tokenizeLessThan = function(next) {
  next = this.advance();
  switch (next) {
    case 61/*null.$EQ*/:

      this.appendStringToken(60/*null.LT_TOKEN*/, "<=");
      return this.advance();

    case 60/*null.$LT*/:

      return this.select(61/*null.$EQ*/, "<<=", "<<");

    default:

      this.appendStringToken(60/*null.LT_TOKEN*/, "<");
      return next;

  }
}
AbstractScanner$S.prototype.tokenizeNumber = function(next) {
  var start = this.get$byteOffset();
  while ($notnull_bool(true)) {
    next = this.advance();
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:

        break;

      case 46/*null.$PERIOD*/:

        return this.tokenizeFractionPart(this.advance(), start);

      case 101/*null.$e*/:
      case 69/*null.$E*/:
      case 100/*null.$d*/:
      case 68/*null.$D*/:

        return this.tokenizeFractionPart(next, start);

      default:

        this.appendByteStringToken(105/*null.INT_TOKEN*/, this.asciiString(start));
        return next;

    }
  }
}
AbstractScanner$S.prototype.tokenizeHexOrNumber = function(next) {
  var x = this.peek();
  if ($notnull_bool(x == 120/*null.$x*/ || x == 88/*null.$X*/)) {
    this.advance();
    return this.tokenizeHex(x);
  }
  return this.tokenizeNumber(next);
}
AbstractScanner$S.prototype.tokenizeHex = function(next) {
  var start = this.get$byteOffset();
  var hasDigits = false;
  while ($notnull_bool(true)) {
    next = this.advance();
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:
      case 65/*null.$A*/:
      case 66/*null.$B*/:
      case 67/*null.$C*/:
      case 68/*null.$D*/:
      case 69/*null.$E*/:
      case 70/*null.$F*/:
      case 97/*null.$a*/:
      case 98/*null.$b*/:
      case 99/*null.$c*/:
      case 100/*null.$d*/:
      case 101/*null.$e*/:
      case 102/*null.$f*/:

        hasDigits = true;
        break;

      default:

        if ($notnull_bool(!hasDigits)) {
          $throw(new MalformedInputException(this.get$charOffset()));
        }
        this.appendByteStringToken(120/*null.HEXADECIMAL_TOKEN*/, this.asciiString(start));
        return next;

    }
  }
}
AbstractScanner$S.prototype.tokenizeDotOrNumber = function(next) {
  var start = this.get$byteOffset();
  next = this.advance();
  switch (next) {
    case 48/*null.$0*/:
    case 49/*null.$1*/:
    case 50/*null.$2*/:
    case 51/*null.$3*/:
    case 52/*null.$4*/:
    case 53/*null.$5*/:
    case 54/*null.$6*/:
    case 55/*null.$7*/:
    case 56/*null.$8*/:
    case 57/*null.$9*/:

      {
        return this.tokenizeFractionPart(next, start);
      }

    case 46/*null.$PERIOD*/:

      return this.select(46/*null.$PERIOD*/, "...", "..");

    default:

      this.appendStringToken(46/*null.PERIOD_TOKEN*/, ".");
      return next;

  }
}
AbstractScanner$S.prototype.tokenizeFractionPart = function(next, start) {
  var done = false;
  LOOP:
  while ($notnull_bool(!done)) {
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:

        break;

      case 101/*null.$e*/:
      case 69/*null.$E*/:

        next = this.tokenizeExponent(this.advance());
        done = true;
        continue LOOP;

      default:

        done = true;
        continue LOOP;

    }
    next = this.advance();
  }
  if ($notnull_bool(next == 100/*null.$d*/ || next == 68/*null.$D*/)) {
    next = this.advance();
  }
  this.appendByteStringToken(100/*null.DOUBLE_TOKEN*/, this.asciiString(start));
  return next;
}
AbstractScanner$S.prototype.tokenizeExponent = function(next) {
  if ($notnull_bool(next == 43/*null.$PLUS*/ || next == 45/*null.$MINUS*/)) {
    next = this.advance();
  }
  var hasDigits = false;
  while ($notnull_bool(true)) {
    switch (next) {
      case 48/*null.$0*/:
      case 49/*null.$1*/:
      case 50/*null.$2*/:
      case 51/*null.$3*/:
      case 52/*null.$4*/:
      case 53/*null.$5*/:
      case 54/*null.$6*/:
      case 55/*null.$7*/:
      case 56/*null.$8*/:
      case 57/*null.$9*/:

        hasDigits = true;
        break;

      default:

        if ($notnull_bool(!hasDigits)) {
          $throw(new MalformedInputException(this.get$charOffset()));
        }
        return next;

    }
    next = this.advance();
  }
}
AbstractScanner$S.prototype.tokenizeSlashOrComment = function(next) {
  next = this.advance();
  switch (next) {
    case 42/*null.$STAR*/:

      return this.tokenizeMultiLineComment(next);

    case 47/*null.$SLASH*/:

      return this.tokenizeSingleLineComment(next);

    case 61/*null.$EQ*/:

      this.appendStringToken(47/*null.SLASH_TOKEN*/, "/=");
      return this.advance();

    default:

      this.appendStringToken(47/*null.SLASH_TOKEN*/, "/");
      return next;

  }
}
AbstractScanner$S.prototype.tokenizeSingleLineComment = function(next) {
  while ($notnull_bool(true)) {
    next = this.advance();
    switch (next) {
      case -1:
      case 10/*null.$LF*/:
      case 13/*null.$CR*/:

        return next;

    }
  }
}
AbstractScanner$S.prototype.tokenizeMultiLineComment = function(next) {
  next = this.advance();
  while ($notnull_bool(true)) {
    switch (next) {
      case -1:

        return next;

      case 42/*null.$STAR*/:

        next = this.advance();
        if ($notnull_bool(next == 47/*null.$SLASH*/)) {
          return this.advance();
        }
        else if ($notnull_bool(next == -1)) {
          return next;
        }
        break;

      default:

        next = this.advance();
        break;

    }
  }
}
AbstractScanner$S.prototype.tokenizeIdentifier = function(next) {
  var start = this.get$byteOffset();
  var state = null;
  if ($notnull_bool(97/*null.$a*/ <= next && next <= 122/*null.$z*/)) {
    state = KeywordState.get$KEYWORD_STATE().next(next);
    next = this.advance();
  }
  var isAscii = true;
  while ($notnull_bool(true)) {
    if ($notnull_bool(97/*null.$a*/ <= next && next <= 122/*null.$z*/)) {
      if ($notnull_bool(state != null)) {
        state = state.next(next);
      }
    }
    else if ($notnull_bool((48/*null.$0*/ <= next && next <= 57/*null.$9*/) || (65/*null.$A*/ <= next && next <= 90/*null.$Z*/) || next == 95/*null.$_*/ || next == 36/*null.$DOLLAR*/)) {
      state = null;
    }
    else if ($notnull_bool(next < 128)) {
      if ($notnull_bool(state != null && state.isLeaf())) {
        this.appendKeywordToken(state.get$keyword());
      }
      else if ($notnull_bool(isAscii)) {
        this.appendByteStringToken(97/*null.IDENTIFIER_TOKEN*/, this.asciiString(start));
      }
      else {
        this.appendByteStringToken(97/*null.IDENTIFIER_TOKEN*/, this.utf8String(start, -1));
      }
      return next;
    }
    else {
      var nonAsciiStart = this.get$byteOffset();
      do {
        next = this.nextByte();
      }
      while ($notnull_bool(next > 127))
      var string = this.utf8String(nonAsciiStart, -1).toString();
      isAscii = false;
      this.addToCharOffset(string.length);
      return next;
    }
    next = this.advance();
  }
}
AbstractScanner$S.prototype.tokenizeRawString = function(next) {
  var start = this.get$byteOffset();
  next = this.advance();
  if ($notnull_bool(next == 34/*null.$DQ*/ || next == 39/*null.$SQ*/)) {
    return this.tokenizeString(next, start, true);
  }
  else {
    $throw(new MalformedInputException(this.get$charOffset()));
  }
}
AbstractScanner$S.prototype.tokenizeString = function(next, start, raw) {
  var q = next;
  next = this.advance();
  if ($notnull_bool(q == next)) {
    next = this.advance();
    if ($notnull_bool(q == next)) {
      return this.tokenizeMultiLineString(q, start, raw);
    }
    else {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, -1));
      return next;
    }
  }
  if ($notnull_bool(raw)) {
    return this.tokenizeSingleLineRawString(next, q, start);
  }
  else {
    return this.tokenizeSingleLineString(next, q, start);
  }
}
AbstractScanner$S.prototype.tokenizeSingleLineString = function(next, q1, start) {
  while ($notnull_bool(next != -1)) {
    if ($notnull_bool(next == q1)) {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
      return this.advance();
    }
    else if ($notnull_bool(next == 92/*null.$BACKSLASH*/)) {
      next = this.advance();
      if ($notnull_bool(next == -1)) {
        $throw(new MalformedInputException(this.get$charOffset()));
      }
    }
    else if ($notnull_bool(next == 10/*null.$LF*/ || next == 13/*null.$CR*/)) {
      $throw(new MalformedInputException(this.get$charOffset()));
    }
    next = this.advance();
  }
  $throw(new MalformedInputException(this.get$charOffset()));
}
AbstractScanner$S.prototype.tokenizeSingleLineRawString = function(next, q1, start) {
  next = this.advance();
  while ($notnull_bool(next != -1)) {
    if ($notnull_bool(next == q1)) {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
      return this.advance();
    }
    else if ($notnull_bool(next == 10/*null.$LF*/ || next == 13/*null.$CR*/)) {
      $throw(new MalformedInputException(this.get$charOffset()));
    }
    next = this.advance();
  }
  $throw(new MalformedInputException(this.get$charOffset()));
}
AbstractScanner$S.prototype.tokenizeMultiLineString = function(q, start, raw) {
  var next = this.advance();
  while ($notnull_bool(next != -1)) {
    if ($notnull_bool(next == q)) {
      next = this.advance();
      if ($notnull_bool(next == q)) {
        next = this.advance();
        if ($notnull_bool(next == q)) {
          this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
          return this.advance();
        }
      }
    }
    next = this.advance();
  }
  return next;
}
// ********** Code for MalformedInputException **************
function MalformedInputException(ignored) {
  // Initializers done
}
// ********** Code for Parser **************
function Parser(listener) {
  this.listener = listener;
  // Initializers done
}
Parser.prototype.next = function(token) {
  return this.checkEof(token.next);
}
Parser.prototype.checkEof = function(token) {
  if ($notnull_bool(token.kind == 0/*null.EOF_TOKEN*/)) {
    this.listener.unexpectedEof();
    $throw("Unexpected EOF");
  }
  return token;
}
Parser.prototype.parseUnit = function(token) {
  while ($notnull_bool(token.kind != 0/*null.EOF_TOKEN*/)) {
    switch (token.get$value()) {
      case const$203/*Keyword.INTERFACE*/:

        token = this.parseInterface(token);
        break;

      case const$191/*Keyword.CLASS*/:

        token = this.parseClass(token);
        break;

      case const$219/*Keyword.TYPEDEF*/:

        token = this.parseNamedFunctionAlias(token);
        break;

      default:

        if ($notnull_bool($eq(token.get$value(), const$237/*const SourceString("#")*/))) {
          token = this.parseLibraryTags(token);
        }
        else {
          token = this.parseTopLevelMember(token);
        }
        break;

    }
  }
}
Parser.prototype.parseInterface = function(token) {
  this.listener.beginInterface(token);
  token = this.parseIdentifier(this.next(token));
  token = this.parseTypeVariablesOpt(token);
  token = this.parseSupertypesClauseOpt(token);
  token = this.parseFactoryClauseOpt(token);
  return this.parseInterfaceBody(token);
}
Parser.prototype.parseInterfaceBody = function(token) {
  token = this.skipBlock(token);
  this.listener.endInterface(token);
  return token.next;
}
Parser.prototype.parseNamedFunctionAlias = function(token) {
  this.listener.beginFunctionTypeAlias(token);
  token = this.parseReturnTypeOpt(this.next(token));
  token = this.parseIdentifier(token);
  token = this.parseTypeVariablesOpt(token);
  token = this.parseParameters(token);
  this.listener.endFunctionTypeAlias(token);
  return this.expect(const$236/*const SourceString(";")*/, token);
}
Parser.prototype.parseReturnTypeOpt = function(token) {
  if ($notnull_bool($eq(token.get$value(), const$183/*Keyword.VOID*/))) {
    this.listener.voidType(token);
    return this.next(token);
  }
  else {
    return this.parseTypeOpt(token);
  }
}
Parser.prototype.parseParameters = function(token) {
  this.expect(const$234/*const SourceString("(")*/, token);
  if ($notnull_bool(this.optional(const$235/*const SourceString(")")*/, this.next(token)))) {
    return this.next(this.next(token));
  }
  do {
    token = this.parseTypeOpt(this.next(token));
    token = this.parseIdentifier(token);
  }
  while ($notnull_bool(this.optional(const$230/*const SourceString(",")*/, token)))
  return this.expect(const$235/*const SourceString(")")*/, token);
}
Parser.prototype.parseTypeOpt = function(token) {
  switch (true) {
    case this.optional(const$228/*const SourceString("<")*/, this.next(token)):
    case this.optional(const$229/*const SourceString(".")*/, this.next(token)):
    case this.isIdentifier(this.next(token)):

      return this.parseType(token);

    default:

      return token;

  }
}
Parser.prototype.isIdentifier = function(token) {
  switch (token.kind) {
    case 97/*null.IDENTIFIER_TOKEN*/:

      return true;

    case 107/*null.KEYWORD_TOKEN*/:

      return token.get$value().isPseudo;

    default:

      return false;

  }
}
Parser.prototype.parseSupertypesClauseOpt = function(token) {
  if ($notnull_bool(this.optional(const$193/*Keyword.EXTENDS*/, token))) {
    do {
      token = this.parseType(this.next(token));
    }
    while ($notnull_bool(this.optional(const$230/*const SourceString(",")*/, token)))
  }
  return token;
}
Parser.prototype.parseFactoryClauseOpt = function(token) {
  if ($notnull_bool(this.optional(const$195/*Keyword.FACTORY*/, token))) {
    return this.parseType(this.next(token));
  }
  return token;
}
Parser.prototype.skipBlock = function(token) {
  if ($notnull_bool(!this.optional(const$232/*const SourceString("{")*/, token))) {
    return this.listener.expectedBlock(token);
  }
  token = this.next(token);
  var nesting = 1;
  do {
    switch (token.kind) {
      case 123/*null.LBRACE_TOKEN*/:

        nesting++;
        break;

      case 125/*null.RBRACE_TOKEN*/:

        nesting--;
        if ($notnull_bool(nesting == 0)) {
          return token;
        }
        break;

    }
    token = this.next(token);
  }
  while ($notnull_bool(token != null))
  $throw("Internal error: unreachable code");
}
Parser.prototype.parseClass = function(token) {
  this.listener.beginClass(token);
  token = this.parseIdentifier(this.next(token));
  token = this.parseTypeVariablesOpt(token);
  token = this.parseSuperclassClauseOpt(token);
  token = this.parseImplementsOpt(token);
  token = this.parseNativeClassClauseOpt(token);
  return this.parseClassBody(token);
}
Parser.prototype.parseNativeClassClauseOpt = function(token) {
  if ($notnull_bool(this.optional(const$207/*Keyword.NATIVE*/, token))) {
    return this.parseString(this.next(token));
  }
  return token;
}
Parser.prototype.parseString = function(token) {
  switch (token.kind) {
    case 39/*null.STRING_TOKEN*/:

      return this.next(token);

    default:

      return this.listener.expected(const$233/*const SourceString("string")*/, token);

  }
}
Parser.prototype.parseIdentifier = function(token) {
  if ($notnull_bool(this.isIdentifier(token))) {
    this.listener.identifier(token);
  }
  else {
    this.listener.notIdentifier(token);
  }
  return this.next(token);
}
Parser.prototype.parseTypeVariablesOpt = function(token) {
  if ($notnull_bool(!this.optional(const$228/*const SourceString("<")*/, token))) {
    return token;
  }
  this.listener.beginTypeVariables(token);
  do {
    token = this.parseTypeVariable(this.next(token));
  }
  while ($notnull_bool(this.optional(const$230/*const SourceString(",")*/, token)))
  return this.expect(const$231/*const SourceString(">")*/, token);
}
Parser.prototype.expect = function(string, token) {
  if ($notnull_bool($ne(string, token.get$value()))) {
    return this.listener.expected(string, token);
  }
  return token.next;
}
Parser.prototype.parseTypeVariable = function(token) {
  this.listener.beginTypeVariable(token);
  token = this.parseIdentifier(token);
  token = this.parseSuperclassClauseOpt(token);
  this.listener.endTypeVariable(token);
  return token;
}
Parser.prototype.optional = function(value, token) {
  return $eq(value, token.get$value());
}
Parser.prototype.parseSuperclassClauseOpt = function(token) {
  if ($notnull_bool(this.optional(const$193/*Keyword.EXTENDS*/, token))) {
    return this.parseType(this.next(token));
  }
  return token;
}
Parser.prototype.parseType = function(token) {
  if ($notnull_bool(this.isIdentifier(token))) {
    token = this.parseIdentifier(token);
    while ($notnull_bool(this.optional(const$229/*const SourceString(".")*/, token))) {
      token = this.parseIdentifier(this.next(token));
    }
  }
  else {
    token = this.listener.expectedType(token);
  }
  return this.parseTypeArgumentsOpt(token);
}
Parser.prototype.parseTypeArgumentsOpt = function(token) {
  if ($notnull_bool(this.optional(const$228/*const SourceString("<")*/, token))) {
    this.listener.beginTypeArguments(this.next(token));
    do {
      token = this.parseType(this.next(token));
    }
    while ($notnull_bool(this.optional(const$230/*const SourceString(",")*/, token)))
    return this.expect(const$231/*const SourceString(">")*/, token);
  }
  return token;
}
Parser.prototype.parseImplementsOpt = function(token) {
  if ($notnull_bool(this.optional(const$199/*Keyword.IMPLEMENTS*/, token))) {
    do {
      token = this.parseType(this.next(token));
    }
    while ($notnull_bool(this.optional(const$230/*const SourceString(",")*/, token)))
  }
  return token;
}
Parser.prototype.parseClassBody = function(token) {
  token = this.skipBlock(token);
  this.listener.endClass(token);
  return token.next;
}
Parser.prototype.parseTopLevelMember = function(token) {
  var start = token;
  this.listener.beginTopLevelMember(token);
  var previous = token;
  LOOP:
  while ($notnull_bool(token != null)) {
    switch (token.kind) {
      case 123/*null.LBRACE_TOKEN*/:
      case 59/*null.SEMICOLON_TOKEN*/:
      case 40/*null.LPAREN_TOKEN*/:
      case 61/*null.EQ_TOKEN*/:

        break LOOP;

      default:

        previous = token;
        token = this.next(token);
        break;

    }
  }
  token = this.parseIdentifier(previous);
  if ($notnull_bool(this.optional(const$234/*const SourceString("(")*/, token))) {
    this.listener.topLevelMethod(start);
  }
  else if ($notnull_bool(this.optional(const$238/*const SourceString("=")*/, token) || this.optional(const$236/*const SourceString(";")*/, token))) {
    this.listener.topLevelField(start);
  }
  else {
    token = this.listener.unexpected(token);
  }
  while ($notnull_bool(token != null && token.kind != 123/*null.LBRACE_TOKEN*/ && token.kind != 59/*null.SEMICOLON_TOKEN*/)) {
    token = this.next(token);
  }
  if ($notnull_bool(!this.optional(const$236/*const SourceString(";")*/, token))) {
    token = this.skipBlock(token);
  }
  this.listener.endTopLevelMember(token);
  return token.next;
}
Parser.prototype.parseLibraryTags = function(token) {
  this.listener.beginLibraryTag(token);
  token = this.parseIdentifier(this.next(token));
  token = this.expect(const$234/*const SourceString("(")*/, token);
  while ($notnull_bool(token != null && token.kind != 40/*null.LPAREN_TOKEN*/ && token.kind != 41/*null.RPAREN_TOKEN*/)) {
    token = this.next(token);
  }
  token = this.expect(const$235/*const SourceString(")")*/, token);
  return this.expect(const$236/*const SourceString(";")*/, token);
}
// ********** Code for BodyParser **************
function BodyParser(listener0) {
  Parser.call(this, listener0);
  // Initializers done
}
$inherits(BodyParser, Parser);
BodyParser.prototype.parseFunction = function(token) {
  this.listener.beginFunction(token);
  token = this.parseReturnTypeOpt(token);
  this.listener.beginFunctionName(token);
  token = this.parseIdentifier(token);
  this.listener.endFunctionName(token);
  token = this.parseFormalParameters(token);
  return this.parseFunctionBody(token);
}
BodyParser.prototype.parseFormalParameters = function(token) {
  var begin = token;
  this.listener.beginFormalParameters(begin);
  this.expect(const$234/*const SourceString("(")*/, token);
  var parameterCount = 0;
  if ($notnull_bool(this.optional(const$235/*const SourceString(")")*/, token.next))) {
    this.listener.endFormalParameters(parameterCount, begin, token.next);
    return token.next.next;
  }
  do {
    token = this.parseType(this.next(token));
    token = this.parseIdentifier(token);
    ++parameterCount;
  }
  while ($notnull_bool(this.optional(const$230/*const SourceString(",")*/, token)))
  this.listener.endFormalParameters(parameterCount, begin, token);
  return this.expect(const$235/*const SourceString(")")*/, token);
}
BodyParser.prototype.parseFunctionBody = function(token) {
  if ($notnull_bool(this.optional(const$236/*const SourceString(";")*/, token))) {
    this.listener.endFunctionBody(0, null, token);
    return token.next;
  }
  var begin = token;
  var statementCount = 0;
  this.listener.beginFunctionBody(begin);
  token = this.checkEof(this.expect(const$232/*const SourceString("{")*/, token));
  while ($notnull_bool(!this.optional(const$239/*const SourceString("}")*/, token))) {
    token = this.parseStatement(token);
    ++statementCount;
  }
  this.listener.endFunctionBody(statementCount, begin, token);
  return this.expect(const$239/*const SourceString("}")*/, token);
}
BodyParser.prototype.parseStatement = function(token) {
  this.checkEof(token);
  if ($notnull_bool($eq(token.get$value(), const$240/*const SourceString('{')*/))) {
    return this.parseBlock(token);
  }
  switch (token.get$value()) {
    case const$167/*Keyword.RETURN*/:

      return this.parseReturnStatement(token);

    case const$181/*Keyword.VAR*/:

      return this.parseVariablesDeclaration(token);

    case const$157/*Keyword.IF*/:

      return this.parseIfStatement(token);

    default:

      return this.parseExpressionStatement(token);

  }
}
BodyParser.prototype.expectSemicolon = function(token) {
  return this.expect(const$236/*const SourceString(";")*/, token);
}
BodyParser.prototype.parseReturnStatement = function(token) {
  var begin = token;
  this.listener.beginReturnStatement(begin);
  $assert($eq(const$241/*const SourceString("return")*/, token.get$value()), "const SourceString(\"return\") == token.value", "leg/scanner/parser.dart", 393, 12);
  token = this.parseExpression(this.next(token));
  this.listener.endReturnStatement(true, begin, token);
  return this.expectSemicolon(token);
}
BodyParser.prototype.parseExpressionStatement = function(token) {
  this.listener.beginExpressionStatement(token);
  token = this.parseExpression(token);
  this.listener.endExpressionStatement(token);
  return this.expectSemicolon(token);
}
BodyParser.prototype.parseExpression = function(token) {
  token = this.parseConditionalExpression(token);
  if ($notnull_bool(this.isAssignmentOperator(token))) {
    var operator = token;
    token = this.parseExpression(this.next(token));
    this.listener.handleAssignmentExpression(operator);
  }
  return token;
}
BodyParser.prototype.isAssignmentOperator = function(token) {
  return 2 == this.getPrecedence(token);
}
BodyParser.prototype.parseConditionalExpression = function(token) {
  token = this.parseBinaryExpression(token, 4);
  if ($notnull_bool(this.optional(const$242/*const SourceString("?")*/, token))) {
    var question = token;
    token = this.parseExpression(this.next(token));
    var colon = token;
    token = this.expect(const$243/*const SourceString(":")*/, token);
    token = this.parseExpression(token);
    this.listener.handleConditionalExpression(question, colon);
  }
  return token;
}
BodyParser.prototype.parseBinaryExpression = function(token, precedence) {
  $assert(precedence >= 4, "precedence >= 4", "leg/scanner/parser.dart", 434, 12);
  token = this.parsePrimary(token);
  for (var level = this.getPrecedence(token);
   $notnull_bool(level >= precedence); --level) {
    while ($notnull_bool(this.getPrecedence(token) == level)) {
      var operator = token;
      token = this.parseBinaryExpression(this.next(token), level + 1);
      this.listener.handleBinaryExpression(operator);
    }
  }
  return token;
}
BodyParser.prototype.getPrecedence = function(token) {
  if ($notnull_bool(token == null)) return 0;
  var value = token.get$value();
  if ($notnull_bool(!(value instanceof StringWrapper))) return 0;
  switch (value.toString()) {
    case "%=":

      return 2;

    case "&=":

      return 2;

    case "*=":

      return 2;

    case "+=":

      return 2;

    case "-=":

      return 2;

    case "/=":

      return 2;

    case "<<=":

      return 2;

    case "=":

      return 2;

    case ">>=":

      return 2;

    case ">>>=":

      return 2;

    case "^=":

      return 2;

    case "|=":

      return 2;

    case "~/=":

      return 2;

    case "?":

      return 3;

    case "||":

      return 4;

    case "&&":

      return 5;

    case "|":

      return 6;

    case "^":

      return 7;

    case "&":

      return 8;

    case "!=":

      return 9;

    case "!==":

      return 9;

    case "==":

      return 9;

    case "===":

      return 9;

    case "<":

      return 10;

    case "<=":

      return 10;

    case ">":

      return 10;

    case ">=":

      return 10;

    case "is":

      return 10;

    case "<<":

      return 11;

    case ">>":

      return 11;

    case ">>>":

      return 11;

    case "+":

      return 12;

    case "-":

      return 12;

    case "%":

      return 13;

    case "*":

      return 13;

    case "/":

      return 13;

    case "~/":

      return 13;

    default:

      return 0;

  }
}
BodyParser.prototype.parsePrimary = function(token) {
  switch (token.kind) {
    case 105/*null.INT_TOKEN*/:

      return this.parseLiteralInt(token);

    case 100/*null.DOUBLE_TOKEN*/:

      return this.parseLiteralDouble(token);

    case 39/*null.STRING_TOKEN*/:

      return this.parseLiteralString(token);

    case 107/*null.KEYWORD_TOKEN*/:

      {
        switch (token.get$value()) {
          case const$177/*Keyword.TRUE*/:
          case const$149/*Keyword.FALSE*/:

            return this.parseLiteralBool(token);

          default:

            this.listener.unexpected(token);
            $throw("not yet implemented");

        }
      }
      $throw(new FallThroughError());

    case 97/*null.IDENTIFIER_TOKEN*/:

      return this.parseSend(token);

    default:

      this.listener.unexpected(token);
      $throw("not yet implemented");

  }
}
BodyParser.prototype.parseLiteralInt = function(token) {
  this.listener.handleLiteralInt(token);
  return token.next;
}
BodyParser.prototype.parseLiteralDouble = function(token) {
  this.listener.handleLiteralDouble(token);
  return token.next;
}
BodyParser.prototype.parseLiteralString = function(token) {
  this.listener.handleLiteralString(token);
  return token.next;
}
BodyParser.prototype.parseLiteralBool = function(token) {
  this.listener.handleLiteralBool(token);
  return token.next;
}
BodyParser.prototype.parseSend = function(token) {
  this.listener.beginSend(token);
  token = this.parseIdentifier(token);
  token = this.parseArgumentsOpt(token);
  this.listener.endSend(token);
  return token;
}
BodyParser.prototype.parseArgumentsOpt = function(token) {
  if ($notnull_bool(!this.optional(const$234/*const SourceString("(")*/, token))) {
    this.listener.handleNoArgumentsOpt(token);
    return token;
  }
  else return this.parseArguments(token);
}
BodyParser.prototype.parseArguments = function(token) {
  var begin = token;
  this.listener.beginArguments(begin);
  $assert($eq(const$234/*const SourceString("(")*/, token.get$value()), "const SourceString(\"(\") == token.value", "leg/scanner/parser.dart", 559, 12);
  var argumentCount = 0;
  if ($notnull_bool(this.optional(const$235/*const SourceString(")")*/, token.next))) {
    this.listener.endArguments(argumentCount, begin, token.next);
    return token.next.next;
  }
  do {
    token = this.parseExpression(this.next(token));
    ++argumentCount;
  }
  while ($notnull_bool(this.optional(const$230/*const SourceString(",")*/, token)))
  this.listener.endArguments(argumentCount, begin, token);
  return this.expect(const$235/*const SourceString(")")*/, token);
}
BodyParser.prototype.parseVariablesDeclaration = function(token) {
  var count = 1;
  this.listener.beginVariablesDeclaration(token);
  token = this.parseFinalVarOrType(token);
  token = this.parseOptionallyInitializedIdentifier(token);
  while ($notnull_bool(this.optional(const$245/*const SourceString(',')*/, token))) {
    token = this.parseOptionallyInitializedIdentifier(this.next(token));
    ++count;
  }
  this.listener.endVariablesDeclaration(count, token);
  return this.expectSemicolon(token);
}
BodyParser.prototype.parseOptionallyInitializedIdentifier = function(token) {
  this.listener.beginInitializedIdentifier(token);
  token = this.parseIdentifier(token);
  if ($notnull_bool(this.optional(const$244/*const SourceString('=')*/, token))) {
    var assignment = token;
    this.listener.beginInitializer(token);
    token = this.parseExpression(this.next(token));
    this.listener.endInitializer(assignment);
  }
  this.listener.endInitializedIdentifier();
  return token;
}
BodyParser.prototype.parseFinalVarOrType = function(token) {
  this.listener.handleVarKeyword(token);
  return this.expect(const$181/*Keyword.VAR*/, token);
}
BodyParser.prototype.parseIfStatement = function(token) {
  var ifToken = token;
  this.listener.beginIfStatement(ifToken);
  token = this.expect(const$157/*Keyword.IF*/, token);
  this.expect(const$246/*const SourceString('(')*/, token);
  token = this.parseArguments(token);
  token = this.parseStatement(token);
  var elseToken = null;
  if ($notnull_bool(this.optional(const$147/*Keyword.ELSE*/, token))) {
    elseToken = token;
    token = this.parseStatement(token.next);
  }
  this.listener.endIfStatement(ifToken, elseToken);
  return token;
}
BodyParser.prototype.parseBlock = function(token) {
  var begin = token;
  this.listener.beginBlock(begin);
  var statementCount = 0;
  token = this.expect(const$240/*const SourceString('{')*/, token);
  while ($notnull_bool(!this.optional(const$239/*const SourceString("}")*/, token))) {
    token = this.parseStatement(token);
    ++statementCount;
  }
  this.listener.endBlock(statementCount, begin, token);
  return this.expect(const$239/*const SourceString("}")*/, token);
}
// ********** Code for Listener **************
function Listener(canceler) {
  this.classCount = 0
  this.aliasCount = 0
  this.interfaceCount = 0
  this.libraryTagCount = 0
  this.topLevelMemberCount = 0
  this.previousIdentifier = null
  this.canceler = canceler;
  this.builders = const$227/*const EmptyLink<DeclarationBuilder>()*/;
  this.topLevelElements = const$227/*const EmptyLink<DeclarationBuilder>()*/;
  // Initializers done
}
Listener.prototype.beginLibraryTag = function(token) {
  this.canceler.cancel("Cannot handle library tags");
  this.libraryTagCount++;
}
Listener.prototype.beginClass = function(token) {
  this.classCount++;
  this.push(token, this.get$buildClassElement());
}
Listener.prototype.buildClassElement = function(declaration) {
  this.canceler.cancel("Cannot handle classes");
}
Listener.prototype.get$buildClassElement = function() {
  return Listener.prototype.buildClassElement.bind(this);
}
Listener.prototype.endClass = function(token) {
  this.handleDeclaration(this.pop(), token);
}
Listener.prototype.beginInterface = function(token) {
  this.interfaceCount++;
  this.push(token, this.get$buildInterfaceElement());
}
Listener.prototype.buildInterfaceElement = function(declaration) {
  this.canceler.cancel("Cannot handle interfaces");
}
Listener.prototype.get$buildInterfaceElement = function() {
  return Listener.prototype.buildInterfaceElement.bind(this);
}
Listener.prototype.endInterface = function(token) {
  this.handleDeclaration(this.pop(), token);
}
Listener.prototype.beginFunctionTypeAlias = function(token) {
  this.aliasCount++;
  this.push(token, this.get$buildFunctionTypeAliasElement());
}
Listener.prototype.buildFunctionTypeAliasElement = function(declaration) {
  this.canceler.cancel("Cannot handle typedefs");
}
Listener.prototype.get$buildFunctionTypeAliasElement = function() {
  return Listener.prototype.buildFunctionTypeAliasElement.bind(this);
}
Listener.prototype.endFunctionTypeAlias = function(token) {
  this.handleDeclaration(this.pop(), token);
}
Listener.prototype.beginTopLevelMember = function(token) {
  this.topLevelMemberCount++;
}
Listener.prototype.topLevelMethod = function(token) {
  this.push(token, this.get$buildMethod());
  this.builders.get$head().name = this.previousIdentifier.get$source();
}
Listener.prototype.buildMethod = function(declaration) {
  return new PartialFunctionElement(declaration.name, declaration.beginToken, declaration.endToken);
}
Listener.prototype.get$buildMethod = function() {
  return Listener.prototype.buildMethod.bind(this);
}
Listener.prototype.topLevelField = function(token) {
  this.push(token, this.get$buildField());
  this.builders.get$head().name = this.previousIdentifier.get$source();
}
Listener.prototype.buildField = function(declaration) {
  this.canceler.cancel("Cannot handle fields");
}
Listener.prototype.get$buildField = function() {
  return Listener.prototype.buildField.bind(this);
}
Listener.prototype.endTopLevelMember = function(token) {
  this.handleDeclaration(this.pop(), token);
}
Listener.prototype.beginTypeVariable = function(token) {

}
Listener.prototype.endTypeVariable = function(token) {

}
Listener.prototype.beginTypeVariables = function(token) {

}
Listener.prototype.identifier = function(token) {
  this.previousIdentifier = new Identifier(token);
}
Listener.prototype.beginTypeArguments = function(token) {

}
Listener.prototype.expected = function(string, token) {
  this.canceler.cancel(("Expected '" + string + "', but got '" + token + "' ") + ("@ " + token.charOffset + ""));
}
Listener.prototype.unexpectedEof = function() {
  this.canceler.cancel("Unexpected end of file");
}
Listener.prototype.notIdentifier = function(token) {
  this.canceler.cancel(("Expected identifier, but got '" + token + "' ") + ("@ " + token.charOffset + ""));
}
Listener.prototype.expectedType = function(token) {
  this.canceler.cancel(("Expected a type, but got '" + token + "' @ " + token.charOffset + ""));
}
Listener.prototype.expectedBlock = function(token) {
  this.canceler.cancel(("Expected a block, but got '" + token + "' @ " + token.charOffset + ""));
}
Listener.prototype.unexpected = function(token) {
  this.canceler.cancel(("Unexpected token '" + token + "' @ " + token.charOffset + ""));
}
Listener.prototype.push = function(token, builder) {
  var $0;
  this.builders = (($0 = this.builders.prepend(new DeclarationBuilder(token, builder))) && $0.is$Link$DeclarationBuilder());
}
Listener.prototype.addElement = function(element) {
  var $0;
  this.topLevelElements = (($0 = this.topLevelElements.prepend(element)) && $0.is$Link$Element());
}
Listener.prototype.pop = function() {
  var $0;
  var declaration = this.builders.get$head();
  this.builders = (($0 = this.builders.get$tail()) && $0.is$Link$DeclarationBuilder());
  return declaration;
}
Listener.prototype.handleDeclaration = function(declaration, token) {
  declaration.endToken = token;
  declaration.endToken = token;
  this.addElement(declaration.build());
}
Listener.prototype.voidType = function(token) {

}
// ********** Code for DeclarationBuilder **************
function DeclarationBuilder(beginToken, builderFunction) {
  this.beginToken = beginToken;
  this.builderFunction = builderFunction;
  // Initializers done
}
DeclarationBuilder.prototype.get$name = function() { return this.name; };
DeclarationBuilder.prototype.set$name = function(value) { return this.name = value; };
DeclarationBuilder.prototype.build = function() {
  return (this.builderFunction)(this);
}
// ********** Code for BodyListener **************
function BodyListener(canceler0, logger) {
  this.nodes = const$227/*const EmptyLink<DeclarationBuilder>()*/
  this.logger = logger;
  Listener.call(this, canceler0);
  // Initializers done
}
$inherits(BodyListener, Listener);
BodyListener.prototype.beginFormalParameters = function(token) {

}
BodyListener.prototype.endFormalParameters = function(count, beginToken, endToken) {
  this.pushNode(this.makeNodeList(count, beginToken, endToken, ","));
}
BodyListener.prototype.beginArguments = function(token) {

}
BodyListener.prototype.endArguments = function(count, beginToken, endToken) {
  this.pushNode(this.makeNodeList(count, beginToken, endToken, ","));
}
BodyListener.prototype.handleNoArgumentsOpt = function(token) {
  this.pushNode(null);
}
BodyListener.prototype.beginReturnStatement = function(token) {

}
BodyListener.prototype.endReturnStatement = function(hasExpression, beginToken, endToken) {
  var expression = $notnull_bool(hasExpression) ? this.popNode() : null;
  this.pushNode(new Return(beginToken, endToken, expression));
}
BodyListener.prototype.beginExpressionStatement = function(token) {

}
BodyListener.prototype.endExpressionStatement = function(token) {
  this.pushNode(new ExpressionStatement(this.popNode(), token));
}
BodyListener.prototype.onError = function(token, error) {
  this.canceler.cancel(("internal error @ " + token.charOffset + ": '" + token.get$value() + "'") + (": " + error + ""));
}
BodyListener.prototype.get$onError = function() {
  return BodyListener.prototype.onError.bind(this);
}
BodyListener.prototype.handleLiteralInt = function(token) {
  this.pushNode(new LiteralInt(token, this.get$onError()));
}
BodyListener.prototype.handleLiteralDouble = function(token) {
  this.pushNode(new LiteralDouble(token, this.get$onError()));
}
BodyListener.prototype.handleLiteralBool = function(token) {
  this.pushNode(new LiteralBool(token, this.get$onError()));
}
BodyListener.prototype.handleLiteralString = function(token) {
  this.pushNode(new LiteralString(token));
}
BodyListener.prototype.handleBinaryExpression = function(token) {
  var arguments = new NodeList(null, LinkFactory.Link$factory(this.popNode()), null, null);
  this.pushNode(new Send(this.popNode(), new Operator(token), arguments));
}
BodyListener.prototype.handleAssignmentExpression = function(token) {
  var arguments = new NodeList.singleton$ctor(this.popNode());
  var node = this.popNode();
  if ($notnull_bool(!(node instanceof Send))) this.canceler.cancel(('not assignable: ' + node + ''));
  var send = node;
  if ($notnull_bool(!send.get$isPropertyAccess())) this.canceler.cancel(('not assignable: ' + node + ''));
  if ($notnull_bool((send instanceof SetterSend))) this.canceler.cancel('chained assignment');
  this.pushNode(new SetterSend(send.receiver, send.selector, token, arguments));
}
BodyListener.prototype.handleConditionalExpression = function(question, colon) {
  var elseExpression = this.popNode();
  var thenExpression = this.popNode();
  var condition = this.popNode();
  this.canceler.cancel('conditional expression not implemented yet');
}
BodyListener.prototype.beginSend = function(token) {

}
BodyListener.prototype.endSend = function(token) {
  var arguments = this.popNode();
  var selector = this.popNode();
  this.pushNode(new Send(null, selector, arguments));
}
BodyListener.prototype.identifier = function(token) {
  this.pushNode(new Identifier(token));
}
BodyListener.prototype.voidType = function(token) {
  this.pushNode(new Identifier(token));
}
BodyListener.prototype.beginFunction = function(token) {

}
BodyListener.prototype.beginFunctionName = function(token) {

}
BodyListener.prototype.endFunctionName = function(token) {

}
BodyListener.prototype.beginFunctionBody = function(token) {

}
BodyListener.prototype.endFunctionBody = function(count, beginToken, endToken) {
  var $0;
  var block = new Block(this.makeNodeList(count, beginToken, endToken, null));
  var formals = this.popNode();
  var name = this.popNode();
  var type = new TypeAnnotation((($0 = this.popNode()) && $0.is$Identifier()));
  this.pushNode(new FunctionExpression(name, formals, block, type));
}
BodyListener.prototype.beginVariablesDeclaration = function(token) {

}
BodyListener.prototype.endVariablesDeclaration = function(count, endToken) {
  var variables = this.makeNodeList(count, null, null, ",");
  this.pushNode(new VariableDefinitions(null, null, variables, endToken));
}
BodyListener.prototype.beginInitializedIdentifier = function(token) {

}
BodyListener.prototype.endInitializedIdentifier = function() {

}
BodyListener.prototype.beginInitializer = function(token) {

}
BodyListener.prototype.endInitializer = function(assignmentOperator) {
  var operator = new Operator(assignmentOperator);
  var initializer = this.popNode();
  var arguments = new NodeList.singleton$ctor(initializer);
  var name = this.popNode();
  this.pushNode(new Send(name, operator, arguments));
}
BodyListener.prototype.handleVarKeyword = function(token) {

}
BodyListener.prototype.beginIfStatement = function(token) {

}
BodyListener.prototype.endIfStatement = function(ifToken, elseToken) {
  var elsePart = $notnull_bool((elseToken == null)) ? null : this.popNode();
  var thenPart = this.popNode();
  var condition = this.popNode();
  this.pushNode(new If(condition, thenPart, elsePart, ifToken, elseToken));
}
BodyListener.prototype.beginBlock = function(token) {

}
BodyListener.prototype.endBlock = function(count, beginToken, endToken) {
  this.pushNode(new Block(this.makeNodeList(count, beginToken, endToken, null)));
}
BodyListener.prototype.pushNode = function(node) {
  var $0;
  this.nodes = (($0 = this.nodes.prepend(node)) && $0.is$Link$Node());
  this.logger.log(("push " + this.nodes + ""));
}
BodyListener.prototype.popNode = function() {
  var $0;
  $assert(!this.nodes.isEmpty(), "!nodes.isEmpty()", "leg/scanner/listener.dart", 360, 12);
  var node = this.nodes.get$head();
  this.nodes = (($0 = this.nodes.get$tail()) && $0.is$Link$Node());
  this.logger.log(("pop " + this.nodes + ""));
  return node;
}
BodyListener.prototype.makeNodeList = function(count, beginToken, endToken, delimiter) {
  var $0;
  var nodes0 = const$227/*const EmptyLink<DeclarationBuilder>()*/;
  for (; $notnull_bool(count > 0); --count) {
    nodes0 = (($0 = nodes0.prepend(this.popNode())) && $0.is$Link$Node());
  }
  var sourceDelimiter = $notnull_bool((delimiter == null)) ? null : new StringWrapper(delimiter);
  return new NodeList(beginToken, nodes0, endToken, sourceDelimiter);
}
// ********** Code for PartialFunctionElement **************
function PartialFunctionElement(name0, beginToken, endToken) {
  this.beginToken = beginToken;
  this.endToken = endToken;
  FunctionElement.call(this, name0);
  // Initializers done
}
$inherits(PartialFunctionElement, FunctionElement);
PartialFunctionElement.prototype.parseNode = function(canceler, logger) {
  var $0;
  if ($notnull_bool(this.node != null)) return this.node;
  var listener = new BodyListener(canceler, logger);
  new BodyParser(listener).parseFunction(this.beginToken);
  this.node = (($0 = listener.popNode()) && $0.is$FunctionExpression());
  logger.log(("parsed function: " + this.node + ""));
  return this.node;
}
// ********** Code for StringScanner **************
function StringScanner(string) {
  this.string = string;
  ArrayBasedScanner$String.call(this);
  // Initializers done
}
$inherits(StringScanner, ArrayBasedScanner$String);
StringScanner.prototype.nextByte = function() {
  return this.charAt(++this.byteOffset);
}
StringScanner.prototype.peek = function() {
  return this.charAt(this.byteOffset + 1);
}
StringScanner.prototype.charAt = function(index) {
  return $notnull_bool((this.string.length > $assert_num(index))) ? this.string.charCodeAt(index) : -1;
}
StringScanner.prototype.asciiString = function(start) {
  return this.string.substring(start, this.byteOffset);
}
StringScanner.prototype.utf8String = function(start, offset) {
  return this.string.substring(start, this.byteOffset + offset + 1);
}
StringScanner.prototype.appendByteStringToken = function(kind, value) {
  this.tail.next = new StringToken(kind, value, this.tokenStart);
  this.tail = this.tail.next;
}
// ********** Code for Token **************
function Token(kind, charOffset) {
  this.kind = kind;
  this.charOffset = charOffset;
  // Initializers done
}
Token.prototype.get$charOffset = function() { return this.charOffset; };
Token.prototype.get$value = function() {
  return 'EOF';
}
Token.prototype.toString = function() {
  return Strings.String$fromCharCodes$factory([this.kind]);
}
// ********** Code for KeywordToken **************
function KeywordToken(value, charOffset0) {
  this.value = value;
  Token.call(this, 107/*null.KEYWORD_TOKEN*/, charOffset0);
  // Initializers done
}
$inherits(KeywordToken, Token);
KeywordToken.prototype.get$value = function() { return this.value; };
KeywordToken.prototype.toString = function() {
  return this.value.syntax;
}
// ********** Code for StringToken **************
function StringToken(kind0, value0, charOffset0) {
  this.value = new StringWrapper(value0);
  Token.call(this, kind0, charOffset0);
  // Initializers done
}
$inherits(StringToken, Token);
StringToken.prototype.get$value = function() { return this.value; };
StringToken.prototype.toString = function() {
  return this.value.toString();
}
// ********** Code for StringWrapper **************
function StringWrapper(internalString) {
  this.internalString = internalString;
  // Initializers done
}
StringWrapper.prototype.is$SourceString = function(){return this;};
StringWrapper.prototype.hashCode = function() {
  return this.toString().hashCode();
}
StringWrapper.prototype.$eq = function(other) {
  return !!(other && other.is$SourceString) && this.toString() == other.toString();
}
StringWrapper.prototype.printOn = function(sb) {
  sb.add(this.internalString);
}
StringWrapper.prototype.toString = function() {
  return this.internalString;
}
StringWrapper.prototype.printOn$1 = function($0) {
  return this.printOn(($0 && $0.is$StringBuffer()));
}
;
// ********** Code for Keyword **************
function Keyword(syntax, isPseudo) {
  this.syntax = syntax;
  this.isPseudo = isPseudo;
  // Initializers done
}
Keyword.prototype.is$Keyword = function(){return this;};
Keyword.prototype.is$SourceString = function(){return this;};
Keyword.get$keywords = function() {
  if ($notnull_bool(Keyword._keywords == null)) {
    Keyword._keywords = Keyword.computeKeywordMap();
  }
  return Keyword._keywords;
}
Keyword.computeKeywordMap = function() {
  var $0;
  var result = new LinkedHashMapImplementation$String$Keyword();
  for (var $i0 = const$222/*Keyword.values*/.iterator(); $i0.hasNext(); ) {
    var keyword = $i0.next();
    result.$setindex(keyword.syntax, keyword);
  }
  return result;
}
Keyword.prototype.hashCode = function() {
  return this.syntax.hashCode();
}
Keyword.prototype.$eq = function(other) {
  return !!(other && other.is$SourceString) && this.toString() == other.toString();
}
Keyword.prototype.printOn = function(sb) {
  sb.add(this.syntax);
}
Keyword.prototype.toString = function() {
  return this.syntax;
}
Keyword.prototype.printOn$1 = function($0) {
  return this.printOn(($0 && $0.is$StringBuffer()));
}
;
// ********** Code for KeywordState **************
function KeywordState() {}
KeywordState.get$KEYWORD_STATE = function() {
  if ($notnull_bool(KeywordState._KEYWORD_STATE == null)) {
    var strings = new ListFactory$String(const$222/*Keyword.values*/.get$length());
    for (var i = 0;
     $notnull_bool(i < const$222/*Keyword.values*/.get$length()); i++) {
      strings.$setindex(i, const$222/*Keyword.values*/[i].syntax);
    }
    strings.sort((function (a, b) {
      return a.compareTo(b);
    })
    );
    KeywordState._KEYWORD_STATE = KeywordState.computeKeywordStateTable(0, strings, 0, strings.length);
  }
  return KeywordState._KEYWORD_STATE;
}
KeywordState.computeKeywordStateTable = function(start, strings, offset, length) {
  var result = new ListFactory$KeywordState(26);
  $assert(length != 0, "length != 0", "leg/scanner/keyword.dart", 160, 12);
  var chunk = 0;
  var chunkStart = -1;
  for (var i = offset;
   $notnull_bool(i < offset + length); i++) {
    if ($notnull_bool(strings.$index(i).length > start)) {
      var c = strings.$index(i).charCodeAt(start);
      if ($notnull_bool(chunk != c)) {
        if ($notnull_bool(chunkStart != -1)) {
          result.$setindex(chunk - 97/*null.$a*/, KeywordState.computeKeywordStateTable(start + 1, strings, chunkStart, i - chunkStart));
        }
        chunkStart = i;
        chunk = c;
      }
    }
  }
  if ($notnull_bool(chunkStart != -1)) {
    result.$setindex(chunk - 97/*null.$a*/, KeywordState.computeKeywordStateTable(start + 1, strings, chunkStart, offset + length - chunkStart));
  }
  else {
    $assert(length == 1, "length == 1", "leg/scanner/keyword.dart", 182, 14);
    return new LeafKeywordState($assert_String(strings.$index(offset)));
  }
  return new ArrayKeywordState(result);
}
// ********** Code for ArrayKeywordState **************
function ArrayKeywordState(table) {
  this.table = table;
  // Initializers done
}
$inherits(ArrayKeywordState, KeywordState);
ArrayKeywordState.prototype.isLeaf = function() {
  return false;
}
ArrayKeywordState.prototype.next = function(c) {
  return this.table.$index(c - 97/*null.$a*/);
}
ArrayKeywordState.prototype.get$keyword = function() {
  $throw("should not be called");
}
ArrayKeywordState.prototype.toString = function() {
  var sb = new StringBufferImpl("");
  sb.add("[");
  var foo = this.table;
  for (var i = 0;
   $notnull_bool(i < foo.length); i++) {
    if ($notnull_bool($ne(foo.$index(i), null))) {
      sb.add(("" + (i + 97/*null.$a*/) + ": " + foo.$index(i) + "; "));
    }
  }
  sb.add("]");
  return sb.toString();
}
// ********** Code for LeafKeywordState **************
function LeafKeywordState(syntax) {
  var $0;
  this.keyword = (($0 = Keyword.get$keywords().$index(syntax)) && $0.is$Keyword());
  // Initializers done
}
$inherits(LeafKeywordState, KeywordState);
LeafKeywordState.prototype.get$keyword = function() { return this.keyword; };
LeafKeywordState.prototype.set$keyword = function(value) { return this.keyword = value; };
LeafKeywordState.prototype.isLeaf = function() {
  return true;
}
LeafKeywordState.prototype.next = function(c) {
  return null;
}
LeafKeywordState.prototype.toString = function() {
  return this.keyword.syntax;
}
// ********** Code for top level **************
//  ********** Library tree **************
// ********** Code for Node **************
function Node() {}
Node.prototype.is$Node = function(){return this;};
Node.prototype.hashCode = function() {
  return this._hashCode;
}
Node.prototype.toString = function() {
  return this.unparse();
}
Node.prototype.unparse = function() {
  var unparser = new DebugUnparser();
  try {
    return unparser.unparse(this);
  } catch (e) {
    e = $toDartException(e);
    return ('<<unparse error: ' + Object.prototype.toString.call(this) + ': ' + unparser.sb + '>>');
  }
}
// ********** Code for Expression **************
function Expression() {}
$inherits(Expression, Node);
// ********** Code for Statement **************
function Statement() {}
$inherits(Statement, Node);
// ********** Code for Send **************
function Send(receiver, selector, argumentsNode) {
  this.receiver = receiver;
  this.selector = selector;
  this.argumentsNode = argumentsNode;
  // Initializers done
}
$inherits(Send, Expression);
Send.prototype.get$arguments = function() {
  return this.argumentsNode.nodes;
}
Send.prototype.accept = function(visitor) {
  return visitor.visitSend(this);
}
Send.prototype.get$isPropertyAccess = function() {
  return this.argumentsNode == null;
}
Send.prototype.getBeginToken = function() {
  return firstBeginToken(this.receiver, this.selector);
}
Send.prototype.getEndToken = function() {
  var token = this.argumentsNode.getEndToken();
  if ($notnull_bool(token != null)) return token;
  if ($notnull_bool(this.selector != null)) {
    return this.selector.getEndToken();
  }
  return this.receiver.getBeginToken();
}
// ********** Code for SetterSend **************
function SetterSend(receiver0, selector0, assignmentOperator, argumentsNode0) {
  this.assignmentOperator = assignmentOperator;
  Send.call(this, receiver0, selector0, argumentsNode0);
  // Initializers done
}
$inherits(SetterSend, Send);
SetterSend.prototype.accept = function(visitor) {
  return visitor.visitSetterSend(this);
}
// ********** Code for NodeList **************
function NodeList(beginToken, nodes, endToken, delimiter) {
  this.beginToken = beginToken;
  this.nodes = nodes;
  this.endToken = endToken;
  this.delimiter = delimiter;
  // Initializers done
}
NodeList.singleton$ctor = function(node) {
  NodeList.call(this, null, LinkFactory.Link$factory(node));
  // Initializers done
}
NodeList.singleton$ctor.prototype = NodeList.prototype;
$inherits(NodeList, Node);
NodeList.prototype.accept = function(visitor) {
  return visitor.visitNodeList(this);
}
NodeList.prototype.getBeginToken = function() {
  var $0;
  if ($notnull_bool(this.beginToken != null)) return this.beginToken;
  if ($notnull_bool(this.nodes != null)) {
    for (var link = this.nodes;
     $notnull_bool(!link.isEmpty()); link = (($0 = link.get$tail()) && $0.is$Link$Node())) {
      if ($notnull_bool(link.get$head().getBeginToken() != null)) {
        return link.get$head().getBeginToken();
      }
      if ($notnull_bool(link.get$head().getEndToken() != null)) {
        return link.get$head().getEndToken();
      }
    }
  }
  return this.endToken;
}
NodeList.prototype.getEndToken = function() {
  var $0;
  if ($notnull_bool(this.endToken != null)) return this.endToken;
  if ($notnull_bool(this.nodes != null)) {
    var link = this.nodes;
    while ($notnull_bool(!link.get$tail().isEmpty())) link = (($0 = link.get$tail()) && $0.is$Link$Node());
    if ($notnull_bool(link.get$head().getEndToken() != null)) return link.get$head().getEndToken();
    if ($notnull_bool(link.get$head().getBeginToken() != null)) return link.get$head().getBeginToken();
  }
  return this.beginToken;
}
// ********** Code for Block **************
function Block(statements) {
  this.statements = statements;
  // Initializers done
}
$inherits(Block, Statement);
Block.prototype.accept = function(visitor) {
  return visitor.visitBlock(this);
}
Block.prototype.getBeginToken = function() {
  return this.statements.getBeginToken();
}
Block.prototype.getEndToken = function() {
  return this.statements.getEndToken();
}
// ********** Code for If **************
function If(condition, thenPart, elsePart, ifToken, elseToken) {
  this.condition = condition;
  this.thenPart = thenPart;
  this.elsePart = elsePart;
  this.ifToken = ifToken;
  this.elseToken = elseToken;
  // Initializers done
}
$inherits(If, Statement);
If.prototype.get$hasElsePart = function() {
  return this.elsePart != null;
}
If.prototype.accept = function(visitor) {
  return visitor.visitIf(this);
}
If.prototype.getBeginToken = function() {
  return this.ifToken;
}
If.prototype.getEndToken = function() {
  if ($notnull_bool(this.elsePart == null)) return this.thenPart.getEndToken();
  return this.elsePart.getEndToken();
}
// ********** Code for FunctionExpression **************
function FunctionExpression(name, parameters, body, returnType) {
  this.name = name;
  this.parameters = parameters;
  this.body = body;
  this.returnType = returnType;
  // Initializers done
}
$inherits(FunctionExpression, Expression);
FunctionExpression.prototype.is$FunctionExpression = function(){return this;};
FunctionExpression.prototype.get$name = function() { return this.name; };
FunctionExpression.prototype.get$parameters = function() { return this.parameters; };
FunctionExpression.prototype.get$returnType = function() { return this.returnType; };
FunctionExpression.prototype.accept = function(visitor) {
  return visitor.visitFunctionExpression(this);
}
FunctionExpression.prototype.getBeginToken = function() {
  return firstBeginToken(this.returnType, this.name);
}
FunctionExpression.prototype.getEndToken = function() {
  return this.body.getEndToken();
}
// ********** Code for Literal **************
function Literal(token, handler) {
  this.token = token;
  this.handler = handler;
  // Initializers done
}
$inherits(Literal, Expression);
// ********** Code for Literal$SourceString **************
function Literal$SourceString(token, handler) {
  this.token = token;
  this.handler = handler;
  // Initializers done
}
$inherits(Literal$SourceString, Literal);
Literal$SourceString.prototype.hashCode = function() {
  return this._hashCode;
}
// ********** Code for Literal$bool **************
function Literal$bool(token, handler) {
  this.token = token;
  this.handler = handler;
  // Initializers done
}
$inherits(Literal$bool, Literal);
Literal$bool.prototype.hashCode = function() {
  return this._hashCode;
}
// ********** Code for Literal$double **************
function Literal$double(token, handler) {
  this.token = token;
  this.handler = handler;
  // Initializers done
}
$inherits(Literal$double, Literal);
Literal$double.prototype.hashCode = function() {
  return this._hashCode;
}
// ********** Code for Literal$int **************
function Literal$int(token, handler) {
  this.token = token;
  this.handler = handler;
  // Initializers done
}
$inherits(Literal$int, Literal);
Literal$int.prototype.hashCode = function() {
  return this._hashCode;
}
// ********** Code for LiteralInt **************
function LiteralInt(token0, handler0) {
  Literal$int.call(this, token0, handler0);
  // Initializers done
}
$inherits(LiteralInt, Literal$int);
LiteralInt.prototype.get$value = function() {
  try {
    return Math.parseInt($assert_String(this.token.get$value().toString()));
  } catch (ex) {
    ex = $toDartException(ex);
    if (!(ex instanceof BadNumberFormatException)) throw ex;
    (this.handler)(this.token, ex);
  }
}
LiteralInt.prototype.accept = function(visitor) {
  return visitor.visitLiteralInt(this);
}
LiteralInt.prototype.getBeginToken = function() {
  return null;
}
LiteralInt.prototype.getEndToken = function() {
  return null;
}
// ********** Code for LiteralDouble **************
function LiteralDouble(token0, handler0) {
  Literal$double.call(this, token0, handler0);
  // Initializers done
}
$inherits(LiteralDouble, Literal$double);
LiteralDouble.prototype.get$value = function() {
  try {
    return Math.parseDouble($assert_String(this.token.get$value().toString()));
  } catch (ex) {
    ex = $toDartException(ex);
    if (!(ex instanceof BadNumberFormatException)) throw ex;
    (this.handler)(this.token, ex);
  }
}
LiteralDouble.prototype.accept = function(visitor) {
  return visitor.visitLiteralDouble(this);
}
// ********** Code for LiteralBool **************
function LiteralBool(token0, handler0) {
  Literal$bool.call(this, token0, handler0);
  // Initializers done
}
$inherits(LiteralBool, Literal$bool);
LiteralBool.prototype.get$value = function() {
  switch (this.token.get$value()) {
    case const$177/*Keyword.TRUE*/:

      return true;

    case const$149/*Keyword.FALSE*/:

      return false;

    default:

      (this.handler)(this.token, ("not a bool " + this.token.get$value() + ""));

  }
}
LiteralBool.prototype.accept = function(visitor) {
  return visitor.visitLiteralBool(this);
}
// ********** Code for LiteralString **************
function LiteralString(token0) {
  Literal$SourceString.call(this, token0, to$call$2(null));
  // Initializers done
}
$inherits(LiteralString, Literal$SourceString);
LiteralString.prototype.get$value = function() {
  return this.token.get$value();
}
LiteralString.prototype.accept = function(visitor) {
  return visitor.visitLiteralString(this);
}
// ********** Code for Identifier **************
function Identifier(token) {
  this.token = token;
  // Initializers done
}
$inherits(Identifier, Expression);
Identifier.prototype.is$Identifier = function(){return this;};
Identifier.prototype.get$source = function() {
  return this.token.get$value();
}
Identifier.prototype.accept = function(visitor) {
  return visitor.visitIdentifier(this);
}
Identifier.prototype.getBeginToken = function() {
  return this.token;
}
Identifier.prototype.getEndToken = function() {
  return this.token;
}
// ********** Code for Operator **************
function Operator(token0) {
  Identifier.call(this, token0);
  // Initializers done
}
$inherits(Operator, Identifier);
Operator.prototype.accept = function(visitor) {
  return visitor.visitOperator(this);
}
// ********** Code for Parameter **************
function Parameter() {}
$inherits(Parameter, Node);
Parameter.prototype.get$name = function() { return this.name; };
Parameter.prototype.accept = function(visitor) {
  return visitor.visitParameter(this);
}
Parameter.prototype.getBeginToken = function() {
  return firstBeginToken(this.typeAnnotation, this.name);
}
Parameter.prototype.getEndToken = function() {
  return this.name.getEndToken();
}
// ********** Code for Return **************
function Return(beginToken, endToken, expression) {
  this.beginToken = beginToken;
  this.endToken = endToken;
  this.expression = expression;
  // Initializers done
}
$inherits(Return, Statement);
Return.prototype.get$hasExpression = function() {
  return this.expression != null;
}
Return.prototype.accept = function(visitor) {
  return visitor.visitReturn(this);
}
Return.prototype.getBeginToken = function() {
  return this.beginToken;
}
Return.prototype.getEndToken = function() {
  return this.endToken;
}
// ********** Code for ExpressionStatement **************
function ExpressionStatement(expression, endToken) {
  this.expression = expression;
  this.endToken = endToken;
  // Initializers done
}
$inherits(ExpressionStatement, Statement);
ExpressionStatement.prototype.accept = function(visitor) {
  return visitor.visitExpressionStatement(this);
}
ExpressionStatement.prototype.getBeginToken = function() {
  return this.expression.getBeginToken();
}
// ********** Code for TypeAnnotation **************
function TypeAnnotation(typeName) {
  this.typeName = typeName;
  // Initializers done
}
$inherits(TypeAnnotation, Node);
TypeAnnotation.prototype.get$typeName = function() { return this.typeName; };
TypeAnnotation.prototype.accept = function(visitor) {
  return visitor.visitTypeAnnotation(this);
}
TypeAnnotation.prototype.getBeginToken = function() {
  return this.typeName.getBeginToken();
}
TypeAnnotation.prototype.getEndToken = function() {
  return this.typeName.getEndToken();
}
// ********** Code for VariableDefinitions **************
function VariableDefinitions(type, modifiers, definitions, endToken) {
  this.type = type;
  this.modifiers = modifiers;
  this.definitions = definitions;
  this.endToken = endToken;
  // Initializers done
}
$inherits(VariableDefinitions, Statement);
VariableDefinitions.prototype.accept = function(visitor) {
  return visitor.visitVariableDefinitions(this);
}
VariableDefinitions.prototype.getBeginToken = function() {
  return firstBeginToken(this.type, this.definitions);
}
VariableDefinitions.prototype.getEndToken = function() {
  return this.endToken;
}
// ********** Code for DebugUnparser **************
function DebugUnparser() {
  // Initializers done
}
DebugUnparser.prototype.unparse = function(node) {
  this.separator = '';
  this.sb = new StringBufferImpl("");
  this.visit(node);
  return this.sb.toString();
}
DebugUnparser.prototype.visit = function(node, withSeparator) {
  var previous = this.separator;
  this.separator = $assert_String($notnull_bool((withSeparator != null)) ? withSeparator : this.separator);
  if ($notnull_bool(node != null)) node.accept(this);
  this.separator = previous;
}
DebugUnparser.prototype.visitBlock = function(node) {
  this.visit(node.statements);
}
DebugUnparser.prototype.visitExpressionStatement = function(node) {
  this.visit(node.expression);
  this.sb.add(';');
}
DebugUnparser.prototype.visitFunctionExpression = function(node) {
  if ($notnull_bool(node.returnType != null)) {
    this.visit(node.returnType);
    this.sb.add(' ');
  }
  this.visit(node.name);
  this.visit(node.parameters, ', ');
  this.visit(node.body);
}
DebugUnparser.prototype.visitIdentifier = function(node) {
  node.get$source().printOn(this.sb);
}
DebugUnparser.prototype.visitIf = function(node) {
  node.ifToken.get$value().printOn$1(this.sb);
  this.visit(node.condition);
  this.visit(node.thenPart);
  if ($notnull_bool(node.get$hasElsePart())) {
    node.elseToken.get$value().printOn$1(this.sb);
    this.visit(node.elsePart);
  }
}
DebugUnparser.prototype.visitLiteralBool = function(node) {
  node.token.get$value().printOn$1(this.sb);
}
DebugUnparser.prototype.visitLiteralDouble = function(node) {
  node.token.get$value().printOn$1(this.sb);
}
DebugUnparser.prototype.visitLiteralInt = function(node) {
  node.token.get$value().printOn$1(this.sb);
}
DebugUnparser.prototype.visitLiteralString = function(node) {
  node.token.get$value().printOn$1(this.sb);
}
DebugUnparser.prototype.visitNodeList = function(node) {
  var $0;
  var first = true;
  if ($notnull_bool(node.beginToken != null)) this.sb.add(node.beginToken);
  if ($notnull_bool(node.nodes != null)) {
    var delimiter = node.delimiter;
    if ($notnull_bool(delimiter == null)) delimiter = new StringWrapper(this.separator);
    var $list = node.nodes;
    for (var $i = node.nodes.iterator(); $i.hasNext(); ) {
      var element = $i.next();
      if ($notnull_bool(!first)) delimiter.printOn(this.sb);
      first = false;
      this.visit(element);
    }
  }
  if ($notnull_bool(node.endToken != null)) this.sb.add(node.endToken);
}
DebugUnparser.prototype.visitOperator = function(node) {
  this.visitIdentifier(node);
}
DebugUnparser.prototype.visitParameter = function(node) {
  if ($notnull_bool(node.typeAnnotation != null)) {
    this.visit(node.typeAnnotation);
    this.sb.add(' ');
  }
  this.visit(node.name);
}
DebugUnparser.prototype.visitReturn = function(node) {
  node.beginToken.get$value().printOn$1(this.sb);
  if ($notnull_bool(node.get$hasExpression())) {
    this.sb.add(' ');
    this.visit(node.expression);
  }
  node.endToken.get$value().printOn$1(this.sb);
}
DebugUnparser.prototype.visitSend = function(node) {
  if ($notnull_bool(node.receiver != null)) {
    this.visit(node.receiver);
    if ($notnull_bool(!(node.selector instanceof Operator))) this.sb.add('.');
  }
  this.visit(node.selector);
  this.visit(node.argumentsNode, ', ');
}
DebugUnparser.prototype.visitSetterSend = function(node) {
  if ($notnull_bool(node.receiver != null)) {
    this.visit(node.receiver);
    this.sb.add('.');
  }
  this.visit(node.selector);
  node.assignmentOperator.get$value().printOn$1(this.sb);
  this.visit(node.argumentsNode, ', ');
}
DebugUnparser.prototype.visitTypeAnnotation = function(node) {
  this.visit(node.typeName);
}
DebugUnparser.prototype.visitVariableDefinitions = function(node) {
  if ($notnull_bool(node.type != null)) {
    this.visit(node.type);
    this.sb.add(' ');
  }
  this.visit(node.definitions, ', ');
  this.sb.add('; ');
}
// ********** Code for top level **************
function firstBeginToken(first, second) {
  return $notnull_bool((first != null)) ? first.getBeginToken() : second.getBeginToken();
}
//  ********** Library elements **************
// ********** Code for Element **************
function Element(name, enclosingElement) {
  this.name = name;
  this.enclosingElement = enclosingElement;
  // Initializers done
}
Element.prototype.is$Element = function(){return this;};
Element.prototype.get$name = function() { return this.name; };
Element.prototype.hashCode = function() {
  return this.name.hashCode();
}
// ********** Code for FunctionElement **************
function FunctionElement(name0) {
  Element.call(this, name0);
  // Initializers done
}
$inherits(FunctionElement, Element);
FunctionElement.prototype.computeType = function(compiler, types) {
  var $0;
  if ($notnull_bool(this.type != null)) return this.type;
  var node = this.parseNode(compiler, compiler);
  var returnType = getType(node.returnType, types);
  var parameterTypes = new LinkBuilderImplementation$Type();
  for (var link = node.parameters.nodes;
   $notnull_bool(!link.isEmpty()); link = link.get$tail()) {
    compiler.cancel('parameters not supported.');
    var parameter = link.get$head();
    parameterTypes.addLast(getType(parameter.typeAnnotation, types));
  }
  this.type = new FunctionType(returnType, (($0 = parameterTypes.toLink()) && $0.is$Link$Type()));
  return this.type;
}
// ********** Code for top level **************
function getType(annotation, types) {
  if ($notnull_bool(annotation == null || annotation.typeName == null)) {
    return types.DYNAMIC;
  }
  var name = annotation.typeName.get$source();
  if ($notnull_bool($eq(name, types.VOID.get$name()))) {
    return types.VOID;
  }
  else if ($notnull_bool($eq(name, types.INT.get$name()))) {
    return types.INT;
  }
  else if ($notnull_bool($eq(name, types.STRING.get$name()))) {
    return types.STRING;
  }
  else {
    $throw("Unreachable");
  }
}
//  ********** Library ssa **************
// ********** Code for SsaBuilderTask **************
function SsaBuilderTask(compiler0) {
  CompilerTask.call(this, compiler0);
  // Initializers done
}
$inherits(SsaBuilderTask, CompilerTask);
SsaBuilderTask.prototype.get$name = function() {
  return 'SSA builder';
}
SsaBuilderTask.prototype.build = function(tree) {
  var $this = this; // closure support
  return this.measure((function () {
    var function_ = tree;
    var graph = $this.compileMethod(function_.body);
    $assert(graph.isValid(), "graph.isValid()", "leg/ssa/builder.dart", 13, 14);
    if ($notnull_bool(false/*null.GENERATE_SSA_TRACE*/)) {
      var name0 = tree.get$name();
      HTracer.HTracer$singleton$factory().traceCompilation(name0.get$source().toString());
      HTracer.HTracer$singleton$factory().traceGraph('builder', graph);
    }
    return graph;
  })
  );
}
SsaBuilderTask.prototype.compileMethod = function(body) {
  var builder = new SsaBuilder(this.compiler);
  var graph = builder.build(body);
  return graph;
}
// ********** Code for SsaBuilder **************
function SsaBuilder(compiler) {
  this.compiler = compiler;
  // Initializers done
}
SsaBuilder.prototype.build = function(body) {
  this.graph = new HGraph();
  this.block = new HBasicBlock();
  this.stack = new ListFactory$HInstruction();
  body.accept(this);
  if ($notnull_bool(this.block.last == null || !(this.block.last instanceof HReturn))) {
    this.block.add(new HGoto());
    this.graph.setSuccessors(this.block, [this.graph.exit]);
  }
  this.graph.entry.add(new HGoto());
  this.graph.setSuccessors(this.graph.entry, [this.block]);
  return this.graph;
}
SsaBuilder.prototype.add = function(instruction) {
  this.block.add(instruction);
}
SsaBuilder.prototype.push = function(instruction) {
  this.add(instruction);
  this.stack.add(instruction);
}
SsaBuilder.prototype.pop = function() {
  return this.stack.removeLast();
}
SsaBuilder.prototype.visit = function(node) {
  if ($notnull_bool(node != null)) node.accept(this);
}
SsaBuilder.prototype.visitBlock = function(node) {
  this.visit(node.statements);
  if ($notnull_bool(!this.stack.isEmpty())) this.compiler.cancel('non-empty instruction stack');
}
SsaBuilder.prototype.visitExpressionStatement = function(node) {
  this.visit(node.expression);
  this.pop();
}
SsaBuilder.prototype.visitFunctionExpression = function(node) {
  this.compiler.cancel();
}
SsaBuilder.prototype.visitIdentifier = function(node) {
  this.compiler.cancel();
}
SsaBuilder.prototype.visitIf = function(node) {
  this.compiler.cancel("ssa/builder.dart: visitIf not implemented");
}
SsaBuilder.prototype.visitSend = function(node) {
  var $0;
  if ($notnull_bool((node.selector instanceof Operator))) {
    this.visit(node.receiver);
    this.visit(node.argumentsNode);
    var right = this.pop();
    var left = this.pop();
    var op = node.selector;
    if ($notnull_bool($eq(const$258/*const SourceString("+")*/, op.get$source()))) {
      this.push(new HAdd([left, right]));
    }
    else if ($notnull_bool($eq(const$259/*const SourceString("-")*/, op.get$source()))) {
      this.push(new HSubtract([left, right]));
    }
    else if ($notnull_bool($eq(const$260/*const SourceString("*")*/, op.get$source()))) {
      this.push(new HMultiply([left, right]));
    }
    else if ($notnull_bool($eq(const$261/*const SourceString("/")*/, op.get$source()))) {
      this.push(new HDivide([left, right]));
    }
    else if ($notnull_bool($eq(const$262/*const SourceString("~/")*/, op.get$source()))) {
      this.push(new HTruncatingDivide([left, right]));
    }
  }
  else {
    this.visit(node.argumentsNode);
    var arguments = [];
    for (var link = node.get$arguments();
     $notnull_bool(!link.isEmpty()); link = (($0 = link.get$tail()) && $0.is$Link$Node())) {
      arguments.add(this.pop());
    }
    var selector = node.selector;
    this.push(new HInvoke(selector.get$source(), arguments));
  }
}
SsaBuilder.prototype.visitLiteralInt = function(node) {
  this.push(new HLiteral(node.get$value()));
}
SsaBuilder.prototype.visitLiteralDouble = function(node) {
  this.push(new HLiteral(node.get$value()));
}
SsaBuilder.prototype.visitLiteralBool = function(node) {
  this.push(new HLiteral(node.get$value()));
}
SsaBuilder.prototype.visitLiteralString = function(node) {
  this.push(new HLiteral(node.get$value()));
}
SsaBuilder.prototype.visitNodeList = function(node) {
  var $0;
  for (var link = node.nodes;
   $notnull_bool(!link.isEmpty()); link = (($0 = link.get$tail()) && $0.is$Link$Node())) {
    this.visit((($0 = link.get$head()) && $0.is$Node()));
  }
}
SsaBuilder.prototype.visitOperator = function(node) {
  this.compiler.unimplemented("SsaBuilder::visitOperator");
}
SsaBuilder.prototype.visitParameter = function(node) {
  this.compiler.unimplemented("SsaBuilder::visitParameter");
}
SsaBuilder.prototype.visitReturn = function(node) {
  this.visit(node.expression);
  var value = this.pop();
  this.add(new HReturn(value));
  this.graph.setSuccessors(this.block, [this.graph.exit]);
}
SsaBuilder.prototype.visitTypeAnnotation = function(node) {

}
SsaBuilder.prototype.visitVariableDefinitions = function(node) {
  this.compiler.unimplemented("SsaBuilder::visitVariableDefinitions");
}
// ********** Code for SsaCodeGeneratorTask **************
function SsaCodeGeneratorTask(compiler0) {
  CompilerTask.call(this, compiler0);
  // Initializers done
}
$inherits(SsaCodeGeneratorTask, CompilerTask);
SsaCodeGeneratorTask.prototype.get$name = function() {
  return 'SSA code generator';
}
SsaCodeGeneratorTask.prototype.generate = function(tree, graph) {
  var $this = this; // closure support
  return this.measure((function () {
    var function_ = tree;
    var name0 = function_.name;
    if ($notnull_bool(false/*null.GENERATE_SSA_TRACE*/)) {
      HTracer.HTracer$singleton$factory().traceGraph("codegen", graph);
    }
    var code = $this.generateMethod(name0.get$source(), graph);
    return code;
  })
  );
}
SsaCodeGeneratorTask.prototype.generateMethod = function(methodName, graph) {
  var buffer = new StringBufferImpl("");
  var codegen = new SsaCodeGenerator(this.compiler, buffer);
  graph.number();
  codegen.visitGraph(graph);
  return ('function ' + methodName + '() {\n' + buffer + '}\n');
}
// ********** Code for SsaCodeGenerator **************
function SsaCodeGenerator(compiler, buffer) {
  this.compiler = compiler;
  this.buffer = buffer;
  // Initializers done
}
SsaCodeGenerator.prototype.visitGraph = function(graph) {
  var $this = this; // closure support
  function visitBasicBlockAndSuccessors(block) {
    var $0;
    $this.visit(block);
    if ($notnull_bool(!block.successors.isEmpty())) {
      $assert(block.successors.length == 1, "block.successors.length == 1", "leg/ssa/codegen.dart", 39, 16);
      visitBasicBlockAndSuccessors((($0 = block.successors.$index(0)) && $0.is$HBasicBlock()));
    }
  }
  visitBasicBlockAndSuccessors(graph.entry);
}
SsaCodeGenerator.prototype.temporary = function(instruction) {
  return ('t' + instruction.id + '');
}
SsaCodeGenerator.prototype.invoke = function(selector, arguments) {
  var $0;
  this.buffer.add(("" + selector + "("));
  for (var i = 0;
   $notnull_bool(i < arguments.length); i++) {
    if ($notnull_bool(i != 0)) this.buffer.add(', ');
    this.use((($0 = arguments.$index(i)) && $0.is$HInstruction()));
  }
  this.buffer.add(")");
}
SsaCodeGenerator.prototype.define = function(instruction) {
  this.buffer.add(('var ' + this.temporary(instruction) + ' = '));
  this.visit(instruction);
}
SsaCodeGenerator.prototype.use = function(argument) {
  if ($notnull_bool(argument.canBeGeneratedAtUseSite())) {
    this.visit(argument);
  }
  else {
    this.buffer.add(this.temporary(argument));
  }
}
SsaCodeGenerator.prototype.visit = function(node) {
  return node.accept(this);
}
SsaCodeGenerator.prototype.visitAdd = function(node) {
  this.invoke(const$266/*const SourceString('\$add')*/, node.inputs);
}
SsaCodeGenerator.prototype.visitBasicBlock = function(node) {
  var instruction = node.first;
  while ($notnull_bool(instruction != null)) {
    if ($notnull_bool(!instruction.canBeSkipped())) {
      this.buffer.add('  ');
      if ($notnull_bool(!instruction.get$usedBy().isEmpty())) {
        this.define(instruction);
      }
      else {
        this.visit(instruction);
      }
      this.buffer.add(';\n');
    }
    instruction = instruction.next;
  }
}
SsaCodeGenerator.prototype.visitDivide = function(node) {
  this.invoke(const$267/*const SourceString('\$div')*/, node.inputs);
}
SsaCodeGenerator.prototype.visitExit = function(node) {
  unreachable();
}
SsaCodeGenerator.prototype.visitGoto = function(node) {
  unreachable();
}
SsaCodeGenerator.prototype.visitInvoke = function(node) {
  this.invoke(node.selector, node.inputs);
}
SsaCodeGenerator.prototype.visitLiteral = function(node) {
  this.buffer.add(node.value);
}
SsaCodeGenerator.prototype.visitMultiply = function(node) {
  this.invoke(const$268/*const SourceString('\$mul')*/, node.inputs);
}
SsaCodeGenerator.prototype.visitReturn = function(node) {
  var $0;
  this.buffer.add('return ');
  this.use((($0 = node.inputs.$index(0)) && $0.is$HInstruction()));
}
SsaCodeGenerator.prototype.visitSubtract = function(node) {
  this.invoke(const$269/*const SourceString('\$sub')*/, node.inputs);
}
SsaCodeGenerator.prototype.visitTruncatingDivide = function(node) {
  this.invoke(const$270/*const SourceString('\$tdiv')*/, node.inputs);
}
// ********** Code for HGraphVisitor **************
function HGraphVisitor() {
  // Initializers done
}
HGraphVisitor.prototype.visitDominatorTree = function(graph) {
  var $this = this; // closure support
  function visitBasicBlockAndSuccessors(block) {
    var $0;
    $this.visitBasicBlock(block);
    for (var i = 0;
     $notnull_bool(i < block.successors.length); i++) {
      visitBasicBlockAndSuccessors((($0 = block.successors.$index(i)) && $0.is$HBasicBlock()));
    }
  }
  visitBasicBlockAndSuccessors(graph.entry);
}
HGraphVisitor.prototype.visitPostDominatorTree = function(graph) {
  var $this = this; // closure support
  function visitBasicBlockAndSuccessors(block) {
    var $0;
    for (var i = 0;
     $notnull_bool(i < block.successors.length); i++) {
      visitBasicBlockAndSuccessors((($0 = block.successors.$index(i)) && $0.is$HBasicBlock()));
    }
    $this.visitBasicBlock(block);
  }
  visitBasicBlockAndSuccessors(graph.entry);
}
// ********** Code for HInstructionVisitor **************
function HInstructionVisitor() {
  HGraphVisitor.call(this);
  // Initializers done
}
$inherits(HInstructionVisitor, HGraphVisitor);
HInstructionVisitor.prototype.visitBasicBlock = function(node) {
  this.currentBlock = node;
  var instruction = node.first;
  while ($notnull_bool(instruction != null)) {
    this.visitInstruction(instruction);
    instruction = instruction.next;
  }
}
// ********** Code for HGraph **************
function HGraph() {
  this.entry = new HBasicBlock();
  this.exit = new HBasicBlock();
  // Initializers done
  this.exit.add(new HExit());
}
HGraph.prototype.number = function() {
  var basicBlockId = 0;
  function numberBasicBlockAndSuccessors(block, id) {
    var $0;
    id = block.number(basicBlockId++, id);
    for (var i = 0;
     $notnull_bool(i < block.successors.length); i++) {
      id = numberBasicBlockAndSuccessors((($0 = block.successors.$index(i)) && $0.is$HBasicBlock()), id);
    }
    return id;
  }
  numberBasicBlockAndSuccessors(this.entry, 0);
}
HGraph.prototype.setSuccessors = function(source, targets) {
  $assert(((source.last instanceof HGoto) || (source.last instanceof HReturn)) && targets.length == 1, "(source.last is HGoto || source.last is HReturn) &&\n           targets.length == 1", "leg/ssa/nodes.dart", 83, 12);
  $assert(source.successors.isEmpty(), "source.successors.isEmpty()", "leg/ssa/nodes.dart", 85, 12);
  source.successors = targets;
  for (var i = 0;
   $notnull_bool(i < targets.length); i++) {
    targets.$index(i).predecessors.add(source);
  }
}
HGraph.prototype.isValid = function() {
  var validator = new HValidator();
  validator.visitGraph(this);
  return validator.isValid;
}
// ********** Code for HBaseVisitor **************
function HBaseVisitor() {
  HGraphVisitor.call(this);
  // Initializers done
}
$inherits(HBaseVisitor, HGraphVisitor);
HBaseVisitor.prototype.visitBasicBlock = function(node) {
  this.currentBlock = node;
  var instruction = node.first;
  while ($notnull_bool(instruction != null)) {
    instruction.accept(this);
    instruction = instruction.next;
  }
}
HBaseVisitor.prototype.visitInstruction = function(HInstruction0) {

}
HBaseVisitor.prototype.visitArithmetic = function(node, operation) {
  return this.visitInvoke(node);
}
HBaseVisitor.prototype.visitAdd = function(node) {
  return this.visitArithmetic(node, '+');
}
HBaseVisitor.prototype.visitDivide = function(node) {
  return this.visitArithmetic(node, '/');
}
HBaseVisitor.prototype.visitExit = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitGoto = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitInvoke = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitLiteral = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitSubtract = function(node) {
  return this.visitArithmetic(node, '-');
}
HBaseVisitor.prototype.visitMultiply = function(node) {
  return this.visitArithmetic(node, '*');
}
HBaseVisitor.prototype.visitReturn = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitTruncatingDivide = function(node) {
  return this.visitArithmetic(node, '~/');
}
// ********** Code for HBasicBlock **************
function HBasicBlock() {
  this.first = null
  this.last = null
  this.predecessors = [];
  this.successors = const$226/*const []*/;
  // Initializers done
}
HBasicBlock.prototype.is$HBasicBlock = function(){return this;};
HBasicBlock.prototype.number = function(basicBlockId, id0) {
  this.id = basicBlockId;
  var instruction = this.first;
  while ($notnull_bool(instruction != null)) {
    instruction.id = id0++;
    instruction = instruction.next;
  }
  return id0;
}
HBasicBlock.prototype.accept = function(visitor) {
  return visitor.visitBasicBlock(this);
}
HBasicBlock.prototype.add = function(instruction) {
  this.addAfter(this.last, instruction);
}
HBasicBlock.prototype.addAfter = function(cursor, instruction) {
  if ($notnull_bool(cursor == null)) {
    this.first = this.last = instruction;
  }
  else if ($notnull_bool(cursor === this.last)) {
    this.last.next = instruction;
    instruction.previous = this.last;
    this.last = instruction;
  }
  else {
    instruction.previous = cursor;
    instruction.next = cursor.next;
    cursor.next.previous = instruction;
    cursor.next = instruction;
  }
  instruction.notifyAddedToBlock();
}
HBasicBlock.prototype.remove = function(instruction) {
  $assert(instruction.isInBasicBlock(), "instruction.isInBasicBlock()", "leg/ssa/nodes.dart", 183, 12);
  $assert(instruction.get$usedBy().isEmpty(), "instruction.usedBy.isEmpty()", "leg/ssa/nodes.dart", 184, 12);
  if ($notnull_bool(instruction.previous == null)) {
    this.first = instruction.next;
  }
  else {
    instruction.previous.next = instruction.next;
  }
  if ($notnull_bool(instruction.next == null)) {
    this.last = instruction.previous;
  }
  else {
    instruction.next.previous = instruction.previous;
  }
  instruction.notifyRemovedFromBlock();
}
HBasicBlock.prototype.rewrite = function(from, to) {
  var $list = from.get$usedBy();
  for (var $i = 0;$i < $list.length; $i++) {
    var use = $list.$index($i);
    HBasicBlock.rewriteInput(use, from, to);
  }
  to.get$usedBy().addAll(from.get$usedBy());
  from._usedBy = [];
  $assert(this.isValid(), "isValid()", "leg/ssa/nodes.dart", 208, 12);
}
HBasicBlock.rewriteInput = function(instruction, from, to) {
  var inputs = instruction.inputs;
  for (var i = 0;
   $notnull_bool(i < inputs.length); i++) {
    if ($notnull_bool(inputs.$index(i) === from)) inputs.$setindex(i, to);
  }
}
HBasicBlock.prototype.isExitBlock = function() {
  return this.first === this.last && (this.first instanceof HExit);
}
HBasicBlock.prototype.isValid = function() {
  var validator = new HValidator();
  validator.visitBasicBlock(this);
  return validator.isValid;
}
// ********** Code for HInstruction **************
function HInstruction(inputs) {
  this._usedBy = null
  this.previous = null
  this.next = null
  this._canBeGeneratedAtUseSite = false
  this.inputs = inputs;
  // Initializers done
}
HInstruction.prototype.is$HInstruction = function(){return this;};
HInstruction.prototype.canBeGeneratedAtUseSite = function() {
  return this._canBeGeneratedAtUseSite;
}
HInstruction.prototype.setCanBeGeneratedAtUseSite = function() {
  this._canBeGeneratedAtUseSite = true;
}
HInstruction.prototype.canBeSkipped = function() {
  return this.canBeGeneratedAtUseSite();
}
HInstruction.prototype.get$usedBy = function() {
  if ($notnull_bool(this._usedBy == null)) return const$226/*const []*/;
  return this._usedBy;
}
HInstruction.prototype.isInBasicBlock = function() {
  return this._usedBy != null;
}
HInstruction.prototype.$eq = function(other) {
  return false;
}
HInstruction.prototype.hashCode = function() {
  return 0;
}
HInstruction.prototype.notifyAddedToBlock = function() {
  $assert(!this.isInBasicBlock(), "!isInBasicBlock()", "leg/ssa/nodes.dart", 283, 12);
  this._usedBy = [];
  for (var i = 0;
   $notnull_bool(i < this.inputs.length); i++) {
    this.inputs.$index(i).get$usedBy().add(this);
  }
  $assert(this.isValid(), "isValid()", "leg/ssa/nodes.dart", 289, 12);
}
HInstruction.prototype.notifyRemovedFromBlock = function() {
  $assert(this.isInBasicBlock(), "isInBasicBlock()", "leg/ssa/nodes.dart", 293, 12);
  $assert(this.get$usedBy().isEmpty(), "usedBy.isEmpty()", "leg/ssa/nodes.dart", 294, 12);
  for (var i = 0;
   $notnull_bool(i < this.inputs.length); i++) {
    var inputUsedBy = this.inputs.$index(i).get$usedBy();
    for (var j = 0;
     $notnull_bool(j < inputUsedBy.length); j++) {
      if ($notnull_bool(inputUsedBy.$index(j) === this)) {
        inputUsedBy.$setindex(j, inputUsedBy.$index(inputUsedBy.length - 1));
        inputUsedBy.removeLast();
        break;
      }
    }
  }
  this._usedBy = null;
  $assert(this.isValid(), "isValid()", "leg/ssa/nodes.dart", 308, 12);
}
HInstruction.prototype.isValid = function() {
  var validator = new HValidator();
  validator.visitInstruction(this);
  return validator.isValid;
}
// ********** Code for HInvoke **************
function HInvoke(selector, inputs0) {
  this.selector = selector;
  HInstruction.call(this, inputs0);
  // Initializers done
}
$inherits(HInvoke, HInstruction);
HInvoke.prototype.toString = function() {
  return ('invoke: ' + this.selector + '');
}
HInvoke.prototype.hasSideEffects = function() {
  return true;
}
HInvoke.prototype.accept = function(visitor) {
  return visitor.visitInvoke(this);
}
// ********** Code for HAdd **************
function HAdd(inputs0) {
  HInvoke.call(this, const$249/*const SourceString('+')*/, inputs0);
  // Initializers done
}
$inherits(HAdd, HInvoke);
HAdd.prototype.hasSideEffects = function() {
  return !(this.inputs.$index(0) instanceof HLiteral);
}
HAdd.prototype.accept = function(visitor) {
  return visitor.visitAdd(this);
}
// ********** Code for HDivide **************
function HDivide(inputs0) {
  HInvoke.call(this, const$252/*const SourceString('/')*/, inputs0);
  // Initializers done
}
$inherits(HDivide, HInvoke);
HDivide.prototype.hasSideEffects = function() {
  return !(this.inputs.$index(0) instanceof HLiteral);
}
HDivide.prototype.accept = function(visitor) {
  return visitor.visitDivide(this);
}
// ********** Code for HMultiply **************
function HMultiply(inputs0) {
  HInvoke.call(this, const$251/*const SourceString('*')*/, inputs0);
  // Initializers done
}
$inherits(HMultiply, HInvoke);
HMultiply.prototype.hasSideEffects = function() {
  return !(this.inputs.$index(0) instanceof HLiteral);
}
HMultiply.prototype.accept = function(visitor) {
  return visitor.visitMultiply(this);
}
// ********** Code for HSubtract **************
function HSubtract(inputs0) {
  HInvoke.call(this, const$250/*const SourceString('-')*/, inputs0);
  // Initializers done
}
$inherits(HSubtract, HInvoke);
HSubtract.prototype.hasSideEffects = function() {
  return !(this.inputs.$index(0) instanceof HLiteral);
}
HSubtract.prototype.accept = function(visitor) {
  return visitor.visitSubtract(this);
}
// ********** Code for HTruncatingDivide **************
function HTruncatingDivide(inputs0) {
  HInvoke.call(this, const$253/*const SourceString('~/')*/, inputs0);
  // Initializers done
}
$inherits(HTruncatingDivide, HInvoke);
HTruncatingDivide.prototype.hasSideEffects = function() {
  return !(this.inputs.$index(0) instanceof HLiteral);
}
HTruncatingDivide.prototype.accept = function(visitor) {
  return visitor.visitTruncatingDivide(this);
}
// ********** Code for HExit **************
function HExit() {
  HInstruction.call(this, const$226/*const []*/);
  // Initializers done
}
$inherits(HExit, HInstruction);
HExit.prototype.canBeSkipped = function() {
  return true;
}
HExit.prototype.toString = function() {
  return 'exit';
}
HExit.prototype.hasSideEffects = function() {
  return true;
}
HExit.prototype.accept = function(visitor) {
  return visitor.visitExit(this);
}
// ********** Code for HGoto **************
function HGoto() {
  HInstruction.call(this, const$226/*const []*/);
  // Initializers done
}
$inherits(HGoto, HInstruction);
HGoto.prototype.canBeSkipped = function() {
  return true;
}
HGoto.prototype.toString = function() {
  return 'goto';
}
HGoto.prototype.hasSideEffects = function() {
  return true;
}
HGoto.prototype.accept = function(visitor) {
  return visitor.visitGoto(this);
}
// ********** Code for HLiteral **************
function HLiteral(value) {
  this.value = value;
  HInstruction.call(this, []);
  // Initializers done
}
$inherits(HLiteral, HInstruction);
HLiteral.prototype.get$value = function() { return this.value; };
HLiteral.prototype.toString = function() {
  return ('literal: ' + this.value + '');
}
HLiteral.prototype.hasSideEffects = function() {
  return false;
}
HLiteral.prototype.$eq = function(other) {
  return (other instanceof HLiteral) && $eq(this.value, other.get$value());
}
HLiteral.prototype.accept = function(visitor) {
  return visitor.visitLiteral(this);
}
// ********** Code for HReturn **************
function HReturn(value) {
  HInstruction.call(this, [value]);
  // Initializers done
}
$inherits(HReturn, HInstruction);
HReturn.prototype.toString = function() {
  return 'return';
}
HReturn.prototype.hasSideEffects = function() {
  return true;
}
HReturn.prototype.accept = function(visitor) {
  return visitor.visitReturn(this);
}
// ********** Code for SsaOptimizerTask **************
function SsaOptimizerTask(compiler0) {
  CompilerTask.call(this, compiler0);
  // Initializers done
}
$inherits(SsaOptimizerTask, CompilerTask);
SsaOptimizerTask.prototype.get$name = function() {
  return 'SSA optimizer';
}
SsaOptimizerTask.prototype.optimize = function(graph) {
  var $this = this; // closure support
  this.measure((function () {
    new SsaConstantFolder().visitGraph(graph);
    new SsaDeadCodeEliminator().visitGraph(graph);
    new SsaGlobalValueNumberer($this.compiler).visitGraph(graph);
    new SsaInstructionMerger().visitGraph(graph);
  })
  );
}
// ********** Code for SsaConstantFolder **************
function SsaConstantFolder() {
  HBaseVisitor.call(this);
  // Initializers done
}
$inherits(SsaConstantFolder, HBaseVisitor);
SsaConstantFolder.prototype.visitGraph = function(graph) {
  this.visitDominatorTree(graph);
}
SsaConstantFolder.prototype.visitBasicBlock = function(block) {
  var instruction = block.first;
  while ($notnull_bool(instruction != null)) {
    var replacement = instruction.accept(this);
    if ($notnull_bool(replacement !== instruction)) {
      block.addAfter(instruction, (replacement && replacement.is$HInstruction()));
      block.rewrite(instruction, (replacement && replacement.is$HInstruction()));
      block.remove(instruction);
    }
    instruction = instruction.next;
  }
}
SsaConstantFolder.prototype.visitInstruction = function(node) {
  return node;
}
SsaConstantFolder.prototype.visitArithmetic = function(node, operation) {
  function isNumber(input) {
    return (input instanceof HLiteral) && (typeof(input.get$value()) == 'number');
  }
  var inputs = node.inputs;
  $assert(inputs.length == 2, "inputs.length == 2", "leg/ssa/optimize.dart", 50, 12);
  if ($notnull_bool(isNumber(inputs.$index(0)) && isNumber(inputs.$index(1)))) {
    switch (operation) {
      case '+':

        return new HLiteral(inputs.$index(0).get$value() + inputs.$index(1).get$value());

      case '-':

        return new HLiteral(inputs.$index(0).get$value() - inputs.$index(1).get$value());

      case '*':

        return new HLiteral(inputs.$index(0).get$value() * inputs.$index(1).get$value());

      case '/':

        {
          if ($notnull_bool($eq(inputs.$index(1).get$value(), 0))) return node;
          return new HLiteral(inputs.$index(0).get$value() / inputs.$index(1).get$value());
        }

      case '~/':

        {
          if ($notnull_bool($eq(inputs.$index(1).get$value(), 0))) return node;
          return new HLiteral($truncdiv(inputs.$index(0).get$value(), inputs.$index(1).get$value()));
        }

      default:

        unreachable();

    }
  }
  return node;
}
// ********** Code for SsaDeadCodeEliminator **************
function SsaDeadCodeEliminator() {
  HGraphVisitor.call(this);
  // Initializers done
}
$inherits(SsaDeadCodeEliminator, HGraphVisitor);
SsaDeadCodeEliminator.isDeadCode = function(instruction) {
  return !instruction.hasSideEffects() && instruction.get$usedBy().isEmpty();
}
SsaDeadCodeEliminator.prototype.visitGraph = function(graph) {
  this.visitPostDominatorTree(graph);
}
SsaDeadCodeEliminator.prototype.visitBasicBlock = function(block) {
  var instruction = block.last;
  while ($notnull_bool(instruction != null)) {
    var previous = instruction.previous;
    if ($notnull_bool(SsaDeadCodeEliminator.isDeadCode(instruction))) block.remove(instruction);
    instruction = (previous && previous.is$HInstruction());
  }
}
// ********** Code for SsaGlobalValueNumberer **************
function SsaGlobalValueNumberer(compiler) {
  this.compiler = compiler;
  this.values = new HashMapImplementation$HInstruction$HInstruction();
  // Initializers done
}
$inherits(SsaGlobalValueNumberer, HGraphVisitor);
SsaGlobalValueNumberer.prototype.visitGraph = function(graph) {
  this.visitPostDominatorTree(graph);
}
SsaGlobalValueNumberer.prototype.visitBasicBlock = function(block) {
  var instruction = block.first;
  while ($notnull_bool(instruction != null)) {
    if ($notnull_bool(instruction.hasSideEffects())) {
      this.values.clear();
    }
    else {
      var other = this.values.$index(instruction);
      if ($notnull_bool(other != null)) {
        block.rewrite(instruction, other);
        block.remove(instruction);
      }
      else {
        this.values.$setindex(instruction, instruction);
      }
    }
    instruction = instruction.next;
  }
}
// ********** Code for SsaInstructionMerger **************
function SsaInstructionMerger() {
  HInstructionVisitor.call(this);
  // Initializers done
}
$inherits(SsaInstructionMerger, HInstructionVisitor);
SsaInstructionMerger.prototype.visitGraph = function(graph) {
  this.visitDominatorTree(graph);
}
SsaInstructionMerger.prototype.visitInstruction = function(node) {
  var inputs = node.inputs;
  var previousUnused = node.previous;
  for (var i = inputs.length - 1;
   $notnull_bool(i >= 0); i--) {
    if ($notnull_bool(previousUnused == null)) return;
    if ($notnull_bool(inputs.$index(i).get$usedBy().length != 1)) return;
    if ($notnull_bool(inputs.$index(i) !== previousUnused)) return;
    inputs.$index(i).setCanBeGeneratedAtUseSite();
    previousUnused = previousUnused.previous;
  }
}
// ********** Code for HTracer **************
function HTracer() {}
HTracer._internal$ctor = function() {
  this.indent = 0
  this.output = new StringBufferImpl("");
  // Initializers done
}
HTracer._internal$ctor.prototype = HTracer.prototype;
$inherits(HTracer, HGraphVisitor);
HTracer.HTracer$singleton$factory = function() {
  if ($notnull_bool(HTracer._singleton == null)) HTracer._singleton = new HTracer._internal$ctor();
  return HTracer._singleton;
}
HTracer.prototype.traceCompilation = function(methodName) {
  var $this = this; // closure support
  this.tag("compilation", (function () {
    $this.printProperty("name", methodName);
    $this.printProperty("method", methodName);
    $this.printProperty("date", new DateImplementation.now$ctor().value);
  })
  );
}
HTracer.prototype.traceGraph = function(name, graph) {
  var $this = this; // closure support
  graph.number();
  this.tag("cfg", (function () {
    $this.printProperty("name", name);
    $this.visitDominatorTree(graph);
  })
  );
}
HTracer.prototype.addPredecessors = function(block) {
  if ($notnull_bool(block.predecessors.isEmpty())) {
    this.printEmptyProperty("predecessors");
  }
  else {
    this.addIndent();
    this.add("predecessors");
    var $list = block.predecessors;
    for (var $i = 0;$i < $list.length; $i++) {
      var predecessor = $list.$index($i);
      this.add((' "B' + predecessor.id + '"'));
    }
    this.add("\n");
  }
}
HTracer.prototype.addSuccessors = function(block) {
  if ($notnull_bool(block.successors.isEmpty())) {
    this.printEmptyProperty("successors");
  }
  else {
    this.addIndent();
    this.add("successors");
    var $list = block.successors;
    for (var $i = 0;$i < $list.length; $i++) {
      var successor = $list.$index($i);
      this.add((' "B' + successor.id + '"'));
    }
    this.add("\n");
  }
}
HTracer.prototype.addInstructions = function(block) {
  var stringifier = new HInstructionStringifier(block);
  for (var instruction = block.first;
   $notnull_bool(instruction != null); instruction = instruction.next) {
    var bci = 0;
    var uses = instruction.get$usedBy().length;
    this.addIndent();
    var temporaryId = stringifier.temporaryId(instruction);
    var instructionString = stringifier.visit(instruction);
    this.add(("" + bci + " " + uses + " " + temporaryId + " " + instructionString + " <|@\n"));
  }
}
HTracer.prototype.visitBasicBlock = function(block) {
  var $this = this; // closure support
  $assert(block.id != null, "block.id !== null", "leg/ssa/tracer.dart", 75, 12);
  this.tag("block", (function () {
    $this.printProperty("name", ("B" + block.id + ""));
    $this.printProperty("from_bci", -1);
    $this.printProperty("to_bci", -1);
    $this.addPredecessors(block);
    $this.addSuccessors(block);
    $this.printEmptyProperty("xhandlers");
    $this.printEmptyProperty("flags");
    $this.tag("states", (function () {
      $this.tag("locals", (function () {
        $this.printProperty("size", 0);
        $this.printProperty("method", "None");
      })
      );
    })
    );
    $this.tag("HIR", (function () {
      $this.addInstructions(block);
    })
    );
  })
  );
}
HTracer.prototype.tag = function(tagName, f) {
  this.print(("begin_" + tagName + ""));
  this.indent++;
  f.call$0();
  this.indent--;
  this.print(("end_" + tagName + ""));
}
HTracer.prototype.print = function(string) {
  this.addIndent();
  this.add(string);
  this.add("\n");
}
HTracer.prototype.printEmptyProperty = function(propertyName) {
  this.print(propertyName);
}
HTracer.prototype.printProperty = function(propertyName, value) {
  if ($notnull_bool((typeof(value) == 'number'))) {
    this.print(("" + propertyName + " " + value + ""));
  }
  else {
    this.print(('' + propertyName + ' "' + value + '"'));
  }
}
HTracer.prototype.add = function(string) {
  this.output.add(string);
}
HTracer.prototype.addIndent = function() {
  for (var i = 0;
   $notnull_bool(i < this.indent); i++) {
    this.add("  ");
  }
}
HTracer.prototype.toString = function() {
  return this.output.toString();
}
// ********** Code for HInstructionStringifier **************
function HInstructionStringifier(currentBlock) {
  this.currentBlock = currentBlock;
  // Initializers done
}
HInstructionStringifier.prototype.visit = function(node) {
  return node.accept(this);
}
HInstructionStringifier.prototype.visitBasicBlock = function(node) {
  unreachable();
}
HInstructionStringifier.prototype.temporaryId = function(instruction) {
  return ("v" + instruction.id + "");
}
HInstructionStringifier.prototype.visitAdd = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitDivide = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitExit = function(node) {
  return "exit";
}
HInstructionStringifier.prototype.visitGoto = function(node) {
  var target = this.currentBlock.successors.$index(0);
  return ("Goto (B" + target.id + ")");
}
HInstructionStringifier.prototype.visitInvoke = function(invoke) {
  var $0;
  var arguments = new StringBufferImpl("");
  for (var i = 0;
   $notnull_bool(i < invoke.inputs.length); i++) {
    if ($notnull_bool(i != 0)) arguments.add(", ");
    arguments.add(this.temporaryId((($0 = invoke.inputs.$index(i)) && $0.is$HInstruction())));
  }
  return ("Invoke: " + invoke.selector + "(" + arguments + ")");
}
HInstructionStringifier.prototype.visitLiteral = function(literal) {
  return ("Literal " + literal.value + "");
}
HInstructionStringifier.prototype.visitMultiply = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitReturn = function(node) {
  var $0;
  return ("Return " + this.temporaryId((($0 = node.inputs.$index(0)) && $0.is$HInstruction())) + "");
}
HInstructionStringifier.prototype.visitSubtract = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitTruncatingDivide = function(node) {
  return this.visitInvoke(node);
}
// ********** Code for HValidator **************
function HValidator() {
  this.isValid = true
  HInstructionVisitor.call(this);
  // Initializers done
}
$inherits(HValidator, HInstructionVisitor);
HValidator.prototype.visitGraph = function(graph0) {
  this.graph = graph0;
  this.visitDominatorTree(graph0);
}
HValidator.prototype.visitBasicBlock = function(block) {
  if ($notnull_bool(!this.isValid)) return;
  if ($notnull_bool(block.first == null || block.last == null)) this.isValid = false;
  if ($notnull_bool(!(block.last instanceof HGoto) && !(block.last instanceof HReturn) && !(block.last instanceof HExit))) {
    this.isValid = false;
  }
  if ($notnull_bool((block.last instanceof HGoto) && block.successors.length != 1)) this.isValid = false;
  if ($notnull_bool((block.last instanceof HReturn) && (block.successors.length != 1 || !block.successors.$index(0).isExitBlock()))) {
    this.isValid = false;
  }
  if ($notnull_bool((block.last instanceof HExit) && !block.successors.isEmpty())) this.isValid = false;
  if ($notnull_bool(block.successors.isEmpty() && (block.first !== block.last || !(block.last instanceof HExit)))) {
    this.isValid = false;
  }
  if ($notnull_bool(!this.isValid)) return;
  HInstructionVisitor.prototype.visitBasicBlock.call(this, block);
}
HValidator.countInstruction = function(instructions, instruction) {
  var result = 0;
  for (var i = 0;
   $notnull_bool(i < instructions.length); i++) {
    if ($notnull_bool(instructions.$index(i) === instruction)) result++;
  }
  return result;
}
HValidator.everyInstruction = function(instructions, f) {
  var copy = ListFactory.ListFactory$from$factory(instructions);
  for (var i = 0;
   $notnull_bool(i < copy.length); i++) {
    var current = copy.$index(i);
    if ($notnull_bool(current == null)) continue;
    var count = 1;
    for (var j = i + 1;
     $notnull_bool(j < copy.length); j++) {
      if ($notnull_bool(copy.$index(j) === current)) {
        copy.$setindex(j);
        count++;
      }
    }
    if ($notnull_bool(!f.call$2(current, count))) return false;
  }
  return true;
}
HValidator.prototype.visitInstruction = function(instruction) {
  var $this = this; // closure support
  function hasCorrectInputs(instruction0) {
    var inBasicBlock = instruction0.isInBasicBlock();
    return HValidator.everyInstruction(instruction0.inputs, (function (input, count) {
      if ($notnull_bool(inBasicBlock)) {
        return HValidator.countInstruction(input.get$usedBy(), (instruction0 && instruction0.is$HInstruction())) == count;
      }
      else {
        return HValidator.countInstruction(input.get$usedBy(), (instruction0 && instruction0.is$HInstruction())) == 0;
      }
    })
    );
  }
  function hasCorrectUses(instruction0) {
    if ($notnull_bool(!instruction0.isInBasicBlock())) return true;
    return HValidator.everyInstruction(instruction0.get$usedBy(), (function (use, count) {
      return HValidator.countInstruction(use.inputs, (instruction0 && instruction0.is$HInstruction())) == count;
    })
    );
  }
  this.isValid = $assert_bool(this.isValid && hasCorrectInputs(instruction) && hasCorrectUses(instruction));
}
// ********** Code for top level **************
//  ********** Library leg **************
// ********** Code for WorldCompiler **************
function WorldCompiler(world, script0) {
  this.world = world;
  Compiler.call(this, script0);
  // Initializers done
}
$inherits(WorldCompiler, Compiler);
WorldCompiler.prototype.log = function(message) {
  if ($notnull_bool(options.showInfo)) {
    this.world.info(('[leg] ' + message + ''));
  }
}
WorldCompiler.prototype.run = function() {
  var success = Compiler.prototype.run.call(this);
  if ($notnull_bool(success)) {
    var code = this.getGeneratedCode();
    this.world.legCode = $assert_String(code);
    this.world.jsBytesWritten = code.length;
    var $list = this.tasks;
    for (var $i0 = 0;$i0 < $list.length; $i0++) {
      var task = $list.$index($i0);
      this.log(('' + task.get$name() + ' took ' + task.get$timing() + 'msec'));
    }
  }
  return success;
}
WorldCompiler.prototype.spanFromNode = function(node) {
  var begin = node.getBeginToken();
  var end = node.getEndToken();
  if ($notnull_bool(begin == null || end == null)) {
    this.cancel(('cannot find tokens to produce error message for ' + node + '.'));
  }
  var startOffset = begin.get$charOffset();
  var endOffset = end.get$charOffset() + end.toString().length;
  return new SourceSpan(this.script.file, startOffset, endOffset);
}
WorldCompiler.prototype.reportWarning = function(node, message) {
  var $0;
  this.world.warning(('' + message + '.'), (($0 = this.spanFromNode(node)) && $0.is$SourceSpan()));
}
// ********** Code for Compiler **************
function Compiler(script) {
  this.script = script;
  // Initializers done
  this.universe = new Universe();
  this.worklist = DoubleLinkedQueue.DoubleLinkedQueue$from$factory([const$3/*Compiler.MAIN*/]);
  this.scanner = new ScannerTask(this);
  this.resolver = new ResolverTask(this);
  this.checker = new TypeCheckerTask(this);
  this.builder = new SsaBuilderTask(this);
  this.optimizer = new SsaOptimizerTask(this);
  this.generator = new SsaCodeGeneratorTask(this);
  this.tasks = [this.scanner, this.resolver, this.checker, this.builder, this.optimizer, this.generator];
}
Compiler.prototype.unimplemented = function(methodName) {
  this.cancel(("" + methodName + " not implemented"));
}
Compiler.prototype.cancel = function(reason) {
  $throw(new CompilerCancelledException(reason));
}
Compiler.prototype.log = function(message) {

}
Compiler.prototype.run = function() {
  try {
    this.runCompiler();
  } catch (exception) {
    exception = $toDartException(exception);
    if (!(exception instanceof CompilerCancelledException)) throw exception;
    this.log(exception.toString());
    this.log('compilation failed');
    return false;
  }
  if ($notnull_bool(false/*null.GENERATE_SSA_TRACE*/)) {
    print("------------------");
    print(HTracer.HTracer$singleton$factory());
    print("------------------");
  }
  this.log('compilation succeeded');
  return true;
}
Compiler.prototype.runCompiler = function() {
  this.scanner.scan(this.script);
  while ($notnull_bool(!this.worklist.isEmpty())) {
    var name = this.worklist.removeLast();
    var element = this.universe.find(name);
    if ($notnull_bool(element == null)) this.cancel(('Could not find ' + name + ''));
    var tree = element.parseNode(this, this);
    var elements = this.resolver.resolve(tree);
    this.checker.check(tree, elements);
    var graph = this.builder.build(tree);
    this.optimizer.optimize(graph);
    var code = this.generator.generate(tree, graph);
    this.universe.addGeneratedCode(element, code);
  }
}
Compiler.prototype.getGeneratedCode = function() {
  var buffer = new StringBufferImpl("");
  buffer.add("var print = (typeof console == 'object')\n    ? function(obj) { console.log(obj); }\n    : function(obj) { write(obj); write('\\n'); };\n"/*null.PRINT_SUPPORT*/);
  buffer.add("function $add(a, b) {\n  return a + b;\n}\n"/*null.ADD_SUPPORT*/);
  buffer.add("function $div(a, b) {\n  return a / b;\n}\n"/*null.DIV_SUPPORT*/);
  buffer.add("function $sub(a, b) {\n  return a - b;\n}\n"/*null.SUB_SUPPORT*/);
  buffer.add("function $mul(a, b) {\n  return a * b;\n}\n"/*null.MUL_SUPPORT*/);
  buffer.add("function $tdiv(a, b) {\n  var tmp = this / other;\n  if (tmp < 0) {\n    return Math.ceil(tmp);\n  } else {\n    return Math.floor(tmp);\n  }\n}\n"/*null.TDIV_SUPPORT*/);
  var codeBlocks = this.universe.generatedCode.getValues();
  for (var i = codeBlocks.length - 1;
   $notnull_bool(i >= 0); i--) {
    buffer.add(codeBlocks.$index(i));
  }
  buffer.add('main();\n');
  return buffer.toString();
}
// ********** Code for CompilerTask **************
function CompilerTask(compiler) {
  this.compiler = compiler;
  this.watch = new StopWatchImplementation();
  // Initializers done
}
CompilerTask.prototype.get$name = function() {
  return 'Unknown task';
}
CompilerTask.prototype.get$timing = function() {
  return this.watch.elapsedInMs();
}
CompilerTask.prototype.measure = function(action) {
  this.watch.start();
  var result = action.call$0();
  this.watch.stop();
  return result;
}
// ********** Code for CompilerCancelledException **************
function CompilerCancelledException(reason) {
  this.reason = reason;
  // Initializers done
}
CompilerCancelledException.prototype.toString = function() {
  var banner = 'compiler cancelled';
  return $notnull_bool((this.reason != null)) ? ('' + banner + ': ' + this.reason + '') : ('' + banner + '');
}
// ********** Code for ResolverTask **************
function ResolverTask(compiler0) {
  CompilerTask.call(this, compiler0);
  // Initializers done
}
$inherits(ResolverTask, CompilerTask);
ResolverTask.prototype.get$name = function() {
  return 'Resolver';
}
ResolverTask.prototype.resolve = function(tree) {
  var $this = this; // closure support
  return this.measure((function () {
    var visitor = new ResolverVisitor($this.compiler);
    visitor.visit(tree);
    return visitor.mapping;
  })
  );
}
// ********** Code for ResolverVisitor **************
function ResolverVisitor(compiler0) {
  this.compiler = compiler0;
  this.mapping = new HashMapImplementation$Node$Element();
  this.context = new Scope(new TopScope(compiler0.universe));
  // Initializers done
}
ResolverVisitor.prototype.fail = function(node) {
  this.compiler.cancel(('cannot resolve ' + node + ''));
}
ResolverVisitor.prototype.visit = function(node) {
  if ($notnull_bool(node == null)) return null;
  var element = node.accept(this);
  if ($notnull_bool(element != null)) {
    this.mapping.$setindex(node, element);
  }
  return element;
}
ResolverVisitor.prototype.visitIn = function(node, scope) {
  this.context = scope;
  var element = this.visit(node);
  this.context = this.context.parent;
  return element;
}
ResolverVisitor.prototype.visitBlock = function(node) {
  this.visitIn(node.statements, new Scope(this.context));
}
ResolverVisitor.prototype.visitExpressionStatement = function(node) {
  this.visit(node.expression);
}
ResolverVisitor.prototype.visitFunctionExpression = function(node) {
  if ($notnull_bool(!node.parameters.nodes.isEmpty())) this.fail(node);
  var enclosingElement = this.visit(node.name);
  this.visitIn(node.body, new Scope.enclosing$ctor(this.context, enclosingElement));
  return enclosingElement;
}
ResolverVisitor.prototype.visitIdentifier = function(node) {
  var element = this.context.lookup(node.get$source());
  if ($notnull_bool(element == null)) this.fail(node);
  return element;
}
ResolverVisitor.prototype.visitIf = function(node) {
  this.visit(node.condition);
  this.visit(node.thenPart);
  this.visit(node.elsePart);
}
ResolverVisitor.prototype.visitSend = function(node) {
  var $0;
  var target = null;
  this.visit(node.receiver);
  var name = node.selector.get$source();
  if ($notnull_bool($eq(name, const$248/*const SourceString('print')*/) || $eq(name, const$249/*const SourceString('+')*/) || $eq(name, const$250/*const SourceString('-')*/) || $eq(name, const$251/*const SourceString('*')*/) || $eq(name, const$252/*const SourceString('/')*/) || $eq(name, const$253/*const SourceString('~/')*/))) {
  }
  else {
    target = (($0 = this.visit(node.selector)) && $0.is$Element());
    if ($notnull_bool(target == null)) {
      this.fail(node);
    }
    else {
      this.compiler.worklist.add(node.selector.get$source());
    }
  }
  this.visit(node.argumentsNode);
  return target;
}
ResolverVisitor.prototype.visitSetterSend = function(node) {
  this.compiler.unimplemented('ResolverVisitor::visitSetterSend');
}
ResolverVisitor.prototype.visitLiteralInt = function(node) {

}
ResolverVisitor.prototype.visitLiteralDouble = function(node) {

}
ResolverVisitor.prototype.visitLiteralBool = function(node) {

}
ResolverVisitor.prototype.visitLiteralString = function(node) {

}
ResolverVisitor.prototype.visitNodeList = function(node) {
  var $0;
  for (var link = node.nodes;
   $notnull_bool(!link.isEmpty()); link = (($0 = link.get$tail()) && $0.is$Link$Node())) {
    this.visit((($0 = link.get$head()) && $0.is$Node()));
  }
}
ResolverVisitor.prototype.visitOperator = function(node) {
  this.fail(node);
}
ResolverVisitor.prototype.visitReturn = function(node) {
  this.visit(node.expression);
  return null;
}
ResolverVisitor.prototype.visitTypeAnnotation = function(node) {

}
ResolverVisitor.prototype.visitVariableDefinitions = function(node) {
  var visitor = new VariableDefinitionsVisitor(node, this);
  visitor.visit(node.definitions);
}
ResolverVisitor.prototype.setElement = function(node, element) {
  this.mapping.$setindex(node, element);
  this.context.add(element);
}
// ********** Code for VariableDefinitionsVisitor **************
function VariableDefinitionsVisitor(definitions, resolver) {
  this.definitions = definitions;
  this.resolver = resolver;
  // Initializers done
}
VariableDefinitionsVisitor.prototype.visitSend = function(node) {
  var $0;
  $assert(node.get$arguments().get$tail().isEmpty(), "node.arguments.tail.isEmpty()", "leg/resolver.dart", 157, 12);
  var selector = node.selector;
  var name = selector.get$source();
  $assert($eq(name, const$244/*const SourceString('=')*/), "name == const SourceString('=')", "leg/resolver.dart", 160, 12);
  this.resolver.visit((($0 = node.get$arguments().get$head()) && $0.is$Node()));
  this.visit(node.receiver);
}
VariableDefinitionsVisitor.prototype.visitIdentifier = function(node) {
  var variableElement = new Element(node.get$source(), this.resolver.context.enclosingElement);
  this.resolver.setElement(node, variableElement);
}
VariableDefinitionsVisitor.prototype.visitNodeList = function(node) {
  var $0;
  for (var link = node.nodes;
   $notnull_bool(!link.isEmpty()); link = (($0 = link.get$tail()) && $0.is$Link$Node())) {
    this.visit((($0 = link.get$head()) && $0.is$Node()));
  }
}
VariableDefinitionsVisitor.prototype.visit = function(node) {
  return node.accept(this);
}
// ********** Code for Scope **************
function Scope(parent0) {
  Scope.enclosing$ctor.call(this, parent0, parent0.enclosingElement);
  // Initializers done
}
Scope.top$ctor = function() {
  this.parent = null;
  this.elements = const$247/*const {}*/;
  this.enclosingElement = null;
  // Initializers done
}
Scope.top$ctor.prototype = Scope.prototype;
Scope.enclosing$ctor = function(parent, enclosingElement) {
  this.parent = parent;
  this.enclosingElement = enclosingElement;
  this.elements = $map([]);
  // Initializers done
}
Scope.enclosing$ctor.prototype = Scope.prototype;
Scope.prototype.get$parent = function() { return this.parent; };
Scope.prototype.lookup = function(name) {
  var element = this.elements.$index(name);
  if ($notnull_bool(element != null)) return element;
  return this.parent.lookup(name);
}
Scope.prototype.add = function(element) {
  this.elements.$setindex(element.name, element);
}
// ********** Code for TopScope **************
function TopScope(universe) {
  this.universe = universe;
  Scope.top$ctor.call(this);
  // Initializers done
}
$inherits(TopScope, Scope);
TopScope.prototype.lookup = function(name) {
  return this.universe.find(name);
}
TopScope.prototype.add = function(element) {
  $throw("Cannot add an element in the top scope");
}
// ********** Code for ScannerTask **************
function ScannerTask(compiler0) {
  CompilerTask.call(this, compiler0);
  // Initializers done
}
$inherits(ScannerTask, CompilerTask);
ScannerTask.prototype.get$name = function() {
  return 'Scanner';
}
ScannerTask.prototype.scan = function(script) {
  var $this = this; // closure support
  this.measure((function () {
    var $0;
    var elements = $this.scanElements(script.get$text());
    for (var link = elements;
     $notnull_bool(!link.isEmpty()); link = (($0 = link.get$tail()) && $0.is$Link$Element())) {
      $this.compiler.universe.define((($0 = link.get$head()) && $0.is$Element()));
    }
  })
  );
}
ScannerTask.prototype.scanElements = function(text) {
  var tokens = new StringScanner(text).tokenize();
  var listener = new Listener(this.compiler);
  var parser = new Parser(listener);
  parser.parseUnit(tokens);
  return listener.topLevelElements;
}
// ********** Code for leg_Script **************
function leg_Script(file) {
  this.file = file;
  // Initializers done
}
leg_Script.prototype.get$text = function() {
  return this.file.get$text();
}
// ********** Code for TypeCheckerTask **************
function TypeCheckerTask(compiler0) {
  CompilerTask.call(this, compiler0);
  // Initializers done
}
$inherits(TypeCheckerTask, CompilerTask);
TypeCheckerTask.prototype.get$name = function() {
  return "Type checker";
}
TypeCheckerTask.prototype.check = function(tree, elements) {
  var $this = this; // closure support
  this.measure((function () {
    var visitor = new TypeCheckerVisitor($this.compiler, elements, new Types());
    tree.accept(visitor);
  })
  );
}
// ********** Code for CompilerError **************
function CompilerError() {}
CompilerError.NOT_ASSIGNABLE = function(t, s) {
  return ('' + t + ' is not assignable to ' + s + '');
}
// ********** Code for SimpleType **************
function SimpleType(name, element) {
  this.name = name;
  this.element = element;
  // Initializers done
}
SimpleType.prototype.is$Type = function(){return this;};
SimpleType.prototype.get$name = function() { return this.name; };
SimpleType.prototype.get$element = function() { return this.element; };
SimpleType.prototype.toString = function() {
  return this.name.toString();
}
// ********** Code for FunctionType **************
function FunctionType(returnType, parameterTypes) {
  this.returnType = returnType;
  this.parameterTypes = parameterTypes;
  // Initializers done
}
FunctionType.prototype.is$Type = function(){return this;};
FunctionType.prototype.get$returnType = function() { return this.returnType; };
FunctionType.prototype.toString = function() {
  var $0;
  var sb = new StringBufferImpl("");
  var first = true;
  sb.add('(');
  for (var link = this.parameterTypes;
   $notnull_bool(!link.isEmpty()); link = (($0 = link.get$tail()) && $0.is$Link$Type())) {
    if ($notnull_bool(!first)) sb.add(', ');
    first = false;
    sb.add(link.get$head());
  }
  sb.add((') -> ' + this.returnType + ''));
  return sb.toString();
}
// ********** Code for Types **************
function Types() {
  this.VOID = new SimpleType(const$254, new Element(const$254/*const SourceString('void')*/));
  this.INT = new SimpleType(const$255, new Element(const$255/*const SourceString('int')*/));
  this.DYNAMIC = new SimpleType(const$256, new Element(const$256/*const SourceString('Dynamic')*/));
  this.STRING = new SimpleType(const$257, new Element(const$257/*const SourceString('String')*/));
  // Initializers done
}
Types.prototype.isSubtype = function(r, s) {
  return r === s || r === this.DYNAMIC || s === this.DYNAMIC;
}
Types.prototype.isAssignable = function(r, s) {
  return this.isSubtype(r, s) || this.isSubtype(s, r);
}
// ********** Code for TypeCheckerVisitor **************
function TypeCheckerVisitor(compiler, elements, types) {
  this.compiler = compiler;
  this.elements = elements;
  this.types = types;
  // Initializers done
}
TypeCheckerVisitor.prototype.fail = function(node) {
  this.compiler.cancel(('cannot type-check ' + node + ''));
}
TypeCheckerVisitor.prototype.visit = function(node) {
  var type = node.accept(this);
  return type;
}
TypeCheckerVisitor.prototype.visitBlock = function(node) {
  this.visit(node.statements);
  return this.types.VOID;
}
TypeCheckerVisitor.prototype.visitExpressionStatement = function(node) {
  return this.visit(node.expression);
}
TypeCheckerVisitor.prototype.visitFunctionExpression = function(node) {
  var functionType = this.elements.$index(node).computeType(this.compiler, this.types);
  var returnType = functionType.get$returnType();
  var previous = this.expectedReturnType;
  this.expectedReturnType = returnType;
  this.visit(node.body);
  this.expectedReturnType = previous;
  return functionType;
}
TypeCheckerVisitor.prototype.visitIdentifier = function(node) {
  this.fail(node);
}
TypeCheckerVisitor.prototype.visitIf = function(node) {
  this.visit(node.condition);
  this.visit(node.thenPart);
  if ($notnull_bool(node.get$hasElsePart())) this.visit(node.elsePart);
  return this.types.VOID;
}
TypeCheckerVisitor.prototype.visitSend = function(node) {
  var $0;
  var target = this.elements.$index(node);
  if ($notnull_bool(target != null)) {
    var funType = target.computeType(this.compiler, this.types);
    var formals = funType.parameterTypes;
    var arguments = node.get$arguments();
    while ($notnull_bool((!formals.isEmpty()) && (!arguments.isEmpty()))) {
      this.compiler.cancel('parameters not supported.');
      var argumentType = this.visit((($0 = arguments.get$head()) && $0.is$Node()));
      if ($notnull_bool(!this.types.isAssignable((($0 = formals.get$head()) && $0.is$Type()), (argumentType && argumentType.is$Type())))) {
        var warning = CompilerError.NOT_ASSIGNABLE((argumentType && argumentType.is$Type()), (($0 = formals.get$head()) && $0.is$Type()));
        this.compiler.reportWarning(node, warning);
      }
      formals = (($0 = formals.get$tail()) && $0.is$Link$Type());
      arguments = (($0 = arguments.get$tail()) && $0.is$Link$Node());
    }
    if ($notnull_bool(!formals.isEmpty())) {
      this.compiler.reportWarning(node, 'missing argument');
    }
    if ($notnull_bool(!arguments.isEmpty())) {
      this.compiler.reportWarning(node, 'additional arguments');
    }
    return funType.returnType;
  }
  else {
    var selector = node.selector;
    var name = selector.get$source();
    if ($notnull_bool($eq(name, const$248/*const SourceString('print')*/) || $eq(name, const$249/*const SourceString('+')*/))) {
      return this.types.DYNAMIC;
    }
    this.compiler.cancel(('unresolved send ' + name + '.'));
  }
}
TypeCheckerVisitor.prototype.visitSetterSend = function(node) {
  return this.types.DYNAMIC;
}
TypeCheckerVisitor.prototype.visitLiteralInt = function(node) {
  return this.types.INT;
}
TypeCheckerVisitor.prototype.visitLiteralDouble = function(node) {
  return this.types.DYNAMIC;
}
TypeCheckerVisitor.prototype.visitLiteralBool = function(node) {
  return this.types.DYNAMIC;
}
TypeCheckerVisitor.prototype.visitLiteralString = function(node) {
  return this.types.DYNAMIC;
}
TypeCheckerVisitor.prototype.visitNodeList = function(node) {
  var $0;
  for (var link = node.nodes;
   $notnull_bool(!link.isEmpty()); link = (($0 = link.get$tail()) && $0.is$Link$Node())) {
    this.visit((($0 = link.get$head()) && $0.is$Node()));
  }
}
TypeCheckerVisitor.prototype.visitOperator = function(node) {
  return this.types.DYNAMIC;
}
TypeCheckerVisitor.prototype.visitParameter = function(node) {
  return null;
}
TypeCheckerVisitor.prototype.visitReturn = function(node) {
  var expressionType = this.visit(node.expression);
  if ($notnull_bool(!this.types.isAssignable(this.expectedReturnType, expressionType))) {
    var error = CompilerError.NOT_ASSIGNABLE(this.expectedReturnType, expressionType);
    this.compiler.reportWarning(node, error);
  }
  return this.types.VOID;
}
TypeCheckerVisitor.prototype.visitTypeAnnotation = function(node) {
  if ($notnull_bool(node.typeName != null && $ne(node.typeName.get$source(), const$254/*const SourceString('void')*/))) {
    this.compiler.cancel(('unsupported type ' + node.typeName + ''));
  }
  return this.types.VOID;
}
TypeCheckerVisitor.prototype.visitVariableDefinitions = function(node) {
  return this.types.VOID;
}
// ********** Code for Universe **************
function Universe() {
  this.elements = $map([]);
  this.generatedCode = $map([]);
  this.scope = new Element(const$2/*const SourceString('global scope')*/);
  // Initializers done
}
Universe.prototype.find = function(name) {
  return this.elements.$index(name);
}
Universe.prototype.define = function(element) {
  $assert(this.elements.$index(element.name) == null, "elements[element.name] == null", "leg/universe.dart", 19, 12);
  this.elements.$setindex(element.name, element);
}
Universe.prototype.addGeneratedCode = function(element, code) {
  this.generatedCode.$setindex(element, code);
}
// ********** Code for top level **************
function unreachable() {
  $throw(const$265/*const Exception("Internal Error (Leg): UNREACHABLE")*/);
}
function compile(world) {
  var file = world.readFile(options.dartScript);
  var script = new leg_Script(file);
  var compiler = new WorldCompiler(world, script);
  return compiler.run();
}
//  ********** Library lang **************
// ********** Code for CodeWriter **************
function CodeWriter() {
  this._indentation = 0
  this._pendingIndent = false
  this.writeComments = true
  this._buf = new StringBufferImpl("");
  // Initializers done
}
CodeWriter.prototype.is$CodeWriter = function(){return this;};
CodeWriter.prototype.get$text = function() {
  return this._buf.toString();
}
CodeWriter.prototype._indent = function() {
  this._pendingIndent = false;
  for (var i = 0;
   $notnull_bool(i < this._indentation); i++) {
    this._buf.add('  '/*CodeWriter.INDENTATION*/);
  }
}
CodeWriter.prototype.comment = function(text0) {
  if ($notnull_bool(this.writeComments)) {
    this.writeln(text0);
  }
}
CodeWriter.prototype.write = function(text0) {
  if ($notnull_bool(text0.length == 0)) return;
  if ($notnull_bool(this._pendingIndent)) this._indent();
  if ($notnull_bool(text0.indexOf('\n', 0) != -1)) {
    var lines = text0.split('\n');
    for (var i = 0;
     $notnull_bool(i < lines.length - 1); i++) {
      this.writeln($assert_String(lines.$index(i)));
    }
    this.write($assert_String(lines.$index(lines.length - 1)));
  }
  else {
    this._buf.add(text0);
  }
}
CodeWriter.prototype.writeln = function(text0) {
  if ($notnull_bool(text0 != null)) {
    this.write(text0);
  }
  if ($notnull_bool(!text0.endsWith('\n'))) this._buf.add('\n'/*CodeWriter.NEWLINE*/);
  this._pendingIndent = true;
}
CodeWriter.prototype.enterBlock = function(text0) {
  this.writeln(text0);
  this._indentation++;
}
CodeWriter.prototype.exitBlock = function(text0) {
  this._indentation--;
  this.writeln(text0);
}
CodeWriter.prototype.nextBlock = function(text0) {
  this._indentation--;
  this.writeln(text0);
  this._indentation++;
}
// ********** Code for WorldGenerator **************
function WorldGenerator(main, writer) {
  this.main = main;
  this.writer = writer;
  this.globals = $map([]);
  // Initializers done
}
WorldGenerator.prototype.run = function() {
  var metaGen = new MethodGenerator(this.main, null);
  var mainCall = this.main.invoke((metaGen && metaGen.is$MethodGenerator()), null, null, Arguments.get$EMPTY(), false);
  this.main.declaringType.markUsed();
  world.corelib.types.$index('BadNumberFormatException').markUsed();
  world.get$coreimpl().types.$index('MatchImplementation').markUsed();
  world.get$coreimpl().types.$index('NumImplementation').markUsed();
  world.get$coreimpl().types.$index('StringImplementation').markUsed();
  this.writeTypes(world.get$coreimpl());
  this.writeTypes(world.corelib);
  var matchConstructor = world.get$coreimpl().types.$index('MatchImplementation').getConstructor('');
  this.genMethod((matchConstructor && matchConstructor.is$Member()));
  matchConstructor.generator.writeDefinition(this.writer, null);
  this.writeTypes(this.main.declaringType.get$library());
  this._writeDynamicStubs(world.functionType);
  this._writeGlobals();
  this.writer.writeln(('' + mainCall.code + ';'));
}
WorldGenerator.prototype.globalForStaticField = function(field, fieldValue, dependencies) {
  var fullname = ("" + field.declaringType.get$jsname() + "." + field.get$jsname() + "");
  if ($notnull_bool(!this.globals.containsKey(fullname))) {
    this.globals.$setindex(fullname, GlobalValue.GlobalValue$fromStatic$factory(field, fieldValue, dependencies));
  }
  return this.globals.$index(fullname);
}
WorldGenerator.prototype.globalForConst = function(exp, dependencies) {
  var code = exp.canonicalCode;
  if ($notnull_bool(!this.globals.containsKey(code))) {
    this.globals.$setindex(code, GlobalValue.GlobalValue$fromConst$factory(this.globals.get$length(), exp, dependencies));
  }
  return this.globals.$index(code);
}
WorldGenerator.prototype.writeTypes = function(lib) {
  if ($notnull_bool(lib.isWritten)) return;
  lib.isWritten = true;
  var $list = lib.imports;
  for (var $i = 0;$i < $list.length; $i++) {
    var import_ = $list.$index($i);
    this.writeTypes(import_.get$library());
  }
  for (var i = 0;
   $notnull_bool(i < lib.sources.length); i++) {
    lib.sources.$index(i).orderInLibrary = i;
  }
  this.writer.comment(('//  ********** Library ' + lib.name + ' **************'));
  var $list = lib.natives;
  for (var $i = 0;$i < $list.length; $i++) {
    var file = $list.$index($i);
    var filename = basename(file.filename);
    this.writer.comment(('//  ********** Natives ' + filename + ' **************'));
    this.writer.writeln(file.get$text());
  }
  lib.topType.markUsed();
  var $list = this._orderValues(lib.types);
  for (var $i = 0;$i < $list.length; $i++) {
    var type = $list.$index($i);
    if ($notnull_bool(type.get$isUsed() && type.get$isClass())) {
      this.writeType((type && type.is$lang_Type()));
      if ($notnull_bool(type.get$isGeneric())) {
        var $list0 = this._orderValues(type._concreteTypes);
        for (var $i0 = 0;$i0 < $list0.length; $i0++) {
          var ct = $list0.$index($i0);
          this.writeType((ct && ct.is$lang_Type()));
        }
      }
    }
    if ($notnull_bool(type.typeCheckCode != null)) {
      this.writer.writeln(type.typeCheckCode);
    }
  }
}
WorldGenerator.prototype.genMethod = function(meth, enclosingMethod) {
  if ($notnull_bool(!meth.isGenerated && meth.declaringType.get$isClass() && $ne(meth.get$definition(), null) && !meth.get$isAbstract())) {
    new MethodGenerator(meth, enclosingMethod).run();
  }
}
WorldGenerator.prototype._maybeIsTest = function(onType, checkType) {
  if ($notnull_bool(!checkType.isTested)) return;
  var value = 'false';
  if ($notnull_bool(onType.isSubtypeOf(checkType))) {
    value = 'function(){return this;}';
  }
  this.writer.writeln(('' + onType.get$jsname() + '.prototype.is\$' + checkType.get$jsname() + ' = ') + ('' + value + ';'));
}
WorldGenerator.prototype.writeType = function(type) {
  var $0;
  if ($notnull_bool(type.name != null && (type instanceof ConcreteType) && $eq(type.get$library(), world.get$coreimpl()) && type.name.startsWith('ListFactory'))) {
    this.writer.writeln(('' + type.get$jsname() + ' = ' + type.get$genericType().get$jsname() + ';'));
    return;
  }
  var typeName = $notnull_bool(type.get$jsname() != null) ? type.get$jsname() : 'top level';
  this.writer.comment(('// ********** Code for ' + typeName + ' **************'));
  if ($notnull_bool(type.get$isNativeType() && !type.get$isTop())) {
    var nativeName = type.get$definition().nativeType;
    if ($notnull_bool($eq(nativeName, ''))) {
      this.writer.writeln(('function ' + type.get$jsname() + '() {}'));
    }
    else if ($notnull_bool(type.get$jsname() != nativeName)) {
      this.writer.writeln(('' + type.get$jsname() + ' = ' + nativeName + ';'));
    }
  }
  if ($notnull_bool(type.get$isTop())) {
  }
  else if ($notnull_bool(type.constructors.get$length() == 0)) {
    if ($notnull_bool(!type.get$isNativeType())) {
      this.writer.writeln(('function ' + type.get$jsname() + '() {}'));
    }
  }
  else {
    var standardConstructor = type.constructors.$index('');
    if ($notnull_bool(standardConstructor == null || standardConstructor.generator == null)) {
      if ($notnull_bool(!type.get$isNativeType())) {
        this.writer.writeln(('function ' + type.get$jsname() + '() {}'));
      }
    }
    else {
      standardConstructor.generator.writeDefinition(this.writer, null);
    }
    var $list = type.constructors.getValues();
    for (var $i = type.constructors.getValues().iterator(); $i.hasNext(); ) {
      var c = $i.next();
      if ($notnull_bool($ne(c.generator, null) && $ne(c, standardConstructor))) {
        c.generator.writeDefinition(this.writer, null);
      }
    }
  }
  if ($notnull_bool(!type.get$isTop())) {
    if ($notnull_bool((type instanceof ConcreteType))) {
      this.writer.writeln(('\$inherits(' + type.get$jsname() + ', ' + type.get$genericType().get$jsname() + ');'));
    }
    else if ($notnull_bool(!type.get$isNativeType())) {
      if ($notnull_bool(type.get$parent() != null && !type.get$parent().get$isObject())) {
        this.writer.writeln(('\$inherits(' + type.get$jsname() + ', ' + type.get$parent().get$jsname() + ');'));
      }
    }
  }
  if ($notnull_bool(!(type instanceof ConcreteType))) {
    this._maybeIsTest(type, type);
  }
  if ($notnull_bool(type.get$genericType()._concreteTypes != null)) {
    var $list = this._orderValues(type.get$genericType()._concreteTypes);
    for (var $i = 0;$i < $list.length; $i++) {
      var ct = $list.$index($i);
      this._maybeIsTest(type, (ct && ct.is$lang_Type()));
    }
  }
  if ($notnull_bool(type.get$interfaces() != null)) {
    var seen = new HashSetImplementation();
    var worklist = [];
    worklist.addAll(type.get$interfaces());
    seen.addAll(type.get$interfaces());
    while ($notnull_bool(!worklist.isEmpty())) {
      var interface_ = worklist.removeLast();
      this._maybeIsTest(type, interface_.get$genericType());
      if ($notnull_bool(interface_.get$genericType()._concreteTypes != null)) {
        var $list = this._orderValues(interface_.get$genericType()._concreteTypes);
        for (var $i = 0;$i < $list.length; $i++) {
          var ct = $list.$index($i);
          this._maybeIsTest(type, (ct && ct.is$lang_Type()));
        }
      }
      var $list = interface_.get$interfaces();
      for (var $i = 0;$i < $list.length; $i++) {
        var other = $list.$index($i);
        if ($notnull_bool(!seen.contains(other))) {
          worklist.addLast(other);
          seen.add(other);
        }
      }
    }
  }
  type.factories.forEach$1(this.get$_writeMethod());
  var $list = this._orderValues((($0 = type.members) && $0.is$Map()));
  for (var $i = 0;$i < $list.length; $i++) {
    var member = $list.$index($i);
    if ($notnull_bool((member instanceof FieldMember))) {
      this._writeField((member && member.is$FieldMember()));
    }
    if ($notnull_bool((member instanceof PropertyMember))) {
      this._writeProperty((member && member.is$PropertyMember()));
    }
    if ($notnull_bool(member.get$isMethod())) {
      this._writeMethod((member && member.is$Member()));
    }
  }
  this._writeDynamicStubs(type);
}
WorldGenerator.prototype._writeDynamicStubs = function(type) {
  if ($notnull_bool(type.varStubs != null)) {
    var $list = orderValuesByKeys(type.varStubs);
    for (var $i = 0;$i < $list.length; $i++) {
      var stub = $list.$index($i);
      stub.generate(this.writer);
    }
  }
}
WorldGenerator.prototype._writeStaticField = function(field) {
  if ($notnull_bool(field.isFinal)) return;
  var fullname = ("" + field.declaringType.get$jsname() + "." + field.get$jsname() + "");
  if ($notnull_bool(this.globals.containsKey(fullname))) {
    var value = this.globals.$index(fullname);
    if ($notnull_bool(field.declaringType.get$isTop() && !field.isNative)) {
      this.writer.writeln(('var ' + field.get$jsname() + ' = ' + value.exp.code + ';'));
    }
    else {
      this.writer.writeln(('' + field.declaringType.get$jsname() + '.' + field.get$jsname() + ' = ' + value.exp.code + ';'));
    }
  }
}
WorldGenerator.prototype._writeField = function(field) {
  if ($notnull_bool(field.declaringType.get$isTop() && !field.isNative && field.value == null)) {
    this.writer.writeln(('var ' + field.get$jsname() + ';'));
  }
  if ($notnull_bool(field._providePropertySyntax)) {
    this.writer.writeln(('' + field.declaringType.get$jsname() + '.prototype.get\$' + field.get$jsname() + ' = ') + ('function() { return this.' + field.get$jsname() + '; };'));
    if ($notnull_bool(!field.isFinal)) {
      this.writer.writeln(('' + field.declaringType.get$jsname() + '.prototype.set\$' + field.get$jsname() + ' = ') + ('function(value) { return this.' + field.get$jsname() + ' = value; };'));
    }
  }
}
WorldGenerator.prototype._writeProperty = function(property) {
  if ($notnull_bool(property.getter != null)) this._writeMethod(property.getter);
  if ($notnull_bool(property.setter != null)) this._writeMethod(property.setter);
  if ($notnull_bool(property._provideFieldSyntax)) {
    this.writer.enterBlock('Object.defineProperty(' + ('' + property.declaringType.get$jsname() + '.prototype, "' + property.get$jsname() + '", {'));
    if ($notnull_bool(property.getter != null)) {
      this.writer.writeln(('get: ' + property.declaringType.get$jsname() + '.prototype.' + property.getter.get$jsname() + ','));
    }
    if ($notnull_bool(property.setter != null)) {
      this.writer.writeln(('set: ' + property.declaringType.get$jsname() + '.prototype.' + property.setter.get$jsname() + ''));
    }
    this.writer.exitBlock('});');
  }
}
WorldGenerator.prototype._writeMethod = function(method) {
  if ($notnull_bool(method.generator != null)) {
    method.generator.writeDefinition(this.writer, null);
  }
}
WorldGenerator.prototype.get$_writeMethod = function() {
  return WorldGenerator.prototype._writeMethod.bind(this);
}
WorldGenerator.prototype._writeGlobals = function() {
  var $0;
  var list = this.globals.getValues();
  list.sort((function (a, b) {
    return a.compareTo(b);
  })
  );
  for (var $i = list.iterator(); $i.hasNext(); ) {
    var global = $i.next();
    if ($notnull_bool(global.field != null)) {
      this._writeStaticField(global.field);
    }
    else {
      this.writer.writeln(('var ' + global.get$name() + ' = ' + global.exp.code + ';'));
    }
  }
}
WorldGenerator.prototype._orderValues = function(map0) {
  var values = map0.getValues();
  values.sort(this.get$_compareMembers());
  return values;
}
WorldGenerator.prototype._compareMembers = function(x, y) {
  if ($notnull_bool(x.get$span() != null && y.get$span() != null)) {
    var spans = x.get$span().compareTo(y.get$span());
    if ($notnull_bool(spans != 0)) return spans;
  }
  if ($notnull_bool(x.get$span() == null)) return 1;
  if ($notnull_bool(y.get$span() == null)) return -1;
  return x.get$name().compareTo(y.get$name());
}
WorldGenerator.prototype.get$_compareMembers = function() {
  return WorldGenerator.prototype._compareMembers.bind(this);
}
WorldGenerator.prototype.useMapFactory = function() {
  var $0;
  var factType = world.get$coreimpl().types.$index('HashMapImplementation');
  var m = factType.resolveMember('\$setindex');
  this.genMethod((($0 = m.members.$index(0)) && $0.is$Member()));
  var c = factType.getConstructor('');
  this.genMethod((c && c.is$Member()));
  return factType;
}
// ********** Code for BlockScope **************
function BlockScope(enclosingMethod, parent, reentrant) {
  this.enclosingMethod = enclosingMethod;
  this.parent = parent;
  this.reentrant = reentrant;
  this._vars = $map([]);
  // Initializers done
  if ($notnull_bool(this.get$isMethodScope())) {
    this._closedOver = new HashSetImplementation$String();
  }
  else {
    this.reentrant = $assert_bool(this.reentrant || this.parent.reentrant);
  }
}
BlockScope.prototype.get$parent = function() { return this.parent; };
BlockScope.prototype.set$parent = function(value) { return this.parent = value; };
BlockScope.prototype.get$isMethodScope = function() {
  return this.parent == null || $ne(this.parent.enclosingMethod, this.enclosingMethod);
}
BlockScope.prototype.get$methodScope = function() {
  var s = this;
  while ($notnull_bool(!s.get$isMethodScope())) s = s.get$parent();
  return s;
}
BlockScope.prototype.lookup = function(name) {
  var ret = this._vars.$index(name);
  if ($notnull_bool($ne(ret, null))) return ret;
  for (var s = this.parent;
   $notnull_bool($ne(s, null)); s = s.get$parent()) {
    ret = s._vars.$index(name);
    if ($notnull_bool($ne(ret, null))) {
      if ($notnull_bool($ne(s.enclosingMethod, this.enclosingMethod))) {
        s.get$methodScope()._closedOver.add(ret.code);
        if ($notnull_bool(this.enclosingMethod.captures != null && s.reentrant)) {
          this.enclosingMethod.captures.add(ret.code);
        }
      }
      return ret;
    }
  }
}
BlockScope.prototype._isDefinedInParent = function(name) {
  if ($notnull_bool(this.get$isMethodScope() && this._closedOver.contains(name))) return true;
  for (var s = this.parent;
   $notnull_bool($ne(s, null)); s = s.get$parent()) {
    if ($notnull_bool(s._vars.containsKey(name))) return true;
    if ($notnull_bool(s.get$isMethodScope() && s._closedOver.contains(name))) return true;
  }
  var type = this.enclosingMethod.method.declaringType;
  if ($notnull_bool(type.resolveMember(name) != null)) return true;
  if ($notnull_bool(type.get$library().lookup(name, null) != null)) return true;
  return false;
}
BlockScope.prototype.create = function(name, type, location) {
  var jsName = world.toJsIdentifier(name);
  if ($notnull_bool(this._vars.containsKey(name))) {
    if ($notnull_bool(location != null)) {
      world.error(('duplicate name "' + name + '"'), location.span);
    }
    else {
      world.internalError(('conflict with temporary name "' + name + '"'));
    }
  }
  var index = 0;
  while ($notnull_bool(this._isDefinedInParent($assert_String(jsName)))) {
    jsName = ('' + name + '' + index++ + '');
  }
  var ret = new Value(type, jsName, false, false, false);
  this._vars.$setindex(name, ret);
  return ret;
}
BlockScope.prototype.declare = function(id) {
  var type = this.enclosingMethod.method.resolveType(id.type, false);
  return this.create(id.name.name, (type && type.is$lang_Type()), id);
}
BlockScope.prototype.getRethrow = function() {
  var scope = this;
  while ($notnull_bool(scope.rethrow == null && $ne(scope.get$parent(), null))) {
    scope = scope.get$parent();
  }
  return scope.rethrow;
}
// ********** Code for MethodGenerator **************
function MethodGenerator(method, enclosingMethod) {
  var $0;
  this.method = method;
  this.enclosingMethod = enclosingMethod;
  this.writer = new CodeWriter();
  this.needsThis = false;
  // Initializers done
  if ($notnull_bool(this.enclosingMethod != null)) {
    this._scope = new BlockScope(this, this.enclosingMethod._scope, false);
    this.captures = new HashSetImplementation();
  }
  else {
    this._scope = new BlockScope(this, null, false);
  }
  if ($notnull_bool(this.enclosingMethod != null && this.method.name != '')) {
    this._scope.create(this.method.name, this.method.get$functionType(), (($0 = this.method.get$definition()) && $0.is$lang_Node()));
  }
  this._usedTemps = new HashSetImplementation();
  this._freeTemps = [];
}
MethodGenerator.prototype.is$MethodGenerator = function(){return this;};
MethodGenerator.prototype.findMembers = function(name) {
  return this.method.get$library()._findMembers(name);
}
MethodGenerator.prototype.get$isClosure = function() {
  return (this.enclosingMethod != null);
}
MethodGenerator.prototype.getTemp = function(value) {
  return $notnull_bool(value.needsTemp) ? this.forceTemp(value) : value;
}
MethodGenerator.prototype.forceTemp = function(value) {
  var name;
  if ($notnull_bool(this._freeTemps.length > 0)) {
    name = $assert_String(this._freeTemps.removeLast());
  }
  else {
    name = '\$' + this._usedTemps.get$length();
  }
  this._usedTemps.add(name);
  return new Value(value.type, name, false, false, false);
}
MethodGenerator.prototype.assignTemp = function(tmp, v) {
  if ($notnull_bool($eq(tmp, v))) {
    return v;
  }
  else {
    return new Value(v.type, ('(' + tmp.code + ' = ' + v.code + ')'), false, true, false);
  }
}
MethodGenerator.prototype.freeTemp = function(value) {
  if ($notnull_bool(this._usedTemps.remove(value.code))) {
    this._freeTemps.add(value.code);
  }
  else {
    world.internalError(('tried to free unused value or non-temp "' + value.code + '"'));
  }
}
MethodGenerator.prototype.run = function() {
  if ($notnull_bool(this.method.isGenerated)) return;
  this.method.isGenerated = true;
  this.method.generator = this;
  if ($notnull_bool((this.method.get$definition().body instanceof NativeStatement))) {
    if ($notnull_bool(this.method.get$definition().body.body == null)) {
      this.method.generator = null;
    }
    else {
      this._paramCode = map(this.method.get$parameters(), (function (p) {
        return p.get$name();
      })
      );
      this.writer.write($assert_String(this.method.get$definition().body.body));
    }
  }
  else {
    this.writeBody();
  }
}
MethodGenerator.prototype.writeDefinition = function(defWriter, lambda) {
  var paramCode = this._paramCode;
  var names = null;
  if ($notnull_bool(this.captures != null && this.captures.get$length() > 0)) {
    names = ListFactory.ListFactory$from$factory(this.captures);
    names.sort((function (x, y) {
      return x.compareTo(y);
    })
    );
    paramCode = ListFactory.ListFactory$from$factory((names && names.is$Iterable()));
    paramCode.addAll(this._paramCode);
  }
  var _params = ('(' + Strings.join(this._paramCode, ", ") + ')');
  var params = ('(' + Strings.join((paramCode && paramCode.is$List$String()), ", ") + ')');
  if ($notnull_bool(this.method.declaringType.get$isTop() && !this.get$isClosure())) {
    defWriter.enterBlock(('function ' + this.method.get$jsname() + '' + params + ' {'));
  }
  else if ($notnull_bool(this.get$isClosure())) {
    if ($notnull_bool(this.method.name == '')) {
      defWriter.enterBlock(('(function ' + params + ' {'));
    }
    else if ($notnull_bool($ne(names, null))) {
      if ($notnull_bool(lambda == null)) {
        defWriter.enterBlock(('var ' + this.method.get$jsname() + ' = (function' + params + ' {'));
      }
      else {
        defWriter.enterBlock(('(function ' + this.method.get$jsname() + '' + params + ' {'));
      }
    }
    else {
      defWriter.enterBlock(('function ' + this.method.get$jsname() + '' + params + ' {'));
    }
  }
  else if ($notnull_bool(this.method.get$isConstructor())) {
    if ($notnull_bool(this.method.get$constructorName() == '')) {
      defWriter.enterBlock(('function ' + this.method.declaringType.get$jsname() + '' + params + ' {'));
    }
    else {
      defWriter.enterBlock(('' + this.method.declaringType.get$jsname() + '.' + this.method.get$constructorName() + '\$ctor = function' + params + ' {'));
    }
  }
  else if ($notnull_bool(this.method.get$isFactory())) {
    defWriter.enterBlock(('' + this.method.get$generatedFactoryName() + ' = function' + _params + ' {'));
  }
  else if ($notnull_bool(this.method.get$isStatic())) {
    defWriter.enterBlock(('' + this.method.declaringType.get$jsname() + '.' + this.method.get$jsname() + ' = function' + _params + ' {'));
  }
  else {
    defWriter.enterBlock(('' + this.method.declaringType.get$jsname() + '.prototype.') + ('' + this.method.get$jsname() + ' = function' + _params + ' {'));
  }
  if ($notnull_bool(this.needsThis)) {
    defWriter.writeln('var \$this = this; // closure support');
  }
  if ($notnull_bool(this._usedTemps.get$length() > 0 || this._freeTemps.length > 0)) {
    $assert(this._usedTemps.get$length() == 0, "_usedTemps.length == 0", "gen.dart", 651, 14);
    this._freeTemps.addAll(this._usedTemps);
    this._freeTemps.sort((function (x, y) {
      return x.compareTo(y);
    })
    );
    defWriter.writeln(('var ' + Strings.join(this._freeTemps, ", ") + ';'));
  }
  defWriter.writeln(this.writer.get$text());
  if ($notnull_bool($ne(names, null))) {
    defWriter.exitBlock(('}).bind(null, ' + Strings.join((names && names.is$List$String()), ", ") + ')'));
  }
  else if ($notnull_bool(this.get$isClosure() && this.method.name == '')) {
    defWriter.exitBlock('})');
  }
  else {
    defWriter.exitBlock('}');
  }
  if ($notnull_bool(this.method.get$isConstructor() && this.method.get$constructorName() != '')) {
    defWriter.writeln(('' + this.method.declaringType.get$jsname() + '.' + this.method.get$constructorName() + '\$ctor.prototype = ') + ('' + this.method.declaringType.get$jsname() + '.prototype;'));
  }
  this._provideOptionalParamInfo(defWriter);
  if ($notnull_bool((this.method instanceof MethodMember) && this.method._providePropertySyntax)) {
    defWriter.enterBlock(('' + this.method.declaringType.get$jsname() + '.prototype.get\$' + this.method.get$jsname() + ' = function() {'));
    defWriter.writeln(('return ' + this.method.declaringType.get$jsname() + '.prototype.' + this.method.get$jsname() + '.bind(this);'));
    defWriter.exitBlock('}');
    if ($notnull_bool(this.method._provideFieldSyntax)) {
      world.internalError('bound method accessed with field syntax');
    }
  }
}
MethodGenerator.prototype._provideOptionalParamInfo = function(defWriter) {
  if ($notnull_bool((this.method instanceof MethodMember) && this.method._provideOptionalParamInfo)) {
    var optNames = [];
    var optValues = [];
    this.method.genParameterValues();
    var $list = this.method.get$parameters();
    for (var $i = 0;$i < $list.length; $i++) {
      var param = $list.$index($i);
      if ($notnull_bool(param.get$isOptional())) {
        optNames.add(param.get$name());
        optValues.add(MethodGenerator._escapeString(param.get$value().code));
      }
    }
    if ($notnull_bool(optNames.length > 0)) {
      var start = '';
      if ($notnull_bool(this.method.get$isStatic())) {
        if ($notnull_bool(!this.method.declaringType.get$isTop())) {
          start = this.method.declaringType.get$jsname() + '.';
        }
      }
      else {
        start = this.method.declaringType.get$jsname() + '.prototype.';
      }
      optNames.addAll(optValues);
      var optional = "['" + Strings.join((optNames && optNames.is$List$String()), "', '") + "']";
      defWriter.writeln(('' + start + '' + this.method.get$jsname() + '.\$optional = ' + optional + ''));
    }
  }
}
MethodGenerator.prototype.writeBody = function() {
  var $0;
  var initializers = null;
  var initializedFields = null;
  if ($notnull_bool(this.method.get$isConstructor())) {
    initializers = [];
    initializedFields = new HashSetImplementation();
    var $list = world.gen._orderValues(this.method.declaringType.getAllMembers());
    for (var $i = 0;$i < $list.length; $i++) {
      var f = $list.$index($i);
      if ($notnull_bool((f instanceof FieldMember) && !f.get$isStatic())) {
        var cv = f.computeValue();
        if ($notnull_bool($ne(cv, null))) {
          initializers.add(('this.' + f.get$jsname() + ' = ' + cv.code + ''));
          initializedFields.add(f.get$name());
        }
      }
    }
  }
  this._paramCode = [];
  var $list = this.method.get$parameters();
  for (var $i = 0;$i < $list.length; $i++) {
    var p = $list.$index($i);
    if ($notnull_bool($ne(initializers, null) && p.get$name().startsWith('this.'))) {
      var name = p.get$name().substring(5);
      var field = this.method.declaringType.getMember(name);
      if ($notnull_bool(field == null)) {
        world.error('bad this parameter - no matching field', p.get$definition().get$span());
      }
      if ($notnull_bool(!field.get$isField())) {
        world.error(('"' + p.get$name() + '" does not refer to a field'), p.get$definition().get$span());
      }
      var paramValue = new Value(field.get$returnType(), name, false, false, false);
      this._paramCode.add(paramValue.code);
      initializers.add(('this.' + field.get$jsname() + ' = ' + paramValue.code + ';'));
      initializedFields.add(name);
    }
    else {
      var paramValue = this._scope.create($assert_String(p.get$name()), (($0 = p.type) && $0.is$lang_Type()), (($0 = p.get$definition()) && $0.is$lang_Node()));
      this._paramCode.add(paramValue.code);
    }
  }
  var body = this.method.get$definition().body;
  if ($notnull_bool(body == null && !this.method.get$isConstructor())) {
    world.error(('unexpected empty body for ' + this.method.name + ''), this.method.get$definition().get$span());
  }
  if ($notnull_bool($ne(initializers, null))) {
    for (var $i = initializers.iterator(); $i.hasNext(); ) {
      var i = $i.next();
      this.writer.writeln($assert_String(i));
    }
    var declaredInitializers = this.method.get$definition().initializers;
    if ($notnull_bool(declaredInitializers != null)) {
      var initializerCall = null;
      for (var $i = 0;$i < declaredInitializers.length; $i++) {
        var init = declaredInitializers.$index($i);
        if ($notnull_bool((init instanceof CallExpression))) {
          if ($notnull_bool($ne(initializerCall, null))) {
            world.error('only one initializer redirecting call is allowed', init.get$span());
          }
          initializerCall = init;
        }
        else if ($notnull_bool((init instanceof BinaryExpression) && TokenKind.kindFromAssign(init.op.kind) == 0)) {
          var left = init.x;
          if ($notnull_bool(!((left instanceof DotExpression) && (left.self instanceof ThisExpression) || (left instanceof VarExpression)))) {
            world.error('invalid left side of initializer', left.get$span());
            continue;
          }
          initializedFields.add(left.get$name().get$name());
          var assign = this._makeThisValue(null).set_$4(this, left.get$name().get$name(), left.get$name(), this.visitValue(init.y));
          this.writer.writeln(('' + assign.code + ';'));
        }
        else {
          world.error('invalid initializer', init.get$span());
        }
      }
      if ($notnull_bool($ne(initializerCall, null))) {
        var target = this._writeInitializerCall((initializerCall && initializerCall.is$CallExpression()));
        if ($notnull_bool(!target.isSuper)) {
          if ($notnull_bool(initializers.length > 0)) {
            var $list = this.method.get$parameters();
            for (var $i = 0;$i < $list.length; $i++) {
              var p = $list.$index($i);
              if ($notnull_bool(p.get$name().startsWith('this.'))) {
                world.error('no initialization allowed on redirecting constructors', p.get$definition().get$span());
                break;
              }
            }
          }
          if ($notnull_bool(declaredInitializers.length > 1)) {
            var init = $notnull_bool($eq(declaredInitializers.$index(0), initializerCall)) ? declaredInitializers.$index(1) : declaredInitializers.$index(0);
            world.error('no initialization allowed on redirecting constructors', init.get$span());
          }
          initializedFields = null;
        }
      }
      else {
      }
    }
    this.writer.comment('// Initializers done');
  }
  if ($notnull_bool($ne(initializedFields, null))) {
    var $list = this.method.declaringType.members.getKeys();
    for (var $i = this.method.declaringType.members.getKeys().iterator(); $i.hasNext(); ) {
      var name = $i.next();
      var member = this.method.declaringType.members.$index(name);
      if ($notnull_bool((member instanceof FieldMember) && member.isFinal && !member.get$isStatic() && !initializedFields.contains(name))) {
        world.error(('Field "' + name + '" is final and was not initialized'), this.method.get$definition().get$span());
      }
    }
  }
  this.visitStatementsInBlock((body && body.is$lang_Statement()));
}
MethodGenerator.prototype._writeInitializerCall = function(node) {
  var contructorName = '';
  var targetExp = node.target;
  if ($notnull_bool((targetExp instanceof DotExpression))) {
    var dot = targetExp;
    targetExp = dot.self;
    contructorName = dot.name.name;
  }
  var target = null;
  if ($notnull_bool((targetExp instanceof SuperExpression))) {
    target = this._makeSuperValue((targetExp && targetExp.is$lang_Node()));
  }
  else if ($notnull_bool((targetExp instanceof ThisExpression))) {
    target = this._makeThisValue((targetExp && targetExp.is$lang_Node()));
  }
  else {
    world.error('bad call in initializers', node.span);
  }
  var m = target.type.getConstructor(contructorName);
  this.method.set$initDelegate(m);
  var other = m;
  while ($notnull_bool($ne(other, null))) {
    if ($notnull_bool($eq(other, this.method))) {
      world.error('initialization cycle', node.span);
      break;
    }
    other = other.get$initDelegate();
  }
  world.gen.genMethod((m && m.is$Member()));
  var value = m.invoke$4(this, node, target, this._makeArgs(node.arguments));
  if ($notnull_bool($ne(target.type, world.objectType))) {
    this.writer.writeln(('' + value.code + ';'));
  }
  return target;
}
MethodGenerator.prototype._makeArgs = function(arguments) {
  var $0;
  var args = [];
  var seenLabel = false;
  for (var $i = 0;$i < arguments.length; $i++) {
    var arg = arguments.$index($i);
    if ($notnull_bool(arg.label != null)) {
      seenLabel = true;
    }
    else if ($notnull_bool(seenLabel)) {
      world.error('bare argument can not follow named arguments', arg.get$span());
    }
    args.add(this.visitValue((($0 = arg.get$value()) && $0.is$lang_Expression())));
  }
  return new Arguments(arguments, args);
}
MethodGenerator._escapeString = function(text) {
  return text.replaceAll('\\', '\\\\').replaceAll('"', '\\"').replaceAll('\n', '\\n').replaceAll('\r', '\\r');
}
MethodGenerator.prototype.visitStatementsInBlock = function(body) {
  var $0;
  if ($notnull_bool((body instanceof BlockStatement))) {
    var $list = body.body;
    for (var $i = body.body.iterator(); $i.hasNext(); ) {
      var stmt = $i.next();
      stmt.visit(this);
    }
  }
  else {
    if ($notnull_bool(body != null)) body.visit(this);
  }
  return false;
}
MethodGenerator.prototype._pushBlock = function(reentrant) {
  this._scope = new BlockScope(this, this._scope, reentrant);
}
MethodGenerator.prototype._popBlock = function() {
  this._scope = this._scope.parent;
}
MethodGenerator.prototype._makeLambdaMethod = function(name, func) {
  var meth = new MethodMember(name, this.method.declaringType, func);
  meth.isLambda = true;
  meth.resolve(this.method.declaringType);
  world.gen.genMethod((meth && meth.is$Member()), this);
  return meth;
}
MethodGenerator.prototype.visitBool = function(node) {
  return this.visitValue(node).convertToNonNullBool(this, node);
}
MethodGenerator.prototype.visitValue = function(node) {
  if ($notnull_bool(node == null)) return null;
  var value = node.visit(this);
  value.checkFirstClass(node.span);
  return value;
}
MethodGenerator.prototype.visitTypedValue = function(node, expectedType) {
  return this.visitValue(node).convertTo(this, expectedType, node, false);
}
MethodGenerator.prototype.visitVoid = function(node) {
  if ($notnull_bool((node instanceof PostfixExpression))) {
    var value = this.visitPostfixExpression((node && node.is$PostfixExpression()), true);
    value.checkFirstClass(node.span);
    return value;
  }
  return this.visitValue(node);
}
MethodGenerator.prototype.visitDietStatement = function(node) {
  var $0;
  var parser = new lang_Parser(node.span.file, false, node.span.start);
  this.visitStatementsInBlock((($0 = parser.block()) && $0.is$lang_Statement()));
  return false;
}
MethodGenerator.prototype.visitVariableDefinition = function(node) {
  var $0;
  var isFinal = false;
  if ($notnull_bool(node.modifiers != null && node.modifiers.$index(0).kind == 97/*TokenKind.FINAL*/)) {
    isFinal = true;
  }
  this.writer.write('var ');
  var type = this.method.resolveType(node.type, false);
  for (var i = 0;
   $notnull_bool(i < node.names.length); i++) {
    var thisType = type;
    if ($notnull_bool(i > 0)) {
      this.writer.write(', ');
    }
    var name = node.names.$index(i).get$name();
    var value = this.visitValue((($0 = node.values.$index(i)) && $0.is$lang_Expression()));
    if ($notnull_bool(isFinal)) {
      if ($notnull_bool(value == null)) {
        world.error('no value specified for final variable', node.span);
      }
      else {
        if ($notnull_bool(thisType.get$isVar())) thisType = value.type;
      }
    }
    var val = this._scope.create($assert_String(name), (thisType && thisType.is$lang_Type()), (($0 = node.names.$index(i)) && $0.is$lang_Node()));
    if ($notnull_bool(value == null)) {
      this.writer.write(('' + val.code + ''));
    }
    else {
      this.writer.write(('' + val.code + ' = ' + value.code + ''));
    }
  }
  this.writer.writeln(';');
  return false;
}
MethodGenerator.prototype.visitFunctionDefinition = function(node) {
  var $0;
  var name = world.toJsIdentifier(node.name.name);
  var meth = this._makeLambdaMethod($assert_String(name), node);
  var funcValue = this._scope.create($assert_String(name), meth.get$functionType(), (($0 = this.method.get$definition()) && $0.is$lang_Node()));
  meth.generator.writeDefinition(this.writer, null);
  return false;
}
MethodGenerator.prototype.visitReturnStatement = function(node) {
  if ($notnull_bool(node.value == null)) {
    this.writer.writeln('return;');
  }
  else {
    if ($notnull_bool(this.method.get$isConstructor())) {
      world.error('return of value not allowed from constructor', node.span);
    }
    this.writer.writeln(('return ' + this.visitValue(node.value).code + ';'));
  }
  return true;
}
MethodGenerator.prototype.visitThrowStatement = function(node) {
  if ($notnull_bool(node.value != null)) {
    var value = this.visitValue(node.value);
    value.invoke$4(this, 'toString', node, Arguments.get$EMPTY());
    this.writer.writeln(('\$throw(' + value.code + ');'));
  }
  else {
    var rethrow = this._scope.getRethrow();
    if ($notnull_bool(rethrow == null)) {
      world.error('rethrow outside of catch', node.span);
    }
    else {
      this.writer.writeln(('throw ' + rethrow.code + ';'));
    }
  }
  return true;
}
MethodGenerator.prototype.visitAssertStatement = function(node) {
  var $0;
  var test = this.visitValue(node.test);
  if ($notnull_bool(options.enableAsserts)) {
    var err = world.corelib.types.$index('AssertError');
    world.gen.genMethod((($0 = err.getConstructor('')) && $0.is$Member()));
    world.gen.genMethod((($0 = err.members.$index('toString')) && $0.is$Member()));
    var span = node.test.span;
    var line = span.file.getLine(span.start);
    var column = span.file.getColumn($assert_num(line), span.start);
    this.writer.writeln(('\$assert(' + test.code + ', "' + MethodGenerator._escapeString(span.get$text()) + '",') + (' "' + span.file.filename + '", ' + (line + 1) + ', ' + (column + 1) + ');'));
  }
  return false;
}
MethodGenerator.prototype.visitBreakStatement = function(node) {
  if ($notnull_bool(node.label == null)) {
    this.writer.writeln('break;');
  }
  else {
    this.writer.writeln(('break ' + node.label.name + ';'));
  }
  return true;
}
MethodGenerator.prototype.visitContinueStatement = function(node) {
  if ($notnull_bool(node.label == null)) {
    this.writer.writeln('continue;');
  }
  else {
    this.writer.writeln(('continue ' + node.label.name + ';'));
  }
  return true;
}
MethodGenerator.prototype.visitIfStatement = function(node) {
  var test = this.visitBool(node.test);
  this.writer.write(('if (' + test.code + ') '));
  var exit1 = node.trueBranch.visit(this);
  if ($notnull_bool(node.falseBranch != null)) {
    this.writer.write('else ');
    if ($notnull_bool(node.falseBranch.visit(this) && exit1)) {
      return true;
    }
  }
  return false;
}
MethodGenerator.prototype.visitWhileStatement = function(node) {
  var test = this.visitBool(node.test);
  this.writer.write(('while (' + test.code + ') '));
  this._pushBlock(true);
  node.body.visit(this);
  this._popBlock();
  return false;
}
MethodGenerator.prototype.visitDoStatement = function(node) {
  this.writer.write('do ');
  this._pushBlock(true);
  node.body.visit(this);
  this._popBlock();
  var test = this.visitBool(node.test);
  this.writer.writeln(('while (' + test.code + ')'));
  return false;
}
MethodGenerator.prototype.visitForStatement = function(node) {
  this._pushBlock(false);
  this.writer.write('for (');
  if ($notnull_bool(node.init != null)) node.init.visit(this);
  else this.writer.write(';');
  if ($notnull_bool(node.test != null)) {
    var test = this.visitBool(node.test);
    this.writer.write((' ' + test.code + '; '));
  }
  else {
    this.writer.write('; ');
  }
  var needsComma = false;
  var $list = node.step;
  for (var $i = 0;$i < $list.length; $i++) {
    var s = $list.$index($i);
    if ($notnull_bool(needsComma)) this.writer.write(', ');
    var sv = this.visitVoid((s && s.is$lang_Expression()));
    this.writer.write(sv.code);
    needsComma = true;
  }
  this.writer.write(') ');
  this._pushBlock(true);
  node.body.visit(this);
  this._popBlock();
  this._popBlock();
  return false;
}
MethodGenerator.prototype.visitForInStatement = function(node) {
  var $0;
  var itemType = this.method.resolveType(node.item.type, false);
  var itemName = node.item.name.name;
  var list = node.list.visit(this);
  this._pushBlock(true);
  var item = this._scope.create($assert_String(itemName), (itemType && itemType.is$lang_Type()), node.item.name);
  var listVar = list;
  if ($notnull_bool(list.needsTemp)) {
    listVar = this._scope.create('\$list', (($0 = list.type) && $0.is$lang_Type()), null);
    this.writer.writeln(('var ' + listVar.code + ' = ' + list.code + ';'));
  }
  if ($notnull_bool(list.type.get$isList())) {
    var tmpi = this._scope.create('\$i', world.numType, null);
    this.writer.enterBlock(('for (var ' + tmpi.code + ' = 0;') + ('' + tmpi.code + ' < ' + listVar.code + '.length; ' + tmpi.code + '++) {'));
    var value = listVar.invoke(this, '\$index', node.list, new Arguments(null, [tmpi]), false);
    this.writer.writeln(('var ' + item.code + ' = ' + value.code + ';'));
  }
  else {
    this._pushBlock(false);
    var c = world.get$coreimpl().types.$index('ListIterator').getConstructor('');
    c.invoke$4(this, node, null, new Arguments(null, [new Value(null, 'l', false, true, false)]));
    var iterator = list.invoke$4(this, 'iterator', node.list, Arguments.get$EMPTY());
    var tmpi = this._scope.create('\$i', (($0 = iterator.type) && $0.is$lang_Type()), null);
    var hasNext = tmpi.invoke$4(this, 'hasNext', node.list, Arguments.get$EMPTY());
    var next = tmpi.invoke$4(this, 'next', node.list, Arguments.get$EMPTY());
    this.writer.enterBlock(('for (var ' + tmpi.code + ' = ' + iterator.code + '; ' + hasNext.code + '; ) {'));
    this.writer.writeln(('var ' + item.code + ' = ' + next.code + ';'));
  }
  this.visitStatementsInBlock(node.body);
  this.writer.exitBlock('}');
  this._popBlock();
  return false;
}
MethodGenerator.prototype._genToDartException = function(ex) {
  var $0;
  var types = const$393/*const [
        'NullPointerException', 'ObjectNotClosureException',
        'NoSuchMethodException', 'StackOverflowException']*/;
  for (var $i = types.iterator(); $i.hasNext(); ) {
    var name = $i.next();
    world.corelib.types.$index(name).markUsed();
  }
  this.writer.writeln(('' + ex + ' = \$toDartException(' + ex + ');'));
}
MethodGenerator.prototype.visitTryStatement = function(node) {
  var $0;
  this.writer.enterBlock('try {');
  this._pushBlock(false);
  this.visitStatementsInBlock(node.body);
  this._popBlock();
  if ($notnull_bool(node.catches.length == 1)) {
    var catch_ = node.catches.$index(0);
    this._pushBlock(false);
    var ex = this._scope.declare((($0 = catch_.get$exception()) && $0.is$DeclaredIdentifier()));
    this._scope.rethrow = (ex && ex.is$Value());
    this.writer.nextBlock(('} catch (' + ex.code + ') {'));
    if ($notnull_bool(catch_.trace != null)) {
      var trace = this._scope.declare(catch_.trace);
      this.writer.writeln(('var ' + trace.code + ' = \$stackTraceOf(' + ex.code + ');'));
    }
    this._genToDartException(ex.code);
    if ($notnull_bool(!ex.type.get$isVar())) {
      var test = ex.instanceOf(this, (($0 = ex.type) && $0.is$lang_Type()), catch_.get$exception().get$span(), false, true);
      this.writer.writeln(('if (' + test.code + ') throw ' + ex.code + ';'));
    }
    this.visitStatementsInBlock((($0 = node.catches.$index(0).body) && $0.is$lang_Statement()));
    this._popBlock();
  }
  else if ($notnull_bool(node.catches.length > 0)) {
    this._pushBlock(false);
    var ex = this._scope.create('\$ex', world.varType, null);
    this._scope.rethrow = (ex && ex.is$Value());
    this.writer.nextBlock(('} catch (' + ex.code + ') {'));
    var trace = null;
    if ($notnull_bool(node.catches.some((function (c) {
      return c.trace != null;
    })
    ))) {
      trace = this._scope.create('\$trace', world.varType, null);
      this.writer.writeln(('var ' + trace.code + ' = \$stackTraceOf(' + ex.code + ');'));
    }
    this._genToDartException(ex.code);
    var needsRethrow = true;
    for (var i = 0;
     $notnull_bool(i < node.catches.length); i++) {
      var catch_ = node.catches.$index(i);
      this._pushBlock(false);
      var tmp = this._scope.declare((($0 = catch_.get$exception()) && $0.is$DeclaredIdentifier()));
      if ($notnull_bool(!tmp.type.get$isVar())) {
        var test = ex.instanceOf(this, (($0 = tmp.type) && $0.is$lang_Type()), catch_.get$exception().get$span(), true, true);
        if ($notnull_bool(i == 0)) {
          this.writer.enterBlock(('if (' + test.code + ') {'));
        }
        else {
          this.writer.nextBlock(('} else if (' + test.code + ') {'));
        }
      }
      else if ($notnull_bool(i > 0)) {
        this.writer.nextBlock('} else {');
      }
      this.writer.writeln(('var ' + tmp.code + ' = ' + ex.code + ';'));
      if ($notnull_bool(catch_.trace != null)) {
        var tmptrace = this._scope.declare(catch_.trace);
        this.writer.writeln(('var ' + tmptrace.code + ' = ' + trace.code + ';'));
      }
      this.visitStatementsInBlock((($0 = catch_.body) && $0.is$lang_Statement()));
      this._popBlock();
      if ($notnull_bool(tmp.type.get$isVar())) {
        if ($notnull_bool(i + 1 < node.catches.length)) {
          world.warning('Unreachable catch clause', (($0 = node.catches.$index(i + 1)) && $0.is$SourceSpan()));
        }
        if ($notnull_bool(i > 0)) {
          this.writer.exitBlock('}');
        }
        needsRethrow = false;
        break;
      }
    }
    if ($notnull_bool(needsRethrow)) {
      this.writer.nextBlock('} else {');
      this.writer.writeln(('throw ' + ex.code + ';'));
      this.writer.exitBlock('}');
    }
    this._popBlock();
  }
  if ($notnull_bool(node.finallyBlock != null)) {
    this.writer.nextBlock('} finally {');
    this._pushBlock(false);
    this.visitStatementsInBlock(node.finallyBlock);
    this._popBlock();
  }
  this.writer.exitBlock('}');
  return false;
}
MethodGenerator.prototype.visitSwitchStatement = function(node) {
  var test = this.visitValue(node.test);
  this.writer.enterBlock(('switch (' + test.code + ') {'));
  var $list = node.cases;
  for (var $i = 0;$i < $list.length; $i++) {
    var case_ = $list.$index($i);
    if ($notnull_bool(case_.label != null)) {
      world.error('unimplemented: labeled case statement', case_.get$span());
    }
    this._pushBlock(false);
    for (var i = 0;
     $notnull_bool(i < case_.cases.length); i++) {
      var expr = case_.cases.$index(i);
      if ($notnull_bool(expr == null)) {
        if ($notnull_bool(i < case_.cases.length - 1)) {
          world.error('default clause must be the last case', case_.get$span());
        }
        this.writer.writeln('default:');
      }
      else {
        var value = this.visitValue((expr && expr.is$lang_Expression()));
        this.writer.writeln(('case ' + value.code + ':'));
      }
    }
    this.writer.enterBlock('');
    var caseExits = this._visitAllStatements(case_.statements, false);
    if ($notnull_bool($ne(case_, node.cases.$index(node.cases.length - 1)) && !caseExits)) {
      var span = case_.statements.$index(case_.statements.length - 1).get$span();
      this.writer.writeln('\$throw(new FallThroughError());');
    }
    this.writer.exitBlock('');
    this._popBlock();
  }
  this.writer.exitBlock('}');
  return false;
}
MethodGenerator.prototype._visitAllStatements = function(statementList, exits) {
  for (var i = 0;
   $notnull_bool(i < statementList.length); i++) {
    var stmt = statementList.$index(i);
    exits = stmt.visit(this);
    if ($notnull_bool($ne(stmt, statementList.$index(statementList.length - 1)) && exits)) {
      world.warning('unreachable code', statementList.$index(i + 1).get$span());
    }
  }
  return exits;
}
MethodGenerator.prototype.visitBlockStatement = function(node) {
  this._pushBlock(false);
  this.writer.enterBlock('{');
  var exits = this._visitAllStatements(node.body, false);
  this.writer.exitBlock('}');
  this._popBlock();
  return exits;
}
MethodGenerator.prototype.visitLabeledStatement = function(node) {
  this.writer.writeln(('' + node.name.name + ':'));
  node.body.visit(this);
  return false;
}
MethodGenerator.prototype.visitExpressionStatement = function(node) {
  if ($notnull_bool((node.body instanceof VarExpression) || (node.body instanceof ThisExpression))) {
    world.warning('variable used as statement', node.span);
  }
  var value = this.visitVoid(node.body);
  this.writer.writeln(('' + value.code + ';'));
  return false;
}
MethodGenerator.prototype.visitEmptyStatement = function(node) {
  this.writer.writeln(';');
  return false;
}
MethodGenerator.prototype._checkNonStatic = function(node) {
  if ($notnull_bool(this.method.get$isStatic())) {
    world.warning('not allowed in static method', node.span);
  }
}
MethodGenerator.prototype._makeSuperValue = function(node) {
  var parentType = this.method.declaringType.get$parent();
  this._checkNonStatic(node);
  if ($notnull_bool(parentType == null)) {
    world.error('no super class', node.span);
  }
  return new Value(parentType, 'this', true, true, false);
}
MethodGenerator.prototype._getOutermostMethod = function() {
  var result = this;
  while ($notnull_bool(result.enclosingMethod != null)) {
    result = result.enclosingMethod;
  }
  return result;
}
MethodGenerator.prototype._makeThisValue = function(node) {
  if ($notnull_bool(this.enclosingMethod != null)) {
    var outermostMethod = this._getOutermostMethod();
    outermostMethod._checkNonStatic(node);
    outermostMethod.needsThis = true;
    return new Value(outermostMethod.method.declaringType, '\$this', false, true, false);
  }
  else {
    this._checkNonStatic(node);
    return new Value(this.method.declaringType, 'this', false, true, false);
  }
}
MethodGenerator.prototype.visitLambdaExpression = function(node) {
  var name = '';
  if ($notnull_bool(node.func.name != null)) {
    name = world.toJsIdentifier(node.func.name.name);
  }
  var meth = this._makeLambdaMethod($assert_String(name), node.func);
  var w = new CodeWriter();
  meth.generator.writeDefinition((w && w.is$CodeWriter()), node);
  return new Value(meth.get$functionType(), w.get$text(), false, true, false);
}
MethodGenerator.prototype.visitCallExpression = function(node) {
  var target;
  var position = node.target;
  var name = '\$call';
  if ($notnull_bool((node.target instanceof DotExpression))) {
    target = node.target.self.visit(this);
    name = node.target.get$name().get$name();
    position = node.target.get$name();
  }
  else if ($notnull_bool((node.target instanceof VarExpression))) {
    name = node.target.get$name().get$name();
    var meth = this.method.declaringType.resolveMember(name);
    if ($notnull_bool($ne(meth, null))) {
      target = this._makeThisOrType();
      return meth.invoke$4(this, node.target, target, this._makeArgs(node.arguments));
    }
    meth = this.method.declaringType.get$library().lookup($assert_String(name), node.target.span);
    if ($notnull_bool($ne(meth, null))) {
      return meth.invoke$4(this, node.target, null, this._makeArgs(node.arguments));
    }
    name = '\$call';
    target = node.target.visit(this);
  }
  else {
    target = node.target.visit(this);
  }
  return target.invoke$4(this, name, position, this._makeArgs(node.arguments));
}
MethodGenerator.prototype.visitIndexExpression = function(node) {
  var target = this.visitValue(node.target);
  var index = this.visitValue(node.index);
  return target.invoke$4(this, '\$index', node, new Arguments(null, [index]));
}
MethodGenerator.prototype.visitBinaryExpression = function(node) {
  var kind = node.op.kind;
  if ($notnull_bool(kind == 35/*TokenKind.AND*/ || kind == 34/*TokenKind.OR*/)) {
    var x = this.visitValue(node.x);
    var y = this.visitValue(node.y);
    var code = ('' + x.code + ' ' + node.op + ' ' + y.code + '');
    if ($notnull_bool(x.get$isConst() && y.get$isConst())) {
      var value = $notnull_bool((kind == 35/*TokenKind.AND*/)) ? x.get$actualValue() && y.get$actualValue() : x.get$actualValue() || y.get$actualValue();
      return EvaluatedValue.EvaluatedValue$factory(x.type, value, ('' + value + ''), node.span);
    }
    return new Value(null, code, false, true, false);
  }
  else if ($notnull_bool(kind == 50/*TokenKind.EQ_STRICT*/ || kind == 51/*TokenKind.NE_STRICT*/)) {
    var x = this.visitValue(node.x);
    var y = this.visitValue(node.y);
    if ($notnull_bool(x.get$isConst() && y.get$isConst())) {
      var value = $notnull_bool(kind == 50/*TokenKind.EQ_STRICT*/) ? $eq(x.get$actualValue(), y.get$actualValue()) : $ne(x.get$actualValue(), y.get$actualValue());
      return EvaluatedValue.EvaluatedValue$factory(world.boolType, value, ("" + value + ""), node.span);
    }
    if ($notnull_bool(x.code == 'null' || y.code == 'null')) {
      var op = node.op.toString().substring(0, 2);
      return new Value(null, ('' + x.code + ' ' + op + ' ' + y.code + ''), false, true, false);
    }
    else {
      return new Value(null, ('' + x.code + ' ' + node.op + ' ' + y.code + ''), false, true, false);
    }
  }
  var assignKind = TokenKind.kindFromAssign(node.op.kind);
  if ($notnull_bool(assignKind == -1)) {
    var x = this.visitValue(node.x);
    var y = this.visitValue(node.y);
    var name = TokenKind.binaryMethodName(node.op.kind);
    if ($notnull_bool(node.op.kind == 49/*TokenKind.NE*/)) {
      name = '\$ne';
    }
    if ($notnull_bool(name == null)) {
      world.internalError(('unimplemented binary op ' + node.op + ''), node.span);
      return;
    }
    return x.invoke$4(this, name, node, new Arguments(null, [y]));
  }
  else {
    return this._visitAssign(assignKind, node.x, node.y, node, to$call$1(null));
  }
}
MethodGenerator.prototype._visitAssign = function(kind, xn, yn, position, captureOriginal) {
  if ($notnull_bool(captureOriginal == null)) {
    captureOriginal = (function (x) {
      return x;
    })
    ;
  }
  if ($notnull_bool((xn instanceof VarExpression))) {
    return this._visitVarAssign(kind, (xn && xn.is$VarExpression()), yn, position, captureOriginal);
  }
  else if ($notnull_bool((xn instanceof IndexExpression))) {
    return this._visitIndexAssign(kind, (xn && xn.is$IndexExpression()), yn, position, captureOriginal);
  }
  else if ($notnull_bool((xn instanceof DotExpression))) {
    return this._visitDotAssign(kind, (xn && xn.is$DotExpression()), yn, position, captureOriginal);
  }
  else {
    world.error('illegal lhs', position.span);
  }
}
MethodGenerator.prototype._visitVarAssign = function(kind, xn, yn, position, captureOriginal) {
  var $0;
  var x = this._scope.lookup(xn.name.name);
  var y = this.visitValue(yn);
  if ($notnull_bool(x == null)) {
    var members = this.method.declaringType.resolveMember(xn.name.name);
    if ($notnull_bool($ne(members, null))) {
      x = this._makeThisOrType();
    }
    else {
      var member = this.method.declaringType.get$library().lookup(xn.name.name, xn.name.span);
      if ($notnull_bool(member == null)) {
        world.warning(('can not resolve ' + xn.name.name + ''), xn.span);
        return this._makeMissingValue(xn.name.name);
      }
      members = new MemberSet(member);
    }
    if ($notnull_bool(!members.get$treatAsField() || members.get$containsMethods())) {
      if ($notnull_bool(kind != 0)) {
        var right = members.get_$3(this, position, x);
        right = captureOriginal((right && right.is$Value()));
        y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
      }
      return members.set_$4(this, position, x, y);
    }
    x = members.get_$3(this, position, x);
  }
  y = y.convertTo(this, (($0 = x.type) && $0.is$lang_Type()), yn, false);
  if ($notnull_bool(kind == 0)) {
    x = captureOriginal((x && x.is$Value()));
    return new Value(y.type, ('' + x.code + ' = ' + y.code + ''), false, true, false);
  }
  else if ($notnull_bool(x.type.get$isNum() && y.type.get$isNum() && (kind != 46/*TokenKind.TRUNCDIV*/))) {
    x = captureOriginal((x && x.is$Value()));
    var op = TokenKind.kindToString(kind);
    return new Value(y.type, ('' + x.code + ' ' + op + '= ' + y.code + ''), false, true, false);
  }
  else {
    var right = x;
    right = captureOriginal((right && right.is$Value()));
    y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
    return new Value(y.type, ('' + x.code + ' = ' + y.code + ''), false, true, false);
  }
}
MethodGenerator.prototype._visitIndexAssign = function(kind, xn, yn, position, captureOriginal) {
  var target = this.visitValue(xn.target);
  var index = this.visitValue(xn.index);
  var y = this.visitValue(yn);
  var tmptarget = target;
  var tmpindex = index;
  if ($notnull_bool(kind != 0)) {
    tmptarget = this.getTemp((target && target.is$Value()));
    tmpindex = this.getTemp((index && index.is$Value()));
    var right = tmptarget.invoke$4(this, '\$index', position, new Arguments(null, [this.assignTemp((tmpindex && tmpindex.is$Value()), (index && index.is$Value()))]));
    right = captureOriginal((right && right.is$Value()));
    y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
  }
  var ret = this.assignTemp((tmptarget && tmptarget.is$Value()), (target && target.is$Value())).invoke(this, '\$setindex', position, new Arguments(null, [index, y]), false);
  if ($notnull_bool($ne(tmptarget, target))) this.freeTemp((tmptarget && tmptarget.is$Value()));
  if ($notnull_bool($ne(tmpindex, index))) this.freeTemp((tmpindex && tmpindex.is$Value()));
  return ret;
}
MethodGenerator.prototype._visitDotAssign = function(kind, xn, yn, position, captureOriginal) {
  var target = xn.self.visit(this);
  var y = this.visitValue(yn);
  var tmptarget = target;
  if ($notnull_bool(kind != 0)) {
    tmptarget = this.getTemp((target && target.is$Value()));
    var right = tmptarget.get_$3(this, xn.name.name, xn.name);
    right = captureOriginal((right && right.is$Value()));
    y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
  }
  var ret = this.assignTemp((tmptarget && tmptarget.is$Value()), (target && target.is$Value())).set_(this, xn.name.name, xn.name, (y && y.is$Value()), false);
  if ($notnull_bool($ne(tmptarget, target))) this.freeTemp((tmptarget && tmptarget.is$Value()));
  return ret;
}
MethodGenerator.prototype.visitUnaryExpression = function(node) {
  var value = this.visitValue(node.self);
  switch (node.op.kind) {
    case 16/*TokenKind.INCR*/:
    case 17/*TokenKind.DECR*/:

      if ($notnull_bool(value.type.get$isNum())) {
        return new Value(value.type, ('' + node.op + '' + value.code + ''), false, true, false);
      }
      else {
        var kind = ($notnull_bool(16/*TokenKind.INCR*/ == node.op.kind) ? 42/*TokenKind.ADD*/ : 43/*TokenKind.SUB*/);
        var operand = new LiteralExpression(1, new TypeReference(node.span, world.numType), '1', node.span);
        return this._visitAssign($assert_num(kind), node.self, (operand && operand.is$lang_Expression()), node, to$call$1(null));
      }

    case 19/*TokenKind.NOT*/:

      if ($notnull_bool(value.type.get$isBool() && value.get$isConst())) {
        var newVal = !value.get$actualValue();
        return EvaluatedValue.EvaluatedValue$factory(value.type, newVal, ('' + newVal + ''), node.span);
      }
      else {
        return new Value(world.boolType, ('!' + value.code + ''), false, true, false);
      }

    case 42/*TokenKind.ADD*/:
    case 43/*TokenKind.SUB*/:
    case 18/*TokenKind.BIT_NOT*/:

      if ($notnull_bool(value.type.get$isNum())) {
        if ($notnull_bool(value.get$isConst())) {
          if ($notnull_bool(node.op.kind == 42/*TokenKind.ADD*/)) {
            return value;
          }
          else if ($notnull_bool(node.op.kind == 43/*TokenKind.SUB*/)) {
            var newVal = $negate(value.get$actualValue());
            return EvaluatedValue.EvaluatedValue$factory(value.type, newVal, ('' + newVal + ''), node.span);
          }
          else {
            var newVal = (~value.get$actualValue().toInt()).toDouble();
            return EvaluatedValue.EvaluatedValue$factory(value.type, newVal, ('' + newVal + ''), node.span);
          }
        }
        return new Value(value.type, ('' + node.op + '' + value.code + ''), false, true, false);
      }
      else {
        var name;
        if ($notnull_bool(node.op.kind == 18/*TokenKind.BIT_NOT*/)) name = '\$bit_not';
        else if ($notnull_bool(node.op.kind == 43/*TokenKind.SUB*/)) name = '\$negate';
        else world.internalError(('unimplemented: unary ' + node.op + ' on var'), node.span);
        return new Value(world.varType, ('' + name + '(' + value.code + ')'), false, true, false);
      }

    default:

      world.internalError(('unimplemented: ' + node.op + ''), node.span);

  }
}
MethodGenerator.prototype.visitPostfixExpression = function(node, isVoid) {
  var $this = this; // closure support
  var value = this.visitValue(node.body);
  if ($notnull_bool(value.type.get$isNum())) {
    return new Value(value.type, ('' + value.code + '' + node.op + ''), false, true, false);
  }
  var kind = $notnull_bool((16/*TokenKind.INCR*/ == node.op.kind)) ? 42/*TokenKind.ADD*/ : 43/*TokenKind.SUB*/;
  var operand = new LiteralExpression(1, new TypeReference(node.span, world.numType), '1', node.span);
  var tmpleft = null, left = null;
  var ret = this._visitAssign($assert_num(kind), node.body, (operand && operand.is$lang_Expression()), node, (function (l) {
    if ($notnull_bool(isVoid)) {
      return l;
    }
    else {
      left = l;
      tmpleft = $this.forceTemp((l && l.is$Value()));
      return $this.assignTemp((tmpleft && tmpleft.is$Value()), (left && left.is$Value()));
    }
  })
  );
  if ($notnull_bool($ne(tmpleft, null))) {
    ret = new Value(ret.type, ("(" + ret.code + ", " + tmpleft.code + ")"), false, true, false);
  }
  if ($notnull_bool($ne(tmpleft, left))) {
    this.freeTemp((tmpleft && tmpleft.is$Value()));
  }
  return ret;
}
MethodGenerator.prototype.visitNewExpression = function(node) {
  var $0;
  var typeRef = node.type;
  var constructorName = '';
  if ($notnull_bool(node.name != null)) {
    constructorName = node.name.name;
  }
  if ($notnull_bool($eq(constructorName, '') && !(typeRef instanceof GenericTypeReference) && typeRef.names != null)) {
    var names = ListFactory.ListFactory$from$factory(typeRef.names);
    constructorName = names.removeLast().get$name();
    if ($notnull_bool(names.length == 0)) names = null;
    typeRef = new NameTypeReference(typeRef.isFinal, typeRef.get$name(), names, typeRef.get$span());
  }
  var type = this.method.resolveType(typeRef, true);
  if ($notnull_bool(type.get$isTop())) {
    type = type.get$library().findTypeByName($assert_String(constructorName));
    constructorName = '';
  }
  var m = type.getConstructor(constructorName);
  if ($notnull_bool(m == null)) {
    var name = type.get$jsname();
    if ($notnull_bool(type.get$isVar())) {
      name = typeRef.get$name().get$name();
    }
    world.error(('no matching constructor for ' + name + ''), node.span);
    return this._makeMissingValue($assert_String(name));
  }
  if ($notnull_bool(node.isConst)) {
    if ($notnull_bool(!m.get$isConst())) {
      world.error('can\'t use const on a non-const constructor', node.span);
    }
    var $list = node.arguments;
    for (var $i = 0;$i < $list.length; $i++) {
      var arg = $list.$index($i);
      if ($notnull_bool(!this.visitValue((($0 = arg.get$value()) && $0.is$lang_Expression())).get$isConst())) {
        world.error('const constructor expects const arguments', arg.get$span());
      }
    }
  }
  return m.invoke$4(this, node, null, this._makeArgs(node.arguments));
}
MethodGenerator.prototype.visitListExpression = function(node) {
  var argsCode = [];
  var argValues = [];
  var $list = node.values;
  for (var $i = 0;$i < $list.length; $i++) {
    var item = $list.$index($i);
    var arg = this.visitValue((item && item.is$lang_Expression()));
    argValues.add(arg);
    if ($notnull_bool(node.isConst)) {
      if ($notnull_bool(!arg.get$isConst())) {
        world.error('const list can only contain const values', item.get$span());
        argsCode.add(arg.code);
      }
      else {
        argsCode.add(arg.canonicalCode);
      }
    }
    else {
      argsCode.add(arg.code);
    }
  }
  world.get$coreimpl().types.$index('ListFactory').markUsed();
  var code = ('[' + Strings.join((argsCode && argsCode.is$List$String()), ", ") + ']');
  var value = new Value(world.listType, code, false, true, false);
  if ($notnull_bool(node.isConst)) {
    var immutableList = world.get$coreimpl().types.$index('ImmutableList');
    var immutableListCtor = immutableList.getConstructor('from');
    var result = immutableListCtor.invoke$4(this, node, null, new Arguments(null, [value]));
    value = world.gen.globalForConst(ConstListValue.ConstListValue$factory((immutableList && immutableList.is$lang_Type()), (argValues && argValues.is$List$EvaluatedValue()), ('const ' + code + ''), result.code, node.span), (argValues && argValues.is$List$Value()));
  }
  return value;
}
MethodGenerator.prototype.visitMapExpression = function(node) {
  var $0;
  var mapImplType = world.gen.useMapFactory();
  var argValues = [];
  var argsCode = [];
  for (var i = 0;
   $notnull_bool(i < node.items.length); i += 2) {
    var key = this.visitTypedValue((($0 = node.items.$index(i)) && $0.is$lang_Expression()), world.stringType);
    var valueItem = node.items.$index(i + 1);
    var value = this.visitValue((valueItem && valueItem.is$lang_Expression()));
    argValues.add(key);
    argValues.add(value);
    if ($notnull_bool(node.isConst)) {
      if ($notnull_bool(!key.get$isConst() || !value.get$isConst())) {
        world.error('const map can only contain const values', valueItem.get$span());
        argsCode.add(key.code);
        argsCode.add(value.code);
      }
      else {
        argsCode.add(key.canonicalCode);
        argsCode.add(value.canonicalCode);
      }
    }
    else {
      argsCode.add(key.code);
      argsCode.add(value.code);
    }
  }
  var argList = ('[' + Strings.join((argsCode && argsCode.is$List$String()), ", ") + ']');
  var code = ('\$map(' + argList + ')');
  if ($notnull_bool(node.isConst)) {
    var immutableMap = world.get$coreimpl().types.$index('ImmutableMap');
    var immutableMapCtor = immutableMap.getConstructor('');
    var argsValue = new Value(world.listType, argList, false, true, false);
    var result = immutableMapCtor.invoke$4(this, node, null, new Arguments(null, [argsValue]));
    var value = ConstMapValue.ConstMapValue$factory((immutableMap && immutableMap.is$lang_Type()), (argValues && argValues.is$List$EvaluatedValue()), code, result.code, node.span);
    return world.gen.globalForConst(value, (argValues && argValues.is$List$Value()));
  }
  return new Value(mapImplType, code, false, true, false);
}
MethodGenerator.prototype.visitConditionalExpression = function(node) {
  var $0;
  var test = this.visitBool(node.test);
  var trueBranch = this.visitValue(node.trueBranch);
  var falseBranch = this.visitValue(node.falseBranch);
  var code = ('' + test.code + ' ? ' + trueBranch.code + ' : ' + falseBranch.code + '');
  return new Value(lang_Type.union((($0 = trueBranch.type) && $0.is$lang_Type()), (($0 = falseBranch.type) && $0.is$lang_Type())), code, false, true, false);
}
MethodGenerator.prototype.visitIsExpression = function(node) {
  var value = this.visitValue(node.x);
  var type = this.method.resolveType(node.type, false);
  return value.instanceOf(this, (type && type.is$lang_Type()), node.span, node.isTrue, false);
}
MethodGenerator.prototype.visitParenExpression = function(node) {
  var body = this.visitValue(node.body);
  if ($notnull_bool(body.get$isConst())) {
    return EvaluatedValue.EvaluatedValue$factory(body.type, body.get$actualValue(), ('(' + body.canonicalCode + ')'), node.span);
  }
  return new Value(body.type, ('(' + body.code + ')'), false, true, false);
}
MethodGenerator.prototype.visitDotExpression = function(node) {
  var target = node.self.visit(this);
  return target.get_$3(this, node.name.name, node.name);
}
MethodGenerator.prototype.visitVarExpression = function(node) {
  var ret = this._scope.lookup(node.name.name);
  if ($notnull_bool($ne(ret, null))) return ret;
  ret = this.method.declaringType.resolveMember(node.name.name);
  if ($notnull_bool($ne(ret, null))) {
    return ret.get_$3(this, node, this._makeThisOrType());
  }
  ret = this.method.declaringType.get$library().lookup(node.name.name, node.span);
  if ($notnull_bool($ne(ret, null))) {
    return ret.get_$3(this, node);
  }
  world.warning(('can not resolve ' + node.name.name + ''), node.span);
  return this._makeMissingValue(node.name.name);
}
MethodGenerator.prototype._makeMissingValue = function(name) {
  return new Value(null, ('' + name + '()/*NotFound*/'), false, true, false);
}
MethodGenerator.prototype._makeThisOrType = function() {
  var outermost = this._getOutermostMethod();
  if ($notnull_bool(outermost.method.get$isStatic())) {
    return this._makeTypeValue(outermost.method.declaringType);
  }
  else {
    return this._makeThisValue(null);
  }
}
MethodGenerator.prototype._makeTypeValue = function(type) {
  return new Value(type, type.get$jsname(), false, false, true);
}
MethodGenerator.prototype.visitThisExpression = function(node) {
  return this._makeThisValue(node);
}
MethodGenerator.prototype.visitSuperExpression = function(node) {
  return this._makeSuperValue(node);
}
MethodGenerator.prototype.visitNullExpression = function(node) {
  return EvaluatedValue.EvaluatedValue$factory(null, null, 'null', null);
}
MethodGenerator.prototype.visitLiteralExpression = function(node) {
  var $0;
  var type = node.type.type;
  $assert($ne(type, null), "type != null", "gen.dart", 2018, 12);
  if ($notnull_bool(!!(($0 = node.value) && $0.is$List))) {
    var items = [];
    var $list = node.value;
    for (var $i = node.value.iterator(); $i.hasNext(); ) {
      var item = $i.next();
      var val = this.visitValue((item && item.is$lang_Expression()));
      val.invoke$4(this, 'toString', item, Arguments.get$EMPTY());
      var code = val.code;
      if ($notnull_bool((item instanceof BinaryExpression) || (item instanceof ConditionalExpression))) {
        code = ('(' + code + ')');
      }
      items.add(code);
    }
    return new Value(type, ('(' + Strings.join((items && items.is$List$String()), " + ") + ')'), false, true, false);
  }
  var text = node.text;
  if ($notnull_bool(type.get$isString())) {
    if ($notnull_bool(text.startsWith('@'))) {
      text = MethodGenerator._escapeString(parseStringLiteral($assert_String(text)));
      text = ('"' + text + '"');
    }
    else if ($notnull_bool(isMultilineString($assert_String(text)))) {
      text = parseStringLiteral($assert_String(text));
      text = text.replaceAll('\n', '\\n');
      text = text.replaceAll('"', '\\"');
      text = ('"' + text + '"');
    }
    if ($notnull_bool(text !== node.text)) {
      node.value = text;
      node.text = $assert_String(text);
    }
  }
  return EvaluatedValue.EvaluatedValue$factory(type, node.value, node.text, null);
}
MethodGenerator.prototype.visitPostfixExpression$1 = function($0) {
  return this.visitPostfixExpression(($0 && $0.is$PostfixExpression()), false);
}
;
// ********** Code for Arguments **************
function Arguments(nodes, values) {
  this.nodes = nodes;
  this.values = values;
  // Initializers done
}
Arguments.prototype.is$Arguments = function(){return this;};
Arguments.Arguments$bare$factory = function(arity) {
  var values0 = [];
  for (var i = 0;
   $notnull_bool(i < arity); i++) {
    values0.add(new Value(world.varType, ('\$' + i + ''), false, false, false));
  }
  return new Arguments(null, values0);
}
Arguments.get$EMPTY = function() {
  if ($notnull_bool(Arguments._empty == null)) {
    Arguments._empty = new Arguments(null, []);
  }
  return Arguments._empty;
}
Arguments.prototype.get$nameCount = function() {
  return this.get$length() - this.get$bareCount();
}
Arguments.prototype.get$hasNames = function() {
  return this.get$bareCount() < this.get$length();
}
Arguments.prototype.get$length = function() {
  return this.values.length;
}
Object.defineProperty(Arguments.prototype, "length", {
  get: Arguments.prototype.get$length,
});
Arguments.prototype.getName = function(i) {
  return this.nodes.$index(i).label.name;
}
Arguments.prototype.getIndexOfName = function(name) {
  for (var i = this.get$bareCount();
   $notnull_bool(i < this.get$length()); i++) {
    if ($notnull_bool(this.getName(i) == name)) {
      return i;
    }
  }
  return -1;
}
Arguments.prototype.getValue = function(name) {
  var i = this.getIndexOfName(name);
  return $notnull_bool(i >= 0) ? this.values.$index(i) : null;
}
Arguments.prototype.get$bareCount = function() {
  if ($notnull_bool(this._bareCount == null)) {
    this._bareCount = this.get$length();
    if ($notnull_bool(this.nodes != null)) {
      for (var i = 0;
       $notnull_bool(i < this.nodes.length); i++) {
        if ($notnull_bool(this.nodes.$index(i).label != null)) {
          this._bareCount = i;
          break;
        }
      }
    }
  }
  return this._bareCount;
}
Arguments.prototype.getCode = function() {
  var argsCode = [];
  for (var i = 0;
   $notnull_bool(i < this.get$length()); i++) {
    argsCode.add(this.values.$index(i).code);
  }
  Arguments.removeTrailingNulls((argsCode && argsCode.is$List$Value()));
  return Strings.join((argsCode && argsCode.is$List$String()), ", ");
}
Arguments.removeTrailingNulls = function(argsCode) {
  while ($notnull_bool(argsCode.length > 0 && $eq(argsCode.last(), 'null'))) {
    argsCode.removeLast();
  }
}
Arguments.prototype.getNames = function() {
  var names = [];
  for (var i = this.get$bareCount();
   $notnull_bool(i < this.get$length()); i++) {
    names.add(this.getName(i));
  }
  return names;
}
Arguments.prototype.toCallStubArgs = function() {
  var result = [];
  for (var i = 0;
   $notnull_bool(i < this.get$bareCount()); i++) {
    result.add(new Value(world.varType, ('\$' + i + ''), false, false, false));
  }
  for (var i = this.get$bareCount();
   $notnull_bool(i < this.get$length()); i++) {
    var name = this.getName(i);
    if ($notnull_bool(name == null)) name = ('\$' + i + '');
    result.add(new Value(world.varType, name, false, false, false));
  }
  return new Arguments(this.nodes, result);
}
// ********** Code for LibraryImport **************
function LibraryImport(library, prefix) {
  this.library = library;
  this.prefix = prefix;
  // Initializers done
}
LibraryImport.prototype.get$library = function() { return this.library; };
LibraryImport.prototype.set$library = function(value) { return this.library = value; };
// ********** Code for Library **************
function Library(baseSource) {
  this.isWritten = false
  this.baseSource = baseSource;
  // Initializers done
  this.sourceDir = dirname(this.baseSource.filename);
  this.topType = new DefinedType(null, this, null, true);
  this.types = $map(['', this.topType]);
  this.imports = [];
  this.natives = [];
  this.sources = [];
  this._privateMembers = $map([]);
}
Library.prototype.get$name = function() { return this.name; };
Library.prototype.set$name = function(value) { return this.name = value; };
Library.prototype.get$isCore = function() {
  return $eq(this, world.corelib);
}
Library.prototype.get$isCoreImpl = function() {
  return $eq(this, world.get$coreimpl());
}
Library.prototype.get$jsname = function() {
  if ($notnull_bool(this._jsname == null)) {
    this._jsname = this.name.replaceAll('.', '_').replaceAll(':', '_').replaceAll(' ', '_');
  }
  return this._jsname;
}
Library.prototype.get$span = function() {
  return new SourceSpan(this.baseSource, 0, 0);
}
Library.prototype.makeFullPath = function(filename) {
  if ($notnull_bool(filename.startsWith('dart:'))) return filename;
  if ($notnull_bool(filename.startsWith('/'))) return filename;
  if ($notnull_bool(filename.startsWith('file:///'))) return filename;
  if ($notnull_bool(filename.startsWith('http://'))) return filename;
  return joinPaths(this.sourceDir, filename);
}
Library.prototype.addImport = function(fullname, prefix) {
  var newLib = world.getOrAddLibrary(fullname);
  this.imports.add(new LibraryImport(newLib, prefix));
  return newLib;
}
Library.prototype.addNative = function(fullname) {
  this.natives.add(world.reader.readFile(fullname));
}
Library.prototype._findMembers = function(name0) {
  if ($notnull_bool(name0.startsWith('_'))) {
    return this._privateMembers.$index(name0);
  }
  else {
    return world._members.$index(name0);
  }
}
Library.prototype._addMember = function(member) {
  var $0;
  if ($notnull_bool(member.get$isPrivate())) {
    if ($notnull_bool(member.get$isStatic())) {
      if ($notnull_bool(member.declaringType.get$isTop())) {
        world._addTopName(member);
      }
      return;
    }
    var mset = this._privateMembers.$index(member.name);
    if ($notnull_bool(mset == null)) {
      var $list = world.libraries.getValues();
      for (var $i = world.libraries.getValues().iterator(); $i.hasNext(); ) {
        var lib = $i.next();
        if ($notnull_bool(lib._privateMembers.containsKey(member.name))) {
          member.set$jsname(('_' + this.get$jsname() + '' + member.name + ''));
          break;
        }
      }
      mset = new MemberSet(member);
      this._privateMembers.$setindex(member.name, mset);
    }
    else {
      mset.members.add(member);
    }
  }
  else {
    world._addMember(member);
  }
}
Library.prototype.getOrAddFunctionType = function(name0, func, inType) {
  var def = new FunctionTypeDefinition(func, null, func.span);
  var type = new DefinedType(name0, this, def, false);
  type.addMethod('\$call', func);
  type.members.$index('\$call').resolve(inType);
  type.interfaces = [world.functionType];
  return type;
}
Library.prototype.addType = function(name0, definition, isClass) {
  if ($notnull_bool(this.types.containsKey(name0))) {
    var existingType = this.types.$index(name0);
    if ($notnull_bool(this.get$isCore() && existingType.get$definition() == null)) {
      existingType.setDefinition((definition && definition.is$Definition()));
    }
    else {
      world.warning(('duplicate definition of ' + name0 + ''), definition.span);
    }
  }
  else {
    this.types.$setindex(name0, new DefinedType(name0, this, (definition && definition.is$Definition()), isClass));
  }
  return this.types.$index(name0);
}
Library.prototype.findType = function(type) {
  var result = this.findTypeByName(type.name.name);
  if ($notnull_bool(result == null)) return null;
  if ($notnull_bool(type.names != null)) {
    if ($notnull_bool(type.names.length > 1)) {
      return null;
    }
    if ($notnull_bool(!result.get$isTop())) {
      return null;
    }
    return result.get$library().findTypeByName($assert_String(type.names.$index(0).get$name()));
  }
  return result;
}
Library.prototype.findTypeByName = function(name0) {
  var ret = this.types.$index(name0);
  var $list = this.imports;
  for (var $i = 0;$i < $list.length; $i++) {
    var imported = $list.$index($i);
    var newRet = null;
    if ($notnull_bool(imported.prefix == null)) {
      newRet = imported.get$library().types.$index(name0);
    }
    else if ($notnull_bool(imported.prefix == name0)) {
      newRet = imported.get$library().topType;
    }
    if ($notnull_bool($ne(newRet, null))) {
      if ($notnull_bool($ne(ret, null) && $ne(ret, newRet))) {
        world.error(('conflicting types for "' + name0 + '"'), ret.get$span());
        world.error(('conflicting types for "' + name0 + '"'), newRet.get$span());
      }
      else {
        ret = newRet;
      }
    }
  }
  return ret;
}
Library.prototype.lookup = function(name0, span0) {
  var retType = this.findTypeByName(name0);
  var ret = null;
  if ($notnull_bool($ne(retType, null))) {
    ret = retType.get$typeMember();
  }
  var newRet = this.topType.getMember(name0);
  if ($notnull_bool($ne(newRet, null))) {
    if ($notnull_bool($ne(ret, null) && $ne(ret, newRet))) {
      world.error(('conflicting members for "' + name0 + '"'), span0);
      world.error(('conflicting members for "' + name0 + '"'), ret.get$span());
      world.error(('conflicting members for "' + name0 + '"'), newRet.get$span());
    }
    else {
      ret = newRet;
    }
  }
  var $list = this.imports;
  for (var $i = 0;$i < $list.length; $i++) {
    var imported = $list.$index($i);
    if ($notnull_bool(imported.prefix == null)) {
      newRet = imported.get$library().topType.getMember(name0);
      if ($notnull_bool($ne(newRet, null))) {
        if ($notnull_bool($ne(ret, null) && $ne(ret, newRet))) {
          world.error(('conflicting members for "' + name0 + '"'), span0);
          world.error(('conflicting members for "' + name0 + '"'), ret.get$span());
          world.error(('conflicting members for "' + name0 + '"'), newRet.get$span());
        }
        else {
          ret = newRet;
        }
      }
    }
  }
  return ret;
}
Library.prototype.resolve = function() {
  var $0;
  if ($notnull_bool(this.name == null)) {
    this.name = this.baseSource.filename;
    var index = this.name.lastIndexOf('/', this.name.length);
    if ($notnull_bool(index >= 0)) {
      this.name = this.name.substring(index + 1);
    }
    index = this.name.indexOf('.', 0);
    if ($notnull_bool(index > 0)) {
      this.name = this.name.substring(0, index);
    }
  }
  var $list = this.types.getValues();
  for (var $i = this.types.getValues().iterator(); $i.hasNext(); ) {
    var type = $i.next();
    type.resolve();
  }
}
Library.prototype.visitSources = function() {
  var visitor = new _LibraryVisitor(this);
  visitor.addSource(this.baseSource);
}
Library.prototype.toString = function() {
  return this.baseSource.filename;
}
// ********** Code for _LibraryVisitor **************
function _LibraryVisitor(library) {
  this.seenImport = false
  this.seenSource = false
  this.seenResource = false
  this.isTop = true
  this.library = library;
  // Initializers done
  this.currentType = this.library.topType;
  this.sources = [];
}
_LibraryVisitor.prototype.get$library = function() { return this.library; };
_LibraryVisitor.prototype.get$isTop = function() { return this.isTop; };
_LibraryVisitor.prototype.set$isTop = function(value) { return this.isTop = value; };
_LibraryVisitor.prototype.addSourceFromName = function(name, span) {
  var filename = this.library.makeFullPath(name);
  if ($notnull_bool($eq(filename, this.library.baseSource.filename))) {
    world.error('library can not source itself', span);
    return;
  }
  else if ($notnull_bool(this.sources.some((function (s) {
    return s.filename == filename;
  })
  ))) {
    world.error(('file "' + filename + '" has already been sourced'), span);
    return;
  }
  var source = world.readFile(this.library.makeFullPath(name));
  this.sources.add(source);
}
_LibraryVisitor.prototype.addSource = function(source) {
  var $this = this; // closure support
  var $0;
  if ($notnull_bool(this.library.sources.some((function (s) {
    return s.filename == source.filename;
  })
  ))) {
    world.error(('duplicate source file "' + source.filename + '"'));
    return;
  }
  this.library.sources.add(source);
  var parser = new lang_Parser(source, options.dietParse, 0);
  var unit = parser.compilationUnit();
  unit.forEach((function (def) {
    return def.visit($this);
  })
  );
  $assert(this.sources.length == 0 || this.isTop, "sources.length == 0 || isTop", "library.dart", 296, 12);
  this.isTop = false;
  var newSources = this.sources;
  this.sources = [];
  for (var $i = newSources.iterator(); $i.hasNext(); ) {
    var source0 = $i.next();
    this.addSource((source0 && source0.is$SourceFile()));
  }
}
_LibraryVisitor.prototype.visitDirectiveDefinition = function(node) {
  if ($notnull_bool(!this.isTop)) {
    world.error('directives not allowed in sourced file', node.span);
    return;
  }
  var name;
  switch (node.name.name) {
    case "library":

      name = this.getSingleStringArg(node);
      if ($notnull_bool(this.library.name == null)) {
        this.library.name = $assert_String(name);
        if ($notnull_bool($eq(name, 'node') || $eq(name, 'dom'))) {
          this.library.topType.isNativeType = true;
        }
        if ($notnull_bool(this.seenImport || this.seenSource || this.seenResource)) {
          world.error('#library must be first directive in file', node.span);
        }
      }
      else {
        world.error('already specified library name', node.span);
      }
      break;

    case "import":

      this.seenImport = true;
      name = this.getFirstStringArg(node);
      var prefix = this.tryGetNamedStringArg(node, 'prefix');
      if ($notnull_bool(node.arguments.length > 2 || node.arguments.length == 2 && prefix == null)) {
        world.error('expected at most one "name" argument and one optional "prefix"' + (' but found ' + node.arguments.length + ''), node.span);
      }
      else if ($notnull_bool($ne(prefix, null) && prefix.indexOf('.', 0) >= 0)) {
        world.error('library prefix canot contain "."', node.span);
      }
      else if ($notnull_bool(this.seenSource || this.seenResource)) {
        world.error('#imports must come before any #source or #resource', node.span);
      }
      if ($notnull_bool($eq(prefix, ''))) prefix = null;
      var filename = this.library.makeFullPath($assert_String(name));
      if ($notnull_bool(this.library.imports.some((function (li) {
        return $eq(li.get$library().baseSource, filename);
      })
      ))) {
        world.error(('duplicate import of "' + name + '"'), node.span);
        return;
      }
      var newLib = this.library.addImport($assert_String(filename), $assert_String(prefix));
      if ($notnull_bool(newLib.get$name() == null && !filename.startsWith('dart:'))) {
        world.info(('imported library "' + name + '" has no #library directive'), node.span);
      }
      break;

    case "source":

      this.seenSource = true;
      name = this.getSingleStringArg(node);
      this.addSourceFromName($assert_String(name), node.span);
      if ($notnull_bool(this.seenResource)) {
        world.error('#sources must come before any #resource', node.span);
      }
      break;

    case "native":

      name = this.getSingleStringArg(node);
      this.library.addNative(this.library.makeFullPath($assert_String(name)));
      break;

    case "resource":

      this.seenResource = true;
      this.getFirstStringArg(node);
      break;

    default:

      world.error(('unknown directive: ' + node.name.name + ''), node.span);

  }
}
_LibraryVisitor.prototype.getSingleStringArg = function(node) {
  if ($notnull_bool(node.arguments.length != 1)) {
    world.error(('expected exactly one argument but found ' + node.arguments.length + ''), node.span);
  }
  return this.getFirstStringArg(node);
}
_LibraryVisitor.prototype.getFirstStringArg = function(node) {
  if ($notnull_bool(node.arguments.length < 1)) {
    world.error(('expected at least one argument but found ' + node.arguments.length + ''), node.span);
  }
  var arg = node.arguments.$index(0);
  if ($notnull_bool(arg.label != null)) {
    world.error('label not allowed for directive', node.span);
  }
  return this._parseStringArgument((arg && arg.is$ArgumentNode()));
}
_LibraryVisitor.prototype.tryGetNamedStringArg = function(node, argName) {
  var $0;
  var args = node.arguments.filter((function (a) {
    return a.label != null && a.label.name == argName;
  })
  );
  if ($notnull_bool(args.length == 0)) {
    return null;
  }
  if ($notnull_bool(args.length > 1)) {
    world.error(('expected at most one "' + argName + '" argument but found ') + node.arguments.length, node.span);
  }
  for (var $i = args.iterator(); $i.hasNext(); ) {
    var arg = $i.next();
    return this._parseStringArgument((arg && arg.is$ArgumentNode()));
  }
}
_LibraryVisitor.prototype._parseStringArgument = function(arg) {
  var expr = arg.value;
  if ($notnull_bool(!(expr instanceof LiteralExpression) || !expr.type.type.get$isString())) {
    world.error('expected string', expr.get$span());
  }
  return parseStringLiteral($assert_String(expr.get$value()));
}
_LibraryVisitor.prototype.visitTypeDefinition = function(node) {
  var oldType = this.currentType;
  this.currentType = this.library.addType(node.name.name, node, node.isClass);
  var $list = node.body;
  for (var $i = 0;$i < $list.length; $i++) {
    var member = $list.$index($i);
    member.visit(this);
  }
  this.currentType = (oldType && oldType.is$lang_Type());
}
_LibraryVisitor.prototype.visitVariableDefinition = function(node) {
  this.currentType.addField(node);
}
_LibraryVisitor.prototype.visitFunctionDefinition = function(node) {
  this.currentType.addMethod(node.name.name, node);
}
_LibraryVisitor.prototype.visitFunctionTypeDefinition = function(node) {
  var type = this.library.addType(node.func.name.name, node, false);
  type.addMethod('\$call', node.func);
}
// ********** Code for lang_Parameter **************
function lang_Parameter(definition) {
  this.definition = definition;
  // Initializers done
}
lang_Parameter.prototype.get$definition = function() { return this.definition; };
lang_Parameter.prototype.set$definition = function(value) { return this.definition = value; };
lang_Parameter.prototype.get$name = function() { return this.name; };
lang_Parameter.prototype.set$name = function(value) { return this.name = value; };
lang_Parameter.prototype.get$value = function() { return this.value; };
lang_Parameter.prototype.set$value = function(value) { return this.value = value; };
lang_Parameter.prototype.resolve = function(method, inType) {
  this.name = this.definition.name.name;
  this.type = inType.resolveType(this.definition.type, false);
  if ($notnull_bool(method.get$isStatic() && this.type.get$hasTypeParams())) {
    world.error('using type parameter in static context', this.definition.span);
  }
  if ($notnull_bool(this.definition.value != null)) {
    if ($notnull_bool((this.definition.value instanceof NullExpression) && this.definition.value.span.start == this.definition.span.start)) {
      return;
    }
    if ($notnull_bool(method.get$isAbstract())) {
      world.error('default value not allowed on abstract methods', this.definition.span);
    }
    else if ($notnull_bool(!inType.get$isClass())) {
      world.error('default value not allowed on interface methods', this.definition.span);
    }
    else if ($notnull_bool(method.name == '\$call' && method.get$definition().body == null)) {
      world.error('default value not allowed on function type', this.definition.span);
    }
  }
}
lang_Parameter.prototype.genValue = function(method, context) {
  var $0;
  if ($notnull_bool(this.definition.value == null || this.value != null)) return;
  if ($notnull_bool(context == null)) {
    context = new MethodGenerator(method, null);
  }
  this.value = (($0 = this.definition.value.visit(context)) && $0.is$Value());
  this.value = this.value.convertTo(context, this.type, this.definition.value, false);
}
lang_Parameter.prototype.copyWithNewType = function(newType) {
  var ret = new lang_Parameter(this.definition);
  ret.type = newType;
  ret.name = this.name;
  return ret;
}
lang_Parameter.prototype.get$isOptional = function() {
  return this.definition != null && this.definition.value != null;
}
// ********** Code for Member **************
function Member(name, declaringType) {
  this.name = name;
  this.declaringType = declaringType;
  this.isGenerated = false;
  // Initializers done
}
Member.prototype.is$Member = function(){return this;};
Member.prototype.is$Named = function(){return this;};
Member.prototype.get$name = function() { return this.name; };
Member.prototype.get$jsname = function() {
  return $notnull_bool(this._jsname == null) ? this.name : this._jsname;
}
Member.prototype.set$jsname = function(name0) {
  return this._jsname = name0;
}
Member.prototype.get$library = function() {
  return this.declaringType.get$library();
}
Member.prototype.get$isPrivate = function() {
  return this.name.startsWith('_');
}
Member.prototype.get$isConstructor = function() {
  return false;
}
Member.prototype.get$isField = function() {
  return false;
}
Member.prototype.get$isMethod = function() {
  return false;
}
Member.prototype.get$isProperty = function() {
  return false;
}
Member.prototype.get$isAbstract = function() {
  return false;
}
Member.prototype.get$prefersPropertySyntax = function() {
  return true;
}
Member.prototype.get$requiresFieldSyntax = function() {
  return false;
}
Member.prototype.get$isNative = function() {
  return false;
}
Member.prototype.get$constructorName = function() {
  return world.internalError('can not be a constructor', this.get$span());
}
Member.prototype.provideFieldSyntax = function() {
  return world.internalError('can not be field', this.get$span());
}
Member.prototype.providePropertySyntax = function() {
  return world.internalError('can not be property', this.get$span());
}
Member.prototype.get$definition = function() {
  return null;
}
Member.prototype.get$parameters = function() {
  return [];
}
Member.prototype.canInvoke = function(context, args) {
  return this.get$canGet() && new Value(this.get$returnType(), null, false, true, false).canInvoke(context, '\$call', args);
}
Member.prototype.invoke = function(context, node, target, args, isDynamic) {
  var newTarget = this.get_(context, node, target, isDynamic);
  return newTarget.invoke(context, '\$call', node, args, isDynamic);
}
Member.prototype.override = function(other) {
  if ($notnull_bool(this.get$isStatic())) {
    world.error('static members can not hide parent members', this.get$span(), other.get$span());
    return false;
  }
  else if ($notnull_bool(other.get$isStatic())) {
    world.error('can not override static member', this.get$span(), other.get$span());
    return false;
  }
  return true;
}
Member.prototype.get$generatedFactoryName = function() {
  $assert(this.get$isFactory(), "this.isFactory", "member.dart", 157, 12);
  var prefix = ('' + this.declaringType.get$jsname() + '.' + this.get$constructorName() + '\$');
  if ($notnull_bool(this.name == '')) {
    return ('' + prefix + 'factory');
  }
  else {
    return ('' + prefix + '' + this.name + '\$factory');
  }
}
Member.prototype.get_$3 = function($0, $1, $2) {
  return this.get_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()));
}
;
Member.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Arguments()), false);
}
;
Member.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.set_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Value()));
}
;
// ********** Code for TypeMember **************
function TypeMember(type0) {
  this.type = type0;
  Member.call(this, type0.name, type0.library.topType);
  // Initializers done
}
$inherits(TypeMember, Member);
TypeMember.prototype.get$span = function() {
  return this.type.definition.span;
}
TypeMember.prototype.get$isStatic = function() {
  return true;
}
TypeMember.prototype.get$returnType = function() {
  return world.get$isVar();
}
TypeMember.prototype.canInvoke = function(context, args) {
  return false;
}
TypeMember.prototype.get$canGet = function() {
  return true;
}
TypeMember.prototype.get$canSet = function() {
  return false;
}
TypeMember.prototype.resolve = function(inType) {

}
TypeMember.prototype.get_ = function(context, node, target, isDynamic) {
  $assert(target == null || target.type.get$isTop(), "target == null || target.type.isTop", "member.dart", 195, 12);
  return new Value(this.type, this.type.get$jsname(), false, false, true);
}
TypeMember.prototype.set_ = function(context, node, target, value, isDynamic) {
  world.error('can not set type', this.type.definition.span);
}
TypeMember.prototype.invoke = function(context, node, target, args, isDynamic) {
  world.error('can not invoke type', this.type.definition.span);
}
TypeMember.prototype.get_$3 = function($0, $1, $2) {
  return this.get_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), false);
}
;
TypeMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Arguments()), false);
}
;
TypeMember.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.set_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Value()), false);
}
;
// ********** Code for FieldMember **************
function FieldMember(name0, declaringType0, definition, value) {
  this._providePropertySyntax = false
  this._computing = false
  this.definition = definition;
  this.value = value;
  this.isNative = false;
  Member.call(this, name0, declaringType0);
  // Initializers done
}
$inherits(FieldMember, Member);
FieldMember.prototype.is$FieldMember = function(){return this;};
FieldMember.prototype.get$definition = function() { return this.definition; };
FieldMember.prototype.get$value = function() { return this.value; };
FieldMember.prototype.get$isStatic = function() { return this.isStatic; };
FieldMember.prototype.set$isStatic = function(value) { return this.isStatic = value; };
FieldMember.prototype.get$isNative = function() { return this.isNative; };
FieldMember.prototype.set$isNative = function(value) { return this.isNative = value; };
FieldMember.prototype.override = function(other) {
  if ($notnull_bool(!Member.prototype.override.call(this, other))) return false;
  if ($notnull_bool(other.get$isProperty())) {
    return true;
  }
  else {
    world.error('field can not override anything but property', this.get$span(), other.get$span());
    return false;
  }
}
FieldMember.prototype.get$prefersPropertySyntax = function() {
  return false;
}
FieldMember.prototype.get$requiresFieldSyntax = function() {
  return this.isNative;
}
FieldMember.prototype.provideFieldSyntax = function() {

}
FieldMember.prototype.providePropertySyntax = function() {
  return this._providePropertySyntax = true;
}
FieldMember.prototype.get$span = function() {
  return $notnull_bool(this.definition == null) ? null : this.definition.span;
}
FieldMember.prototype.get$returnType = function() {
  return this.type;
}
FieldMember.prototype.get$canGet = function() {
  return true;
}
FieldMember.prototype.get$canSet = function() {
  return !this.isFinal;
}
FieldMember.prototype.get$isField = function() {
  return true;
}
FieldMember.prototype.resolve = function(inType) {
  this.isStatic = this.declaringType.get$isTop();
  this.isFinal = false;
  if ($notnull_bool(this.definition.modifiers != null)) {
    var $list = this.definition.modifiers;
    for (var $i = 0;$i < $list.length; $i++) {
      var mod = $list.$index($i);
      if ($notnull_bool(mod.kind == 86/*TokenKind.STATIC*/)) {
        if ($notnull_bool(this.isStatic)) {
          world.error('duplicate static modifier', mod.get$span());
        }
        this.isStatic = true;
      }
      else if ($notnull_bool(mod.kind == 97/*TokenKind.FINAL*/)) {
        if ($notnull_bool(this.isFinal)) {
          world.error('duplicate final modifier', mod.get$span());
        }
        this.isFinal = true;
      }
      else {
        world.error(('' + mod + ' modifier not allowed on field'), mod.get$span());
      }
    }
  }
  this.type = inType.resolveType(this.definition.type, false);
  if ($notnull_bool(this.isStatic && this.type.get$hasTypeParams())) {
    world.error('using type parameter in static context', this.definition.type.span);
  }
  this.get$library()._addMember(this);
}
FieldMember.prototype.computeValue = function() {
  var $0;
  if ($notnull_bool(this.value == null)) return null;
  if ($notnull_bool(this._computedValue == null)) {
    if ($notnull_bool(this._computing)) {
      world.error('circular reference', this.value.span);
      return null;
    }
    this._computing = true;
    var finalMethod = new MethodMember('final_context', this.declaringType, null);
    finalMethod.isStatic = true;
    var finalGen = new MethodGenerator(finalMethod, null);
    this._computedValue = (($0 = this.value.visit(finalGen)) && $0.is$Value());
    if ($notnull_bool(!this._computedValue.get$isConst())) {
      if ($notnull_bool(this.isStatic)) {
        world.error('non constant static field must be initialized in functions', this.value.span);
      }
      else {
        world.error('non constant field must be initialized in constructor', this.value.span);
      }
    }
    if ($notnull_bool(this.isStatic)) {
      this._computedValue = world.gen.globalForStaticField(this, this._computedValue, [this._computedValue]);
    }
    this._computing = false;
  }
  return this._computedValue;
}
FieldMember.prototype.get_ = function(context, node, target, isDynamic) {
  if ($notnull_bool(!isDynamic)) {
    this.declaringType.markUsed();
  }
  if ($notnull_bool(this.isStatic)) {
    var cv = this.computeValue();
    if ($notnull_bool(this.isFinal)) {
      return cv;
    }
    if ($notnull_bool(this.declaringType.get$isTop())) {
      return new Value(this.type, ('' + this.get$jsname() + ''), false, true, false);
    }
    else {
      return new Value(this.type, ('' + this.declaringType.get$jsname() + '.' + this.get$jsname() + ''), false, true, false);
    }
  }
  else if ($notnull_bool(target.get$isConst() && this.isFinal)) {
    var constTarget = $notnull_bool((target instanceof GlobalValue)) ? target.exp : target;
    if ($notnull_bool((constTarget instanceof ConstObjectValue))) {
      return constTarget.fields.$index(this.name);
    }
    else if ($notnull_bool($eq(constTarget.type, world.stringType) && this.name == 'length')) {
      return new Value(this.type, ('' + constTarget.get$actualValue().length + ''), false, true, false);
    }
  }
  return new Value(this.type, ('' + target.code + '.' + this.get$jsname() + ''), false, true, false);
}
FieldMember.prototype.set_ = function(context, node, target, value0, isDynamic) {
  var lhs = this.get_(context, node, target, isDynamic);
  value0 = value0.convertTo(context, this.type, node, isDynamic);
  return new Value(this.type, ('' + lhs.code + ' = ' + value0.code + ''), false, true, false);
}
FieldMember.prototype.get_$3 = function($0, $1, $2) {
  return this.get_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), false);
}
;
FieldMember.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.set_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Value()), false);
}
;
// ********** Code for PropertyMember **************
function PropertyMember(name0, declaringType0) {
  this._provideFieldSyntax = false
  Member.call(this, name0, declaringType0);
  // Initializers done
}
$inherits(PropertyMember, Member);
PropertyMember.prototype.is$PropertyMember = function(){return this;};
PropertyMember.prototype.get$span = function() {
  return $notnull_bool(this.getter != null) ? this.getter.get$span() : null;
}
PropertyMember.prototype.get$canGet = function() {
  return this.getter != null;
}
PropertyMember.prototype.get$canSet = function() {
  return this.setter != null;
}
PropertyMember.prototype.get$prefersPropertySyntax = function() {
  return true;
}
PropertyMember.prototype.get$requiresFieldSyntax = function() {
  return false;
}
PropertyMember.prototype.provideFieldSyntax = function() {
  return this._provideFieldSyntax = true;
}
PropertyMember.prototype.providePropertySyntax = function() {

}
PropertyMember.prototype.get$isStatic = function() {
  return $notnull_bool(this.getter == null) ? this.setter.isStatic : this.getter.isStatic;
}
PropertyMember.prototype.get$isProperty = function() {
  return true;
}
PropertyMember.prototype.get$returnType = function() {
  return $notnull_bool(this.getter == null) ? this.setter.returnType : this.getter.returnType;
}
PropertyMember.prototype.override = function(other) {
  if ($notnull_bool(!Member.prototype.override.call(this, other))) return false;
  if ($notnull_bool(other.get$isProperty() || other.get$isField())) {
    if ($notnull_bool(other.get$isProperty())) this.addFromParent(other);
    return true;
  }
  else {
    world.error('property can only override field or property', this.get$span(), other.get$span());
    return false;
  }
}
PropertyMember.prototype.get_ = function(context, node, target, isDynamic) {
  if ($notnull_bool(this.getter == null)) {
    return target.invokeNoSuchMethod(context, ('get:' + this.name + ''), node);
  }
  return this.getter.invoke(context, node, target, Arguments.get$EMPTY(), false);
}
PropertyMember.prototype.set_ = function(context, node, target, value, isDynamic) {
  return this.setter.invoke(context, node, target, new Arguments(null, [value]), isDynamic);
}
PropertyMember.prototype.addFromParent = function(parentMember) {
  if ($notnull_bool((parentMember instanceof ConcreteMember))) {
    parentMember = parentMember.baseMember;
  }
  if ($notnull_bool(this.getter == null)) this.getter = parentMember.getter;
  if ($notnull_bool(this.setter == null)) this.setter = parentMember.setter;
}
PropertyMember.prototype.resolve = function(inType) {
  if ($notnull_bool(this.getter != null)) this.getter.resolve(inType);
  if ($notnull_bool(this.setter != null)) this.setter.resolve(inType);
  this.get$library()._addMember(this);
}
PropertyMember.prototype.get_$3 = function($0, $1, $2) {
  return this.get_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), false);
}
;
PropertyMember.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.set_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Value()), false);
}
;
// ********** Code for ConcreteMember **************
function ConcreteMember(name0, declaringType0, baseMember) {
  this.baseMember = baseMember;
  Member.call(this, name0, declaringType0);
  // Initializers done
  this.parameters = [];
  this.returnType = this.baseMember.get$returnType().resolveTypeParams(declaringType0);
  var $list = this.baseMember.get$parameters();
  for (var $i = 0;$i < $list.length; $i++) {
    var p = $list.$index($i);
    var newType = p.type.resolveTypeParams(declaringType0);
    if ($notnull_bool($ne(newType, p.type))) {
      this.parameters.add(p.copyWithNewType((newType && newType.is$lang_Type())));
    }
    else {
      this.parameters.add(p);
    }
  }
}
$inherits(ConcreteMember, Member);
ConcreteMember.prototype.get$returnType = function() { return this.returnType; };
ConcreteMember.prototype.set$returnType = function(value) { return this.returnType = value; };
ConcreteMember.prototype.get$parameters = function() { return this.parameters; };
ConcreteMember.prototype.set$parameters = function(value) { return this.parameters = value; };
ConcreteMember.prototype.get$span = function() {
  return this.baseMember.get$span();
}
ConcreteMember.prototype.get$isStatic = function() {
  return this.baseMember.get$isStatic();
}
ConcreteMember.prototype.get$isAbstract = function() {
  return this.baseMember.get$isAbstract();
}
ConcreteMember.prototype.get$isConst = function() {
  return this.baseMember.get$isConst();
}
ConcreteMember.prototype.get$jsname = function() {
  return this.baseMember.get$jsname();
}
ConcreteMember.prototype.set$jsname = function(name0) {
  return world.internalError('bad set of jsname on ConcreteMember');
}
ConcreteMember.prototype.get$isFactory = function() {
  return this.baseMember.get$isFactory();
}
ConcreteMember.prototype.get$canGet = function() {
  return this.baseMember.get$canGet();
}
ConcreteMember.prototype.get$canSet = function() {
  return this.baseMember.get$canSet();
}
ConcreteMember.prototype.canInvoke = function(context, args) {
  return this.baseMember.canInvoke(context, args);
}
ConcreteMember.prototype.get$isField = function() {
  return this.baseMember.get$isField();
}
ConcreteMember.prototype.get$isMethod = function() {
  return this.baseMember.get$isMethod();
}
ConcreteMember.prototype.get$isProperty = function() {
  return this.baseMember.get$isProperty();
}
ConcreteMember.prototype.get$prefersPropertySyntax = function() {
  return this.baseMember.get$prefersPropertySyntax();
}
ConcreteMember.prototype.get$requiresFieldSyntax = function() {
  return this.baseMember.get$requiresFieldSyntax();
}
ConcreteMember.prototype.provideFieldSyntax = function() {
  return this.baseMember.provideFieldSyntax();
}
ConcreteMember.prototype.providePropertySyntax = function() {
  return this.baseMember.providePropertySyntax();
}
ConcreteMember.prototype.get$isConstructor = function() {
  return this.name == this.declaringType.name;
}
ConcreteMember.prototype.get$constructorName = function() {
  return this.baseMember.get$constructorName();
}
ConcreteMember.prototype.get$definition = function() {
  return this.baseMember.get$definition();
}
ConcreteMember.prototype.get$initDelegate = function() {
  return this.baseMember.get$initDelegate();
}
ConcreteMember.prototype.set$initDelegate = function(ctor) {
  this.baseMember.set$initDelegate(ctor);
}
ConcreteMember.prototype.resolveType = function(node, isRequired) {
  var type = this.baseMember.resolveType(node, isRequired);
  return type.resolveTypeParams(this.declaringType);
}
ConcreteMember.prototype.override = function(other) {
  return this.baseMember.override(other);
}
ConcreteMember.prototype.get_ = function(context, node, target, isDynamic) {
  var ret = this.baseMember.get_(context, node, target, isDynamic);
  return new Value(this.returnType, ret.code, false, true, false);
}
ConcreteMember.prototype.set_ = function(context, node, target, value, isDynamic) {
  var ret = this.baseMember.set_(context, node, target, value, isDynamic);
  return new Value(this.returnType, ret.code, false, true, false);
}
ConcreteMember.prototype.invoke = function(context, node, target, args, isDynamic) {
  var ret = this.baseMember.invoke(context, node, target, args, isDynamic);
  var code = ret.code;
  if ($notnull_bool(this.get$isConstructor())) {
    code = code.replaceFirst(this.declaringType.get$genericType().get$jsname(), this.declaringType.get$jsname());
  }
  this.declaringType.genMethod(this);
  return new Value(this.returnType, code, false, true, false);
}
ConcreteMember.prototype.get_$3 = function($0, $1, $2) {
  return this.get_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), false);
}
;
ConcreteMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Arguments()), false);
}
;
ConcreteMember.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.set_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Value()), false);
}
;
// ********** Code for MethodMember **************
function MethodMember(name0, declaringType0, definition) {
  this.isStatic = false
  this.isAbstract = false
  this.isConst = false
  this.isFactory = false
  this.isLambda = false
  this._providePropertySyntax = false
  this._provideFieldSyntax = false
  this._provideOptionalParamInfo = false
  this.definition = definition;
  Member.call(this, name0, declaringType0);
  // Initializers done
}
$inherits(MethodMember, Member);
MethodMember.prototype.is$MethodMember = function(){return this;};
MethodMember.prototype.get$definition = function() { return this.definition; };
MethodMember.prototype.set$definition = function(value) { return this.definition = value; };
MethodMember.prototype.get$returnType = function() { return this.returnType; };
MethodMember.prototype.set$returnType = function(value) { return this.returnType = value; };
MethodMember.prototype.get$parameters = function() { return this.parameters; };
MethodMember.prototype.set$parameters = function(value) { return this.parameters = value; };
MethodMember.prototype.get$isStatic = function() { return this.isStatic; };
MethodMember.prototype.set$isStatic = function(value) { return this.isStatic = value; };
MethodMember.prototype.get$isAbstract = function() { return this.isAbstract; };
MethodMember.prototype.set$isAbstract = function(value) { return this.isAbstract = value; };
MethodMember.prototype.get$isConst = function() { return this.isConst; };
MethodMember.prototype.set$isConst = function(value) { return this.isConst = value; };
MethodMember.prototype.get$isFactory = function() { return this.isFactory; };
MethodMember.prototype.set$isFactory = function(value) { return this.isFactory = value; };
MethodMember.prototype.get$initDelegate = function() { return this.initDelegate; };
MethodMember.prototype.set$initDelegate = function(value) { return this.initDelegate = value; };
MethodMember.prototype.get$isConstructor = function() {
  return this.name == this.declaringType.name;
}
MethodMember.prototype.get$isMethod = function() {
  return !this.get$isConstructor();
}
MethodMember.prototype.get$isNative = function() {
  return (this.definition.body instanceof NativeStatement);
}
MethodMember.prototype.get$canGet = function() {
  return false;
}
MethodMember.prototype.get$canSet = function() {
  return false;
}
MethodMember.prototype.get$span = function() {
  return $notnull_bool(this.definition == null) ? null : this.definition.span;
}
MethodMember.prototype.get$constructorName = function() {
  if ($notnull_bool(this.definition.returnType == null)) return '';
  if ($notnull_bool(this.definition.returnType.names != null)) {
    return this.definition.returnType.names.$index(0).get$name();
  }
  else if ($notnull_bool($ne(this.definition.returnType.get$name(), null))) {
    return this.definition.returnType.get$name().get$name();
  }
  world.internalError('no valid constructor name', this.definition.span);
}
MethodMember.prototype.get$functionType = function() {
  if ($notnull_bool(this._functionType == null)) {
    this._functionType = this.get$library().getOrAddFunctionType(this.name, this.definition, this.declaringType);
    if ($notnull_bool(this.parameters == null)) {
      this.resolve(this.declaringType);
    }
  }
  return this._functionType;
}
MethodMember.prototype.override = function(other) {
  if ($notnull_bool(!Member.prototype.override.call(this, other))) return false;
  if ($notnull_bool(other.get$isMethod())) {
    return true;
  }
  else {
    world.error('method can only override methods', this.get$span(), other.get$span());
    return false;
  }
}
MethodMember.prototype.canInvoke = function(context, args) {
  var bareCount = args.get$bareCount();
  if ($notnull_bool(bareCount > this.parameters.length)) return false;
  if ($notnull_bool(bareCount == this.parameters.length)) {
    if ($notnull_bool(bareCount != args.get$length())) return false;
  }
  else {
    if ($notnull_bool(!this.parameters.$index(bareCount).get$isOptional())) return false;
    for (var i = bareCount;
     $notnull_bool(i < args.get$length()); i++) {
      if ($notnull_bool(this.indexOfParameter(args.getName(i)) < 0)) {
        return false;
      }
    }
  }
  return true;
}
MethodMember.prototype.indexOfParameter = function(name0) {
  for (var i = 0;
   $notnull_bool(i < this.parameters.length); i++) {
    var p = this.parameters.$index(i);
    if ($notnull_bool(p.get$isOptional() && $eq(p.get$name(), name0))) {
      return i;
    }
  }
  return -1;
}
MethodMember.prototype.resolveType = function(node, isRequired) {
  var type = this.declaringType.resolveType(node, isRequired);
  if ($notnull_bool(this.isStatic && type.get$hasTypeParams())) {
    world.error('using type parameter in static context', node.span);
  }
  return type;
}
MethodMember.prototype.get$prefersPropertySyntax = function() {
  return true;
}
MethodMember.prototype.get$requiresFieldSyntax = function() {
  return false;
}
MethodMember.prototype.provideFieldSyntax = function() {
  return this._provideFieldSyntax = true;
}
MethodMember.prototype.providePropertySyntax = function() {
  return this._providePropertySyntax = true;
}
MethodMember.prototype.set_ = function(context, Node0, target, value, isDynamic) {
  world.error('can not set method', this.definition.span);
}
MethodMember.prototype.get_ = function(context, node, target, isDynamic) {
  this.declaringType.genMethod(this);
  this._provideOptionalParamInfo = true;
  if ($notnull_bool(this.isStatic)) {
    var type = $notnull_bool(this.declaringType.get$isTop()) ? '' : ('' + this.declaringType.get$jsname() + '.');
    return new Value(this.get$functionType(), ('' + type + '' + this.get$jsname() + ''), false, true, false);
  }
  this._providePropertySyntax = true;
  return new Value(this.get$functionType(), ('' + target.code + '.get\$' + this.get$jsname() + '()'), false, true, false);
}
MethodMember.prototype.namesInOrder = function(args) {
  if ($notnull_bool(!args.get$hasNames())) return true;
  var lastParameter = null;
  for (var i = args.get$bareCount();
   $notnull_bool(i < this.parameters.length); i++) {
    var p = args.getIndexOfName($assert_String(this.parameters.$index(i).get$name()));
    if ($notnull_bool(p >= 0 && args.values.$index(p).needsTemp)) {
      if ($notnull_bool(lastParameter != null && lastParameter > $assert_num(p))) {
        return false;
      }
      lastParameter = $assert_num(p);
    }
  }
  return true;
}
MethodMember.prototype.needsArgumentConversion = function(args) {
  var $0;
  var bareCount = args.get$bareCount();
  for (var i = 0;
   $notnull_bool(i < bareCount); i++) {
    var arg = args.values.$index(i);
    if ($notnull_bool(arg.needsConversion((($0 = this.parameters.$index(i).type) && $0.is$lang_Type())))) {
      return false;
    }
  }
  if ($notnull_bool(bareCount < this.parameters.length)) {
    this.genParameterValues();
    for (var i = bareCount;
     $notnull_bool(i < this.parameters.length); i++) {
      var arg = args.getValue($assert_String(this.parameters.$index(i).get$name()));
      if ($notnull_bool($ne(arg, null) && arg.needsConversion((($0 = this.parameters.$index(i).type) && $0.is$lang_Type())))) {
        return false;
      }
    }
  }
  return true;
}
MethodMember._argCountMsg = function(actual, expected, atLeast) {
  return 'wrong number of arguments, expected ' + ('' + ($notnull_bool(atLeast) ? "at least " : "") + '' + expected + ' but found ' + actual + '');
}
MethodMember.prototype._argError = function(context, node, target, args, msg) {
  if ($notnull_bool(this.isStatic || this.get$isConstructor())) {
    world.error(msg, node.span);
  }
  else {
    world.warning(msg, node.span);
  }
  return target.invokeNoSuchMethod(context, this.name, node, args);
}
MethodMember.prototype.genParameterValues = function() {
  var $list = this.parameters;
  for (var $i = 0;$i < $list.length; $i++) {
    var p = $list.$index($i);
    p.genValue(this, this.generator);
  }
}
MethodMember.prototype.invoke = function(context, node, target, args, isDynamic) {
  var $0;
  if ($notnull_bool(this.parameters == null)) {
    world.info(('surprised to need to resolve: ' + this.declaringType.name + '.' + this.name + ''));
    this.resolve(this.declaringType);
  }
  this.declaringType.genMethod(this);
  if ($notnull_bool(this.isStatic || this.isFactory)) {
    this.declaringType.markUsed();
  }
  if ($notnull_bool(!this.namesInOrder(args))) {
    return context.findMembers(this.name).invokeOnVar(context, node, target, args);
  }
  var argsCode = [];
  if ($notnull_bool(target != null && (this.get$isConstructor() || target.isSuper))) {
    argsCode.add('this');
  }
  var bareCount = args.get$bareCount();
  for (var i = 0;
   $notnull_bool(i < bareCount); i++) {
    var arg = args.values.$index(i);
    if ($notnull_bool(i >= this.parameters.length)) {
      var msg = MethodMember._argCountMsg(args.get$length(), this.parameters.length, false);
      return this._argError(context, node, target, args, $assert_String(msg));
    }
    arg = arg.convertTo(context, (($0 = this.parameters.$index(i).type) && $0.is$lang_Type()), node, isDynamic);
    if ($notnull_bool(this.isConst && arg.get$isConst())) {
      argsCode.add(arg.canonicalCode);
    }
    else {
      argsCode.add(arg.code);
    }
  }
  if ($notnull_bool(bareCount < this.parameters.length)) {
    this.genParameterValues();
    var namedArgsUsed = 0;
    for (var i = bareCount;
     $notnull_bool(i < this.parameters.length); i++) {
      var arg = args.getValue($assert_String(this.parameters.$index(i).get$name()));
      if ($notnull_bool(arg == null)) {
        arg = this.parameters.$index(i).get$value();
      }
      else {
        arg = arg.convertTo(context, (($0 = this.parameters.$index(i).type) && $0.is$lang_Type()), node, isDynamic);
        namedArgsUsed++;
      }
      if ($notnull_bool(arg == null || !this.parameters.$index(i).get$isOptional())) {
        var msg = MethodMember._argCountMsg(Math.min(i, args.get$length()), i + 1, true);
        return this._argError(context, node, target, args, $assert_String(msg));
      }
      else {
        argsCode.add($notnull_bool(this.isConst && arg.get$isConst()) ? arg.canonicalCode : arg.code);
      }
    }
    if ($notnull_bool(namedArgsUsed < args.get$nameCount())) {
      var seen = new HashSetImplementation$String();
      for (var i = bareCount;
       $notnull_bool(i < args.get$length()); i++) {
        var name0 = args.getName(i);
        if ($notnull_bool(seen.contains(name0))) {
          return this._argError(context, node, target, args, ('duplicate argument "' + name0 + '"'));
        }
        seen.add(name0);
        var p = this.indexOfParameter($assert_String(name0));
        if ($notnull_bool(p < 0)) {
          return this._argError(context, node, target, args, ('method does not have optional parameter "' + name0 + '"'));
        }
        else if ($notnull_bool(p < bareCount)) {
          return this._argError(context, node, target, args, ('argument "' + name0 + '" passed as positional and named'));
        }
      }
      world.internalError(('wrong named arguments calling ' + this.name + ''), node.span);
    }
    Arguments.removeTrailingNulls((argsCode && argsCode.is$List$Value()));
  }
  var argsString = Strings.join((argsCode && argsCode.is$List$String()), ', ');
  if ($notnull_bool(this.get$isConstructor())) {
    return this._invokeConstructor(context, node, target, args, argsString);
  }
  if ($notnull_bool(this.name.startsWith('\$'))) {
    return this._invokeBuiltin(context, node, target, args, argsCode);
  }
  if ($notnull_bool(target != null && target.isSuper)) {
    return new Value(this.returnType, ('' + this.declaringType.get$jsname() + '.prototype.' + this.get$jsname() + '.call(' + argsString + ')'), false, true, false);
  }
  if ($notnull_bool(this.isFactory)) {
    return new Value(this.returnType, ('' + this.get$generatedFactoryName() + '(' + argsString + ')'), false, true, false);
  }
  if ($notnull_bool(this.isStatic)) {
    if ($notnull_bool(this.declaringType.get$isTop())) {
      return new Value(this.returnType, ('' + this.get$jsname() + '(' + argsString + ')'), false, true, false);
    }
    return new Value(this.returnType, ('' + this.declaringType.get$jsname() + '.' + this.get$jsname() + '(' + argsString + ')'), false, true, false);
  }
  var code = ('' + target.code + '.' + this.get$jsname() + '(' + argsString + ')');
  if ($notnull_bool(target.get$isConst())) {
    if ($notnull_bool((target instanceof GlobalValue))) {
      target = target.exp;
    }
    if ($notnull_bool(this.name == 'get\$length')) {
      if ($notnull_bool((target instanceof ConstListValue) || (target instanceof ConstMapValue))) {
        code = ('' + target.values.length + '');
      }
    }
    else if ($notnull_bool(this.name == 'isEmpty')) {
      if ($notnull_bool((target instanceof ConstListValue) || (target instanceof ConstMapValue))) {
        code = ('' + target.values.isEmpty() + '');
      }
    }
  }
  return new Value(this.returnType, code, false, true, false);
}
MethodMember.prototype._invokeConstructor = function(context, node, target, args, argsString) {
  this.declaringType.markUsed();
  if ($notnull_bool(target != null)) {
    var code = $notnull_bool((this.get$constructorName() != '')) ? ('' + this.declaringType.get$jsname() + '.' + this.get$constructorName() + '\$ctor.call(' + argsString + ')') : ('' + this.declaringType.get$jsname() + '.call(' + argsString + ')');
    return new Value(this.declaringType, code, false, true, false);
  }
  else {
    var code = $notnull_bool((this.get$constructorName() != '')) ? ('new ' + this.declaringType.get$jsname() + '.' + this.get$constructorName() + '\$ctor(' + argsString + ')') : ('new ' + this.declaringType.get$jsname() + '(' + argsString + ')');
    if ($notnull_bool(this.isConst && node.get$isConst())) {
      return this._invokeConstConstructor(node, $assert_String(code), target, args);
    }
    else {
      return new Value(this.declaringType, code, false, true, false);
    }
  }
}
MethodMember.prototype._invokeConstConstructor = function(node, code, target, args) {
  var $0;
  var fields = new HashMapImplementation$String$EvaluatedValue();
  for (var i = 0;
   $notnull_bool(i < this.parameters.length); i++) {
    var param = this.parameters.$index(i).get$name();
    if ($notnull_bool(param.startsWith('this.'))) {
      var fname = param.substring(5);
      var value = null;
      if ($notnull_bool(i < args.get$length())) {
        value = args.values.$index(i);
      }
      else {
        value = args.getValue($assert_String(this.parameters.$index(i).get$name()));
        if ($notnull_bool(value == null)) {
          value = this.parameters.$index(i).get$value();
        }
      }
      fields.$setindex(fname, value);
    }
  }
  if ($notnull_bool(this.definition.initializers != null)) {
    this.generator._pushBlock(false);
    for (var j = 0;
     $notnull_bool(j < this.definition.formals.length); j++) {
      var name0 = this.definition.formals.$index(j).get$name().get$name();
      var value = null;
      if ($notnull_bool(j < args.get$length())) {
        value = args.values.$index(j);
      }
      else {
        value = args.getValue($assert_String(this.parameters.$index(j).get$name()));
        if ($notnull_bool(value == null)) {
          value = this.parameters.$index(j).get$value();
        }
      }
      this.generator._scope._vars.$setindex(name0, value);
    }
    var $list = this.definition.initializers;
    for (var $i = 0;$i < $list.length; $i++) {
      var init = $list.$index($i);
      if ($notnull_bool((init instanceof CallExpression))) {
        var delegateArgs = this.generator._makeArgs((($0 = init.get$arguments()) && $0.is$List$ArgumentNode()));
        var value = this.initDelegate.invoke(this.generator, node, target, delegateArgs, false);
        if ($notnull_bool((init.target instanceof ThisExpression))) {
          return value;
        }
        else {
          if ($notnull_bool((value instanceof GlobalValue))) {
            value = value.exp;
          }
          var $list0 = value.fields.getKeys();
          for (var $i0 = value.fields.getKeys().iterator(); $i0.hasNext(); ) {
            var fname = $i0.next();
            fields.$setindex(fname, value.fields.$index(fname));
          }
        }
      }
      else {
        var fname = init.x.get$name().get$name();
        var val = this.generator.visitValue(init.y);
        fields.$setindex(fname, val);
      }
    }
    this.generator._popBlock();
  }
  var $list = this.declaringType.members.getValues();
  for (var $i = this.declaringType.members.getValues().iterator(); $i.hasNext(); ) {
    var f = $i.next();
    if ($notnull_bool((f instanceof FieldMember) && !f.get$isStatic() && $ne(f.get$value(), null) && !fields.containsKey(f.get$name()))) {
      fields.$setindex(f.get$name(), f.computeValue());
    }
  }
  return world.gen.globalForConst(ConstObjectValue.ConstObjectValue$factory(this.declaringType, fields, code, node.span), args.values);
}
MethodMember.prototype._invokeBuiltin = function(context, node, target, args, argsCode) {
  var allConst = target.get$isConst() && args.values.every((function (arg) {
    return arg.get$isConst();
  })
  );
  if ($notnull_bool(this.declaringType.get$isNum())) {
    if ($notnull_bool(!allConst)) {
      var code;
      if ($notnull_bool(this.name == '\$negate')) {
        code = ('-' + target.code + '');
      }
      else if ($notnull_bool(this.name == '\$bit_not')) {
        code = ('~' + target.code + '');
      }
      else if ($notnull_bool(this.name == '\$truncdiv')) {
        code = ('' + this.name + '(' + target.code + ', ' + argsCode.$index(0) + ')');
      }
      else if ($notnull_bool(this.name == '\$mod')) {
        code = ('' + this.name + '(' + target.code + ', ' + argsCode.$index(0) + ')');
      }
      else {
        var op = TokenKind.rawOperatorFromMethod(this.name);
        code = ('' + target.code + ' ' + op + ' ' + argsCode.$index(0) + '');
      }
      return new Value(this.returnType, code, false, true, false);
    }
    else {
      var value;
      var val0, val1, ival0, ival1;
      val0 = $assert_num(target.get$dynamic().get$actualValue());
      ival0 = val0.toInt();
      if ($notnull_bool(args.values.length > 0)) {
        val1 = $assert_num(args.values.$index(0).get$dynamic().get$actualValue());
        ival1 = val1.toInt();
      }
      switch (this.name) {
        case '\$negate':

          value = -val0;
          break;

        case '\$add':

          value = val0 + val1;
          break;

        case '\$sub':

          value = val0 - val1;
          break;

        case '\$mul':

          value = val0 * val1;
          break;

        case '\$div':

          value = val0 / val1;
          break;

        case '\$truncdiv':

          value = $truncdiv(val0, val1);
          break;

        case '\$mod':

          value = $mod(val0, val1);
          break;

        case '\$eq':

          value = val0 == val1;
          break;

        case '\$lt':

          value = val0 < val1;
          break;

        case '\$gt':

          value = val0 > val1;
          break;

        case '\$lte':

          value = val0 <= val1;
          break;

        case '\$gte':

          value = val0 >= val1;
          break;

        case '\$ne':

          value = val0 != val1;
          break;

        case '\$bit_not':

          value = (~ival0).toDouble();
          break;

        case '\$bit_or':

          value = (ival0 | ival1).toDouble();
          break;

        case '\$bit_xor':

          value = (ival0 ^ ival1).toDouble();
          break;

        case '\$bit_and':

          value = (ival0 & ival1).toDouble();
          break;

        case '\$shl':

          value = (ival0 << ival1).toDouble();
          break;

        case '\$sar':

          value = (ival0 >> ival1).toDouble();
          break;

        case '\$shr':

          value = (ival0 >>> ival1).toDouble();
          break;

      }
      return EvaluatedValue.EvaluatedValue$factory(this.returnType, value, ("" + value + ""), node.span);
    }
  }
  else if ($notnull_bool(this.declaringType.get$isString())) {
    if ($notnull_bool(this.name == '\$index')) {
      return new Value(this.declaringType, ('' + target.code + '[' + argsCode.$index(0) + ']'), false, true, false);
    }
    else if ($notnull_bool(this.name == '\$add')) {
      if ($notnull_bool(allConst)) {
        var val0 = target.get$dynamic().get$actualValue();
        val0 = val0.substring(1, val0.length - 1);
        var val1 = args.values.$index(0).get$dynamic().get$actualValue();
        if ($notnull_bool(args.values.$index(0).type.get$isString())) {
          val1 = val1.substring(1, val1.length - 1);
        }
        var value = ('' + val0 + '' + val1 + '');
        value = '"' + value.replaceAll('"', '\\"') + '"';
        return EvaluatedValue.EvaluatedValue$factory(world.stringType, value, value, node.span);
      }
      args.values.$index(0).invoke$4(context, 'toString', node, Arguments.get$EMPTY());
      return new Value(this.declaringType, ('' + target.code + ' + ' + argsCode.$index(0) + ''), false, true, false);
    }
  }
  else if ($notnull_bool(this.declaringType.get$isNativeType())) {
    if ($notnull_bool(this.name == '\$index')) {
      return new Value(null, ('' + target.code + '[' + argsCode.$index(0) + ']'), false, true, false);
    }
    else if ($notnull_bool(this.name == '\$setindex')) {
      return new Value(null, ('' + target.code + '[' + argsCode.$index(0) + '] = ' + argsCode.$index(1) + ''), false, true, false);
    }
  }
  if ($notnull_bool(this.name == '\$eq' || this.name == '\$ne')) {
    var op = $notnull_bool(this.name == '\$eq') ? '==' : '!=';
    if ($notnull_bool(allConst)) {
      var val0 = target.get$dynamic().get$actualValue();
      var val1 = args.values.$index(0).get$dynamic().get$actualValue();
      var newVal = $notnull_bool(this.name == '\$eq') ? $eq(val0, val1) : $ne(val0, val1);
      return EvaluatedValue.EvaluatedValue$factory(world.boolType, newVal, ("" + newVal + ""), node.span);
    }
    if ($notnull_bool($eq(argsCode.$index(0), 'null'))) {
      return new Value(this.returnType, ('' + target.code + ' ' + op + ' null'), false, true, false);
    }
    else if ($notnull_bool(target.type.get$isNum() || target.type.get$isString())) {
      return new Value(this.returnType, ('' + target.code + ' ' + op + ' ' + argsCode.$index(0) + ''), false, true, false);
    }
    return new Value(this.returnType, ('' + this.name + '(' + target.code + ', ' + argsCode.$index(0) + ')'), false, true, false);
  }
  if ($notnull_bool(this.name == '\$call')) {
    this.declaringType.markUsed();
    return new Value(this.returnType, ('' + target.code + '(' + Strings.join((argsCode && argsCode.is$List$String()), ", ") + ')'), false, true, false);
  }
  return target.invokeSpecial(this.get$jsname(), args, this.returnType);
}
MethodMember.prototype.resolve = function(inType) {
  this.isStatic = inType.get$isTop();
  this.isConst = false;
  this.isFactory = false;
  this.isAbstract = false;
  if ($notnull_bool(this.definition.modifiers != null)) {
    var $list = this.definition.modifiers;
    for (var $i = 0;$i < $list.length; $i++) {
      var mod = $list.$index($i);
      if ($notnull_bool(mod.kind == 86/*TokenKind.STATIC*/)) {
        if ($notnull_bool(this.isStatic)) {
          world.error('duplicate static modifier', mod.get$span());
        }
        this.isStatic = true;
      }
      else if ($notnull_bool(this.get$isConstructor() && mod.kind == 91/*TokenKind.CONST*/)) {
        if ($notnull_bool(this.isConst)) {
          world.error('duplicate const modifier', mod.get$span());
        }
        this.isConst = true;
      }
      else if ($notnull_bool(mod.kind == 75/*TokenKind.FACTORY*/)) {
        if ($notnull_bool(this.isFactory)) {
          world.error('duplicate factory modifier', mod.get$span());
        }
        this.isFactory = true;
      }
      else if ($notnull_bool(mod.kind == 71/*TokenKind.ABSTRACT*/)) {
        if ($notnull_bool(this.isAbstract)) {
          world.error('duplicate abstract modifier', mod.get$span());
        }
        this.isAbstract = true;
      }
      else {
        world.error(('' + mod + ' modifier not allowed on method'), mod.get$span());
      }
    }
  }
  if ($notnull_bool(this.isFactory)) {
    this.isStatic = true;
  }
  if ($notnull_bool(this.isAbstract)) {
    if ($notnull_bool(this.definition.body != null)) {
      world.error('abstract method can not have a body', this.definition.body.span);
    }
    if ($notnull_bool(this.isStatic)) {
      world.error('static method can not be abstract', this.definition.span);
    }
  }
  else {
  }
  if ($notnull_bool(this.get$isConstructor())) {
    this.returnType = this.declaringType;
  }
  else {
    this.returnType = inType.resolveType(this.definition.returnType, false);
    if ($notnull_bool(this.isStatic && this.returnType.get$hasTypeParams())) {
      world.error('using type parameter in static context', this.definition.returnType.span);
    }
  }
  this.parameters = [];
  var $list = this.definition.formals;
  for (var $i = 0;$i < $list.length; $i++) {
    var formal = $list.$index($i);
    var param = new lang_Parameter(formal);
    param.resolve(this, inType);
    this.parameters.add(param);
  }
  if ($notnull_bool(!this.isLambda)) {
    this.get$library()._addMember(this);
  }
}
MethodMember.prototype.get_$3 = function($0, $1, $2) {
  return this.get_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), false);
}
;
MethodMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Arguments()), false);
}
;
MethodMember.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.set_(($0 && $0.is$MethodGenerator()), $1, ($2 && $2.is$Value()), ($3 && $3.is$Value()), false);
}
;
// ********** Code for MemberSet **************
function MemberSet(member) {
  this.name = member.name;
  this.members = [member];
  this.jsname = member.get$jsname();
  // Initializers done
}
MemberSet.prototype.get$name = function() { return this.name; };
MemberSet.prototype.get$jsname = function() { return this.jsname; };
MemberSet.prototype.toString = function() {
  return ('' + this.name + ':' + this.members.length + '');
}
MemberSet.prototype.get$containsMethods = function() {
  return this.members.some((function (m) {
    return (m instanceof MethodMember);
  })
  );
}
MemberSet.prototype.add = function(member) {
  return this.members.add(member);
}
MemberSet.prototype.canInvoke = function(context, args) {
  return this.members.some((function (m) {
    return m.canInvoke(context, args);
  })
  );
}
MemberSet.prototype._makeError = function(node, target, action) {
  if ($notnull_bool(!target.type.get$isVar())) {
    world.warning(('could not find applicable ' + action + ' for "' + this.name + '"'), node.span);
  }
  return new Value(null, ('' + target.code + '.' + this.jsname + '() /*no applicable ' + action + '*/'), false, true, false);
}
MemberSet.prototype.get$treatAsField = function() {
  if ($notnull_bool(this._treatAsField == null)) {
    this._treatAsField = true;
    var $list = this.members;
    for (var $i = 0;$i < $list.length; $i++) {
      var member = $list.$index($i);
      if ($notnull_bool(member.get$requiresFieldSyntax())) {
        this._treatAsField = true;
        break;
      }
      if ($notnull_bool(member.get$prefersPropertySyntax())) {
        this._treatAsField = false;
      }
    }
    var $list = this.members;
    for (var $i = 0;$i < $list.length; $i++) {
      var member = $list.$index($i);
      if ($notnull_bool(this._treatAsField)) {
        member.provideFieldSyntax();
      }
      else {
        member.providePropertySyntax();
      }
    }
  }
  return this._treatAsField;
}
MemberSet.prototype.get_ = function(context, node, target, isDynamic) {
  var $0;
  if ($notnull_bool(this.members.length == 1)) {
    return this.members.$index(0).get_(context, node, target, isDynamic);
  }
  var targets = this.members.filter((function (m) {
    return m.get$canGet();
  })
  );
  if ($notnull_bool(targets.length == 1)) {
    return targets.$index(0).get_(context, node, target, isDynamic);
  }
  var returnValue = null;
  for (var $i = targets.iterator(); $i.hasNext(); ) {
    var member = $i.next();
    var value = member.get_(context, node, target, true);
    returnValue = this._tryUnion(returnValue, value, node);
  }
  if ($notnull_bool(returnValue == null)) {
    return this._makeError(node, target, 'getter');
  }
  if ($notnull_bool(returnValue.code == null)) {
    if ($notnull_bool(this.get$treatAsField())) {
      return new Value(returnValue.type, ('' + target.code + '.' + this.jsname + ''), false, true, false);
    }
    else {
      return new Value(returnValue.type, ('' + target.code + '.get\$' + this.jsname + '()'), false, true, false);
    }
  }
  return returnValue;
}
MemberSet.prototype.set_ = function(context, node, target, value, isDynamic) {
  var $0;
  if ($notnull_bool(this.members.length == 1)) {
    return this.members.$index(0).set_(context, node, target, value, isDynamic);
  }
  var targets = this.members.filter((function (m) {
    return m.get$canSet();
  })
  );
  if ($notnull_bool(targets.length == 1)) {
    return targets.$index(0).set_(context, node, target, value, isDynamic);
  }
  var returnValue = null;
  for (var $i = targets.iterator(); $i.hasNext(); ) {
    var member = $i.next();
    var res = member.set_(context, node, target, value, true);
    returnValue = this._tryUnion(returnValue, (res && res.is$Value()), node);
  }
  if ($notnull_bool(returnValue == null)) {
    return this._makeError(node, target, 'setter');
  }
  if ($notnull_bool(returnValue.code == null)) {
    if ($notnull_bool(this.get$treatAsField())) {
      return new Value(returnValue.type, ('' + target.code + '.' + this.jsname + ' = ' + value.code + ''), false, true, false);
    }
    else {
      return new Value(returnValue.type, ('' + target.code + '.set\$' + this.jsname + '(' + value.code + ')'), false, true, false);
    }
  }
  return returnValue;
}
MemberSet.prototype.invoke = function(context, node, target, args, isDynamic) {
  var $0;
  if ($notnull_bool(this.members.length == 1)) {
    return this.members.$index(0).invoke(context, node, target, args, isDynamic);
  }
  var targets = this.members.filter((function (m) {
    return m.canInvoke(context, args);
  })
  );
  if ($notnull_bool(targets.length == 1)) {
    return targets.$index(0).invoke(context, node, target, args, isDynamic);
  }
  var returnValue = null;
  for (var $i = targets.iterator(); $i.hasNext(); ) {
    var member = $i.next();
    var res = member.invoke(context, node, target, args, true);
    returnValue = this._tryUnion(returnValue, (res && res.is$Value()), node);
  }
  if ($notnull_bool(returnValue == null)) {
    return this._makeError(node, target, 'method');
  }
  if ($notnull_bool(returnValue.code == null)) {
    if ($notnull_bool(this.name.startsWith('\$'))) {
      return target.invokeSpecial(this.name, args, returnValue.type);
    }
    else {
      return this.invokeOnVar(context, node, target, args);
    }
  }
  return returnValue;
}
MemberSet.prototype.invokeOnVar = function(context, node, target, args) {
  return this.getVarMember(context, node, args).invoke(context, node, target, args);
}
MemberSet.prototype._tryUnion = function(x, y, node) {
  if ($notnull_bool(x == null)) return y;
  var type = lang_Type.union(x.type, y.type);
  if ($notnull_bool(x.code == y.code)) {
    if ($notnull_bool($eq(type, x.type))) {
      return x;
    }
    else if ($notnull_bool(x.get$isConst() || y.get$isConst())) {
      world.internalError("unexpected: union of const values ");
    }
    else {
      return new Value(type, x.code, x.isSuper && y.isSuper, x.needsTemp || y.needsTemp, x.isType && y.isType);
    }
  }
  else {
    return new Value(type, null, false, true, false);
  }
}
MemberSet.prototype.getVarMember = function(context, node, args) {
  if ($notnull_bool(world.objectType.varStubs == null)) {
    world.objectType.varStubs = $map([]);
  }
  var stubName = _getCallStubName(this.name, args);
  var stub = world.objectType.varStubs.$index(stubName);
  if ($notnull_bool(stub == null)) {
    var mset = context.findMembers(this.name).members;
    var targets = mset.filter((function (m) {
      return m.canInvoke(context, args);
    })
    );
    var returnType = reduce(map((targets && targets.is$Iterable()), (function (t) {
      return t.get$returnType();
    })
    ), lang_Type.union);
    stub = new VarMethodSet($assert_String(stubName), targets, args, returnType);
    world.objectType.varStubs.$setindex(stubName, stub);
  }
  return stub;
}
MemberSet.prototype.get_$3 = function($0, $1, $2) {
  return this.get_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), false);
}
;
MemberSet.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Arguments()), false);
}
;
MemberSet.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.set_(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Value()), false);
}
;
// ********** Code for FactoryMap **************
function FactoryMap() {
  this.factories = $map([]);
  // Initializers done
}
FactoryMap.prototype.getFactoriesFor = function(typeName) {
  var ret = this.factories.$index(typeName);
  if ($notnull_bool(ret == null)) {
    ret = $map([]);
    this.factories.$setindex(typeName, ret);
  }
  return ret;
}
FactoryMap.prototype.addFactory = function(typeName, name, member) {
  this.getFactoriesFor(typeName).$setindex(name, member);
}
FactoryMap.prototype.getFactory = function(typeName, name) {
  return this.getFactoriesFor(typeName).$index(name);
}
FactoryMap.prototype.forEach = function(f) {
  this.factories.forEach((function (_, constructors) {
    constructors.forEach((function (_0, member) {
      f(member);
    })
    );
  })
  );
}
FactoryMap.prototype.forEach$1 = FactoryMap.prototype.forEach;
// ********** Code for lang_Token **************
function lang_Token(kind, source, start, end) {
  this.kind = kind;
  this.source = source;
  this.start = start;
  this.end = end;
  // Initializers done
}
lang_Token.prototype.get$source = function() { return this.source; };
lang_Token.prototype.get$text = function() {
  return this.source.get$text().substring(this.start, this.end);
}
lang_Token.prototype.toString = function() {
  var kindText = TokenKind.kindToString(this.kind);
  var actualText = this.get$text();
  if ($notnull_bool($ne(kindText, actualText))) {
    if ($notnull_bool(actualText.length > 10)) {
      actualText = actualText.substring(0, 8) + '...';
    }
    return ('' + kindText + '(' + actualText + ')');
  }
  else {
    return kindText;
  }
}
lang_Token.prototype.get$span = function() {
  return new SourceSpan(this.source, this.start, this.end);
}
// ********** Code for SourceFile **************
function SourceFile(filename, _text) {
  this.filename = filename;
  this._text = _text;
  // Initializers done
}
SourceFile.prototype.is$SourceFile = function(){return this;};
SourceFile.prototype.get$text = function() {
  return this._text;
}
SourceFile.prototype.get$lineStarts = function() {
  if ($notnull_bool(this._lineStarts == null)) {
    var starts = [0];
    var index = 0;
    while ($notnull_bool(index < this.get$text().length)) {
      index = this.get$text().indexOf('\n', index) + 1;
      if ($notnull_bool(index <= 0)) break;
      starts.add(index);
    }
    starts.add(this.get$text().length + 1);
    this._lineStarts = (starts && starts.is$List$int());
  }
  return this._lineStarts;
}
SourceFile.prototype.getLine = function(position) {
  var starts = this.get$lineStarts();
  for (var i = 0;
   $notnull_bool(i < starts.length); i++) {
    if ($notnull_bool(starts.$index(i) > position)) return i - 1;
  }
  world.internalError('bad position');
}
SourceFile.prototype.getColumn = function(line, position) {
  return position - $assert_num(this.get$lineStarts().$index(line));
}
SourceFile.prototype.getLocationMessage = function(message, start, end, includeText) {
  var line = this.getLine(start);
  var column = this.getColumn($assert_num(line), start);
  var buf = new StringBufferImpl(('' + this.filename + ':' + (line + 1) + ':' + (column + 1) + ': ' + message + ''));
  if ($notnull_bool(includeText)) {
    buf.add('\n');
    var textLine;
    if ($notnull_bool((line + 2) < this._lineStarts.length)) {
      textLine = this.get$text().substring(this._lineStarts.$index(line), this._lineStarts.$index(line + 1));
    }
    else {
      textLine = this.get$text().substring(this._lineStarts.$index(line)) + '\n';
    }
    buf.add(textLine);
    var i = 0;
    for (; $notnull_bool(i < $assert_num(column)); i++) {
      buf.add(' ');
    }
    var toColumn = Math.min($assert_num(column + (end - start)), textLine.length);
    for (; $notnull_bool(i < toColumn); i++) {
      buf.add('^');
    }
  }
  return buf.toString();
}
SourceFile.prototype.compareTo = function(other) {
  if ($notnull_bool(this.orderInLibrary != null && other.orderInLibrary != null)) {
    return this.orderInLibrary - other.orderInLibrary;
  }
  else {
    return this.filename.compareTo(other.filename);
  }
}
// ********** Code for SourceSpan **************
function SourceSpan(file, start, end) {
  this.file = file;
  this.start = start;
  this.end = end;
  // Initializers done
}
SourceSpan.prototype.is$SourceSpan = function(){return this;};
SourceSpan.prototype.get$text = function() {
  return this.file.get$text().substring(this.start, this.end);
}
SourceSpan.prototype.toMessageString = function(message) {
  return this.file.getLocationMessage(message, this.start, this.end, true);
}
SourceSpan.prototype.get$locationText = function() {
  var line = this.file.getLine(this.start);
  var column = this.file.getColumn($assert_num(line), this.start);
  return ('' + this.file.filename + ':' + (line + 1) + ':' + (column + 1) + '');
}
SourceSpan.prototype.compareTo = function(other) {
  if ($notnull_bool($eq(this.file, other.file))) {
    var d = this.start - other.start;
    return $notnull_bool(d == 0) ? (this.end - other.end) : d;
  }
  return this.file.compareTo(other.file);
}
// ********** Code for InterpStack **************
function InterpStack(previous, quote, isMultiline) {
  this.previous = previous;
  this.quote = quote;
  this.isMultiline = isMultiline;
  this.depth = -1;
  // Initializers done
}
InterpStack.prototype.pop = function() {
  return this.previous;
}
InterpStack.push = function(stack, quote0, isMultiline0) {
  var newStack = new InterpStack(stack, quote0, isMultiline0);
  if ($notnull_bool(stack != null)) newStack.previous = stack;
  return newStack;
}
// ********** Code for TokenizerBase **************
function TokenizerBase(_source, _skipWhitespace, _index) {
  this._source = _source;
  this._skipWhitespace = _skipWhitespace;
  this._lang_index = _index;
  // Initializers done
  this._text = this._source.get$text();
}
$inherits(TokenizerBase, TokenizerHelpers);
TokenizerBase.prototype._nextChar = function() {
  if ($notnull_bool(this._lang_index < this._text.length)) {
    return this._text.charCodeAt(this._lang_index++);
  }
  else {
    return 0;
  }
}
TokenizerBase.prototype._peekChar = function() {
  if ($notnull_bool(this._lang_index < this._text.length)) {
    return this._text.charCodeAt(this._lang_index);
  }
  else {
    return 0;
  }
}
TokenizerBase.prototype._maybeEatChar = function(ch) {
  if ($notnull_bool(this._lang_index < this._text.length)) {
    if ($notnull_bool(this._text.charCodeAt(this._lang_index) == ch)) {
      this._lang_index++;
      return true;
    }
    else {
      return false;
    }
  }
  else {
    return false;
  }
}
TokenizerBase.prototype._finishToken = function(kind) {
  return new lang_Token(kind, this._source, this._startIndex, this._lang_index);
}
TokenizerBase.prototype._errorToken = function() {
  return this._finishToken(65/*TokenKind.ERROR*/);
}
TokenizerBase.prototype.finishWhitespace = function() {
  while ($notnull_bool(this._lang_index < this._text.length)) {
    if ($notnull_bool(!TokenizerHelpers.isWhitespace(this._text.charCodeAt(this._lang_index++)))) {
      this._lang_index--;
      return this.next();
    }
  }
  return this._finishToken(1/*TokenKind.END_OF_FILE*/);
}
TokenizerBase.prototype.finishHashBang = function() {
  while ($notnull_bool(true)) {
    var ch = this._nextChar();
    if ($notnull_bool(ch == 0 || ch == 10 || ch == 13)) {
      return this._finishToken(13/*TokenKind.HASHBANG*/);
    }
  }
}
TokenizerBase.prototype.finishSingleLineComment = function() {
  while ($notnull_bool(true)) {
    var ch = this._nextChar();
    if ($notnull_bool(ch == 0 || ch == 10 || ch == 13)) {
      if ($notnull_bool(this._skipWhitespace)) {
        return this.next();
      }
      else {
        return this._finishToken(64/*TokenKind.COMMENT*/);
      }
    }
  }
}
TokenizerBase.prototype.finishMultiLineComment = function() {
  while ($notnull_bool(true)) {
    var ch = this._nextChar();
    if ($notnull_bool(ch == 0)) {
      return this._finishToken(67/*TokenKind.INCOMPLETE_COMMENT*/);
    }
    else if ($notnull_bool(ch == 42)) {
      if ($notnull_bool(this._maybeEatChar(47))) {
        if ($notnull_bool(this._skipWhitespace)) {
          return this.next();
        }
        else {
          return this._finishToken(64/*TokenKind.COMMENT*/);
        }
      }
    }
  }
  return this._errorToken();
}
TokenizerBase.prototype.eatDigits = function() {
  while ($notnull_bool(this._lang_index < this._text.length)) {
    if ($notnull_bool(TokenizerHelpers.isDigit(this._text.charCodeAt(this._lang_index)))) {
      this._lang_index++;
    }
    else {
      return;
    }
  }
}
TokenizerBase.prototype.eatHexDigits = function() {
  while ($notnull_bool(this._lang_index < this._text.length)) {
    if ($notnull_bool(TokenizerHelpers.isHexDigit(this._text.charCodeAt(this._lang_index)))) {
      this._lang_index++;
    }
    else {
      return;
    }
  }
}
TokenizerBase.prototype.maybeEatHexDigit = function() {
  if ($notnull_bool(this._lang_index < this._text.length && TokenizerHelpers.isHexDigit(this._text.charCodeAt(this._lang_index)))) {
    this._lang_index++;
    return true;
  }
  return false;
}
TokenizerBase.prototype.finishHex = function() {
  this.eatHexDigits();
  return this._finishToken(61/*TokenKind.HEX_INTEGER*/);
}
TokenizerBase.prototype.finishNumber = function() {
  this.eatDigits();
  if ($notnull_bool(this._peekChar() == 46)) {
    this._nextChar();
    if ($notnull_bool(TokenizerHelpers.isDigit(this._peekChar()))) {
      this.eatDigits();
      return this.finishNumberExtra(62/*TokenKind.DOUBLE*/);
    }
    else {
      this._lang_index--;
    }
  }
  return this.finishNumberExtra(60/*TokenKind.INTEGER*/);
}
TokenizerBase.prototype.finishNumberExtra = function(kind) {
  if ($notnull_bool(this._maybeEatChar(101) || this._maybeEatChar(69))) {
    kind = 62/*TokenKind.DOUBLE*/;
    this._maybeEatChar(45);
    this._maybeEatChar(43);
    this.eatDigits();
  }
  if ($notnull_bool(this._peekChar() != 0 && TokenizerHelpers.isIdentifierStart(this._peekChar()))) {
    this._nextChar();
    return this._errorToken();
  }
  return this._finishToken(kind);
}
TokenizerBase.prototype.finishMultilineString = function(quote) {
  while ($notnull_bool(true)) {
    var ch = this._nextChar();
    if ($notnull_bool(ch == 0)) {
      var kind = $notnull_bool(quote == 34) ? 68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/ : 69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/;
      return this._finishToken(kind);
    }
    else if ($notnull_bool(ch == quote)) {
      if ($notnull_bool(this._maybeEatChar(quote))) {
        if ($notnull_bool(this._maybeEatChar(quote))) {
          return this._finishToken(58/*TokenKind.STRING*/);
        }
      }
    }
    else if ($notnull_bool(ch == 36)) {
      this._interpStack = InterpStack.push(this._interpStack, quote, true);
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
    else if ($notnull_bool(ch == 92)) {
      if ($notnull_bool(!this.eatEscapeSequence())) {
        return this._errorToken();
      }
    }
  }
}
TokenizerBase.prototype._finishOpenBrace = function() {
  var $0;
  if ($notnull_bool(this._interpStack != null)) {
    if ($notnull_bool(this._interpStack.depth == -1)) {
      this._interpStack.depth = 1;
    }
    else {
      $assert(this._interpStack.depth >= 0, "_interpStack.depth >= 0", "tokenizer.dart", 257, 16);
      ($0 = this._interpStack).depth = $0.depth + 1;
    }
  }
  return this._finishToken(6/*TokenKind.LBRACE*/);
}
TokenizerBase.prototype._finishCloseBrace = function() {
  var $0;
  if ($notnull_bool(this._interpStack != null)) {
    ($0 = this._interpStack).depth = $0.depth - 1;
    $assert(this._interpStack.depth >= 0, "_interpStack.depth >= 0", "tokenizer.dart", 267, 14);
  }
  return this._finishToken(7/*TokenKind.RBRACE*/);
}
TokenizerBase.prototype.finishString = function(quote) {
  if ($notnull_bool(this._maybeEatChar(quote))) {
    if ($notnull_bool(this._maybeEatChar(quote))) {
      return this.finishMultilineString(quote);
    }
    else {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
  }
  return this.finishStringBody(quote);
}
TokenizerBase.prototype.finishRawString = function(quote) {
  if ($notnull_bool(this._maybeEatChar(quote))) {
    if ($notnull_bool(this._maybeEatChar(quote))) {
      return this.finishMultilineRawString(quote);
    }
    else {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
  }
  while ($notnull_bool(true)) {
    var ch = this._nextChar();
    if ($notnull_bool(ch == quote)) {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
    else if ($notnull_bool(ch == 0)) {
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
  }
}
TokenizerBase.prototype.finishMultilineRawString = function(quote) {
  while ($notnull_bool(true)) {
    var ch = this._nextChar();
    if ($notnull_bool(ch == 0)) {
      var kind = $notnull_bool(quote == 34) ? 68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/ : 69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/;
      return this._finishToken(kind);
    }
    else if ($notnull_bool(ch == quote && this._maybeEatChar(quote) && this._maybeEatChar(quote))) {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
  }
}
TokenizerBase.prototype.finishStringBody = function(quote) {
  while ($notnull_bool(true)) {
    var ch = this._nextChar();
    if ($notnull_bool(ch == quote)) {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
    else if ($notnull_bool(ch == 36)) {
      this._interpStack = InterpStack.push(this._interpStack, quote, false);
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
    else if ($notnull_bool(ch == 0)) {
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
    else if ($notnull_bool(ch == 92)) {
      if ($notnull_bool(!this.eatEscapeSequence())) {
        return this._errorToken();
      }
    }
  }
}
TokenizerBase.prototype.eatEscapeSequence = function() {
  var hex;
  switch (this._nextChar()) {
    case 120:

      return this.maybeEatHexDigit() && this.maybeEatHexDigit();

    case 117:

      if ($notnull_bool(this._maybeEatChar(123))) {
        var start = this._lang_index;
        this.eatHexDigits();
        var chars = this._lang_index - start;
        if ($notnull_bool(chars > 0 && chars <= 6 && this._maybeEatChar(125))) {
          hex = this._text.substring(start, start + chars);
          break;
        }
        else {
          return false;
        }
      }
      else {
        if ($notnull_bool(this.maybeEatHexDigit() && this.maybeEatHexDigit() && this.maybeEatHexDigit() && this.maybeEatHexDigit())) {
          hex = this._text.substring(this._lang_index - 4, this._lang_index);
          break;
        }
        else {
          return false;
        }
      }

    default:

      return true;

  }
  var n = lang_Parser.parseHex(hex);
  return n < 0xD800 || n > 0xDFFF && n <= 0x10FFFF;
}
TokenizerBase.prototype.finishDot = function() {
  if ($notnull_bool(TokenizerHelpers.isDigit(this._peekChar()))) {
    this.eatDigits();
    return this.finishNumberExtra(62/*TokenKind.DOUBLE*/);
  }
  else {
    return this._finishToken(14/*TokenKind.DOT*/);
  }
}
TokenizerBase.prototype.finishIdentifier = function() {
  while ($notnull_bool(this._lang_index < this._text.length)) {
    if ($notnull_bool(!TokenizerHelpers.isIdentifierPart(this._text.charCodeAt(this._lang_index++)))) {
      this._lang_index--;
      break;
    }
  }
  var kind = this.getIdentifierKind();
  if ($notnull_bool(this._interpStack != null && this._interpStack.depth == -1)) {
    this._interpStack.depth = 0;
  }
  if ($notnull_bool(kind == 70/*TokenKind.IDENTIFIER*/)) {
    return this._finishToken(70/*TokenKind.IDENTIFIER*/);
  }
  else {
    return this._finishToken(kind);
  }
}
// ********** Code for Tokenizer **************
function Tokenizer(source, skipWhitespace, index) {
  TokenizerBase.call(this, source, skipWhitespace, index);
  // Initializers done
}
$inherits(Tokenizer, TokenizerBase);
Tokenizer.prototype.next = function() {
  this._startIndex = this._lang_index;
  if ($notnull_bool(this._interpStack != null && this._interpStack.depth == 0)) {
    var istack = this._interpStack;
    this._interpStack = this._interpStack.pop();
    if ($notnull_bool(istack.isMultiline)) {
      return this.finishMultilineString(istack.quote);
    }
    else {
      return this.finishStringBody(istack.quote);
    }
  }
  var ch;
  ch = this._nextChar();
  switch (ch) {
    case 0:

      return this._finishToken(1/*TokenKind.END_OF_FILE*/);

    case 32:
    case 9:
    case 10:
    case 13:

      return this.finishWhitespace();

    case 33:

      if ($notnull_bool(this._maybeEatChar(61))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(51/*TokenKind.NE_STRICT*/);
        }
        else {
          return this._finishToken(49/*TokenKind.NE*/);
        }
      }
      else {
        return this._finishToken(19/*TokenKind.NOT*/);
      }

    case 34:

      return this.finishString(34);

    case 35:

      if ($notnull_bool(this._maybeEatChar(33))) {
        return this.finishHashBang();
      }
      else {
        return this._finishToken(12/*TokenKind.HASH*/);
      }

    case 36:

      if ($notnull_bool(this._maybeEatChar(34))) {
        return this.finishString(34);
      }
      else if ($notnull_bool(this._maybeEatChar(39))) {
        return this.finishString(39);
      }
      else {
        return this.finishIdentifier();
      }

    case 37:

      if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(32/*TokenKind.ASSIGN_MOD*/);
      }
      else {
        return this._finishToken(47/*TokenKind.MOD*/);
      }

    case 38:

      if ($notnull_bool(this._maybeEatChar(38))) {
        return this._finishToken(35/*TokenKind.AND*/);
      }
      else if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(23/*TokenKind.ASSIGN_AND*/);
      }
      else {
        return this._finishToken(38/*TokenKind.BIT_AND*/);
      }

    case 39:

      return this.finishString(39);

    case 40:

      return this._finishToken(2/*TokenKind.LPAREN*/);

    case 41:

      return this._finishToken(3/*TokenKind.RPAREN*/);

    case 42:

      if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(29/*TokenKind.ASSIGN_MUL*/);
      }
      else {
        return this._finishToken(44/*TokenKind.MUL*/);
      }

    case 43:

      if ($notnull_bool(this._maybeEatChar(43))) {
        return this._finishToken(16/*TokenKind.INCR*/);
      }
      else if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(27/*TokenKind.ASSIGN_ADD*/);
      }
      else {
        return this._finishToken(42/*TokenKind.ADD*/);
      }

    case 44:

      return this._finishToken(11/*TokenKind.COMMA*/);

    case 45:

      if ($notnull_bool(this._maybeEatChar(45))) {
        return this._finishToken(17/*TokenKind.DECR*/);
      }
      else if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(28/*TokenKind.ASSIGN_SUB*/);
      }
      else {
        return this._finishToken(43/*TokenKind.SUB*/);
      }

    case 46:

      if ($notnull_bool(this._maybeEatChar(46))) {
        if ($notnull_bool(this._maybeEatChar(46))) {
          return this._finishToken(15/*TokenKind.ELLIPSIS*/);
        }
        else {
          return this._errorToken();
        }
      }
      else {
        return this.finishDot();
      }

    case 47:

      if ($notnull_bool(this._maybeEatChar(42))) {
        return this.finishMultiLineComment();
      }
      else if ($notnull_bool(this._maybeEatChar(47))) {
        return this.finishSingleLineComment();
      }
      else if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(30/*TokenKind.ASSIGN_DIV*/);
      }
      else {
        return this._finishToken(45/*TokenKind.DIV*/);
      }

    case 48:

      if ($notnull_bool(this._maybeEatChar(88))) {
        return this.finishHex();
      }
      else if ($notnull_bool(this._maybeEatChar(120))) {
        return this.finishHex();
      }
      else {
        return this.finishNumber();
      }

    case 58:

      return this._finishToken(8/*TokenKind.COLON*/);

    case 59:

      return this._finishToken(10/*TokenKind.SEMICOLON*/);

    case 60:

      if ($notnull_bool(this._maybeEatChar(60))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(24/*TokenKind.ASSIGN_SHL*/);
        }
        else {
          return this._finishToken(39/*TokenKind.SHL*/);
        }
      }
      else if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(54/*TokenKind.LTE*/);
      }
      else {
        return this._finishToken(52/*TokenKind.LT*/);
      }

    case 61:

      if ($notnull_bool(this._maybeEatChar(61))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(50/*TokenKind.EQ_STRICT*/);
        }
        else {
          return this._finishToken(48/*TokenKind.EQ*/);
        }
      }
      else if ($notnull_bool(this._maybeEatChar(62))) {
        return this._finishToken(9/*TokenKind.ARROW*/);
      }
      else {
        return this._finishToken(20/*TokenKind.ASSIGN*/);
      }

    case 62:

      if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(55/*TokenKind.GTE*/);
      }
      else if ($notnull_bool(this._maybeEatChar(62))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(25/*TokenKind.ASSIGN_SAR*/);
        }
        else if ($notnull_bool(this._maybeEatChar(62))) {
          if ($notnull_bool(this._maybeEatChar(61))) {
            return this._finishToken(26/*TokenKind.ASSIGN_SHR*/);
          }
          else {
            return this._finishToken(41/*TokenKind.SHR*/);
          }
        }
        else {
          return this._finishToken(40/*TokenKind.SAR*/);
        }
      }
      else {
        return this._finishToken(53/*TokenKind.GT*/);
      }

    case 63:

      return this._finishToken(33/*TokenKind.CONDITIONAL*/);

    case 64:

      if ($notnull_bool(this._maybeEatChar(34))) {
        return this.finishRawString(34);
      }
      else if ($notnull_bool(this._maybeEatChar(39))) {
        return this.finishRawString(39);
      }
      else {
        return this._errorToken();
      }

    case 91:

      if ($notnull_bool(this._maybeEatChar(93))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(57/*TokenKind.SETINDEX*/);
        }
        else {
          return this._finishToken(56/*TokenKind.INDEX*/);
        }
      }
      else {
        return this._finishToken(4/*TokenKind.LBRACK*/);
      }

    case 93:

      return this._finishToken(5/*TokenKind.RBRACK*/);

    case 94:

      if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(22/*TokenKind.ASSIGN_XOR*/);
      }
      else {
        return this._finishToken(37/*TokenKind.BIT_XOR*/);
      }

    case 123:

      return this._finishOpenBrace();

    case 124:

      if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(21/*TokenKind.ASSIGN_OR*/);
      }
      else if ($notnull_bool(this._maybeEatChar(124))) {
        return this._finishToken(34/*TokenKind.OR*/);
      }
      else {
        return this._finishToken(36/*TokenKind.BIT_OR*/);
      }

    case 125:

      return this._finishCloseBrace();

    case 126:

      if ($notnull_bool(this._maybeEatChar(47))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(31/*TokenKind.ASSIGN_TRUNCDIV*/);
        }
        else {
          return this._finishToken(46/*TokenKind.TRUNCDIV*/);
        }
      }
      else {
        return this._finishToken(18/*TokenKind.BIT_NOT*/);
      }

    default:

      if ($notnull_bool(TokenizerHelpers.isIdentifierStart(ch))) {
        return this.finishIdentifier();
      }
      else if ($notnull_bool(TokenizerHelpers.isDigit(ch))) {
        return this.finishNumber();
      }
      else {
        return this._errorToken();
      }

  }
}
Tokenizer.prototype.getIdentifierKind = function() {
  var i0 = this._startIndex;
  switch (this._lang_index - i0) {
    case 2:

      if ($notnull_bool(this._text.charCodeAt(i0) == 100)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 111)) return 94/*TokenKind.DO*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 105)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 102)) {
          return 100/*TokenKind.IF*/;
        }
        else if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 110)) {
          return 101/*TokenKind.IN*/;
        }
        else if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 115)) {
          return 102/*TokenKind.IS*/;
        }
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 3:

      if ($notnull_bool(this._text.charCodeAt(i0) == 102)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 111 && this._text.charCodeAt(i0 + 2) == 114)) return 99/*TokenKind.FOR*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 103)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 116)) return 76/*TokenKind.GET*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 110)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 119)) return 103/*TokenKind.NEW*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 115)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 116)) return 84/*TokenKind.SET*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 116)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 114 && this._text.charCodeAt(i0 + 2) == 121)) return 111/*TokenKind.TRY*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 118)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 97 && this._text.charCodeAt(i0 + 2) == 114)) return 112/*TokenKind.VAR*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 4:

      if ($notnull_bool(this._text.charCodeAt(i0) == 99)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 97 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 101)) return 89/*TokenKind.CASE*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 101)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 108 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 101)) return 95/*TokenKind.ELSE*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 110)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 117 && this._text.charCodeAt(i0 + 2) == 108 && this._text.charCodeAt(i0 + 3) == 108)) return 104/*TokenKind.NULL*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 116)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 104)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 115)) return 108/*TokenKind.THIS*/;
        }
        else if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 114)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 117 && this._text.charCodeAt(i0 + 3) == 101)) return 110/*TokenKind.TRUE*/;
        }
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 118)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 111 && this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 100)) return 113/*TokenKind.VOID*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 5:

      if ($notnull_bool(this._text.charCodeAt(i0) == 98)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 114 && this._text.charCodeAt(i0 + 2) == 101 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 107)) return 88/*TokenKind.BREAK*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 99)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 97)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 99 && this._text.charCodeAt(i0 + 4) == 104)) return 90/*TokenKind.CATCH*/;
        }
        else if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 108)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 97 && this._text.charCodeAt(i0 + 3) == 115 && this._text.charCodeAt(i0 + 4) == 115)) return 73/*TokenKind.CLASS*/;
        }
        else if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 111)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 115 && this._text.charCodeAt(i0 + 4) == 116)) return 91/*TokenKind.CONST*/;
        }
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 102)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 97)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 108 && this._text.charCodeAt(i0 + 3) == 115 && this._text.charCodeAt(i0 + 4) == 101)) return 96/*TokenKind.FALSE*/;
        }
        else if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 105)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 108)) return 97/*TokenKind.FINAL*/;
        }
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 115)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 117 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 114)) return 106/*TokenKind.SUPER*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 116)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 104 && this._text.charCodeAt(i0 + 2) == 114 && this._text.charCodeAt(i0 + 3) == 111 && this._text.charCodeAt(i0 + 4) == 119)) return 109/*TokenKind.THROW*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 119)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 104 && this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 108 && this._text.charCodeAt(i0 + 4) == 101)) return 114/*TokenKind.WHILE*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 6:

      if ($notnull_bool(this._text.charCodeAt(i0) == 97)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 115 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 116)) return 72/*TokenKind.ASSERT*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 105)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 109 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 111 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 116)) return 78/*TokenKind.IMPORT*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 110)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 97)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 105 && this._text.charCodeAt(i0 + 4) == 118 && this._text.charCodeAt(i0 + 5) == 101)) return 81/*TokenKind.NATIVE*/;
        }
        else if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 101)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 103 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 116 && this._text.charCodeAt(i0 + 5) == 101)) return 82/*TokenKind.NEGATE*/;
        }
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 114)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 117 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 110)) return 105/*TokenKind.RETURN*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 115)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 111)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 117 && this._text.charCodeAt(i0 + 3) == 114 && this._text.charCodeAt(i0 + 4) == 99 && this._text.charCodeAt(i0 + 5) == 101)) return 85/*TokenKind.SOURCE*/;
        }
        else if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 116)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 97 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 105 && this._text.charCodeAt(i0 + 5) == 99)) return 86/*TokenKind.STATIC*/;
        }
        else if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 119)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 99 && this._text.charCodeAt(i0 + 5) == 104)) return 107/*TokenKind.SWITCH*/;
        }
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 7:

      if ($notnull_bool(this._text.charCodeAt(i0) == 100)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 102 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 117 && this._text.charCodeAt(i0 + 5) == 108 && this._text.charCodeAt(i0 + 6) == 116)) return 93/*TokenKind.DEFAULT*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 101)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 120 && this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 110 && this._text.charCodeAt(i0 + 5) == 100 && this._text.charCodeAt(i0 + 6) == 115)) return 74/*TokenKind.EXTENDS*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 102)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 97)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 99 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 111 && this._text.charCodeAt(i0 + 5) == 114 && this._text.charCodeAt(i0 + 6) == 121)) return 75/*TokenKind.FACTORY*/;
        }
        else if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 105)) {
          if ($notnull_bool(this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 108 && this._text.charCodeAt(i0 + 5) == 108 && this._text.charCodeAt(i0 + 6) == 121)) return 98/*TokenKind.FINALLY*/;
        }
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 108)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 105 && this._text.charCodeAt(i0 + 2) == 98 && this._text.charCodeAt(i0 + 3) == 114 && this._text.charCodeAt(i0 + 4) == 97 && this._text.charCodeAt(i0 + 5) == 114 && this._text.charCodeAt(i0 + 6) == 121)) return 80/*TokenKind.LIBRARY*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 116)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 121 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 100 && this._text.charCodeAt(i0 + 5) == 101 && this._text.charCodeAt(i0 + 6) == 102)) return 87/*TokenKind.TYPEDEF*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 8:

      if ($notnull_bool(this._text.charCodeAt(i0) == 97)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 98 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 97 && this._text.charCodeAt(i0 + 6) == 99 && this._text.charCodeAt(i0 + 7) == 116)) return 71/*TokenKind.ABSTRACT*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 99)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 111 && this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 105 && this._text.charCodeAt(i0 + 5) == 110 && this._text.charCodeAt(i0 + 6) == 117 && this._text.charCodeAt(i0 + 7) == 101)) return 92/*TokenKind.CONTINUE*/;
      }
      else if ($notnull_bool(this._text.charCodeAt(i0) == 111)) {
        if ($notnull_bool(this._text.charCodeAt(i0 + 1) == 112 && this._text.charCodeAt(i0 + 2) == 101 && this._text.charCodeAt(i0 + 3) == 114 && this._text.charCodeAt(i0 + 4) == 97 && this._text.charCodeAt(i0 + 5) == 116 && this._text.charCodeAt(i0 + 6) == 111 && this._text.charCodeAt(i0 + 7) == 114)) return 83/*TokenKind.OPERATOR*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 9:

      if ($notnull_bool(this._text.charCodeAt(i0) == 105 && this._text.charCodeAt(i0 + 1) == 110 && this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 102 && this._text.charCodeAt(i0 + 6) == 97 && this._text.charCodeAt(i0 + 7) == 99 && this._text.charCodeAt(i0 + 8) == 101)) return 79/*TokenKind.INTERFACE*/;
      return 70/*TokenKind.IDENTIFIER*/;

    case 10:

      if ($notnull_bool(this._text.charCodeAt(i0) == 105 && this._text.charCodeAt(i0 + 1) == 109 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 108 && this._text.charCodeAt(i0 + 4) == 101 && this._text.charCodeAt(i0 + 5) == 109 && this._text.charCodeAt(i0 + 6) == 101 && this._text.charCodeAt(i0 + 7) == 110 && this._text.charCodeAt(i0 + 8) == 116 && this._text.charCodeAt(i0 + 9) == 115)) return 77/*TokenKind.IMPLEMENTS*/;
      return 70/*TokenKind.IDENTIFIER*/;

    default:

      return 70/*TokenKind.IDENTIFIER*/;

  }
}
// ********** Code for TokenizerHelpers **************
function TokenizerHelpers() {}
TokenizerHelpers.isIdentifierStart = function(c) {
  return ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || c == 95);
}
TokenizerHelpers.isDigit = function(c) {
  return (c >= 48 && c <= 57);
}
TokenizerHelpers.isHexDigit = function(c) {
  return (TokenizerHelpers.isDigit(c) || (c >= 97 && c <= 102) || (c >= 65 && c <= 70));
}
TokenizerHelpers.isWhitespace = function(c) {
  return (c == 32 || c == 9 || c == 10 || c == 13);
}
TokenizerHelpers.isIdentifierPart = function(c) {
  return (TokenizerHelpers.isIdentifierStart(c) || TokenizerHelpers.isDigit(c));
}
// ********** Code for TokenKind **************
function TokenKind() {}
TokenKind.kindToString = function(kind) {
  switch (kind) {
    case 1/*TokenKind.END_OF_FILE*/:

      return "end of file";

    case 2/*TokenKind.LPAREN*/:

      return "(";

    case 3/*TokenKind.RPAREN*/:

      return ")";

    case 4/*TokenKind.LBRACK*/:

      return "[";

    case 5/*TokenKind.RBRACK*/:

      return "]";

    case 6/*TokenKind.LBRACE*/:

      return "{";

    case 7/*TokenKind.RBRACE*/:

      return "}";

    case 8/*TokenKind.COLON*/:

      return ":";

    case 9/*TokenKind.ARROW*/:

      return "=>";

    case 10/*TokenKind.SEMICOLON*/:

      return ";";

    case 11/*TokenKind.COMMA*/:

      return ",";

    case 12/*TokenKind.HASH*/:

      return "#";

    case 13/*TokenKind.HASHBANG*/:

      return "#!";

    case 14/*TokenKind.DOT*/:

      return ".";

    case 15/*TokenKind.ELLIPSIS*/:

      return "...";

    case 16/*TokenKind.INCR*/:

      return "++";

    case 17/*TokenKind.DECR*/:

      return "--";

    case 18/*TokenKind.BIT_NOT*/:

      return "~";

    case 19/*TokenKind.NOT*/:

      return "!";

    case 20/*TokenKind.ASSIGN*/:

      return "=";

    case 21/*TokenKind.ASSIGN_OR*/:

      return "|=";

    case 22/*TokenKind.ASSIGN_XOR*/:

      return "^=";

    case 23/*TokenKind.ASSIGN_AND*/:

      return "&=";

    case 24/*TokenKind.ASSIGN_SHL*/:

      return "<<=";

    case 25/*TokenKind.ASSIGN_SAR*/:

      return ">>=";

    case 26/*TokenKind.ASSIGN_SHR*/:

      return ">>>=";

    case 27/*TokenKind.ASSIGN_ADD*/:

      return "+=";

    case 28/*TokenKind.ASSIGN_SUB*/:

      return "-=";

    case 29/*TokenKind.ASSIGN_MUL*/:

      return "*=";

    case 30/*TokenKind.ASSIGN_DIV*/:

      return "/=";

    case 31/*TokenKind.ASSIGN_TRUNCDIV*/:

      return "~/=";

    case 32/*TokenKind.ASSIGN_MOD*/:

      return "%=";

    case 33/*TokenKind.CONDITIONAL*/:

      return "?";

    case 34/*TokenKind.OR*/:

      return "||";

    case 35/*TokenKind.AND*/:

      return "&&";

    case 36/*TokenKind.BIT_OR*/:

      return "|";

    case 37/*TokenKind.BIT_XOR*/:

      return "^";

    case 38/*TokenKind.BIT_AND*/:

      return "&";

    case 39/*TokenKind.SHL*/:

      return "<<";

    case 40/*TokenKind.SAR*/:

      return ">>";

    case 41/*TokenKind.SHR*/:

      return ">>>";

    case 42/*TokenKind.ADD*/:

      return "+";

    case 43/*TokenKind.SUB*/:

      return "-";

    case 44/*TokenKind.MUL*/:

      return "*";

    case 45/*TokenKind.DIV*/:

      return "/";

    case 46/*TokenKind.TRUNCDIV*/:

      return "~/";

    case 47/*TokenKind.MOD*/:

      return "%";

    case 48/*TokenKind.EQ*/:

      return "==";

    case 49/*TokenKind.NE*/:

      return "!=";

    case 50/*TokenKind.EQ_STRICT*/:

      return "===";

    case 51/*TokenKind.NE_STRICT*/:

      return "!==";

    case 52/*TokenKind.LT*/:

      return "<";

    case 53/*TokenKind.GT*/:

      return ">";

    case 54/*TokenKind.LTE*/:

      return "<=";

    case 55/*TokenKind.GTE*/:

      return ">=";

    case 56/*TokenKind.INDEX*/:

      return "[]";

    case 57/*TokenKind.SETINDEX*/:

      return "[]=";

    case 58/*TokenKind.STRING*/:

      return "string";

    case 59/*TokenKind.STRING_PART*/:

      return "string part";

    case 60/*TokenKind.INTEGER*/:

      return "integer";

    case 61/*TokenKind.HEX_INTEGER*/:

      return "hex integer";

    case 62/*TokenKind.DOUBLE*/:

      return "double";

    case 63/*TokenKind.WHITESPACE*/:

      return "whitespace";

    case 64/*TokenKind.COMMENT*/:

      return "comment";

    case 65/*TokenKind.ERROR*/:

      return "error";

    case 66/*TokenKind.INCOMPLETE_STRING*/:

      return "incomplete string";

    case 67/*TokenKind.INCOMPLETE_COMMENT*/:

      return "incomplete comment";

    case 68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/:

      return "incomplete multiline string dq";

    case 69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/:

      return "incomplete multiline string sq";

    case 70/*TokenKind.IDENTIFIER*/:

      return "identifier";

    case 71/*TokenKind.ABSTRACT*/:

      return "pseudo-keyword 'abstract'";

    case 72/*TokenKind.ASSERT*/:

      return "pseudo-keyword 'assert'";

    case 73/*TokenKind.CLASS*/:

      return "pseudo-keyword 'class'";

    case 74/*TokenKind.EXTENDS*/:

      return "pseudo-keyword 'extends'";

    case 75/*TokenKind.FACTORY*/:

      return "pseudo-keyword 'factory'";

    case 76/*TokenKind.GET*/:

      return "pseudo-keyword 'get'";

    case 77/*TokenKind.IMPLEMENTS*/:

      return "pseudo-keyword 'implements'";

    case 78/*TokenKind.IMPORT*/:

      return "pseudo-keyword 'import'";

    case 79/*TokenKind.INTERFACE*/:

      return "pseudo-keyword 'interface'";

    case 80/*TokenKind.LIBRARY*/:

      return "pseudo-keyword 'library'";

    case 81/*TokenKind.NATIVE*/:

      return "pseudo-keyword 'native'";

    case 82/*TokenKind.NEGATE*/:

      return "pseudo-keyword 'negate'";

    case 83/*TokenKind.OPERATOR*/:

      return "pseudo-keyword 'operator'";

    case 84/*TokenKind.SET*/:

      return "pseudo-keyword 'set'";

    case 85/*TokenKind.SOURCE*/:

      return "pseudo-keyword 'source'";

    case 86/*TokenKind.STATIC*/:

      return "pseudo-keyword 'static'";

    case 87/*TokenKind.TYPEDEF*/:

      return "pseudo-keyword 'typedef'";

    case 88/*TokenKind.BREAK*/:

      return "keyword 'break'";

    case 89/*TokenKind.CASE*/:

      return "keyword 'case'";

    case 90/*TokenKind.CATCH*/:

      return "keyword 'catch'";

    case 91/*TokenKind.CONST*/:

      return "keyword 'const'";

    case 92/*TokenKind.CONTINUE*/:

      return "keyword 'continue'";

    case 93/*TokenKind.DEFAULT*/:

      return "keyword 'default'";

    case 94/*TokenKind.DO*/:

      return "keyword 'do'";

    case 95/*TokenKind.ELSE*/:

      return "keyword 'else'";

    case 96/*TokenKind.FALSE*/:

      return "keyword 'false'";

    case 97/*TokenKind.FINAL*/:

      return "keyword 'final'";

    case 98/*TokenKind.FINALLY*/:

      return "keyword 'finally'";

    case 99/*TokenKind.FOR*/:

      return "keyword 'for'";

    case 100/*TokenKind.IF*/:

      return "keyword 'if'";

    case 101/*TokenKind.IN*/:

      return "keyword 'in'";

    case 102/*TokenKind.IS*/:

      return "keyword 'is'";

    case 103/*TokenKind.NEW*/:

      return "keyword 'new'";

    case 104/*TokenKind.NULL*/:

      return "keyword 'null'";

    case 105/*TokenKind.RETURN*/:

      return "keyword 'return'";

    case 106/*TokenKind.SUPER*/:

      return "keyword 'super'";

    case 107/*TokenKind.SWITCH*/:

      return "keyword 'switch'";

    case 108/*TokenKind.THIS*/:

      return "keyword 'this'";

    case 109/*TokenKind.THROW*/:

      return "keyword 'throw'";

    case 110/*TokenKind.TRUE*/:

      return "keyword 'true'";

    case 111/*TokenKind.TRY*/:

      return "keyword 'try'";

    case 112/*TokenKind.VAR*/:

      return "keyword 'var'";

    case 113/*TokenKind.VOID*/:

      return "keyword 'void'";

    case 114/*TokenKind.WHILE*/:

      return "keyword 'while'";

    default:

      return "TokenKind(" + kind.toString() + ")";

  }
}
TokenKind.isIdentifier = function(kind) {
  return kind >= 70/*TokenKind.IDENTIFIER*/ && kind < 88/*TokenKind.BREAK*/;
}
TokenKind.infixPrecedence = function(kind) {
  switch (kind) {
    case 20/*TokenKind.ASSIGN*/:

      return 2;

    case 21/*TokenKind.ASSIGN_OR*/:

      return 2;

    case 22/*TokenKind.ASSIGN_XOR*/:

      return 2;

    case 23/*TokenKind.ASSIGN_AND*/:

      return 2;

    case 24/*TokenKind.ASSIGN_SHL*/:

      return 2;

    case 25/*TokenKind.ASSIGN_SAR*/:

      return 2;

    case 26/*TokenKind.ASSIGN_SHR*/:

      return 2;

    case 27/*TokenKind.ASSIGN_ADD*/:

      return 2;

    case 28/*TokenKind.ASSIGN_SUB*/:

      return 2;

    case 29/*TokenKind.ASSIGN_MUL*/:

      return 2;

    case 30/*TokenKind.ASSIGN_DIV*/:

      return 2;

    case 31/*TokenKind.ASSIGN_TRUNCDIV*/:

      return 2;

    case 32/*TokenKind.ASSIGN_MOD*/:

      return 2;

    case 33/*TokenKind.CONDITIONAL*/:

      return 3;

    case 34/*TokenKind.OR*/:

      return 4;

    case 35/*TokenKind.AND*/:

      return 5;

    case 36/*TokenKind.BIT_OR*/:

      return 6;

    case 37/*TokenKind.BIT_XOR*/:

      return 7;

    case 38/*TokenKind.BIT_AND*/:

      return 8;

    case 39/*TokenKind.SHL*/:

      return 11;

    case 40/*TokenKind.SAR*/:

      return 11;

    case 41/*TokenKind.SHR*/:

      return 11;

    case 42/*TokenKind.ADD*/:

      return 12;

    case 43/*TokenKind.SUB*/:

      return 12;

    case 44/*TokenKind.MUL*/:

      return 13;

    case 45/*TokenKind.DIV*/:

      return 13;

    case 46/*TokenKind.TRUNCDIV*/:

      return 13;

    case 47/*TokenKind.MOD*/:

      return 13;

    case 48/*TokenKind.EQ*/:

      return 9;

    case 49/*TokenKind.NE*/:

      return 9;

    case 50/*TokenKind.EQ_STRICT*/:

      return 9;

    case 51/*TokenKind.NE_STRICT*/:

      return 9;

    case 52/*TokenKind.LT*/:

      return 10;

    case 53/*TokenKind.GT*/:

      return 10;

    case 54/*TokenKind.LTE*/:

      return 10;

    case 55/*TokenKind.GTE*/:

      return 10;

    case 102/*TokenKind.IS*/:

      return 10;

    default:

      return -1;

  }
}
TokenKind.rawOperatorFromMethod = function(name) {
  switch (name) {
    case '\$bit_not':

      return '~';

    case '\$bit_or':

      return '|';

    case '\$bit_xor':

      return '^';

    case '\$bit_and':

      return '&';

    case '\$shl':

      return '<<';

    case '\$sar':

      return '>>';

    case '\$shr':

      return '>>>';

    case '\$add':

      return '+';

    case '\$sub':

      return '-';

    case '\$mul':

      return '*';

    case '\$div':

      return '/';

    case '\$truncdiv':

      return '~/';

    case '\$mod':

      return '%';

    case '\$eq':

      return '==';

    case '\$lt':

      return '<';

    case '\$gt':

      return '>';

    case '\$lte':

      return '<=';

    case '\$gte':

      return '>=';

    case '\$index':

      return '[]';

    case '\$setindex':

      return '[]=';

    case '\$ne':

      return '!=';

  }
}
TokenKind.binaryMethodName = function(kind) {
  switch (kind) {
    case 18/*TokenKind.BIT_NOT*/:

      return '\$bit_not';

    case 36/*TokenKind.BIT_OR*/:

      return '\$bit_or';

    case 37/*TokenKind.BIT_XOR*/:

      return '\$bit_xor';

    case 38/*TokenKind.BIT_AND*/:

      return '\$bit_and';

    case 39/*TokenKind.SHL*/:

      return '\$shl';

    case 40/*TokenKind.SAR*/:

      return '\$sar';

    case 41/*TokenKind.SHR*/:

      return '\$shr';

    case 42/*TokenKind.ADD*/:

      return '\$add';

    case 43/*TokenKind.SUB*/:

      return '\$sub';

    case 44/*TokenKind.MUL*/:

      return '\$mul';

    case 45/*TokenKind.DIV*/:

      return '\$div';

    case 46/*TokenKind.TRUNCDIV*/:

      return '\$truncdiv';

    case 47/*TokenKind.MOD*/:

      return '\$mod';

    case 48/*TokenKind.EQ*/:

      return '\$eq';

    case 52/*TokenKind.LT*/:

      return '\$lt';

    case 53/*TokenKind.GT*/:

      return '\$gt';

    case 54/*TokenKind.LTE*/:

      return '\$lte';

    case 55/*TokenKind.GTE*/:

      return '\$gte';

    case 56/*TokenKind.INDEX*/:

      return '\$index';

    case 57/*TokenKind.SETINDEX*/:

      return '\$setindex';

  }
}
TokenKind.kindFromAssign = function(kind) {
  if ($notnull_bool(kind == 20/*TokenKind.ASSIGN*/)) return 0;
  if ($notnull_bool(kind > 20/*TokenKind.ASSIGN*/ && kind <= 32/*TokenKind.ASSIGN_MOD*/)) {
    return kind + (15)/*(ADD - ASSIGN_ADD)*/;
  }
  return -1;
}
// ********** Code for lang_Parser **************
function lang_Parser(source, diet, startOffset) {
  this.source = source;
  this.diet = diet;
  // Initializers done
  this.tokenizer = new Tokenizer(this.source, true, startOffset);
  this._peekToken = this.tokenizer.next();
  this._previousToken = null;
  this._inInitializers = false;
}
lang_Parser.prototype.get$source = function() { return this.source; };
lang_Parser.prototype.isPrematureEndOfFile = function() {
  if ($notnull_bool(this._maybeEat(1/*TokenKind.END_OF_FILE*/))) {
    this._lang_error('unexpected end of file', this._peekToken.get$span());
    return true;
  }
  else {
    return false;
  }
}
lang_Parser.prototype._peek = function() {
  return this._peekToken.kind;
}
lang_Parser.prototype._lang_next = function() {
  this._previousToken = this._peekToken;
  this._peekToken = this.tokenizer.next();
  return this._previousToken;
}
lang_Parser.prototype._peekKind = function(kind) {
  return this._peekToken.kind == kind;
}
lang_Parser.prototype._peekIdentifier = function() {
  return TokenKind.isIdentifier(this._peekToken.kind);
}
lang_Parser.prototype._maybeEat = function(kind) {
  if ($notnull_bool(this._peekToken.kind == kind)) {
    this._previousToken = this._peekToken;
    this._peekToken = this.tokenizer.next();
    return true;
  }
  else {
    return false;
  }
}
lang_Parser.prototype._eat = function(kind) {
  if ($notnull_bool(!this._maybeEat(kind))) {
    this._errorExpected(TokenKind.kindToString(kind));
  }
}
lang_Parser.prototype._eatSemicolon = function() {
  this._eat(10/*TokenKind.SEMICOLON*/);
}
lang_Parser.prototype._errorExpected = function(expected) {
  var tok = this._lang_next();
  var message = ('expected ' + expected + ', but found ' + tok + '');
  this._lang_error($assert_String(message), tok.get$span());
}
lang_Parser.prototype._lang_error = function(message, location) {
  if ($notnull_bool(location == null)) {
    location = this._peekToken.get$span();
  }
  world.fatal(message, location);
}
lang_Parser.prototype._skipBlock = function() {
  var depth = 1;
  this._eat(6/*TokenKind.LBRACE*/);
  while ($notnull_bool(true)) {
    var tok = this._lang_next();
    if ($notnull_bool(tok.kind == 6/*TokenKind.LBRACE*/)) {
      depth += 1;
    }
    else if ($notnull_bool(tok.kind == 7/*TokenKind.RBRACE*/)) {
      depth -= 1;
      if ($notnull_bool(depth == 0)) return;
    }
    else if ($notnull_bool(tok.kind == 1/*TokenKind.END_OF_FILE*/)) {
      this._lang_error('unexpected end of file during diet parse', tok.get$span());
      return;
    }
  }
}
lang_Parser.prototype._makeSpan = function(start) {
  return new SourceSpan(this.source, start, this._previousToken.end);
}
lang_Parser.prototype.compilationUnit = function() {
  var ret = [];
  this._maybeEat(13/*TokenKind.HASHBANG*/);
  while ($notnull_bool(this._peekKind(12/*TokenKind.HASH*/))) {
    ret.add(this.directive());
  }
  while ($notnull_bool(!this._maybeEat(1/*TokenKind.END_OF_FILE*/))) {
    ret.add(this.topLevelDefinition());
  }
  return ret;
}
lang_Parser.prototype.directive = function() {
  var start = this._peekToken.start;
  this._eat(12/*TokenKind.HASH*/);
  var name = this.identifier();
  var args = this.arguments();
  this._eatSemicolon();
  return new DirectiveDefinition(name, args, this._makeSpan(start));
}
lang_Parser.prototype.topLevelDefinition = function() {
  switch (this._peek()) {
    case 73/*TokenKind.CLASS*/:

      return this.classDefinition(73/*TokenKind.CLASS*/);

    case 79/*TokenKind.INTERFACE*/:

      return this.classDefinition(79/*TokenKind.INTERFACE*/);

    case 87/*TokenKind.TYPEDEF*/:

      return this.functionTypeAlias();

    default:

      return this.declaration(true);

  }
}
lang_Parser.prototype.classDefinition = function(kind) {
  var start = this._peekToken.start;
  this._eat(kind);
  var name = this.identifier();
  var typeParams = null;
  if ($notnull_bool(this._peekKind(52/*TokenKind.LT*/))) {
    typeParams = this.typeParameters();
  }
  var _extends = null;
  if ($notnull_bool(this._maybeEat(74/*TokenKind.EXTENDS*/))) {
    _extends = this.typeList();
  }
  var _implements = null;
  if ($notnull_bool(this._maybeEat(77/*TokenKind.IMPLEMENTS*/))) {
    _implements = this.typeList();
  }
  var _native = null;
  if ($notnull_bool(this._maybeEat(81/*TokenKind.NATIVE*/))) {
    _native = this.maybeStringLiteral();
  }
  var _factory = null;
  if ($notnull_bool(this._maybeEat(75/*TokenKind.FACTORY*/))) {
    _factory = this.type(0);
  }
  var body = [];
  if ($notnull_bool(this._maybeEat(6/*TokenKind.LBRACE*/))) {
    while ($notnull_bool(!this._maybeEat(7/*TokenKind.RBRACE*/))) {
      if ($notnull_bool(this.isPrematureEndOfFile())) break;
      body.add(this.declaration(true));
    }
  }
  else {
    this._errorExpected('block starting with "{" or ";"');
  }
  return new TypeDefinition(kind == 73/*TokenKind.CLASS*/, name, typeParams, _extends, _implements, _native, _factory, body, this._makeSpan(start));
}
lang_Parser.prototype.functionTypeAlias = function() {
  var start = this._peekToken.start;
  this._eat(87/*TokenKind.TYPEDEF*/);
  var di = this.declaredIdentifier(false);
  var typeParams = null;
  if ($notnull_bool(this._peekKind(52/*TokenKind.LT*/))) {
    typeParams = this.typeParameters();
  }
  var formals = this.formalParameterList();
  this._eatSemicolon();
  var func = new FunctionDefinition(null, di.type, di.get$name(), formals, null, null, this._makeSpan(start));
  return new FunctionTypeDefinition(func, typeParams, this._makeSpan(start));
}
lang_Parser.prototype.initializers = function() {
  this._inInitializers = true;
  var ret = [];
  do {
    ret.add(this.expression());
  }
  while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/)))
  this._inInitializers = false;
  return ret;
}
lang_Parser.prototype.functionBody = function(inExpression) {
  var start = this._peekToken.start;
  if ($notnull_bool(this._maybeEat(9/*TokenKind.ARROW*/))) {
    var expr = this.expression();
    if ($notnull_bool(!inExpression)) {
      this._eatSemicolon();
    }
    return new ReturnStatement(expr, this._makeSpan(start));
  }
  else if ($notnull_bool(this._peekKind(6/*TokenKind.LBRACE*/))) {
    if ($notnull_bool(this.diet)) {
      this._skipBlock();
      return new DietStatement(this._makeSpan(start));
    }
    else {
      return this.block();
    }
  }
  else if ($notnull_bool(!inExpression)) {
    if ($notnull_bool(this._maybeEat(10/*TokenKind.SEMICOLON*/))) {
      return null;
    }
    else if ($notnull_bool(this._maybeEat(81/*TokenKind.NATIVE*/))) {
      var nativeBody = this.maybeStringLiteral();
      if ($notnull_bool(this._peekKind(10/*TokenKind.SEMICOLON*/))) {
        this._eatSemicolon();
        return new NativeStatement(nativeBody, this._makeSpan(start));
      }
      else {
        return this.functionBody(inExpression);
      }
    }
  }
  this._lang_error('Expected function body (neither { nor => found)');
}
lang_Parser.prototype.finishField = function(start, modifiers, type0, name, value) {
  var names = [name];
  var values = [value];
  while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
    names.add(this.identifier());
    if ($notnull_bool(this._maybeEat(20/*TokenKind.ASSIGN*/))) {
      values.add(this.expression());
    }
    else {
      values.add(null);
    }
  }
  this._eatSemicolon();
  return new VariableDefinition(modifiers, type0, names, values, this._makeSpan($assert_num(start)));
}
lang_Parser.prototype.finishDefinition = function(start, modifiers, di) {
  switch (this._peek()) {
    case 2/*TokenKind.LPAREN*/:

      var formals = this.formalParameterList();
      var inits = null;
      if ($notnull_bool(this._maybeEat(8/*TokenKind.COLON*/))) {
        inits = this.initializers();
      }
      var body = this.functionBody(false);
      if ($notnull_bool(di.get$name() == null)) {
        di.name = di.type.get$name();
      }
      return new FunctionDefinition(modifiers, di.type, di.get$name(), formals, inits, body, this._makeSpan($assert_num(start)));

    case 20/*TokenKind.ASSIGN*/:

      this._eat(20/*TokenKind.ASSIGN*/);
      var value = this.expression();
      return this.finishField(start, modifiers, di.type, di.get$name(), value);

    case 11/*TokenKind.COMMA*/:
    case 10/*TokenKind.SEMICOLON*/:

      return this.finishField(start, modifiers, di.type, di.get$name(), null);

    default:

      this._errorExpected('declaration');
      return null;

  }
}
lang_Parser.prototype.declaration = function(includeOperators) {
  var start = this._peekToken.start;
  if ($notnull_bool(this._peekKind(75/*TokenKind.FACTORY*/))) {
    return this.factoryConstructorDeclaration();
  }
  var modifiers = this._readModifiers();
  return this.finishDefinition(start, modifiers, this.declaredIdentifier(includeOperators));
}
lang_Parser.prototype.factoryConstructorDeclaration = function() {
  var start = this._peekToken.start;
  var factoryToken = this._lang_next();
  var names = [this.identifier()];
  while ($notnull_bool(this._maybeEat(14/*TokenKind.DOT*/))) {
    names.add(this.identifier());
  }
  var typeParams = null;
  if ($notnull_bool(this._peekKind(52/*TokenKind.LT*/))) {
    typeParams = this.typeParameters();
  }
  var name = null;
  var type0 = null;
  if ($notnull_bool(this._maybeEat(14/*TokenKind.DOT*/))) {
    name = this.identifier();
  }
  else if ($notnull_bool(typeParams == null)) {
    if ($notnull_bool(names.length > 1)) {
      name = names.removeLast();
    }
    else {
      name = new lang_Identifier('', names.$index(0).get$span());
    }
  }
  else {
    name = new lang_Identifier('', names.$index(0).get$span());
  }
  if ($notnull_bool(names.length > 1)) {
    this._lang_error('unsupported qualified name for factory', names.$index(0).get$span());
  }
  type0 = new NameTypeReference(false, names.$index(0), null, names.$index(0).get$span());
  var di = new DeclaredIdentifier(type0, name, this._makeSpan(start));
  return this.finishDefinition(start, [factoryToken], di);
}
lang_Parser.prototype.statement = function() {
  switch (this._peek()) {
    case 88/*TokenKind.BREAK*/:

      return this.breakStatement();

    case 92/*TokenKind.CONTINUE*/:

      return this.continueStatement();

    case 105/*TokenKind.RETURN*/:

      return this.returnStatement();

    case 109/*TokenKind.THROW*/:

      return this.throwStatement();

    case 72/*TokenKind.ASSERT*/:

      return this.assertStatement();

    case 114/*TokenKind.WHILE*/:

      return this.whileStatement();

    case 94/*TokenKind.DO*/:

      return this.doStatement();

    case 99/*TokenKind.FOR*/:

      return this.forStatement();

    case 100/*TokenKind.IF*/:

      return this.ifStatement();

    case 107/*TokenKind.SWITCH*/:

      return this.switchStatement();

    case 111/*TokenKind.TRY*/:

      return this.tryStatement();

    case 6/*TokenKind.LBRACE*/:

      return this.block();

    case 10/*TokenKind.SEMICOLON*/:

      return this.emptyStatement();

    case 97/*TokenKind.FINAL*/:

      return this.declaration(false);

    case 112/*TokenKind.VAR*/:

      return this.declaration(false);

    default:

      return this.finishExpressionAsStatement(this.expression());

  }
}
lang_Parser.prototype.finishExpressionAsStatement = function(expr) {
  var start = expr.get$span().start;
  if ($notnull_bool(this._maybeEat(8/*TokenKind.COLON*/))) {
    var label = this._makeLabel(expr);
    return new LabeledStatement(label, this.statement(), this._makeSpan(start));
  }
  if ($notnull_bool((expr instanceof LambdaExpression))) {
    if ($notnull_bool(!(expr.func.body instanceof BlockStatement))) {
      this._eatSemicolon();
      expr.func.span = this._makeSpan(start);
    }
    return expr.func;
  }
  else if ($notnull_bool((expr instanceof DeclaredIdentifier))) {
    var value = null;
    if ($notnull_bool(this._maybeEat(20/*TokenKind.ASSIGN*/))) {
      value = this.expression();
    }
    return this.finishField(start, null, expr.type, expr.get$name(), value);
  }
  else if ($notnull_bool(this._isBin(expr, 20/*TokenKind.ASSIGN*/) && ((expr.x instanceof DeclaredIdentifier)))) {
    var di = expr.x;
    return this.finishField(start, null, di.type, di.name, expr.y);
  }
  else if ($notnull_bool(this._isBin(expr, 52/*TokenKind.LT*/) && this._maybeEat(11/*TokenKind.COMMA*/))) {
    var baseType = this._makeType(expr.x);
    var typeArgs = [this._makeType(expr.y)];
    var gt = this._finishTypeArguments((baseType && baseType.is$TypeReference()), 0, typeArgs);
    var name = this.identifier();
    var value = null;
    if ($notnull_bool(this._maybeEat(20/*TokenKind.ASSIGN*/))) {
      value = this.expression();
    }
    return this.finishField(expr.get$span().start, null, gt, name, value);
  }
  else {
    this._eatSemicolon();
    return new lang_ExpressionStatement(expr, this._makeSpan(expr.get$span().start));
  }
}
lang_Parser.prototype.testCondition = function() {
  this._eat(2/*TokenKind.LPAREN*/);
  var ret = this.expression();
  this._eat(3/*TokenKind.RPAREN*/);
  return ret;
}
lang_Parser.prototype.block = function() {
  var start = this._peekToken.start;
  this._eat(6/*TokenKind.LBRACE*/);
  var stmts = [];
  while ($notnull_bool(!this._maybeEat(7/*TokenKind.RBRACE*/))) {
    if ($notnull_bool(this.isPrematureEndOfFile())) break;
    stmts.add(this.statement());
  }
  return new BlockStatement(stmts, this._makeSpan(start));
}
lang_Parser.prototype.emptyStatement = function() {
  var start = this._peekToken.start;
  this._eat(10/*TokenKind.SEMICOLON*/);
  return new EmptyStatement(this._makeSpan(start));
}
lang_Parser.prototype.ifStatement = function() {
  var start = this._peekToken.start;
  this._eat(100/*TokenKind.IF*/);
  var test = this.testCondition();
  var trueBranch = this.statement();
  var falseBranch = null;
  if ($notnull_bool(this._maybeEat(95/*TokenKind.ELSE*/))) {
    falseBranch = this.statement();
  }
  return new IfStatement(test, trueBranch, falseBranch, this._makeSpan(start));
}
lang_Parser.prototype.whileStatement = function() {
  var start = this._peekToken.start;
  this._eat(114/*TokenKind.WHILE*/);
  var test = this.testCondition();
  var body = this.statement();
  return new WhileStatement(test, body, this._makeSpan(start));
}
lang_Parser.prototype.doStatement = function() {
  var start = this._peekToken.start;
  this._eat(94/*TokenKind.DO*/);
  var body = this.statement();
  this._eat(114/*TokenKind.WHILE*/);
  var test = this.testCondition();
  this._eatSemicolon();
  return new DoStatement(body, test, this._makeSpan(start));
}
lang_Parser.prototype.forStatement = function() {
  var start = this._peekToken.start;
  this._eat(99/*TokenKind.FOR*/);
  this._eat(2/*TokenKind.LPAREN*/);
  var init = this.forInitializerStatement(start);
  if ($notnull_bool((init instanceof ForInStatement))) {
    return init;
  }
  var test = null;
  if ($notnull_bool(!this._maybeEat(10/*TokenKind.SEMICOLON*/))) {
    test = this.expression();
    this._eatSemicolon();
  }
  var step = [];
  if ($notnull_bool(!this._maybeEat(3/*TokenKind.RPAREN*/))) {
    step.add(this.expression());
    while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
      step.add(this.expression());
    }
    this._eat(3/*TokenKind.RPAREN*/);
  }
  var body = this.statement();
  return new ForStatement(init, test, step, body, this._makeSpan(start));
}
lang_Parser.prototype.forInitializerStatement = function(start) {
  var $0;
  if ($notnull_bool(this._maybeEat(10/*TokenKind.SEMICOLON*/))) {
    return null;
  }
  else {
    var init = this.expression();
    if ($notnull_bool(this._peekKind(11/*TokenKind.COMMA*/) && this._isBin(init, 52/*TokenKind.LT*/))) {
      this._eat(11/*TokenKind.COMMA*/);
      var baseType = this._makeType(init.x);
      var typeArgs = [this._makeType(init.y)];
      var gt = this._finishTypeArguments((baseType && baseType.is$TypeReference()), 0, typeArgs);
      var name = this.identifier();
      init = new DeclaredIdentifier(gt, name, this._makeSpan(init.get$span().start));
    }
    if ($notnull_bool(this._maybeEat(101/*TokenKind.IN*/))) {
      return this._finishForIn(start, (($0 = this._makeDeclaredIdentifier(init)) && $0.is$DeclaredIdentifier()));
    }
    else {
      return this.finishExpressionAsStatement(init);
    }
  }
}
lang_Parser.prototype._finishForIn = function(start, di) {
  var expr = this.expression();
  this._eat(3/*TokenKind.RPAREN*/);
  var body = this.statement();
  return new ForInStatement(di, expr, body, this._makeSpan(start));
}
lang_Parser.prototype.tryStatement = function() {
  var start = this._peekToken.start;
  this._eat(111/*TokenKind.TRY*/);
  var body = this.block();
  var catches = [];
  while ($notnull_bool(this._peekKind(90/*TokenKind.CATCH*/))) {
    catches.add(this.catchNode());
  }
  var finallyBlock = null;
  if ($notnull_bool(this._maybeEat(98/*TokenKind.FINALLY*/))) {
    finallyBlock = this.block();
  }
  return new TryStatement(body, catches, finallyBlock, this._makeSpan(start));
}
lang_Parser.prototype.catchNode = function() {
  var start = this._peekToken.start;
  this._eat(90/*TokenKind.CATCH*/);
  this._eat(2/*TokenKind.LPAREN*/);
  var exc = this.declaredIdentifier(false);
  var trace = null;
  if ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
    trace = this.declaredIdentifier(false);
  }
  this._eat(3/*TokenKind.RPAREN*/);
  var body = this.block();
  return new CatchNode(exc, trace, body, this._makeSpan(start));
}
lang_Parser.prototype.switchStatement = function() {
  var start = this._peekToken.start;
  this._eat(107/*TokenKind.SWITCH*/);
  var test = this.testCondition();
  var cases = [];
  this._eat(6/*TokenKind.LBRACE*/);
  while ($notnull_bool(!this._maybeEat(7/*TokenKind.RBRACE*/))) {
    cases.add(this.caseNode());
  }
  return new SwitchStatement(test, cases, this._makeSpan(start));
}
lang_Parser.prototype._peekCaseEnd = function() {
  var kind = this._peek();
  return $eq(kind, 7/*TokenKind.RBRACE*/) || $eq(kind, 89/*TokenKind.CASE*/) || $eq(kind, 93/*TokenKind.DEFAULT*/);
}
lang_Parser.prototype.caseNode = function() {
  var start = this._peekToken.start;
  var label = null;
  if ($notnull_bool(this._peekIdentifier())) {
    label = this.identifier();
    this._eat(8/*TokenKind.COLON*/);
  }
  var cases = [];
  while ($notnull_bool(true)) {
    if ($notnull_bool(this._maybeEat(89/*TokenKind.CASE*/))) {
      cases.add(this.expression());
      this._eat(8/*TokenKind.COLON*/);
    }
    else if ($notnull_bool(this._maybeEat(93/*TokenKind.DEFAULT*/))) {
      cases.add(null);
      this._eat(8/*TokenKind.COLON*/);
    }
    else {
      break;
    }
  }
  if ($notnull_bool(cases.length == 0)) {
    this._lang_error('case or default');
  }
  var stmts = [];
  while ($notnull_bool(!this._peekCaseEnd())) {
    if ($notnull_bool(this.isPrematureEndOfFile())) break;
    stmts.add(this.statement());
  }
  return new CaseNode(label, cases, stmts, this._makeSpan(start));
}
lang_Parser.prototype.returnStatement = function() {
  var start = this._peekToken.start;
  this._eat(105/*TokenKind.RETURN*/);
  var expr;
  if ($notnull_bool(this._maybeEat(10/*TokenKind.SEMICOLON*/))) {
    expr = null;
  }
  else {
    expr = this.expression();
    this._eatSemicolon();
  }
  return new ReturnStatement(expr, this._makeSpan(start));
}
lang_Parser.prototype.throwStatement = function() {
  var start = this._peekToken.start;
  this._eat(109/*TokenKind.THROW*/);
  var expr;
  if ($notnull_bool(this._maybeEat(10/*TokenKind.SEMICOLON*/))) {
    expr = null;
  }
  else {
    expr = this.expression();
    this._eatSemicolon();
  }
  return new ThrowStatement(expr, this._makeSpan(start));
}
lang_Parser.prototype.assertStatement = function() {
  var start = this._peekToken.start;
  this._eat(72/*TokenKind.ASSERT*/);
  this._eat(2/*TokenKind.LPAREN*/);
  var expr = this.expression();
  this._eat(3/*TokenKind.RPAREN*/);
  this._eatSemicolon();
  return new AssertStatement(expr, this._makeSpan(start));
}
lang_Parser.prototype.breakStatement = function() {
  var start = this._peekToken.start;
  this._eat(88/*TokenKind.BREAK*/);
  var name = null;
  if ($notnull_bool(this._peekIdentifier())) {
    name = this.identifier();
  }
  this._eatSemicolon();
  return new BreakStatement(name, this._makeSpan(start));
}
lang_Parser.prototype.continueStatement = function() {
  var start = this._peekToken.start;
  this._eat(92/*TokenKind.CONTINUE*/);
  var name = null;
  if ($notnull_bool(this._peekIdentifier())) {
    name = this.identifier();
  }
  this._eatSemicolon();
  return new ContinueStatement(name, this._makeSpan(start));
}
lang_Parser.prototype.expression = function() {
  return this.infixExpression(0);
}
lang_Parser.prototype._makeType = function(expr) {
  if ($notnull_bool((expr instanceof VarExpression))) {
    return new NameTypeReference(false, expr.get$name(), null, expr.get$span());
  }
  else if ($notnull_bool((expr instanceof DotExpression))) {
    var type0 = this._makeType(expr.self);
    if ($notnull_bool(type0.names == null)) {
      type0.names = [expr.get$name()];
    }
    else {
      type0.names.add(expr.get$name());
    }
    type0.span = expr.get$span();
    return type0;
  }
  else {
    this._lang_error('expected type reference');
    return null;
  }
}
lang_Parser.prototype.infixExpression = function(precedence) {
  var $0;
  return this.finishInfixExpression((($0 = this.unaryExpression()) && $0.is$lang_Expression()), precedence);
}
lang_Parser.prototype._finishDeclaredId = function(type0) {
  var name = this.identifier();
  return this.finishPostfixExpression(new DeclaredIdentifier(type0, name, this._makeSpan(type0.get$span().start)));
}
lang_Parser.prototype._fixAsType = function(x) {
  $assert(this._isBin(x, 52/*TokenKind.LT*/), "_isBin(x, TokenKind.LT)", "parser.dart", 771, 12);
  if ($notnull_bool(this._maybeEat(53/*TokenKind.GT*/))) {
    var base = this._makeType(x.x);
    var typeParam = this._makeType(x.y);
    var type0 = new GenericTypeReference(base, [typeParam], 0, this._makeSpan(x.span.start));
    return this._finishDeclaredId(type0);
  }
  else {
    $assert(this._peekKind(52/*TokenKind.LT*/), "_peekKind(TokenKind.LT)", "parser.dart", 782, 14);
    var base = this._makeType(x.x);
    var paramBase = this._makeType(x.y);
    var firstParam = this.addTypeArguments((paramBase && paramBase.is$TypeReference()), 1);
    var type0;
    if ($notnull_bool(firstParam.depth <= 0)) {
      type0 = new GenericTypeReference(base, [firstParam], 0, this._makeSpan(x.span.start));
    }
    else if ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
      type0 = this._finishTypeArguments((base && base.is$TypeReference()), 0, [firstParam]);
    }
    else {
      this._eat(53/*TokenKind.GT*/);
      type0 = new GenericTypeReference(base, [firstParam], 0, this._makeSpan(x.span.start));
    }
    return this._finishDeclaredId(type0);
  }
}
lang_Parser.prototype.finishInfixExpression = function(x, precedence) {
  while ($notnull_bool(true)) {
    var kind = this._peek();
    var prec = TokenKind.infixPrecedence(this._peek());
    if ($notnull_bool(prec >= precedence)) {
      if ($notnull_bool(kind == 52/*TokenKind.LT*/ || kind == 53/*TokenKind.GT*/)) {
        if ($notnull_bool(this._isBin(x, 52/*TokenKind.LT*/))) {
          return this._fixAsType((x && x.is$BinaryExpression()));
        }
      }
      var op = this._lang_next();
      if ($notnull_bool(op.kind == 102/*TokenKind.IS*/)) {
        var isTrue = !this._maybeEat(19/*TokenKind.NOT*/);
        var typeRef = this.type(0);
        x = new IsExpression(isTrue, x, typeRef, this._makeSpan(x.span.start));
        continue;
      }
      var y = this.infixExpression($assert_num($notnull_bool($eq(prec, 2)) ? prec : prec + 1));
      if ($notnull_bool(op.kind == 33/*TokenKind.CONDITIONAL*/)) {
        this._eat(8/*TokenKind.COLON*/);
        var z = this.infixExpression($assert_num(prec + 1));
        x = new ConditionalExpression(x, y, z, this._makeSpan(x.span.start));
      }
      else {
        x = new BinaryExpression(op, x, y, this._makeSpan(x.span.start));
      }
    }
    else {
      break;
    }
  }
  return x;
}
lang_Parser.prototype._isPrefixUnaryOperator = function(kind) {
  switch (kind) {
    case 42/*TokenKind.ADD*/:
    case 43/*TokenKind.SUB*/:
    case 19/*TokenKind.NOT*/:
    case 18/*TokenKind.BIT_NOT*/:
    case 16/*TokenKind.INCR*/:
    case 17/*TokenKind.DECR*/:

      return true;

    default:

      return false;

  }
}
lang_Parser.prototype.unaryExpression = function() {
  var start = this._peekToken.start;
  if ($notnull_bool(this._isPrefixUnaryOperator(this._peek()))) {
    var tok = this._lang_next();
    var expr = this.unaryExpression();
    return new UnaryExpression(tok, expr, this._makeSpan(start));
  }
  return this.finishPostfixExpression(this.primary());
}
lang_Parser.prototype.argument = function() {
  var start = this._peekToken.start;
  var expr;
  var label = null;
  if ($notnull_bool(this._maybeEat(15/*TokenKind.ELLIPSIS*/))) {
    label = new lang_Identifier('...', this._makeSpan(start));
  }
  expr = this.expression();
  if ($notnull_bool(label == null && this._maybeEat(8/*TokenKind.COLON*/))) {
    label = this._makeLabel(expr);
    expr = this.expression();
  }
  return new ArgumentNode(label, expr, this._makeSpan(start));
}
lang_Parser.prototype.arguments = function() {
  var args = [];
  this._eat(2/*TokenKind.LPAREN*/);
  if ($notnull_bool(!this._maybeEat(3/*TokenKind.RPAREN*/))) {
    do {
      args.add(this.argument());
    }
    while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/)))
    this._eat(3/*TokenKind.RPAREN*/);
  }
  return args;
}
lang_Parser.prototype.get$arguments = function() {
  return lang_Parser.prototype.arguments.bind(this);
}
lang_Parser.prototype.finishPostfixExpression = function(expr) {
  switch (this._peek()) {
    case 2/*TokenKind.LPAREN*/:

      return this.finishPostfixExpression(new CallExpression(expr, this.arguments(), this._makeSpan(expr.get$span().start)));

    case 4/*TokenKind.LBRACK*/:

      this._eat(4/*TokenKind.LBRACK*/);
      var index = this.expression();
      this._eat(5/*TokenKind.RBRACK*/);
      return this.finishPostfixExpression(new IndexExpression(expr, index, this._makeSpan(expr.get$span().start)));

    case 14/*TokenKind.DOT*/:

      this._eat(14/*TokenKind.DOT*/);
      var name = this.identifier();
      var ret = new DotExpression(expr, name, this._makeSpan(expr.get$span().start));
      return this.finishPostfixExpression(ret);

    case 16/*TokenKind.INCR*/:
    case 17/*TokenKind.DECR*/:

      var tok = this._lang_next();
      return new PostfixExpression(expr, tok, this._makeSpan(expr.get$span().start));

    case 9/*TokenKind.ARROW*/:
    case 6/*TokenKind.LBRACE*/:

      if ($notnull_bool(this._inInitializers)) return expr;
      var body = this.functionBody(true);
      return this._makeFunction(expr, body);

    default:

      if ($notnull_bool(this._peekIdentifier())) {
        return this.finishPostfixExpression(new DeclaredIdentifier(this._makeType(expr), this.identifier(), this._makeSpan(expr.get$span().start)));
      }
      else {
        return expr;
      }

  }
}
lang_Parser.prototype._isBin = function(expr, kind) {
  return (expr instanceof BinaryExpression) && expr.op.kind == kind;
}
lang_Parser.prototype._boolTypeRef = function(span) {
  return new TypeReference(span, world.boolType);
}
lang_Parser.prototype._intTypeRef = function(span) {
  return new TypeReference(span, world.intType);
}
lang_Parser.prototype._doubleTypeRef = function(span) {
  return new TypeReference(span, world.doubleType);
}
lang_Parser.prototype._stringTypeRef = function(span) {
  return new TypeReference(span, world.stringType);
}
lang_Parser.prototype.primary = function() {
  var start = this._peekToken.start;
  switch (this._peek()) {
    case 108/*TokenKind.THIS*/:

      this._eat(108/*TokenKind.THIS*/);
      return new ThisExpression(this._makeSpan(start));

    case 106/*TokenKind.SUPER*/:

      this._eat(106/*TokenKind.SUPER*/);
      return new SuperExpression(this._makeSpan(start));

    case 91/*TokenKind.CONST*/:

      this._eat(91/*TokenKind.CONST*/);
      if ($notnull_bool(this._peekKind(4/*TokenKind.LBRACK*/) || this._peekKind(56/*TokenKind.INDEX*/))) {
        return this.finishListLiteral(start, true, null);
      }
      else if ($notnull_bool(this._peekKind(6/*TokenKind.LBRACE*/))) {
        return this.finishMapLiteral(start, true, null);
      }
      else if ($notnull_bool(this._peekKind(52/*TokenKind.LT*/))) {
        return this.finishTypedLiteral(start, true);
      }
      else {
        return this.finishNewExpression(start, true);
      }

    case 103/*TokenKind.NEW*/:

      this._eat(103/*TokenKind.NEW*/);
      return this.finishNewExpression(start, false);

    case 2/*TokenKind.LPAREN*/:

      return this._parenOrLambda();

    case 4/*TokenKind.LBRACK*/:
    case 56/*TokenKind.INDEX*/:

      return this.finishListLiteral(start, false, null);

    case 6/*TokenKind.LBRACE*/:

      return this.finishMapLiteral(start, false, null);

    case 104/*TokenKind.NULL*/:

      this._eat(104/*TokenKind.NULL*/);
      return new NullExpression(this._makeSpan(start));

    case 110/*TokenKind.TRUE*/:

      this._eat(110/*TokenKind.TRUE*/);
      return new LiteralExpression(true, this._boolTypeRef(this._makeSpan(start)), 'true', this._makeSpan(start));

    case 96/*TokenKind.FALSE*/:

      this._eat(96/*TokenKind.FALSE*/);
      return new LiteralExpression(false, this._boolTypeRef(this._makeSpan(start)), 'false', this._makeSpan(start));

    case 61/*TokenKind.HEX_INTEGER*/:

      var t = this._lang_next();
      return new LiteralExpression(lang_Parser.parseHex(t.get$text().substring(2)), this._intTypeRef(this._makeSpan(start)), t.get$text(), this._makeSpan(start));

    case 60/*TokenKind.INTEGER*/:

      var t = this._lang_next();
      return new LiteralExpression(Math.parseInt(t.get$text()), this._intTypeRef(this._makeSpan(start)), t.get$text(), this._makeSpan(start));

    case 62/*TokenKind.DOUBLE*/:

      var t = this._lang_next();
      return new LiteralExpression(Math.parseDouble(t.get$text()), this._doubleTypeRef(this._makeSpan(start)), t.get$text(), this._makeSpan(start));

    case 58/*TokenKind.STRING*/:

      return this.stringLiteralExpr();

    case 66/*TokenKind.INCOMPLETE_STRING*/:

      return this.stringInterpolation();

    case 52/*TokenKind.LT*/:

      return this.finishTypedLiteral(start, false);

    case 113/*TokenKind.VOID*/:
    case 112/*TokenKind.VAR*/:
    case 97/*TokenKind.FINAL*/:

      return this.declaredIdentifier(false);

    default:

      if ($notnull_bool(!this._peekIdentifier())) {
        this._errorExpected('expression');
      }
      return new VarExpression(this.identifier(), this._makeSpan(start));

  }
}
lang_Parser.prototype.stringInterpolation = function() {
  var start = this._peekToken.start;
  var lits = [];
  var startQuote = null, endQuote = null;
  while ($notnull_bool(this._peekKind(66/*TokenKind.INCOMPLETE_STRING*/))) {
    var token = this._lang_next();
    var text = token.get$text();
    if ($notnull_bool(startQuote == null)) {
      if ($notnull_bool(isMultilineString($assert_String(text)))) {
        endQuote = text.substring(0, 3);
        startQuote = endQuote + '\n';
      }
      else {
        startQuote = endQuote = text.$index(0);
      }
      text = text.substring(0, text.length - 1) + endQuote;
    }
    else {
      text = startQuote + text.substring(0, text.length - 1) + endQuote;
    }
    lits.add(this.makeStringLiteral($assert_String(text), token.get$span()));
    if ($notnull_bool(this._maybeEat(6/*TokenKind.LBRACE*/))) {
      lits.add(this.expression());
      this._eat(7/*TokenKind.RBRACE*/);
    }
    else {
      var id = this.identifier();
      lits.add(new VarExpression(id, id.get$span()));
    }
  }
  var tok = this._lang_next();
  if ($notnull_bool(tok.kind != 58/*TokenKind.STRING*/)) {
    this._errorExpected('interpolated string');
  }
  var text = startQuote + tok.get$text();
  lits.add(this.makeStringLiteral($assert_String(text), tok.get$span()));
  var span = this._makeSpan(start);
  return new LiteralExpression(lits, this._stringTypeRef((span && span.is$SourceSpan())), '\$\$\$', (span && span.is$SourceSpan()));
}
lang_Parser.prototype.makeStringLiteral = function(text, span) {
  return new LiteralExpression(text, this._stringTypeRef(span), text, span);
}
lang_Parser.prototype.stringLiteralExpr = function() {
  var token = this._lang_next();
  return this.makeStringLiteral(token.get$text(), token.get$span());
}
lang_Parser.prototype.maybeStringLiteral = function() {
  var kind = this._peek();
  if ($notnull_bool($eq(kind, 58/*TokenKind.STRING*/))) {
    return parseStringLiteral(this._lang_next().get$text());
  }
  else if ($notnull_bool($eq(kind, 59/*TokenKind.STRING_PART*/))) {
    this._lang_next();
    this._errorExpected('string literal, but found interpolated string start');
  }
  else if ($notnull_bool($eq(kind, 66/*TokenKind.INCOMPLETE_STRING*/))) {
    this._lang_next();
    this._errorExpected('string literal, but found incomplete string');
  }
  return null;
}
lang_Parser.prototype._parenOrLambda = function() {
  var start = this._peekToken.start;
  var args = this.arguments();
  if ($notnull_bool(!this._inInitializers && (this._peekKind(9/*TokenKind.ARROW*/) || this._peekKind(6/*TokenKind.LBRACE*/)))) {
    var body = this.functionBody(true);
    var formals = this._makeFormals(args);
    var func = new FunctionDefinition(null, null, null, formals, null, body, this._makeSpan(start));
    return new LambdaExpression(func, func.get$span());
  }
  else {
    if ($notnull_bool(args.length == 1)) {
      return new ParenExpression(args.$index(0).get$value(), this._makeSpan(start));
    }
    else {
      this._lang_error('unexpected comma expression');
      return args.$index(0).get$value();
    }
  }
}
lang_Parser.prototype._typeAsIdentifier = function(type0) {
  return type0.get$name();
}
lang_Parser.prototype._specialIdentifier = function(includeOperators) {
  var start = this._peekToken.start;
  var name;
  switch (this._peek()) {
    case 15/*TokenKind.ELLIPSIS*/:

      this._eat(15/*TokenKind.ELLIPSIS*/);
      this._lang_error('rest no longer supported', this._previousToken.get$span());
      name = $assert_String(this.identifier().get$name());
      break;

    case 108/*TokenKind.THIS*/:

      this._eat(108/*TokenKind.THIS*/);
      this._eat(14/*TokenKind.DOT*/);
      name = ('this.' + this.identifier().get$name() + '');
      break;

    case 76/*TokenKind.GET*/:

      if ($notnull_bool(!includeOperators)) return null;
      this._eat(76/*TokenKind.GET*/);
      if ($notnull_bool(this._peekIdentifier())) {
        name = ('get\$' + this.identifier().get$name() + '');
      }
      else {
        name = 'get';
      }
      break;

    case 84/*TokenKind.SET*/:

      if ($notnull_bool(!includeOperators)) return null;
      this._eat(84/*TokenKind.SET*/);
      if ($notnull_bool(this._peekIdentifier())) {
        name = ('set\$' + this.identifier().get$name() + '');
      }
      else {
        name = 'set';
      }
      break;

    case 83/*TokenKind.OPERATOR*/:

      if ($notnull_bool(!includeOperators)) return null;
      this._eat(83/*TokenKind.OPERATOR*/);
      var kind = this._peek();
      if ($notnull_bool($eq(kind, 82/*TokenKind.NEGATE*/))) {
        name = '\$negate';
        this._lang_next();
      }
      else {
        name = TokenKind.binaryMethodName($assert_num(kind));
        if ($notnull_bool(name == null)) {
          name = 'operator';
        }
        else {
          this._lang_next();
        }
      }
      break;

    default:

      return null;

  }
  return new lang_Identifier(name, this._makeSpan(start));
}
lang_Parser.prototype.declaredIdentifier = function(includeOperators) {
  var start = this._peekToken.start;
  var myType = null;
  var name = this._specialIdentifier(includeOperators);
  if ($notnull_bool(name == null)) {
    myType = this.type(0);
    name = this._specialIdentifier(includeOperators);
    if ($notnull_bool(name == null)) {
      if ($notnull_bool(this._peekIdentifier())) {
        name = this.identifier();
      }
      else if ($notnull_bool((myType instanceof NameTypeReference) && myType.names == null)) {
        name = this._typeAsIdentifier(myType);
        myType = null;
      }
      else {
      }
    }
  }
  return new DeclaredIdentifier(myType, name, this._makeSpan(start));
}
lang_Parser._hexDigit = function(c) {
  if ($notnull_bool(c >= 48 && c <= 57)) {
    return c - 48;
  }
  else if ($notnull_bool(c >= 97 && c <= 102)) {
    return c - 87;
  }
  else if ($notnull_bool(c >= 65 && c <= 70)) {
    return c - 55;
  }
  else {
    return -1;
  }
}
lang_Parser.parseHex = function(hex) {
  var result = 0;
  for (var i = 0;
   $notnull_bool(i < hex.length); i++) {
    var digit = lang_Parser._hexDigit(hex.charCodeAt(i));
    $assert($ne(digit, -1), "digit != -1", "parser.dart", 1238, 14);
    result = (result << 4) + $assert_num(digit);
  }
  return result;
}
lang_Parser.prototype.finishNewExpression = function(start, isConst) {
  var type0 = this.type(0);
  var name = null;
  if ($notnull_bool(this._maybeEat(14/*TokenKind.DOT*/))) {
    name = this.identifier();
  }
  var args = this.arguments();
  return new lang_NewExpression(isConst, type0, name, args, this._makeSpan(start));
}
lang_Parser.prototype.finishListLiteral = function(start, isConst, type0) {
  if ($notnull_bool(this._maybeEat(56/*TokenKind.INDEX*/))) {
    return new ListExpression(isConst, type0, [], this._makeSpan(start));
  }
  var values = [];
  this._eat(4/*TokenKind.LBRACK*/);
  while ($notnull_bool(!this._maybeEat(5/*TokenKind.RBRACK*/))) {
    if ($notnull_bool(this.isPrematureEndOfFile())) break;
    values.add(this.expression());
    if ($notnull_bool(!this._maybeEat(11/*TokenKind.COMMA*/))) {
      this._eat(5/*TokenKind.RBRACK*/);
      break;
    }
  }
  return new ListExpression(isConst, type0, values, this._makeSpan(start));
}
lang_Parser.prototype.finishMapLiteral = function(start, isConst, type0) {
  var items = [];
  this._eat(6/*TokenKind.LBRACE*/);
  while ($notnull_bool(!this._maybeEat(7/*TokenKind.RBRACE*/))) {
    if ($notnull_bool(this.isPrematureEndOfFile())) break;
    items.add(this.expression());
    this._eat(8/*TokenKind.COLON*/);
    items.add(this.expression());
    if ($notnull_bool(!this._maybeEat(11/*TokenKind.COMMA*/))) {
      this._eat(7/*TokenKind.RBRACE*/);
      break;
    }
  }
  return new MapExpression(isConst, type0, items, this._makeSpan(start));
}
lang_Parser.prototype.finishTypedLiteral = function(start, isConst) {
  var span = this._makeSpan(start);
  var typeToBeNamedLater = new NameTypeReference(false, null, null, (span && span.is$SourceSpan()));
  var genericType = this.addTypeArguments((typeToBeNamedLater && typeToBeNamedLater.is$TypeReference()), 0);
  if ($notnull_bool(this._peekKind(4/*TokenKind.LBRACK*/) || this._peekKind(56/*TokenKind.INDEX*/))) {
    return this.finishListLiteral(start, isConst, (genericType && genericType.is$TypeReference()));
  }
  else if ($notnull_bool(this._peekKind(6/*TokenKind.LBRACE*/))) {
    return this.finishMapLiteral(start, isConst, (genericType && genericType.is$TypeReference()));
  }
  else {
    this._errorExpected('array or map literal');
  }
}
lang_Parser.prototype._readModifiers = function() {
  var modifiers = null;
  while ($notnull_bool(true)) {
    switch (this._peek()) {
      case 86/*TokenKind.STATIC*/:
      case 97/*TokenKind.FINAL*/:
      case 91/*TokenKind.CONST*/:
      case 71/*TokenKind.ABSTRACT*/:
      case 75/*TokenKind.FACTORY*/:

        if ($notnull_bool(modifiers == null)) modifiers = [];
        modifiers.add(this._lang_next());
        break;

      default:

        return modifiers;

    }
  }
  return null;
}
lang_Parser.prototype.typeParameter = function() {
  var start = this._peekToken.start;
  var name = this.identifier();
  var myType = null;
  if ($notnull_bool(this._maybeEat(74/*TokenKind.EXTENDS*/))) {
    myType = this.type(1);
  }
  return new TypeParameter(name, myType, this._makeSpan(start));
}
lang_Parser.prototype.typeParameters = function() {
  this._eat(52/*TokenKind.LT*/);
  var closed = false;
  var ret = [];
  do {
    var tp = this.typeParameter();
    ret.add(tp);
    if ($notnull_bool((tp.extendsType instanceof GenericTypeReference) && tp.extendsType.depth == 0)) {
      closed = true;
      break;
    }
  }
  while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/)))
  if ($notnull_bool(!closed)) {
    this._eat(53/*TokenKind.GT*/);
  }
  return ret;
}
lang_Parser.prototype.get$typeParameters = function() {
  return lang_Parser.prototype.typeParameters.bind(this);
}
lang_Parser.prototype._eatClosingAngle = function(depth) {
  if ($notnull_bool(this._maybeEat(53/*TokenKind.GT*/))) {
    return depth;
  }
  else if ($notnull_bool(depth > 0 && this._maybeEat(40/*TokenKind.SAR*/))) {
    return depth - 1;
  }
  else if ($notnull_bool(depth > 1 && this._maybeEat(41/*TokenKind.SHR*/))) {
    return depth - 2;
  }
  else {
    this._errorExpected('>');
    return depth;
  }
}
lang_Parser.prototype.addTypeArguments = function(baseType, depth) {
  this._eat(52/*TokenKind.LT*/);
  return this._finishTypeArguments(baseType, depth, []);
}
lang_Parser.prototype._finishTypeArguments = function(baseType, depth, types) {
  var delta = -1;
  do {
    var myType = this.type(depth + 1);
    types.add(myType);
    if ($notnull_bool((myType instanceof GenericTypeReference) && myType.depth <= depth)) {
      delta = depth - myType.depth;
      break;
    }
  }
  while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/)))
  if ($notnull_bool(delta >= 0)) {
    depth -= $assert_num(delta);
  }
  else {
    depth = this._eatClosingAngle(depth);
  }
  var span = this._makeSpan(baseType.span.start);
  return new GenericTypeReference(baseType, types, depth, (span && span.is$SourceSpan()));
}
lang_Parser.prototype.typeList = function() {
  var types = [];
  do {
    types.add(this.type(0));
  }
  while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/)))
  return types;
}
lang_Parser.prototype.type = function(depth) {
  var start = this._peekToken.start;
  var name;
  var names = null;
  var typeArgs = null;
  var isFinal = false;
  switch (this._peek()) {
    case 113/*TokenKind.VOID*/:

      return new TypeReference(this._lang_next().get$span(), world.voidType);

    case 112/*TokenKind.VAR*/:

      return new TypeReference(this._lang_next().get$span(), world.varType);

    case 97/*TokenKind.FINAL*/:

      this._eat(97/*TokenKind.FINAL*/);
      isFinal = true;
      name = this.identifier();
      break;

    default:

      name = this.identifier();
      break;

  }
  while ($notnull_bool(this._maybeEat(14/*TokenKind.DOT*/))) {
    if ($notnull_bool(names == null)) names = [];
    names.add(this.identifier());
  }
  var typeRef = new NameTypeReference(isFinal, name, names, this._makeSpan(start));
  if ($notnull_bool(this._peekKind(52/*TokenKind.LT*/))) {
    return this.addTypeArguments((typeRef && typeRef.is$TypeReference()), depth);
  }
  else {
    return typeRef;
  }
}
lang_Parser.prototype.formalParameter = function(inOptionalBlock) {
  var start = this._peekToken.start;
  var isThis = false;
  var isRest = false;
  var di = this.declaredIdentifier(false);
  var type0 = di.type;
  var name = di.get$name();
  var value = null;
  if ($notnull_bool(this._maybeEat(20/*TokenKind.ASSIGN*/))) {
    if ($notnull_bool(!inOptionalBlock)) {
      this._lang_error('default values only allowed inside [optional] section');
    }
    value = this.expression();
  }
  else if ($notnull_bool(this._peekKind(2/*TokenKind.LPAREN*/))) {
    var formals = this.formalParameterList();
    var func = new FunctionDefinition(null, type0, name, formals, null, null, this._makeSpan(start));
    type0 = new FunctionTypeReference(false, func, func.get$span());
  }
  if ($notnull_bool(inOptionalBlock && value == null)) {
    value = new NullExpression(this._makeSpan(start));
  }
  return new FormalNode(isThis, isRest, type0, name, value, this._makeSpan(start));
}
lang_Parser.prototype.formalParameterList = function() {
  this._eat(2/*TokenKind.LPAREN*/);
  var formals = [];
  var inOptionalBlock = false;
  if ($notnull_bool(!this._maybeEat(3/*TokenKind.RPAREN*/))) {
    if ($notnull_bool(this._maybeEat(4/*TokenKind.LBRACK*/))) {
      inOptionalBlock = true;
    }
    formals.add(this.formalParameter($assert_bool(inOptionalBlock)));
    while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
      if ($notnull_bool(this._maybeEat(4/*TokenKind.LBRACK*/))) {
        if ($notnull_bool(inOptionalBlock)) {
          this._lang_error('already inside an optional block', this._previousToken.get$span());
        }
        inOptionalBlock = true;
      }
      formals.add(this.formalParameter($assert_bool(inOptionalBlock)));
    }
    if ($notnull_bool(inOptionalBlock)) {
      this._eat(5/*TokenKind.RBRACK*/);
    }
    this._eat(3/*TokenKind.RPAREN*/);
  }
  return formals;
}
lang_Parser.prototype.identifier = function() {
  var tok = this._lang_next();
  if ($notnull_bool(!TokenKind.isIdentifier(tok.kind))) {
    this._lang_error(('expected identifier, but found ' + tok + ''), tok.get$span());
  }
  return new lang_Identifier(tok.get$text(), this._makeSpan(tok.start));
}
lang_Parser.prototype._makeFunction = function(expr, body) {
  var name, type0;
  if ($notnull_bool((expr instanceof CallExpression))) {
    if ($notnull_bool((expr.target instanceof VarExpression))) {
      name = expr.target.get$name();
      type0 = null;
    }
    else if ($notnull_bool((expr.target instanceof DeclaredIdentifier))) {
      name = expr.target.get$name();
      type0 = expr.target.type;
    }
    else {
      this._lang_error('bad function');
    }
    var formals = this._makeFormals(expr.get$arguments());
    var span = new SourceSpan(expr.get$span().file, expr.get$span().start, body.get$span().end);
    var func = new FunctionDefinition(null, type0, name, formals, null, body, (span && span.is$SourceSpan()));
    return new LambdaExpression(func, func.get$span());
  }
  else {
    this._lang_error('expected function');
  }
}
lang_Parser.prototype._makeFormal = function(expr) {
  if ($notnull_bool((expr instanceof VarExpression))) {
    return new FormalNode(false, false, null, expr.get$name(), null, expr.get$span());
  }
  else if ($notnull_bool((expr instanceof DeclaredIdentifier))) {
    return new FormalNode(false, false, expr.type, expr.get$name(), null, expr.get$span());
  }
  else if ($notnull_bool(this._isBin(expr, 20/*TokenKind.ASSIGN*/) && ((expr.x instanceof DeclaredIdentifier)))) {
    var di = expr.x;
    return new FormalNode(false, false, di.type, di.name, expr.y, expr.get$span());
  }
  else if ($notnull_bool(this._isBin(expr, 52/*TokenKind.LT*/))) {
    return null;
  }
  else if ($notnull_bool((expr instanceof ListExpression))) {
    return this._makeFormalsFromList(expr);
  }
  else {
    this._lang_error('expected formal', expr.get$span());
  }
}
lang_Parser.prototype._makeFormalsFromList = function(expr) {
  if ($notnull_bool(expr.get$isConst())) {
    this._lang_error('expected formal, but found "const"', expr.get$span());
  }
  else if ($notnull_bool($ne(expr.type, null))) {
    this._lang_error('expected formal, but found generic type arguments', expr.type.get$span());
  }
  return this._makeFormalsFromExpressions(expr.values, false);
}
lang_Parser.prototype._makeFormals = function(arguments0) {
  var expressions = [];
  for (var i = 0;
   $notnull_bool(i < arguments0.length); i++) {
    var arg = arguments0.$index(i);
    if ($notnull_bool(arg.label != null)) {
      this._lang_error('expected formal, but found ":"');
    }
    expressions.add(arg.get$value());
  }
  return this._makeFormalsFromExpressions(expressions, true);
}
lang_Parser.prototype._makeFormalsFromExpressions = function(expressions, allowOptional) {
  var formals = [];
  for (var i = 0;
   $notnull_bool(i < expressions.length); i++) {
    var formal = this._makeFormal(expressions.$index(i));
    if ($notnull_bool(formal == null)) {
      var baseType = this._makeType(expressions.$index(i).x);
      var typeParams = [this._makeType(expressions.$index(i).y)];
      i++;
      while ($notnull_bool(i < expressions.length)) {
        var expr = expressions.$index(i++);
        if ($notnull_bool(this._isBin(expr, 53/*TokenKind.GT*/))) {
          typeParams.add(this._makeType(expr.x));
          var type0 = new GenericTypeReference(baseType, typeParams, 0, this._makeSpan(baseType.get$span().start));
          var name = null;
          if ($notnull_bool((expr.y instanceof VarExpression))) {
            var ve = expr.y;
            name = ve.name;
          }
          else {
            this._lang_error('expected formal', expr.get$span());
          }
          formal = new FormalNode(false, false, type0, name, null, this._makeSpan(expressions.$index(0).get$span().start));
          break;
        }
        else {
          typeParams.add(this._makeType(expr));
        }
      }
      formals.add(formal);
    }
    else if ($notnull_bool(!!(formal && formal.is$List))) {
      formals.addAll(formal);
      if ($notnull_bool(!allowOptional)) {
        this._lang_error('unexpected nested optional formal', expressions.$index(i).get$span());
      }
    }
    else {
      formals.add(formal);
    }
  }
  return formals;
}
lang_Parser.prototype._makeDeclaredIdentifier = function(e) {
  if ($notnull_bool((e instanceof VarExpression))) {
    return new DeclaredIdentifier(null, e.get$name(), e.get$span());
  }
  else if ($notnull_bool((e instanceof DeclaredIdentifier))) {
    return e;
  }
  else {
    this._lang_error('expected declared identifier');
    return new DeclaredIdentifier(null, null, e.get$span());
  }
}
lang_Parser.prototype._makeLabel = function(expr) {
  if ($notnull_bool((expr instanceof VarExpression))) {
    return expr.get$name();
  }
  else {
    this._errorExpected('label');
    return null;
  }
}
// ********** Code for lang_Node **************
function lang_Node(span) {
  this.span = span;
  // Initializers done
}
lang_Node.prototype.is$lang_Node = function(){return this;};
lang_Node.prototype.get$span = function() { return this.span; };
lang_Node.prototype.set$span = function(value) { return this.span = value; };
// ********** Code for Definition **************
function Definition(span0) {
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(Definition, lang_Statement);
Definition.prototype.is$Definition = function(){return this;};
Definition.prototype.get$typeParameters = function() {
  return null;
}
// ********** Code for lang_Statement **************
function lang_Statement(span0) {
  lang_Node.call(this, span0);
  // Initializers done
}
$inherits(lang_Statement, lang_Node);
lang_Statement.prototype.is$lang_Statement = function(){return this;};
// ********** Code for lang_Expression **************
function lang_Expression(span0) {
  lang_Node.call(this, span0);
  // Initializers done
}
$inherits(lang_Expression, lang_Node);
lang_Expression.prototype.is$lang_Expression = function(){return this;};
// ********** Code for TypeReference **************
function TypeReference(span0, type) {
  this.type = type;
  lang_Node.call(this, span0);
  // Initializers done
}
$inherits(TypeReference, lang_Node);
TypeReference.prototype.is$TypeReference = function(){return this;};
TypeReference.prototype.visit = function(visitor) {
  return visitor.visitTypeReference(this);
}
// ********** Code for DirectiveDefinition **************
function DirectiveDefinition(name, arguments, span0) {
  this.name = name;
  this.arguments = arguments;
  Definition.call(this, span0);
  // Initializers done
}
$inherits(DirectiveDefinition, Definition);
DirectiveDefinition.prototype.get$name = function() { return this.name; };
DirectiveDefinition.prototype.set$name = function(value) { return this.name = value; };
DirectiveDefinition.prototype.get$arguments = function() { return this.arguments; };
DirectiveDefinition.prototype.set$arguments = function(value) { return this.arguments = value; };
DirectiveDefinition.prototype.visit = function(visitor) {
  return visitor.visitDirectiveDefinition(this);
}
// ********** Code for TypeDefinition **************
function TypeDefinition(isClass, name, typeParameters, extendsTypes, implementsTypes, nativeType, factoryType, body, span0) {
  this.isClass = isClass;
  this.name = name;
  this.typeParameters = typeParameters;
  this.extendsTypes = extendsTypes;
  this.implementsTypes = implementsTypes;
  this.nativeType = nativeType;
  this.factoryType = factoryType;
  this.body = body;
  Definition.call(this, span0);
  // Initializers done
}
$inherits(TypeDefinition, Definition);
TypeDefinition.prototype.get$isClass = function() { return this.isClass; };
TypeDefinition.prototype.set$isClass = function(value) { return this.isClass = value; };
TypeDefinition.prototype.get$name = function() { return this.name; };
TypeDefinition.prototype.set$name = function(value) { return this.name = value; };
TypeDefinition.prototype.get$typeParameters = function() { return this.typeParameters; };
TypeDefinition.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
TypeDefinition.prototype.visit = function(visitor) {
  return visitor.visitTypeDefinition(this);
}
// ********** Code for FunctionTypeDefinition **************
function FunctionTypeDefinition(func, typeParameters, span0) {
  this.func = func;
  this.typeParameters = typeParameters;
  Definition.call(this, span0);
  // Initializers done
}
$inherits(FunctionTypeDefinition, Definition);
FunctionTypeDefinition.prototype.get$typeParameters = function() { return this.typeParameters; };
FunctionTypeDefinition.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
FunctionTypeDefinition.prototype.visit = function(visitor) {
  return visitor.visitFunctionTypeDefinition(this);
}
// ********** Code for VariableDefinition **************
function VariableDefinition(modifiers, type, names, values, span0) {
  this.modifiers = modifiers;
  this.type = type;
  this.names = names;
  this.values = values;
  Definition.call(this, span0);
  // Initializers done
}
$inherits(VariableDefinition, Definition);
VariableDefinition.prototype.visit = function(visitor) {
  return visitor.visitVariableDefinition(this);
}
// ********** Code for FunctionDefinition **************
function FunctionDefinition(modifiers, returnType, name, formals, initializers, body, span0) {
  this.modifiers = modifiers;
  this.returnType = returnType;
  this.name = name;
  this.formals = formals;
  this.initializers = initializers;
  this.body = body;
  Definition.call(this, span0);
  // Initializers done
}
$inherits(FunctionDefinition, Definition);
FunctionDefinition.prototype.is$FunctionDefinition = function(){return this;};
FunctionDefinition.prototype.get$returnType = function() { return this.returnType; };
FunctionDefinition.prototype.set$returnType = function(value) { return this.returnType = value; };
FunctionDefinition.prototype.get$name = function() { return this.name; };
FunctionDefinition.prototype.set$name = function(value) { return this.name = value; };
FunctionDefinition.prototype.visit = function(visitor) {
  return visitor.visitFunctionDefinition(this);
}
// ********** Code for ReturnStatement **************
function ReturnStatement(value, span0) {
  this.value = value;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(ReturnStatement, lang_Statement);
ReturnStatement.prototype.get$value = function() { return this.value; };
ReturnStatement.prototype.set$value = function(value) { return this.value = value; };
ReturnStatement.prototype.visit = function(visitor) {
  return visitor.visitReturnStatement(this);
}
// ********** Code for ThrowStatement **************
function ThrowStatement(value, span0) {
  this.value = value;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(ThrowStatement, lang_Statement);
ThrowStatement.prototype.get$value = function() { return this.value; };
ThrowStatement.prototype.set$value = function(value) { return this.value = value; };
ThrowStatement.prototype.visit = function(visitor) {
  return visitor.visitThrowStatement(this);
}
// ********** Code for AssertStatement **************
function AssertStatement(test, span0) {
  this.test = test;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(AssertStatement, lang_Statement);
AssertStatement.prototype.visit = function(visitor) {
  return visitor.visitAssertStatement(this);
}
// ********** Code for BreakStatement **************
function BreakStatement(label, span0) {
  this.label = label;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(BreakStatement, lang_Statement);
BreakStatement.prototype.visit = function(visitor) {
  return visitor.visitBreakStatement(this);
}
// ********** Code for ContinueStatement **************
function ContinueStatement(label, span0) {
  this.label = label;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(ContinueStatement, lang_Statement);
ContinueStatement.prototype.visit = function(visitor) {
  return visitor.visitContinueStatement(this);
}
// ********** Code for IfStatement **************
function IfStatement(test, trueBranch, falseBranch, span0) {
  this.test = test;
  this.trueBranch = trueBranch;
  this.falseBranch = falseBranch;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(IfStatement, lang_Statement);
IfStatement.prototype.visit = function(visitor) {
  return visitor.visitIfStatement(this);
}
// ********** Code for WhileStatement **************
function WhileStatement(test, body, span0) {
  this.test = test;
  this.body = body;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(WhileStatement, lang_Statement);
WhileStatement.prototype.visit = function(visitor) {
  return visitor.visitWhileStatement(this);
}
// ********** Code for DoStatement **************
function DoStatement(body, test, span0) {
  this.body = body;
  this.test = test;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(DoStatement, lang_Statement);
DoStatement.prototype.visit = function(visitor) {
  return visitor.visitDoStatement(this);
}
// ********** Code for ForStatement **************
function ForStatement(init, test, step, body, span0) {
  this.init = init;
  this.test = test;
  this.step = step;
  this.body = body;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(ForStatement, lang_Statement);
ForStatement.prototype.visit = function(visitor) {
  return visitor.visitForStatement(this);
}
// ********** Code for ForInStatement **************
function ForInStatement(item, list, body, span0) {
  this.item = item;
  this.list = list;
  this.body = body;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(ForInStatement, lang_Statement);
ForInStatement.prototype.visit = function(visitor) {
  return visitor.visitForInStatement(this);
}
// ********** Code for TryStatement **************
function TryStatement(body, catches, finallyBlock, span0) {
  this.body = body;
  this.catches = catches;
  this.finallyBlock = finallyBlock;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(TryStatement, lang_Statement);
TryStatement.prototype.visit = function(visitor) {
  return visitor.visitTryStatement(this);
}
// ********** Code for SwitchStatement **************
function SwitchStatement(test, cases, span0) {
  this.test = test;
  this.cases = cases;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(SwitchStatement, lang_Statement);
SwitchStatement.prototype.visit = function(visitor) {
  return visitor.visitSwitchStatement(this);
}
// ********** Code for BlockStatement **************
function BlockStatement(body, span0) {
  this.body = body;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(BlockStatement, lang_Statement);
BlockStatement.prototype.visit = function(visitor) {
  return visitor.visitBlockStatement(this);
}
// ********** Code for LabeledStatement **************
function LabeledStatement(name, body, span0) {
  this.name = name;
  this.body = body;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(LabeledStatement, lang_Statement);
LabeledStatement.prototype.get$name = function() { return this.name; };
LabeledStatement.prototype.set$name = function(value) { return this.name = value; };
LabeledStatement.prototype.visit = function(visitor) {
  return visitor.visitLabeledStatement(this);
}
// ********** Code for lang_ExpressionStatement **************
function lang_ExpressionStatement(body, span0) {
  this.body = body;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(lang_ExpressionStatement, lang_Statement);
lang_ExpressionStatement.prototype.visit = function(visitor) {
  return visitor.visitExpressionStatement(this);
}
// ********** Code for EmptyStatement **************
function EmptyStatement(span0) {
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(EmptyStatement, lang_Statement);
EmptyStatement.prototype.visit = function(visitor) {
  return visitor.visitEmptyStatement(this);
}
// ********** Code for DietStatement **************
function DietStatement(span0) {
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(DietStatement, lang_Statement);
DietStatement.prototype.visit = function(visitor) {
  return visitor.visitDietStatement(this);
}
// ********** Code for NativeStatement **************
function NativeStatement(body, span0) {
  this.body = body;
  lang_Statement.call(this, span0);
  // Initializers done
}
$inherits(NativeStatement, lang_Statement);
NativeStatement.prototype.visit = function(visitor) {
  return visitor.visitNativeStatement(this);
}
// ********** Code for LambdaExpression **************
function LambdaExpression(func, span0) {
  this.func = func;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(LambdaExpression, lang_Expression);
LambdaExpression.prototype.visit = function(visitor) {
  return visitor.visitLambdaExpression(this);
}
// ********** Code for CallExpression **************
function CallExpression(target, arguments, span0) {
  this.target = target;
  this.arguments = arguments;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(CallExpression, lang_Expression);
CallExpression.prototype.is$CallExpression = function(){return this;};
CallExpression.prototype.get$arguments = function() { return this.arguments; };
CallExpression.prototype.set$arguments = function(value) { return this.arguments = value; };
CallExpression.prototype.visit = function(visitor) {
  return visitor.visitCallExpression(this);
}
// ********** Code for IndexExpression **************
function IndexExpression(target, index, span0) {
  this.target = target;
  this.index = index;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(IndexExpression, lang_Expression);
IndexExpression.prototype.is$IndexExpression = function(){return this;};
IndexExpression.prototype.visit = function(visitor) {
  return visitor.visitIndexExpression(this);
}
// ********** Code for BinaryExpression **************
function BinaryExpression(op, x, y, span0) {
  this.op = op;
  this.x = x;
  this.y = y;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(BinaryExpression, lang_Expression);
BinaryExpression.prototype.is$BinaryExpression = function(){return this;};
BinaryExpression.prototype.visit = function(visitor) {
  return visitor.visitBinaryExpression(this);
}
// ********** Code for UnaryExpression **************
function UnaryExpression(op, self, span0) {
  this.op = op;
  this.self = self;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(UnaryExpression, lang_Expression);
UnaryExpression.prototype.visit = function(visitor) {
  return visitor.visitUnaryExpression(this);
}
// ********** Code for PostfixExpression **************
function PostfixExpression(body, op, span0) {
  this.body = body;
  this.op = op;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(PostfixExpression, lang_Expression);
PostfixExpression.prototype.is$PostfixExpression = function(){return this;};
PostfixExpression.prototype.visit = function(visitor) {
  return visitor.visitPostfixExpression$1(this);
}
// ********** Code for lang_NewExpression **************
function lang_NewExpression(isConst, type, name, arguments, span0) {
  this.isConst = isConst;
  this.type = type;
  this.name = name;
  this.arguments = arguments;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(lang_NewExpression, lang_Expression);
lang_NewExpression.prototype.get$isConst = function() { return this.isConst; };
lang_NewExpression.prototype.set$isConst = function(value) { return this.isConst = value; };
lang_NewExpression.prototype.get$name = function() { return this.name; };
lang_NewExpression.prototype.set$name = function(value) { return this.name = value; };
lang_NewExpression.prototype.get$arguments = function() { return this.arguments; };
lang_NewExpression.prototype.set$arguments = function(value) { return this.arguments = value; };
lang_NewExpression.prototype.visit = function(visitor) {
  return visitor.visitNewExpression(this);
}
// ********** Code for ListExpression **************
function ListExpression(isConst, type, values, span0) {
  this.isConst = isConst;
  this.type = type;
  this.values = values;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(ListExpression, lang_Expression);
ListExpression.prototype.get$isConst = function() { return this.isConst; };
ListExpression.prototype.set$isConst = function(value) { return this.isConst = value; };
ListExpression.prototype.visit = function(visitor) {
  return visitor.visitListExpression(this);
}
// ********** Code for MapExpression **************
function MapExpression(isConst, type, items, span0) {
  this.isConst = isConst;
  this.type = type;
  this.items = items;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(MapExpression, lang_Expression);
MapExpression.prototype.get$isConst = function() { return this.isConst; };
MapExpression.prototype.set$isConst = function(value) { return this.isConst = value; };
MapExpression.prototype.visit = function(visitor) {
  return visitor.visitMapExpression(this);
}
// ********** Code for ConditionalExpression **************
function ConditionalExpression(test, trueBranch, falseBranch, span0) {
  this.test = test;
  this.trueBranch = trueBranch;
  this.falseBranch = falseBranch;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(ConditionalExpression, lang_Expression);
ConditionalExpression.prototype.visit = function(visitor) {
  return visitor.visitConditionalExpression(this);
}
// ********** Code for IsExpression **************
function IsExpression(isTrue, x, type, span0) {
  this.isTrue = isTrue;
  this.x = x;
  this.type = type;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(IsExpression, lang_Expression);
IsExpression.prototype.visit = function(visitor) {
  return visitor.visitIsExpression(this);
}
// ********** Code for ParenExpression **************
function ParenExpression(body, span0) {
  this.body = body;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(ParenExpression, lang_Expression);
ParenExpression.prototype.visit = function(visitor) {
  return visitor.visitParenExpression(this);
}
// ********** Code for DotExpression **************
function DotExpression(self, name, span0) {
  this.self = self;
  this.name = name;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(DotExpression, lang_Expression);
DotExpression.prototype.is$DotExpression = function(){return this;};
DotExpression.prototype.get$name = function() { return this.name; };
DotExpression.prototype.set$name = function(value) { return this.name = value; };
DotExpression.prototype.visit = function(visitor) {
  return visitor.visitDotExpression(this);
}
// ********** Code for VarExpression **************
function VarExpression(name, span0) {
  this.name = name;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(VarExpression, lang_Expression);
VarExpression.prototype.is$VarExpression = function(){return this;};
VarExpression.prototype.get$name = function() { return this.name; };
VarExpression.prototype.set$name = function(value) { return this.name = value; };
VarExpression.prototype.visit = function(visitor) {
  return visitor.visitVarExpression(this);
}
// ********** Code for ThisExpression **************
function ThisExpression(span0) {
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(ThisExpression, lang_Expression);
ThisExpression.prototype.visit = function(visitor) {
  return visitor.visitThisExpression(this);
}
// ********** Code for SuperExpression **************
function SuperExpression(span0) {
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(SuperExpression, lang_Expression);
SuperExpression.prototype.visit = function(visitor) {
  return visitor.visitSuperExpression(this);
}
// ********** Code for NullExpression **************
function NullExpression(span0) {
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(NullExpression, lang_Expression);
NullExpression.prototype.visit = function(visitor) {
  return visitor.visitNullExpression(this);
}
// ********** Code for LiteralExpression **************
function LiteralExpression(value, type, text, span0) {
  this.value = value;
  this.type = type;
  this.text = text;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(LiteralExpression, lang_Expression);
LiteralExpression.prototype.get$value = function() { return this.value; };
LiteralExpression.prototype.set$value = function(value) { return this.value = value; };
LiteralExpression.prototype.get$text = function() { return this.text; };
LiteralExpression.prototype.set$text = function(value) { return this.text = value; };
LiteralExpression.prototype.visit = function(visitor) {
  return visitor.visitLiteralExpression(this);
}
// ********** Code for NameTypeReference **************
function NameTypeReference(isFinal, name, names, span0) {
  this.isFinal = isFinal;
  this.name = name;
  this.names = names;
  TypeReference.call(this, span0);
  // Initializers done
}
$inherits(NameTypeReference, TypeReference);
NameTypeReference.prototype.is$NameTypeReference = function(){return this;};
NameTypeReference.prototype.get$name = function() { return this.name; };
NameTypeReference.prototype.set$name = function(value) { return this.name = value; };
NameTypeReference.prototype.visit = function(visitor) {
  return visitor.visitNameTypeReference(this);
}
// ********** Code for GenericTypeReference **************
function GenericTypeReference(baseType, typeArguments, depth, span0) {
  this.baseType = baseType;
  this.typeArguments = typeArguments;
  this.depth = depth;
  TypeReference.call(this, span0);
  // Initializers done
}
$inherits(GenericTypeReference, TypeReference);
GenericTypeReference.prototype.visit = function(visitor) {
  return visitor.visitGenericTypeReference(this);
}
// ********** Code for FunctionTypeReference **************
function FunctionTypeReference(isFinal, func, span0) {
  this.isFinal = isFinal;
  this.func = func;
  TypeReference.call(this, span0);
  // Initializers done
}
$inherits(FunctionTypeReference, TypeReference);
FunctionTypeReference.prototype.visit = function(visitor) {
  return visitor.visitFunctionTypeReference(this);
}
// ********** Code for ArgumentNode **************
function ArgumentNode(label, value, span0) {
  this.label = label;
  this.value = value;
  lang_Node.call(this, span0);
  // Initializers done
}
$inherits(ArgumentNode, lang_Node);
ArgumentNode.prototype.is$ArgumentNode = function(){return this;};
ArgumentNode.prototype.get$value = function() { return this.value; };
ArgumentNode.prototype.set$value = function(value) { return this.value = value; };
ArgumentNode.prototype.visit = function(visitor) {
  return visitor.visitArgumentNode(this);
}
// ********** Code for FormalNode **************
function FormalNode(isThis, isRest, type, name, value, span0) {
  this.isThis = isThis;
  this.isRest = isRest;
  this.type = type;
  this.name = name;
  this.value = value;
  lang_Node.call(this, span0);
  // Initializers done
}
$inherits(FormalNode, lang_Node);
FormalNode.prototype.get$name = function() { return this.name; };
FormalNode.prototype.set$name = function(value) { return this.name = value; };
FormalNode.prototype.get$value = function() { return this.value; };
FormalNode.prototype.set$value = function(value) { return this.value = value; };
FormalNode.prototype.visit = function(visitor) {
  return visitor.visitFormalNode(this);
}
// ********** Code for CatchNode **************
function CatchNode(exception, trace, body, span0) {
  this.exception = exception;
  this.trace = trace;
  this.body = body;
  lang_Node.call(this, span0);
  // Initializers done
}
$inherits(CatchNode, lang_Node);
CatchNode.prototype.get$exception = function() { return this.exception; };
CatchNode.prototype.set$exception = function(value) { return this.exception = value; };
CatchNode.prototype.visit = function(visitor) {
  return visitor.visitCatchNode(this);
}
// ********** Code for CaseNode **************
function CaseNode(label, cases, statements, span0) {
  this.label = label;
  this.cases = cases;
  this.statements = statements;
  lang_Node.call(this, span0);
  // Initializers done
}
$inherits(CaseNode, lang_Node);
CaseNode.prototype.visit = function(visitor) {
  return visitor.visitCaseNode(this);
}
// ********** Code for TypeParameter **************
function TypeParameter(name, extendsType, span0) {
  this.name = name;
  this.extendsType = extendsType;
  lang_Node.call(this, span0);
  // Initializers done
}
$inherits(TypeParameter, lang_Node);
TypeParameter.prototype.get$name = function() { return this.name; };
TypeParameter.prototype.set$name = function(value) { return this.name = value; };
TypeParameter.prototype.visit = function(visitor) {
  return visitor.visitTypeParameter(this);
}
// ********** Code for lang_Identifier **************
function lang_Identifier(name, span0) {
  this.name = name;
  lang_Node.call(this, span0);
  // Initializers done
}
$inherits(lang_Identifier, lang_Node);
lang_Identifier.prototype.get$name = function() { return this.name; };
lang_Identifier.prototype.set$name = function(value) { return this.name = value; };
lang_Identifier.prototype.visit = function(visitor) {
  return visitor.visitIdentifier(this);
}
// ********** Code for DeclaredIdentifier **************
function DeclaredIdentifier(type, name, span0) {
  this.type = type;
  this.name = name;
  lang_Expression.call(this, span0);
  // Initializers done
}
$inherits(DeclaredIdentifier, lang_Expression);
DeclaredIdentifier.prototype.is$DeclaredIdentifier = function(){return this;};
DeclaredIdentifier.prototype.get$name = function() { return this.name; };
DeclaredIdentifier.prototype.set$name = function(value) { return this.name = value; };
DeclaredIdentifier.prototype.visit = function(visitor) {
  return visitor.visitDeclaredIdentifier(this);
}
// ********** Code for lang_Type **************
function lang_Type(name) {
  this.name = name;
  this.isTested = false;
  // Initializers done
}
lang_Type.prototype.is$lang_Type = function(){return this;};
lang_Type.prototype.is$Named = function(){return this;};
lang_Type.prototype.get$name = function() { return this.name; };
lang_Type.prototype.markUsed = function() {

}
lang_Type.prototype.get$typeMember = function() {
  var $0;
  if ($notnull_bool(this._typeMember == null)) {
    this._typeMember = new TypeMember((($0 = this) && $0.is$DefinedType()));
  }
  return this._typeMember;
}
lang_Type.prototype.getMember = function(name0) {
  return null;
}
lang_Type.prototype.get$isVar = function() {
  return false;
}
lang_Type.prototype.get$isTop = function() {
  return false;
}
lang_Type.prototype.get$isObject = function() {
  return false;
}
lang_Type.prototype.get$isString = function() {
  return false;
}
lang_Type.prototype.get$isBool = function() {
  return false;
}
lang_Type.prototype.get$isFunction = function() {
  return false;
}
lang_Type.prototype.get$isList = function() {
  return false;
}
lang_Type.prototype.get$isNum = function() {
  return false;
}
lang_Type.prototype.get$isVoid = function() {
  return false;
}
lang_Type.prototype.get$isVarOrFunction = function() {
  return this.get$isVar() || this.get$isFunction();
}
lang_Type.prototype.getCallMethod = function() {
  return null;
}
lang_Type.prototype.get$isClosed = function() {
  return this.get$isString() || this.get$isBool() || this.get$isNum() || this.get$isFunction() || this.get$isVar();
}
lang_Type.prototype.get$isUsed = function() {
  return false;
}
lang_Type.prototype.get$isGeneric = function() {
  return false;
}
lang_Type.prototype.get$isNativeType = function() {
  return false;
}
lang_Type.prototype.get$isNative = function() {
  return this.get$isNativeType();
}
lang_Type.prototype.get$hasTypeParams = function() {
  return false;
}
lang_Type.prototype.get$typeofName = function() {
  return null;
}
lang_Type.prototype.get$jsname = function() {
  return $notnull_bool(this._jsname == null) ? this.name : this._jsname;
}
lang_Type.prototype.set$jsname = function(name0) {
  return this._jsname = name0;
}
lang_Type.prototype.get$typeArgsInOrder = function() {
  return null;
}
lang_Type.prototype.get$genericType = function() {
  return this;
}
lang_Type.prototype.get$interfaces = function() {
  return null;
}
lang_Type.prototype.get$parent = function() {
  return null;
}
lang_Type.prototype.getAllMembers = function() {
  return $map([]);
}
lang_Type.prototype.hashCode = function() {
  return this.name.hashCode();
}
lang_Type.prototype.ensureSubtypeOf = function(other, span0, typeErrors) {
  if ($notnull_bool(!this.isSubtypeOf(other))) {
    var msg = ('type ' + this.name + ' is not a subtype of ' + other.name + '');
    if ($notnull_bool(typeErrors)) {
      world.error($assert_String(msg), span0);
    }
    else {
      world.warning($assert_String(msg), span0);
    }
  }
}
lang_Type.prototype.needsVarCall = function(args) {
  if ($notnull_bool(this.get$isVarOrFunction())) {
    return true;
  }
  var call = this.getCallMethod();
  if ($notnull_bool($ne(call, null))) {
    if ($notnull_bool(args.get$length() != call.get$parameters().length || !call.namesInOrder(args))) {
      return true;
    }
  }
  return false;
}
lang_Type.union = function(x, y) {
  if ($notnull_bool($eq(x, y))) return x;
  if ($notnull_bool(x.get$isNum() && y.get$isNum())) return world.numType;
  if ($notnull_bool(x.get$isString() && y.get$isString())) return world.stringType;
  return world.varType;
}
lang_Type.prototype.isAssignable = function(other) {
  return this.isSubtypeOf(other) || other.isSubtypeOf(this);
}
lang_Type.prototype._isDirectSupertypeOf = function(other) {
  var $this = this; // closure support
  if ($notnull_bool(other.get$isClass())) {
    return $eq(other.get$parent(), this) || this.get$isObject() && other.get$parent() == null;
  }
  else {
    if ($notnull_bool(other.get$interfaces() == null || other.get$interfaces().isEmpty())) {
      return this.get$isObject();
    }
    else {
      return other.get$interfaces().some((function (i) {
        return $eq(i, $this);
      })
      );
    }
  }
}
lang_Type.prototype.isSubtypeOf = function(other) {
  if ($notnull_bool((other instanceof ParameterType))) {
    return true;
  }
  if ($notnull_bool($eq(this, other))) return true;
  if ($notnull_bool(this.get$isVar())) return true;
  if ($notnull_bool(other.get$isVar())) return true;
  if ($notnull_bool(other._isDirectSupertypeOf(this))) return true;
  var call = this.getCallMethod();
  var otherCall = other.getCallMethod();
  if ($notnull_bool($ne(call, null) && $ne(otherCall, null))) {
    return lang_Type._isFunctionSubtypeOf((call && call.is$MethodMember()), (otherCall && otherCall.is$MethodMember()));
  }
  if ($notnull_bool($eq(this.get$genericType(), other.get$genericType()) && $ne(this.get$typeArgsInOrder(), null) && $ne(other.get$typeArgsInOrder(), null) && this.get$typeArgsInOrder().length == other.get$typeArgsInOrder().length)) {
    var t = this.get$typeArgsInOrder().iterator();
    var s = other.get$typeArgsInOrder().iterator();
    while ($notnull_bool(t.hasNext())) {
      if ($notnull_bool(!t.next().isSubtypeOf(s.next()))) return false;
    }
    return true;
  }
  if ($notnull_bool(this.get$parent() != null && this.get$parent().isSubtypeOf(other))) {
    return true;
  }
  if ($notnull_bool(this.get$interfaces() != null && this.get$interfaces().some((function (i) {
    return i.isSubtypeOf(other);
  })
  ))) {
    return true;
  }
  return false;
}
lang_Type._isFunctionSubtypeOf = function(t, s) {
  var $0;
  if ($notnull_bool(!s.returnType.get$isVoid() && !s.returnType.isAssignable(t.returnType))) {
    return false;
  }
  var tp = t.parameters;
  var sp = s.parameters;
  if ($notnull_bool(tp.length < sp.length)) return false;
  for (var i = 0;
   $notnull_bool(i < sp.length); i++) {
    if ($notnull_bool($ne(tp.$index(i).get$isOptional(), sp.$index(i).get$isOptional()))) return false;
    if ($notnull_bool(tp.$index(i).get$isOptional() && $ne(tp.$index(i).get$name(), sp.$index(i).get$name()))) return false;
    if ($notnull_bool(!tp.$index(i).type.isAssignable((($0 = sp.$index(i).type) && $0.is$lang_Type())))) return false;
  }
  if ($notnull_bool(tp.length > sp.length && !tp.$index(sp.length).get$isOptional())) return false;
  return true;
}
// ********** Code for ParameterType **************
function ParameterType(name0, typeParameter) {
  this.typeParameter = typeParameter;
  lang_Type.call(this, name0);
  // Initializers done
}
$inherits(ParameterType, lang_Type);
ParameterType.prototype.get$isClass = function() {
  return false;
}
ParameterType.prototype.get$library = function() {
  return null;
}
ParameterType.prototype.get$span = function() {
  return this.typeParameter.span;
}
ParameterType.prototype.getCallMethod = function() {
  return this.extendsType.getCallMethod();
}
ParameterType.prototype.genMethod = function(method) {
  this.extendsType.genMethod(method);
}
ParameterType.prototype.isSubtypeOf = function(child) {
  return true;
}
ParameterType.prototype.resolveMember = function(memberName) {
  return this.extendsType.resolveMember(memberName);
}
ParameterType.prototype.getConstructor = function(constructorName) {
  world.internalError('no constructors on type parameters yet');
}
ParameterType.prototype.resolveTypeParams = function(inType) {
  return inType.typeArguments.$index(this.name);
}
ParameterType.prototype.resolve = function(inType) {
  if ($notnull_bool(this.typeParameter.extendsType != null)) {
    this.extendsType = inType.resolveType(this.typeParameter.extendsType, true);
  }
  else {
    this.extendsType = world.objectType;
  }
}
// ********** Code for ConcreteType **************
function ConcreteType(name0, genericType, typeArguments, typeArgsInOrder) {
  this.genericType = genericType;
  this.typeArguments = typeArguments;
  this.typeArgsInOrder = typeArgsInOrder;
  this.constructors = $map([]);
  this.members = $map([]);
  this.factories = new FactoryMap();
  lang_Type.call(this, name0);
  // Initializers done
}
$inherits(ConcreteType, lang_Type);
ConcreteType.prototype.get$genericType = function() { return this.genericType; };
ConcreteType.prototype.get$typeArgsInOrder = function() { return this.typeArgsInOrder; };
ConcreteType.prototype.set$typeArgsInOrder = function(value) { return this.typeArgsInOrder = value; };
ConcreteType.prototype.get$isList = function() {
  return this.genericType.get$isList();
}
ConcreteType.prototype.get$isClass = function() {
  return this.genericType.get$isClass();
}
ConcreteType.prototype.get$library = function() {
  return this.genericType.get$library();
}
ConcreteType.prototype.get$span = function() {
  return this.genericType.get$span();
}
ConcreteType.prototype.get$hasTypeParams = function() {
  return this.typeArguments.getValues().some((function (e) {
    return (e instanceof ParameterType);
  })
  );
}
ConcreteType.prototype.resolveTypeParams = function(inType) {
  var newTypeArgs = [];
  var needsNewType = false;
  var $list = this.typeArgsInOrder;
  for (var $i = 0;$i < $list.length; $i++) {
    var t = $list.$index($i);
    var newType = t.resolveTypeParams(inType);
    if ($notnull_bool($ne(newType, t))) needsNewType = true;
    newTypeArgs.add(newType);
  }
  if ($notnull_bool(!needsNewType)) return this;
  return this.genericType.getOrMakeConcreteType(newTypeArgs);
}
ConcreteType.prototype.getOrMakeConcreteType = function(typeArgs) {
  return this.genericType.getOrMakeConcreteType(typeArgs);
}
ConcreteType.prototype.get$parent = function() {
  return this.genericType.get$parent();
}
ConcreteType.prototype.get$interfaces = function() {
  if ($notnull_bool(this._interfaces == null && this.genericType.get$interfaces() != null)) {
    this._interfaces = [];
    var $list = this.genericType.get$interfaces();
    for (var $i = 0;$i < $list.length; $i++) {
      var i = $list.$index($i);
      this._interfaces.add(i.resolveTypeParams(this));
    }
  }
  return this._interfaces;
}
ConcreteType.prototype.getCallMethod = function() {
  return this.genericType.getCallMethod();
}
ConcreteType.prototype.getAllMembers = function() {
  var $0;
  var result = this.genericType.getAllMembers();
  var $list = result.getKeys();
  for (var $i = result.getKeys().iterator(); $i.hasNext(); ) {
    var memberName = $i.next();
    var myMember = this.members.$index(memberName);
    if ($notnull_bool($ne(myMember, null))) {
      result.$setindex(memberName, myMember);
    }
  }
  return result;
}
ConcreteType.prototype.markUsed = function() {
  this.genericType.markUsed();
}
ConcreteType.prototype.genMethod = function(method) {
  this.genericType.genMethod(method);
}
ConcreteType.prototype.getFactory = function(type, constructorName) {
  return this.genericType.getFactory(type, constructorName);
}
ConcreteType.prototype.getConstructor = function(constructorName) {
  var ret = this.constructors.$index(constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  ret = this.factories.getFactory(this.name, constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  var genericMember = this.genericType.getConstructor(constructorName);
  if ($notnull_bool(genericMember == null)) return null;
  if ($notnull_bool($ne(genericMember.declaringType, this.genericType))) {
    if ($notnull_bool(!genericMember.declaringType.get$isGeneric())) return genericMember;
    var newDeclaringType = genericMember.declaringType.getOrMakeConcreteType(this.typeArgsInOrder);
    return newDeclaringType.getConstructor(constructorName);
  }
  if ($notnull_bool(genericMember.get$isFactory())) {
    ret = new ConcreteMember($assert_String(genericMember.get$name()), this, genericMember);
    this.factories.addFactory(this.name, constructorName, (ret && ret.is$Member()));
  }
  else {
    ret = new ConcreteMember(this.name, this, genericMember);
    this.constructors.$setindex(constructorName, ret);
  }
  return ret;
}
ConcreteType.prototype.getMember = function(memberName) {
  var ret = this.members.$index(memberName);
  if ($notnull_bool($ne(ret, null))) return ret;
  var genericMember = this.genericType.getMember(memberName);
  if ($notnull_bool(genericMember == null)) return null;
  ret = new ConcreteMember($assert_String(genericMember.get$name()), this, genericMember);
  this.members.$setindex(memberName, ret);
  return ret;
}
ConcreteType.prototype.resolveMember = function(memberName) {
  var $0;
  var mem = this.getMember(memberName);
  if ($notnull_bool(mem == null)) return null;
  var ret = new MemberSet((mem && mem.is$Member()));
  if ($notnull_bool(mem.get$isStatic())) return ret;
  var $list = this.genericType.get$subtypes();
  for (var $i = this.genericType.get$subtypes().iterator(); $i.hasNext(); ) {
    var t = $i.next();
    var m = t.members.$index(memberName);
    if ($notnull_bool($ne(m, null))) ret.add(m);
  }
  return ret;
}
ConcreteType.prototype.resolveType = function(node, isRequired) {
  var ret = this.genericType.resolveType(node, isRequired);
  return ret;
}
ConcreteType.prototype.addDirectSubtype = function(type) {
  this.genericType.addDirectSubtype(type);
}
// ********** Code for DefinedType **************
function DefinedType(name0, library, definition0, isClass) {
  this.isUsed = false
  this.isNativeType = false
  this.library = library;
  this.isClass = isClass;
  this.directSubtypes = new HashSetImplementation$Type();
  this.constructors = $map([]);
  this.members = $map([]);
  this.factories = new FactoryMap();
  this._resolvedMembers = $map([]);
  lang_Type.call(this, name0);
  // Initializers done
  this.setDefinition(definition0);
}
$inherits(DefinedType, lang_Type);
DefinedType.prototype.is$DefinedType = function(){return this;};
DefinedType.prototype.get$definition = function() { return this.definition; };
DefinedType.prototype.set$definition = function(value) { return this.definition = value; };
DefinedType.prototype.get$library = function() { return this.library; };
DefinedType.prototype.get$isClass = function() { return this.isClass; };
DefinedType.prototype.get$parent = function() { return this.parent; };
DefinedType.prototype.set$parent = function(value) { return this.parent = value; };
DefinedType.prototype.get$interfaces = function() { return this.interfaces; };
DefinedType.prototype.set$interfaces = function(value) { return this.interfaces = value; };
DefinedType.prototype.get$typeParameters = function() { return this.typeParameters; };
DefinedType.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
DefinedType.prototype.get$isUsed = function() { return this.isUsed; };
DefinedType.prototype.set$isUsed = function(value) { return this.isUsed = value; };
DefinedType.prototype.get$isNativeType = function() { return this.isNativeType; };
DefinedType.prototype.set$isNativeType = function(value) { return this.isNativeType = value; };
DefinedType.prototype.setDefinition = function(def) {
  $assert(this.definition == null, "definition == null", "type.dart", 541, 12);
  this.definition = def;
  if ($notnull_bool((this.definition instanceof TypeDefinition) && this.definition.nativeType != null)) {
    this.isNativeType = true;
  }
  if ($notnull_bool(this.definition != null && this.definition.get$typeParameters() != null)) {
    this._concreteTypes = $map([]);
    this.typeParameters = [];
    var $list = this.definition.get$typeParameters();
    for (var $i = 0;$i < $list.length; $i++) {
      var tp = $list.$index($i);
      var paramName = tp.get$name().get$name();
      this.typeParameters.add(new ParameterType($assert_String(paramName), tp));
    }
  }
}
DefinedType.prototype.get$typeArgsInOrder = function() {
  if ($notnull_bool(this.typeParameters == null)) return null;
  if ($notnull_bool(this._typeArgsInOrder == null)) {
    this._typeArgsInOrder = new FixedCollection$Type(world.varType, this.typeParameters.length);
  }
  return this._typeArgsInOrder;
}
DefinedType.prototype.get$isVar = function() {
  return $eq(this, world.varType);
}
DefinedType.prototype.get$isVoid = function() {
  return $eq(this, world.voidType);
}
DefinedType.prototype.get$isTop = function() {
  return this.name == null;
}
DefinedType.prototype.get$isObject = function() {
  return this.library.get$isCore() && this.name == 'Object';
}
DefinedType.prototype.get$isString = function() {
  return this.library.get$isCore() && this.name == 'String' || this.library.get$isCoreImpl() && this.name == 'StringImplementation';
}
DefinedType.prototype.get$isBool = function() {
  return this.library.get$isCore() && this.name == 'bool';
}
DefinedType.prototype.get$isFunction = function() {
  return this.library.get$isCore() && this.name == 'Function';
}
DefinedType.prototype.get$isList = function() {
  return this.library.get$isCore() && this.name == 'List';
}
DefinedType.prototype.get$isGeneric = function() {
  return this.typeParameters != null;
}
DefinedType.prototype.get$span = function() {
  return $notnull_bool(this.definition == null) ? null : this.definition.span;
}
DefinedType.prototype.get$typeofName = function() {
  if ($notnull_bool(!this.library.get$isCore())) return null;
  if ($notnull_bool(this.get$isBool())) return 'boolean';
  else if ($notnull_bool(this.get$isNum())) return 'number';
  else if ($notnull_bool(this.get$isString())) return 'string';
  else if ($notnull_bool(this.get$isFunction())) return 'function';
  else return null;
}
DefinedType.prototype.get$isNum = function() {
  return this.library != null && this.library.get$isCore() && (this.name == 'num' || this.name == 'int' || this.name == 'double');
}
DefinedType.prototype.getCallMethod = function() {
  return this.members.$index('\$call');
}
DefinedType.prototype.getAllMembers = function() {
  return HashMapImplementation.HashMapImplementation$from$factory(this.members);
}
DefinedType.prototype.markUsed = function() {
  if ($notnull_bool(this.isUsed)) return;
  this.isUsed = true;
  if ($notnull_bool(this._lazyGenMethods != null)) {
    var $list = orderValuesByKeys(this._lazyGenMethods);
    for (var $i = 0;$i < $list.length; $i++) {
      var method = $list.$index($i);
      world.gen.genMethod((method && method.is$Member()));
    }
    this._lazyGenMethods = null;
  }
  if ($notnull_bool(this.parent != null)) this.parent.markUsed();
}
DefinedType.prototype.genMethod = function(method) {
  if ($notnull_bool(this.isUsed)) {
    world.gen.genMethod(method);
  }
  else if ($notnull_bool(this.isClass)) {
    if ($notnull_bool(this._lazyGenMethods == null)) this._lazyGenMethods = $map([]);
    this._lazyGenMethods.$setindex(method.name, method);
  }
}
DefinedType.prototype._resolveInterfaces = function(types) {
  if ($notnull_bool(types == null)) return [];
  var interfaces0 = [];
  for (var $i = 0;$i < types.length; $i++) {
    var type = types.$index($i);
    var resolvedInterface = this.resolveType((type && type.is$TypeReference()), true);
    if ($notnull_bool(resolvedInterface.get$isClosed() && !(this.library.get$isCore() || this.library.get$isCoreImpl()))) {
      world.error(('can not implement "' + resolvedInterface.get$name() + '": ') + 'only native implementation allowed', type.get$span());
    }
    resolvedInterface.addDirectSubtype(this);
    interfaces0.add(resolvedInterface);
  }
  return interfaces0;
}
DefinedType.prototype.addDirectSubtype = function(type) {
  $assert(this._subtypes == null, "_subtypes == null", "type.dart", 657, 12);
  this.directSubtypes.add(type);
}
DefinedType.prototype.get$subtypes = function() {
  var $0;
  if ($notnull_bool(this._subtypes == null)) {
    this._subtypes = new HashSetImplementation$Type();
    var $list = this.directSubtypes;
    for (var $i = this.directSubtypes.iterator(); $i.hasNext(); ) {
      var st = $i.next();
      this._subtypes.add(st);
      this._subtypes.addAll(st.get$subtypes());
    }
  }
  return this._subtypes;
}
DefinedType.prototype._cycleInClassExtends = function() {
  var seen = new HashSetImplementation();
  seen.add(this);
  var ancestor = this.parent;
  while ($notnull_bool($ne(ancestor, null))) {
    if ($notnull_bool(ancestor === this)) {
      return true;
    }
    if ($notnull_bool(seen.contains(ancestor))) {
      return false;
    }
    seen.add(ancestor);
    ancestor = ancestor.get$parent();
  }
  return false;
}
DefinedType.prototype._cycleInInterfaceExtends = function() {
  var $this = this; // closure support
  var seen = new HashSetImplementation();
  seen.add(this);
  function _helper(ancestor) {
    if ($notnull_bool(ancestor == null)) return false;
    if ($notnull_bool(ancestor === $this)) return true;
    if ($notnull_bool(seen.contains(ancestor))) {
      return false;
    }
    seen.add(ancestor);
    if ($notnull_bool(ancestor.get$interfaces() != null)) {
      var $list = ancestor.get$interfaces();
      for (var $i = 0;$i < $list.length; $i++) {
        var parent0 = $list.$index($i);
        if ($notnull_bool(_helper(parent0))) return true;
      }
    }
    return false;
  }
  for (var i = 0;
   $notnull_bool(i < this.interfaces.length); i++) {
    if ($notnull_bool(_helper(this.interfaces.$index(i)))) return i;
  }
  return -1;
}
DefinedType.prototype.resolve = function() {
  var $this = this; // closure support
  var $0;
  if ($notnull_bool((this.definition instanceof TypeDefinition))) {
    if ($notnull_bool(this.isClass)) {
      if ($notnull_bool(this.definition.extendsTypes != null && this.definition.extendsTypes.length > 0)) {
        if ($notnull_bool(this.definition.extendsTypes.length > 1)) {
          world.error('more than one base class', this.definition.extendsTypes.$index(1).get$span());
        }
        var extendsTypeRef = this.definition.extendsTypes.$index(0);
        if ($notnull_bool((extendsTypeRef instanceof GenericTypeReference))) {
          var g = extendsTypeRef;
          this.parent = this.resolveType(g.baseType, true);
        }
        this.parent = this.resolveType((extendsTypeRef && extendsTypeRef.is$TypeReference()), true);
        if ($notnull_bool(!this.parent.get$isClass())) {
          world.error('class may not extend an interface - use implements', this.definition.extendsTypes.$index(0).get$span());
        }
        this.parent.addDirectSubtype(this);
        if ($notnull_bool(this._cycleInClassExtends())) {
          world.error(('class "' + this.name + '" has a cycle in its inheritance chain'), extendsTypeRef.get$span());
        }
      }
      else {
        if ($notnull_bool(!this.get$isObject())) {
          this.parent = world.objectType;
        }
      }
      this.interfaces = this._resolveInterfaces(this.definition.implementsTypes);
      if ($notnull_bool(this.definition.factoryType != null)) {
        world.error('factory not allowed on classes', this.definition.factoryType.span);
      }
    }
    else {
      if ($notnull_bool(this.definition.implementsTypes != null && this.definition.implementsTypes.length > 0)) {
        world.error('implements not allowed on interfaces (use extends)', this.definition.implementsTypes.$index(0).get$span());
      }
      this.interfaces = this._resolveInterfaces(this.definition.extendsTypes);
      var res = this._cycleInInterfaceExtends();
      if ($notnull_bool(res >= 0)) {
        world.error(('interface "' + this.name + '" has a cycle in its inheritance chain'), this.definition.extendsTypes.$index(res).get$span());
      }
      if ($notnull_bool(this.definition.factoryType != null)) {
        this.factory_ = this.resolveType(this.definition.factoryType, true);
        if ($notnull_bool(this.factory_ == null)) {
          world.info(('unresolved factory: ' + this.definition.factoryType.get$name().get$name() + ''), this.definition.factoryType.get$name().get$span());
        }
      }
    }
  }
  else if ($notnull_bool((this.definition instanceof FunctionTypeDefinition))) {
    this.interfaces = [world.functionType];
  }
  if ($notnull_bool(this.typeParameters != null)) {
    var $list = this.typeParameters;
    for (var $i = 0;$i < $list.length; $i++) {
      var tp = $list.$index($i);
      tp.resolve(this);
    }
  }
  world._addType(this);
  var $list = this.constructors.getValues();
  for (var $i = this.constructors.getValues().iterator(); $i.hasNext(); ) {
    var c = $i.next();
    c.resolve(this);
  }
  var $list0 = this.members.getValues();
  for (var $i = this.members.getValues().iterator(); $i.hasNext(); ) {
    var m = $i.next();
    m.resolve(this);
  }
  this.factories.forEach((function (f) {
    return f.resolve($this);
  })
  );
}
DefinedType.prototype.addMethod = function(methodName, definition0) {
  if ($notnull_bool(methodName == null)) methodName = definition0.name.name;
  var method = new MethodMember(methodName, this, definition0);
  if ($notnull_bool(method.get$isConstructor())) {
    if ($notnull_bool(this.constructors.containsKey(method.get$constructorName()))) {
      world.error(('duplicate constructor definition of ' + method.get$name() + ''), definition0.span);
      return;
    }
    this.constructors.$setindex(method.get$constructorName(), method);
    return;
  }
  if ($notnull_bool(definition0.modifiers != null && definition0.modifiers.length == 1 && definition0.modifiers.$index(0).kind == 75/*TokenKind.FACTORY*/)) {
    if ($notnull_bool(this.factories.getFactory(method.get$constructorName(), $assert_String(method.get$name())) != null)) {
      world.error(('duplicate factory definition of ' + method.get$name() + ''), definition0.span);
      return;
    }
    this.factories.addFactory(method.get$constructorName(), $assert_String(method.get$name()), (method && method.is$Member()));
    return;
  }
  if ($notnull_bool(methodName.startsWith('get\$') || methodName.startsWith('set\$'))) {
    var propName = methodName.substring(4);
    var prop = this.members.$index(propName);
    if ($notnull_bool(prop == null)) {
      prop = new PropertyMember($assert_String(propName), this);
      this.members.$setindex(propName, prop);
    }
    if ($notnull_bool(!(prop instanceof PropertyMember))) {
      world.error(('property conflicts with field name: ' + propName + ''), definition0.span);
      return;
    }
    if ($notnull_bool(methodName[0] == 'g')) {
      if ($notnull_bool(prop.getter != null)) {
        world.error(('duplicate getter definition for ' + propName + ''), definition0.span);
      }
      prop.getter = (method && method.is$MethodMember());
    }
    else {
      if ($notnull_bool(prop.setter != null)) {
        world.error(('duplicate setter definition for ' + propName + ''), definition0.span);
      }
      prop.setter = (method && method.is$MethodMember());
    }
    return;
  }
  if ($notnull_bool(this.members.containsKey(methodName))) {
    world.error(('duplicate method definition of ' + method.get$name() + ''), definition0.span);
    return;
  }
  this.members.$setindex(methodName, method);
}
DefinedType.prototype.addField = function(definition0) {
  for (var i = 0;
   $notnull_bool(i < definition0.names.length); i++) {
    var name0 = definition0.names.$index(i).get$name();
    if ($notnull_bool(this.members.containsKey(name0))) {
      world.error(('duplicate field definition of ' + name0 + ''), definition0.span);
      return;
    }
    var value = null;
    if ($notnull_bool(definition0.values != null)) {
      value = definition0.values.$index(i);
    }
    var field = new FieldMember($assert_String(name0), this, definition0, value);
    this.members.$setindex(name0, field);
    if ($notnull_bool(this.isNativeType)) {
      field.isNative = true;
    }
  }
}
DefinedType.prototype.getFactory = function(type, constructorName) {
  var ret = this.factories.getFactory(type.name, constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  ret = this.factories.getFactory(this.name, constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  ret = this.constructors.$index(constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  return this._tryCreateDefaultConstructor(constructorName);
}
DefinedType.prototype.getConstructor = function(constructorName) {
  var ret = this.constructors.$index(constructorName);
  if ($notnull_bool($ne(ret, null))) {
    if ($notnull_bool(this.factory_ != null)) {
      return this.factory_.getFactory(this, constructorName);
    }
    return ret;
  }
  ret = this.factories.getFactory(this.name, constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  return this._tryCreateDefaultConstructor(constructorName);
}
DefinedType.prototype._tryCreateDefaultConstructor = function(name0) {
  if ($notnull_bool(name0 == '' && this.definition != null && this.isClass && this.constructors.get$length() == 0)) {
    var span0 = this.definition.span;
    var inits = null, body = null;
    if ($notnull_bool(this.isNativeType)) {
      body = new NativeStatement(null, (span0 && span0.is$SourceSpan()));
      inits = null;
    }
    else {
      body = null;
      inits = [new CallExpression(new SuperExpression((span0 && span0.is$SourceSpan())), [], (span0 && span0.is$SourceSpan()))];
    }
    var c = new FunctionDefinition(null, null, this.definition.get$name(), [], inits, body, (span0 && span0.is$SourceSpan()));
    this.addMethod(null, (c && c.is$FunctionDefinition()));
    this.constructors.$index('').resolve(this);
    return this.constructors.$index('');
  }
  return null;
}
DefinedType.prototype.getMember = function(memberName) {
  var member = this.members.$index(memberName);
  if ($notnull_bool(member != null)) {
    var parentMember = this.getMemberInParents(memberName);
    if ($notnull_bool($ne(parentMember, null))) {
      if ($notnull_bool(!member.get$isPrivate() || $eq(member.get$library(), parentMember.get$library()))) {
        member.override(parentMember);
      }
    }
    return member;
  }
  if ($notnull_bool(this.get$isTop())) {
    var libType = this.library.findTypeByName(memberName);
    if ($notnull_bool($ne(libType, null))) {
      return libType.get$typeMember();
    }
  }
  return this.getMemberInParents(memberName);
}
DefinedType.prototype.getMemberInParents = function(memberName) {
  if ($notnull_bool(this.isClass)) {
    if ($notnull_bool(this.parent != null)) {
      return this.parent.getMember(memberName);
    }
    else if ($notnull_bool(this.get$isObject())) {
      if ($notnull_bool(memberName == '\$ne')) {
        var ret = this._createNotEqualMember();
        this.members.$setindex(memberName, ret);
        return ret;
      }
      return null;
    }
  }
  else {
    if ($notnull_bool(this.interfaces != null && this.interfaces.length > 0)) {
      var $list = this.interfaces;
      for (var $i = 0;$i < $list.length; $i++) {
        var i = $list.$index($i);
        var ret = i.getMember(memberName);
        if ($notnull_bool($ne(ret, null))) {
          return ret;
        }
      }
      return null;
    }
    else {
      return world.objectType.getMember(memberName);
    }
  }
}
DefinedType.prototype.resolveMember = function(memberName) {
  var $0;
  var ret = this._resolvedMembers.$index(memberName);
  if ($notnull_bool(ret != null)) return ret;
  var member = this.getMember(memberName);
  if ($notnull_bool(member == null)) {
    return null;
  }
  ret = new MemberSet(member);
  this._resolvedMembers.$setindex(memberName, ret);
  if ($notnull_bool(member.get$isStatic())) {
    return ret;
  }
  else {
    var $list = this.get$subtypes();
    for (var $i = this.get$subtypes().iterator(); $i.hasNext(); ) {
      var t = $i.next();
      var m;
      if ($notnull_bool(!this.isClass && t.get$isClass())) {
        m = t.getMember(memberName);
      }
      else {
        m = t.members.$index(memberName);
      }
      if ($notnull_bool($ne(m, null))) ret.add((m && m.is$Member()));
    }
    return ret;
  }
}
DefinedType.prototype._createNotEqualMember = function() {
  var eq = this.members.$index('\$eq');
  if ($notnull_bool(eq == null)) {
    world.internalError('INTERNAL: object does not define ==', this.definition.span);
  }
  var ne = new MethodMember('\$ne', this, eq.definition);
  ne.isGenerated = true;
  ne.returnType = eq.returnType;
  ne.parameters = eq.parameters;
  ne.isStatic = eq.isStatic;
  ne.isAbstract = eq.isAbstract;
  return ne;
}
DefinedType._getDottedName = function(type) {
  if ($notnull_bool(type.names != null)) {
    var names = map(type.names, (function (n) {
      return n.get$name();
    })
    );
    return type.name.name + '.' + Strings.join((names && names.is$List$String()), '.');
  }
  else {
    return type.name.name;
  }
}
DefinedType.prototype.resolveType = function(node, typeErrors) {
  var $0;
  if ($notnull_bool(node == null)) return world.varType;
  if ($notnull_bool(node.type != null)) return node.type;
  if ($notnull_bool((node instanceof NameTypeReference))) {
    var name0;
    if ($notnull_bool(node.names != null)) {
      name0 = $assert_String(node.names.last().get$name());
    }
    else {
      name0 = $assert_String(node.get$name().get$name());
    }
    if ($notnull_bool(this.typeParameters != null)) {
      var $list = this.typeParameters;
      for (var $i = 0;$i < $list.length; $i++) {
        var tp = $list.$index($i);
        if ($notnull_bool($eq(tp.get$name(), name0))) {
          node.type = (tp && tp.is$lang_Type());
        }
      }
    }
    if ($notnull_bool(node.type == null)) {
      node.type = this.library.findType((node && node.is$NameTypeReference()));
    }
    if ($notnull_bool(node.type == null)) {
      var message = ('can not find type ' + DefinedType._getDottedName((node && node.is$NameTypeReference())) + '');
      if ($notnull_bool(typeErrors)) {
        world.error($assert_String(message), node.span);
        node.type = world.objectType;
      }
      else {
        world.warning($assert_String(message), node.span);
        node.type = world.varType;
      }
    }
  }
  else if ($notnull_bool((node instanceof GenericTypeReference))) {
    var baseType = this.resolveType(node.baseType, typeErrors);
    if ($notnull_bool(!baseType.get$isGeneric())) {
      world.error(('' + baseType.get$name() + ' is not generic'), node.span);
      return null;
    }
    if ($notnull_bool(node.typeArguments.length != baseType.get$typeParameters().length)) {
      world.error('wrong number of type arguments', node.span);
      return null;
    }
    var typeArgs = [];
    for (var i = 0;
     $notnull_bool(i < node.typeArguments.length); i++) {
      var extendsType = baseType.get$typeParameters().$index(i).extendsType;
      var typeArg = this.resolveType((($0 = node.typeArguments.$index(i)) && $0.is$TypeReference()), typeErrors);
      typeArgs.add(typeArg);
      if ($notnull_bool($ne(extendsType, null) && !(typeArg instanceof ParameterType))) {
        typeArg.ensureSubtypeOf((extendsType && extendsType.is$lang_Type()), node.typeArguments.$index(i).get$span(), typeErrors);
      }
    }
    node.type = baseType.getOrMakeConcreteType(typeArgs);
  }
  else if ($notnull_bool((node instanceof FunctionTypeReference))) {
    var name0 = '';
    if ($notnull_bool(node.func.name != null)) name0 = node.func.name.name;
    node.type = this.library.getOrAddFunctionType($assert_String(name0), node.func, this);
  }
  else {
    world.internalError('unknown type reference', node.span);
  }
  return node.type;
}
DefinedType.prototype.resolveTypeParams = function(inType) {
  return this;
}
DefinedType.prototype.getOrMakeConcreteType = function(typeArgs) {
  $assert(this.get$isGeneric(), "isGeneric", "type.dart", 1136, 12);
  var names = [this.name];
  var typeMap = $map([]);
  for (var i = 0;
   $notnull_bool(i < typeArgs.length); i++) {
    var paramName = this.typeParameters.$index(i).get$name();
    typeMap.$setindex(paramName, typeArgs.$index(i));
    names.add(typeArgs.$index(i).get$name());
  }
  var concreteName = Strings.join((names && names.is$List$String()), '\$');
  var ret = this._concreteTypes.$index(concreteName);
  if ($notnull_bool(ret == null)) {
    ret = new ConcreteType($assert_String(concreteName), this, typeMap, typeArgs);
    this._concreteTypes.$setindex(concreteName, ret);
  }
  return ret;
}
DefinedType.prototype.getCallStub = function(args) {
  $assert(this.get$isFunction(), "isFunction", "type.dart", 1156, 12);
  var name0 = _getCallStubName('call', args);
  if ($notnull_bool(this.varStubs == null)) this.varStubs = $map([]);
  var stub = this.varStubs.$index(name0);
  if ($notnull_bool(stub == null)) {
    stub = new VarFunctionStub($assert_String(name0), args);
    this.varStubs.$setindex(name0, stub);
  }
  return stub;
}
// ********** Code for FixedCollection **************
function FixedCollection(value, length) {
  this.value = value;
  this.length = length;
  // Initializers done
}
FixedCollection.prototype.is$Iterable = function(){return this;};
FixedCollection.prototype.get$value = function() { return this.value; };
FixedCollection.prototype.iterator = function() {
  return new FixedIterator$E(this.value, this.length);
}
FixedCollection.prototype.forEach = function(f) {
  Collections.forEach(this, f);
}
FixedCollection.prototype.filter = function(f) {
  return Collections.filter(this, new ListFactory$E(), f);
}
FixedCollection.prototype.some = function(f) {
  return Collections.some(this, f);
}
FixedCollection.prototype.isEmpty = function() {
  return this.length == 0;
}
FixedCollection.prototype.forEach$1 = FixedCollection.prototype.forEach;
// ********** Code for FixedCollection$Type **************
function FixedCollection$Type(value, length) {
  this.value = value;
  this.length = length;
  // Initializers done
}
$inherits(FixedCollection$Type, FixedCollection);
FixedCollection$Type.prototype.is$Iterable = function(){return this;};
// ********** Code for FixedIterator **************
function FixedIterator(value, length) {
  this._index = 0
  this.value = value;
  this.length = length;
  // Initializers done
}
FixedIterator.prototype.get$value = function() { return this.value; };
FixedIterator.prototype.hasNext = function() {
  return this._index < this.length;
}
FixedIterator.prototype.next = function() {
  this._index++;
  return this.value;
}
// ********** Code for FixedIterator$E **************
function FixedIterator$E(value, length) {
  this._index = 0
  this.value = value;
  this.length = length;
  // Initializers done
}
$inherits(FixedIterator$E, FixedIterator);
// ********** Code for Value **************
function Value(type, code, isSuper, needsTemp, isType) {
  this.type = type;
  this.code = code;
  this.isSuper = isSuper;
  this.needsTemp = needsTemp;
  this.isType = isType;
  // Initializers done
  if ($notnull_bool(this.type == null)) this.type = world.varType;
}
Value.prototype.is$Value = function(){return this;};
Value.prototype.get$isConst = function() {
  return false;
}
Value.prototype.get_ = function(context, name, node) {
  var member = this._resolveMember(context, name, node);
  if ($notnull_bool($ne(member, null))) {
    member = member.get_$3(context, node, this);
  }
  if ($notnull_bool($ne(member, null))) {
    return member;
  }
  else {
    return this.invokeNoSuchMethod(context, ('get:' + name + ''), node);
  }
}
Value.prototype.set_ = function(context, name, node, value, isDynamic) {
  var member = this._resolveMember(context, name, node);
  if ($notnull_bool($ne(member, null))) {
    member = member.set_(context, node, this, value, isDynamic);
  }
  if ($notnull_bool($ne(member, null))) {
    return member;
  }
  else {
    return this.invokeNoSuchMethod(context, ('set:' + name + ''), node, new Arguments(null, [value]));
  }
}
Value.prototype.invoke = function(context, name, node, args, isDynamic) {
  if ($notnull_bool(this.type.get$isVar() && name == '\$ne')) {
    if ($notnull_bool(args.values.length != 1)) {
      world.warning('wrong number of arguments for !=', node.span);
    }
    return new Value(null, ('\$ne(' + this.code + ', ' + args.values.$index(0).code + ')'), false, true, false);
  }
  if ($notnull_bool(name == '\$call')) {
    if ($notnull_bool(this.isType)) {
      world.error('must use "new" or "const" to construct a new instance', node.span);
    }
    if ($notnull_bool(this.type.needsVarCall(args))) {
      return this._varCall(context, args);
    }
  }
  var member = this._resolveMember(context, name, node);
  if ($notnull_bool(member == null)) {
    return this.invokeNoSuchMethod(context, name, node, args);
  }
  else {
    return member.invoke(context, node, this, args, isDynamic);
  }
}
Value.prototype.canInvoke = function(context, name, args) {
  if ($notnull_bool(this.type.get$isVar() && name == '\$ne')) {
    return true;
  }
  if ($notnull_bool(this.type.get$isVarOrFunction() && name == '\$call')) {
    return true;
  }
  var member = this._tryResolveMember(context, name);
  return $ne(member, null) && member.canInvoke(context, args);
}
Value.prototype._tryResolveMember = function(context, name) {
  var member = null;
  if ($notnull_bool(!this.type.get$isVar())) {
    if ($notnull_bool(this.isSuper)) {
      return this.type.getMember(name);
    }
    else {
      member = this.type.resolveMember(name);
    }
  }
  if ($notnull_bool(member == null)) {
    member = context.findMembers(name);
  }
  return member;
}
Value.prototype._resolveMember = function(context, name, node) {
  var member = this._tryResolveMember(context, name);
  if ($notnull_bool(member == null)) {
    if ($notnull_bool(this._tryResolveMember(context, 'noSuchMethod').members.length > 1)) {
      return null;
    }
    var typeName = $notnull_bool(this.type.name == null) ? this.type.get$library().name : this.type.name;
    var message = ('can not resolve "' + name + '" on "' + typeName + '"');
    if ($notnull_bool(this.isType)) {
      world.error($assert_String(message), node.span);
    }
    else {
      world.warning($assert_String(message), node.span);
    }
    if ($notnull_bool(context.findMembers(name) == null)) {
      world.warning(('' + name + ' is not defined anywhere in the world.'), node.span);
    }
  }
  return member;
}
Value.prototype.checkFirstClass = function(span) {
  if ($notnull_bool(this.isType)) {
    world.error('Types are not first class', span);
  }
}
Value.prototype._varCall = function(context, args) {
  var stub = world.functionType.getCallStub(args);
  return new Value(null, ('' + this.code + '.' + stub.get$name() + '(' + args.getCode() + ')'), false, true, false);
}
Value.prototype.needsConversion = function(toType) {
  var callMethod = toType.getCallMethod();
  if ($notnull_bool($ne(callMethod, null))) {
    var arity = callMethod.get$parameters().length;
    var myCall = this.type.getCallMethod();
    if ($notnull_bool(myCall == null || myCall.get$parameters().length != arity)) {
      return true;
    }
  }
  if ($notnull_bool(options.enableTypeChecks)) {
    var fromType = this.type;
    if ($notnull_bool(this.type.get$isVar() && this.code != 'null')) {
      fromType = world.objectType;
    }
    var bothNum = this.type.get$isNum() && toType.get$isNum();
    return fromType.isSubtypeOf(toType) || bothNum;
  }
  return false;
}
Value.prototype.convertTo = function(context, toType, node, isDynamic) {
  var checked = !isDynamic;
  var callMethod = toType.getCallMethod();
  if ($notnull_bool($ne(callMethod, null))) {
    if ($notnull_bool(checked && !toType.isAssignable(this.type))) {
      this.convertWarning(toType, node);
    }
    var arity = callMethod.get$parameters().length;
    var myCall = this.type.getCallMethod();
    if ($notnull_bool(myCall == null || myCall.get$parameters().length != arity)) {
      var stub = world.functionType.getCallStub(Arguments.Arguments$bare$factory(arity));
      return new Value(toType, ('to\$' + stub.name + '(' + this.code + ')'), false, true, false);
    }
  }
  if ($notnull_bool(!options.enableTypeChecks)) {
    return this;
  }
  var fromType = this.type;
  if ($notnull_bool(this.type.get$isVar() && this.code != 'null')) {
    fromType = world.objectType;
  }
  var bothNum = this.type.get$isNum() && toType.get$isNum();
  if ($notnull_bool(!checked || fromType.isSubtypeOf(toType) || bothNum)) {
    return this;
  }
  if ($notnull_bool(!toType.isSubtypeOf(this.type))) {
    this.convertWarning(toType, node);
  }
  return this._typeAssert(context, toType, node);
}
Value.prototype.convertToNonNullBool = function(context, node) {
  if ($notnull_bool(!this.type.isAssignable(world.boolType))) {
    this.convertWarning(world.boolType, node);
  }
  if ($notnull_bool(!options.enableTypeChecks)) {
    return this;
  }
  else {
    if ($notnull_bool(this.code.startsWith('\$notnull_bool'))) {
      return this;
    }
    else {
      return new Value(world.boolType, ('\$notnull_bool(' + this.code + ')'), false, true, false);
    }
  }
}
Value.prototype._typeAssert = function(context, toType, node) {
  if ($notnull_bool((toType instanceof ParameterType))) {
    var p = toType;
    toType = p.extendsType;
  }
  if ($notnull_bool(toType.get$isObject() || toType.get$isVar())) {
    world.internalError(('We thought ' + this.type.name + ' is not a subtype of ' + toType.name + '?'));
  }
  if ($notnull_bool(toType.get$isNum())) toType = world.numType;
  var check;
  if ($notnull_bool(toType.get$library().get$isCore() && toType.get$typeofName() != null)) {
    check = ('\$assert_' + toType.name + '(' + this.code + ')');
    if ($notnull_bool(toType.typeCheckCode == null)) {
      toType.typeCheckCode = ("function $assert_" + toType.name + "(x) {\n  if (x == null || typeof(x) == \"" + toType.get$typeofName() + "\") return x;\n  throw new TypeError(\"'\" + x + \"' is not a " + toType.name + ".\");\n}");
    }
  }
  else {
    toType.isTested = true;
    var temp = context.getTemp(this);
    check = ('(' + context.assignTemp((temp && temp.is$Value()), this).code + ' &&');
    check = check + (' ' + temp.code + '.is\$' + toType.get$jsname() + '())');
    if ($notnull_bool($ne(this, temp))) context.freeTemp((temp && temp.is$Value()));
  }
  return new Value(toType, check, false, true, false);
}
Value.prototype.instanceOf = function(context, toType, span, isTrue, forceCheck) {
  if ($notnull_bool(toType.get$isVar())) {
    world.error('can not resolve type', span);
    return EvaluatedValue.EvaluatedValue$factory(world.boolType, true, 'true', null);
  }
  if ($notnull_bool((toType instanceof ParameterType))) {
    return EvaluatedValue.EvaluatedValue$factory(world.boolType, true, 'true', null);
  }
  var testCode = null;
  if ($notnull_bool(toType.get$library().get$isCore())) {
    var typeofName = toType.get$typeofName();
    if ($notnull_bool($ne(typeofName, null))) {
      testCode = ("(typeof(" + this.code + ") " + ($notnull_bool(isTrue) ? '==' : '!=') + " '" + typeofName + "')");
    }
  }
  if ($notnull_bool(toType.get$isClass() && !(toType instanceof ConcreteType))) {
    toType.markUsed();
    testCode = ('(' + this.code + ' instanceof ' + toType.get$jsname() + ')');
    if ($notnull_bool(!isTrue)) {
      testCode = '!' + testCode;
    }
  }
  if ($notnull_bool(testCode == null)) {
    toType.isTested = true;
    var temp = context.getTemp(this);
    testCode = ('(' + context.assignTemp((temp && temp.is$Value()), this).code + ' &&');
    testCode = testCode + (' ' + temp.code + '.is\$' + toType.get$jsname() + ')');
    if ($notnull_bool(isTrue)) {
      testCode = '!!' + testCode;
    }
    else {
      testCode = '!' + testCode;
    }
    if ($notnull_bool($ne(this, temp))) context.freeTemp((temp && temp.is$Value()));
  }
  return new Value(world.boolType, testCode, false, true, false);
}
Value.prototype.convertWarning = function(toType, node) {
  world.warning(('type "' + this.type.name + '" is not assignable to "' + toType.name + '"'), node.span);
}
Value.prototype.invokeNoSuchMethod = function(context, name, node, args) {
  var pos = '';
  if ($notnull_bool(args != null)) {
    var argsCode = [];
    for (var i = 0;
     $notnull_bool(i < args.get$length()); i++) {
      argsCode.add(args.values.$index(i).code);
    }
    pos = Strings.join((argsCode && argsCode.is$List$String()), ", ");
  }
  var noSuchArgs = [new Value(world.stringType, ('"' + name + '"'), false, true, false), new Value(world.listType, ('[' + pos + ']'), false, true, false)];
  return this._tryResolveMember(context, 'noSuchMethod').invoke$4(context, node, this, new Arguments(null, noSuchArgs));
}
Value.prototype.invokeSpecial = function(name, args, returnType) {
  $assert(name.startsWith('\$'), "name.startsWith('\\$')", "value.dart", 410, 12);
  $assert(!args.get$hasNames(), "!args.hasNames", "value.dart", 411, 12);
  var argsString = args.getCode();
  if ($notnull_bool(name == '\$index' || name == '\$setindex')) {
    return new Value(returnType, ('' + this.code + '.' + name + '(' + argsString + ')'), false, true, false);
  }
  else {
    if ($notnull_bool(argsString.length > 0)) argsString = (', ' + argsString + '');
    return new Value(returnType, ('' + name + '(' + this.code + '' + argsString + ')'), false, true, false);
  }
}
Value.prototype.get_$3 = function($0, $1, $2) {
  return this.get_(($0 && $0.is$MethodGenerator()), $assert_String($1), ($2 && $2.is$lang_Node()));
}
;
Value.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 && $0.is$MethodGenerator()), $assert_String($1), ($2 && $2.is$lang_Node()), ($3 && $3.is$Arguments()), false);
}
;
Value.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.set_(($0 && $0.is$MethodGenerator()), $assert_String($1), ($2 && $2.is$lang_Node()), ($3 && $3.is$Value()), false);
}
;
// ********** Code for EvaluatedValue **************
function EvaluatedValue() {}
EvaluatedValue._internal$ctor = function(type0, actualValue, canonicalCode, original, code0) {
  this.actualValue = actualValue;
  this.canonicalCode = canonicalCode;
  this.original = original;
  Value.call(this, type0, code0, false, false, false);
  // Initializers done
}
EvaluatedValue._internal$ctor.prototype = EvaluatedValue.prototype;
$inherits(EvaluatedValue, Value);
EvaluatedValue.EvaluatedValue$factory = function(type0, actualValue0, canonicalCode0, original0) {
  return new EvaluatedValue._internal$ctor(type0, actualValue0, canonicalCode0, original0, EvaluatedValue.codeWithComments($assert_String(canonicalCode0), (original0 && original0.is$SourceSpan())));
}
EvaluatedValue.prototype.get$actualValue = function() { return this.actualValue; };
EvaluatedValue.prototype.set$actualValue = function(value) { return this.actualValue = value; };
EvaluatedValue.prototype.get$isConst = function() {
  return true;
}
EvaluatedValue.codeWithComments = function(canonicalCode0, original0) {
  return $notnull_bool((original0 != null && original0.get$text() != canonicalCode0)) ? ('' + canonicalCode0 + '/*' + original0.get$text() + '*/') : canonicalCode0;
}
// ********** Code for ConstListValue **************
function ConstListValue() {}
ConstListValue._internal$ctor = function(type0, values, actualValue0, canonicalCode0, original0, code0) {
  this.values = values;
  EvaluatedValue._internal$ctor.call(this, type0, actualValue0, canonicalCode0, original0, code0);
  // Initializers done
}
ConstListValue._internal$ctor.prototype = ConstListValue.prototype;
$inherits(ConstListValue, EvaluatedValue);
ConstListValue.ConstListValue$factory = function(type0, values0, actualValue0, canonicalCode0, original0) {
  return new ConstListValue._internal$ctor(type0, values0, actualValue0, canonicalCode0, original0, EvaluatedValue.codeWithComments(canonicalCode0, original0));
}
// ********** Code for ConstMapValue **************
function ConstMapValue() {}
ConstMapValue._internal$ctor = function(type0, values, actualValue0, canonicalCode0, original0, code0) {
  this.values = values;
  EvaluatedValue._internal$ctor.call(this, type0, actualValue0, canonicalCode0, original0, code0);
  // Initializers done
}
ConstMapValue._internal$ctor.prototype = ConstMapValue.prototype;
$inherits(ConstMapValue, EvaluatedValue);
ConstMapValue.ConstMapValue$factory = function(type0, keyValuePairs, actualValue0, canonicalCode0, original0) {
  var values0 = new HashMapImplementation$String$EvaluatedValue();
  for (var i = 0;
   $notnull_bool(i < keyValuePairs.length); i += 2) {
    values0.$setindex(keyValuePairs.$index(i).get$actualValue(), keyValuePairs.$index(i + 1));
  }
  return new ConstMapValue._internal$ctor(type0, values0, actualValue0, canonicalCode0, original0, EvaluatedValue.codeWithComments(canonicalCode0, original0));
}
// ********** Code for ConstObjectValue **************
function ConstObjectValue() {}
ConstObjectValue._internal$ctor = function(type0, fields, actualValue0, canonicalCode0, original0, code0) {
  this.fields = fields;
  EvaluatedValue._internal$ctor.call(this, type0, actualValue0, canonicalCode0, original0, code0);
  // Initializers done
}
ConstObjectValue._internal$ctor.prototype = ConstObjectValue.prototype;
$inherits(ConstObjectValue, EvaluatedValue);
ConstObjectValue.ConstObjectValue$factory = function(type0, fields0, canonicalCode0, original0) {
  var $0;
  var fieldValues = [];
  var $list = fields0.getKeys();
  for (var $i = fields0.getKeys().iterator(); $i.hasNext(); ) {
    var f = $i.next();
    fieldValues.add(('' + f + ' = ' + fields0.$index(f).get$actualValue() + ''));
  }
  fieldValues.sort((function (a, b) {
    return a.compareTo(b);
  })
  );
  var actualValue0 = ('const ' + type0.get$jsname() + ' [') + Strings.join(fieldValues, ',') + ']';
  return new ConstObjectValue._internal$ctor(type0, fields0, actualValue0, canonicalCode0, original0, EvaluatedValue.codeWithComments(canonicalCode0, original0));
}
// ********** Code for GlobalValue **************
function GlobalValue(type0, code0, isConst0, field, name, exp, canonicalCode, original, dependencies) {
  this.field = field;
  this.name = name;
  this.exp = exp;
  this.canonicalCode = canonicalCode;
  this.original = original;
  this.dependencies = dependencies;
  Value.call(this, type0, code0, false, !isConst0, false);
  // Initializers done
}
$inherits(GlobalValue, Value);
GlobalValue.GlobalValue$fromStatic$factory = function(field0, exp0, dependencies0) {
  var code0 = ($notnull_bool(exp0.get$isConst()) ? exp0.canonicalCode : exp0.code);
  var codeWithComment = ('' + code0 + '/*' + field0.declaringType.name + '.' + field0.get$name() + '*/');
  return new GlobalValue(exp0.type, codeWithComment, field0.isFinal, field0, null, exp0, code0, null, dependencies0.filter((function (d) {
    return (d instanceof GlobalValue);
  })
  ));
}
GlobalValue.GlobalValue$fromConst$factory = function(uniqueId, exp0, dependencies0) {
  var name0 = ("const\$" + uniqueId + "");
  var codeWithComment = ("" + name0 + "/*" + exp0.original.get$text() + "*/");
  return new GlobalValue(exp0.type, codeWithComment, true, null, name0, exp0, name0, exp0.original, dependencies0.filter((function (d) {
    return (d instanceof GlobalValue);
  })
  ));
}
GlobalValue.prototype.get$name = function() { return this.name; };
GlobalValue.prototype.set$name = function(value) { return this.name = value; };
GlobalValue.prototype.get$isConst = function() {
  return this.exp.get$isConst() && (this.field == null || this.field.isFinal);
}
GlobalValue.prototype.get$actualValue = function() {
  return this.exp.get$dynamic().get$actualValue();
}
GlobalValue.prototype.compareTo = function(other) {
  if ($notnull_bool($eq(other, this))) {
    return 0;
  }
  else if ($notnull_bool(this.dependencies.indexOf(other, 0) >= 0)) {
    return 1;
  }
  else if ($notnull_bool(other.dependencies.indexOf(this, 0) >= 0)) {
    return -1;
  }
  else if ($notnull_bool(this.dependencies.length > other.dependencies.length)) {
    return 1;
  }
  else if ($notnull_bool(this.dependencies.length < other.dependencies.length)) {
    return -1;
  }
  else if ($notnull_bool(this.name == null && other.name != null)) {
    return 1;
  }
  else if ($notnull_bool(this.name != null && other.name == null)) {
    return -1;
  }
  else if ($notnull_bool(this.name != null)) {
    return this.name.compareTo(other.name);
  }
  else {
    return this.field.name.compareTo(other.field.name);
  }
}
// ********** Code for CompilerException **************
function CompilerException(_message, _location) {
  this._lang_message = _message;
  this._location = _location;
  // Initializers done
}
CompilerException.prototype.toString = function() {
  if ($notnull_bool(this._location != null)) {
    return ('CompilerException: ' + this._location.toMessageString(this._lang_message) + '');
  }
  else {
    return ('CompilerException: ' + this._lang_message + '');
  }
}
// ********** Code for World **************
function World(files) {
  this.errors = 0
  this.warnings = 0
  this.dartBytesRead = 0
  this.jsBytesWritten = 0
  this.seenFatal = false
  this.files = files;
  this.libraries = $map([]);
  this._todo = [];
  this._members = $map([]);
  this._topNames = $map([]);
  this.reader = new LibraryReader();
  // Initializers done
}
World.prototype.get$coreimpl = function() {
  return this.libraries.$index('dart:coreimpl');
}
World.prototype.get$dom = function() {
  return this.libraries.$index('dart:dom');
}
World.prototype.get$functionType = function() { return this.functionType; };
World.prototype.set$functionType = function(value) { return this.functionType = value; };
World.prototype.init = function() {
  var $0;
  this.corelib = new Library(this.readFile('dart:core'));
  this.libraries.$setindex('dart:core', this.corelib);
  this._todo.add(this.corelib);
  this.voidType = (($0 = this._addToCoreLib('void', false)) && $0.is$lang_Type());
  this.dynamicType = (($0 = this._addToCoreLib('Dynamic', false)) && $0.is$lang_Type());
  this.varType = this.dynamicType;
  this.objectType = (($0 = this._addToCoreLib('Object', true)) && $0.is$lang_Type());
  this.numType = (($0 = this._addToCoreLib('num', false)) && $0.is$lang_Type());
  this.intType = (($0 = this._addToCoreLib('int', false)) && $0.is$lang_Type());
  this.doubleType = (($0 = this._addToCoreLib('double', false)) && $0.is$lang_Type());
  this.boolType = (($0 = this._addToCoreLib('bool', false)) && $0.is$lang_Type());
  this.stringType = (($0 = this._addToCoreLib('String', false)) && $0.is$lang_Type());
  this.listType = (($0 = this._addToCoreLib('List', false)) && $0.is$lang_Type());
  this.mapType = (($0 = this._addToCoreLib('Map', false)) && $0.is$lang_Type());
  this.functionType = (($0 = this._addToCoreLib('Function', false)) && $0.is$lang_Type());
}
World.prototype._addMember = function(member) {
  $assert(!member.get$isPrivate(), "!member.isPrivate", "world.dart", 141, 12);
  if ($notnull_bool(member.get$isStatic())) {
    if ($notnull_bool(member.declaringType.get$isTop())) {
      this._addTopName(member);
    }
    return;
  }
  var mset = this._members.$index(member.name);
  if ($notnull_bool(mset == null)) {
    mset = new MemberSet(member);
    this._members.$setindex(mset.get$name(), mset);
  }
  else {
    mset.members.add(member);
  }
}
World.prototype._addTopName = function(named) {
  var existing = this._topNames.$index(named.get$name());
  if ($notnull_bool($ne(existing, null))) {
    this.info(('mangling matching top level name "' + named.get$name() + '" in ') + ('both "' + named.get$library().name + '" and "' + existing.get$library().name + '"'));
    if ($notnull_bool(named.get$isNative())) {
      if ($notnull_bool(existing.get$isNative())) {
        world.internalError(('conflicting native names "' + named.get$name() + '" ') + ('(already defined in ' + existing.get$span().get$locationText() + ')'), named.get$span());
      }
      else {
        this._topNames.$setindex(named.get$name(), named);
        this._addJavascriptTopName((existing && existing.is$Named()));
      }
    }
    else if ($notnull_bool(named.get$library().get$isCore())) {
      if ($notnull_bool(existing.get$library().get$isCore())) {
        world.internalError(('conflicting top-level names in core "' + named.get$name() + '" ') + ('(previously defined in ' + existing.get$span().get$locationText() + ')'), named.get$span());
      }
      else {
        this._topNames.$setindex(named.get$name(), named);
        this._addJavascriptTopName((existing && existing.is$Named()));
      }
    }
    else {
      this._addJavascriptTopName(named);
    }
  }
  else {
    this._topNames.$setindex(named.get$name(), named);
  }
}
World.prototype._addJavascriptTopName = function(named) {
  named.set$jsname(('' + named.get$library().get$jsname() + '_' + named.get$name() + ''));
  var existing = this._topNames.$index(named.get$jsname());
  if ($notnull_bool($ne(existing, null) && $ne(existing, named))) {
    world.internalError(('name mangling failed for "' + named.get$jsname() + '" ') + ('("' + named.get$jsname() + '" defined also in ' + existing.get$span().get$locationText() + ')'), named.get$span());
  }
  this._topNames.$setindex(named.get$jsname(), named);
}
World.prototype._addType = function(type) {
  if ($notnull_bool(!type.get$isTop())) this._addTopName(type);
}
World.prototype._addToCoreLib = function(name, isClass) {
  var ret = new DefinedType(name, this.corelib, null, isClass);
  this.corelib.types.$setindex(name, ret);
  return ret;
}
World.prototype.toJsIdentifier = function(name) {
  if ($notnull_bool(this._jsKeywords == null)) {
    this._jsKeywords = HashSetImplementation.HashSetImplementation$from$factory(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof', 'new', 'return', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'class', 'enum', 'export', 'extends', 'import', 'super', 'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield', 'native']);
  }
  if ($notnull_bool(this._jsKeywords.contains(name))) {
    return name + '_';
  }
  else {
    return name;
  }
}
World.prototype.compile = function() {
  if ($notnull_bool(options.dartScript == null)) {
    this.fatal('no script provided to compile');
    return false;
  }
  try {
    this.info(('compiling ' + options.dartScript + ' with corelib ' + this.corelib + ''));
    if ($notnull_bool(!this.runLeg())) this.runCompilationPhases();
  } catch (exc) {
    exc = $toDartException(exc);
    if ($notnull_bool(this.get$hasErrors() && !options.throwOnErrors)) {
    }
    else {
      throw exc;
    }
  }
  this.printStatus();
  return !this.get$hasErrors();
}
World.prototype.runLeg = function() {
  var $this = this; // closure support
  if ($notnull_bool(!options.enableLeg)) return false;
  var res = this.withTiming('try leg compile', (function () {
    return compile($this);
  })
  );
  if ($notnull_bool(!res && options.legOnly)) {
    this.fatal(("Leg could not compile " + options.dartScript + ""));
  }
  return res;
}
World.prototype.runCompilationPhases = function() {
  var $this = this; // closure support
  var lib = this.withTiming('first pass', (function () {
    return $this.processScript(options.dartScript);
  })
  );
  this.withTiming('resolve top level', (function () {
    $this.resolveAll();
  })
  );
  this.withTiming('generate code', (function () {
    var $0;
    var mainMembers = lib.topType.resolveMember('main');
    var main = null;
    if ($notnull_bool(mainMembers == null || mainMembers.members.length == 0)) {
      $this.fatal('no main method specified');
    }
    else if ($notnull_bool(mainMembers.members.length > 1)) {
      var $list = mainMembers.members;
      for (var $i = mainMembers.members.iterator(); $i.hasNext(); ) {
        var m = $i.next();
        main = m;
        $this.error('more than one main member (using last?)', main.get$span());
      }
    }
    else {
      main = mainMembers.members.$index(0);
    }
    var codeWriter = new CodeWriter();
    $this.gen = new WorldGenerator(main, codeWriter);
    $this.gen.run();
    $this.jsBytesWritten = codeWriter.get$text().length;
  })
  );
}
World.prototype.getGeneratedCode = function() {
  if ($notnull_bool(this.legCode != null)) {
    $assert(options.enableLeg, "options.enableLeg", "world.dart", 304, 14);
    return this.legCode;
  }
  else {
    return this.gen.writer.get$text();
  }
}
World.prototype.readFile = function(filename) {
  try {
    var sourceFile = this.reader.readFile(filename);
    this.dartBytesRead += sourceFile.get$text().length;
    return sourceFile;
  } catch (e) {
    e = $toDartException(e);
    this.warning(('Error reading file: ' + filename + ''));
    return new SourceFile(filename, '');
  }
}
World.prototype.getOrAddLibrary = function(filename) {
  var library = this.libraries.$index(filename);
  if ($notnull_bool(library == null)) {
    library = new Library(this.readFile(filename));
    this.info(('read library ' + filename + ''));
    if ($notnull_bool(!library.get$isCore() && !library.imports.some((function (li) {
      return li.get$library().get$isCore();
    })
    ))) {
      library.imports.add(new LibraryImport(this.corelib));
    }
    this.libraries.$setindex(filename, library);
    this._todo.add(library);
  }
  return library;
}
World.prototype.process = function() {
  while ($notnull_bool(this._todo.length > 0)) {
    var todo = this._todo;
    this._todo = [];
    for (var $i = 0;$i < todo.length; $i++) {
      var lib = todo.$index($i);
      lib.visitSources();
    }
  }
}
World.prototype.processScript = function(filename) {
  var library = this.getOrAddLibrary(filename);
  this.process();
  return library;
}
World.prototype.resolveAll = function() {
  var $0;
  var $list = this.libraries.getValues();
  for (var $i = this.libraries.getValues().iterator(); $i.hasNext(); ) {
    var lib = $i.next();
    lib.resolve();
  }
}
World.prototype._message = function(message, span, span1, throwing) {
  var text = message;
  if ($notnull_bool(span != null)) {
    text = span.toMessageString(message);
  }
  print(text);
  if ($notnull_bool(span1 != null)) {
    print(span1.toMessageString(message));
  }
  if ($notnull_bool(throwing)) {
    $throw(new CompilerException(message, span));
  }
}
World.prototype.error = function(message, span, span1) {
  this.errors++;
  this._message(('error: ' + message + ''), span, span1, options.throwOnErrors);
}
World.prototype.warning = function(message, span, span1) {
  this.warnings++;
  if ($notnull_bool(options.showWarnings)) {
    this._message(('warning: ' + message + ''), span, span1, options.throwOnWarnings);
  }
}
World.prototype.fatal = function(message, span, span1) {
  this.errors++;
  this.seenFatal = true;
  this._message(('fatal: ' + message + ''), span, span1, $assert_bool(options.throwOnFatal || options.throwOnErrors));
}
World.prototype.internalError = function(message, span, span1) {
  this._message(('We are sorry, but... ' + message + ''), span, span1, true);
}
World.prototype.info = function(message, span, span1) {
  if ($notnull_bool(options.showInfo)) {
    this._message(('info: ' + message + ''), span, span1, false);
  }
}
World.prototype.get$hasErrors = function() {
  return this.errors > 0;
}
World.prototype.printStatus = function() {
  this.info(('compiled ' + this.dartBytesRead + ' bytes Dart -> ' + this.jsBytesWritten + ' bytes JS'));
  if ($notnull_bool(this.get$hasErrors())) {
    print(('compilation failed with ' + this.errors + ' errors'));
  }
  else {
    if ($notnull_bool(this.warnings > 0)) {
      this.info(('compilation completed successfully with ' + this.warnings + ' warnings'));
    }
    else {
      this.info('compilation completed sucessfully');
    }
  }
}
World.prototype.withTiming = function(name, f) {
  var sw = new StopWatchImplementation();
  sw.start();
  var result = f();
  sw.stop();
  this.info(('' + name + ' in ' + sw.elapsedInMs() + 'msec'));
  return result;
}
// ********** Code for FrogOptions **************
function FrogOptions(homedir, args, files) {
  var $0;
  this.enableLeg = false
  this.legOnly = false
  this.enableAsserts = false
  this.enableTypeChecks = false
  this.verifyImplements = false
  this.compileAll = false
  this.dietParse = false
  this.compileOnly = false
  this.throwOnErrors = false
  this.throwOnWarnings = false
  this.throwOnFatal = false
  this.showInfo = false
  this.showWarnings = true
  // Initializers done
  this.libDir = homedir + '/lib';
  var ignoreUnrecognizedFlags = false;
  var passedLibDir = false;
  this.childArgs = [];
  loop:
  for (var i = 2;
   $notnull_bool(i < args.length); i++) {
    var arg = args.$index(i);
    switch (arg) {
      case '--enable_leg':

        this.enableLeg = true;
        continue loop;

      case '--leg_only':

        this.enableLeg = true;
        this.legOnly = true;
        continue loop;

      case '--enable_asserts':

        this.enableAsserts = true;
        continue loop;

      case '--enable_type_checks':

        this.enableTypeChecks = true;
        this.enableAsserts = true;
        continue loop;

      case '--verify_implements':

        this.verifyImplements = true;
        continue loop;

      case '--compile_all':

        this.compileAll = true;
        continue loop;

      case '--diet-parse':

        this.dietParse = true;
        continue loop;

      case '--ignore-unrecognized-flags':

        ignoreUnrecognizedFlags = true;
        continue loop;

      case '--verbose':

        this.showInfo = true;
        continue loop;

      case '--throw_on_errors':

        this.throwOnErrors = true;
        continue loop;

      case '--throw_on_warnings':

        this.throwOnWarnings = true;
        continue loop;

      case '--compile-only':

        this.compileOnly = true;
        continue loop;

      default:

        if ($notnull_bool(arg.endsWith('.dart'))) {
          this.dartScript = $assert_String(arg);
          this.childArgs = (($0 = args.getRange(i + 1, args.length - i - 1)) && $0.is$List$String());
          break loop;
        }
        else if ($notnull_bool(arg.startsWith('--out='))) {
          this.outfile = arg.substring('--out='.length);
        }
        else if ($notnull_bool(arg.startsWith('--libdir='))) {
          this.libDir = arg.substring('--libdir='.length);
          passedLibDir = true;
        }
        else {
          if ($notnull_bool(!ignoreUnrecognizedFlags)) {
            print(('unrecognized flag: "' + arg + '"'));
          }
        }

    }
  }
  if ($notnull_bool(!passedLibDir && !files.fileExists(this.libDir))) {
    var temp = 'frog/lib';
    if ($notnull_bool(files.fileExists(temp))) {
      this.libDir = $assert_String(temp);
    }
    else {
      this.libDir = 'lib';
    }
  }
}
// ********** Code for LibraryReader **************
function LibraryReader() {
  // Initializers done
  this._specialLibs = $map(['dart:core', joinPaths(options.libDir, 'corelib.dart'), 'dart:coreimpl', joinPaths(options.libDir, 'corelib_impl.dart'), 'dart:html', joinPaths(options.libDir, '../../client/html/release/html.dart'), 'dart:dom', joinPaths(options.libDir, 'dom/dom.dart'), 'dart:json', joinPaths(options.libDir, 'json.dart')]);
}
LibraryReader.prototype.readFile = function(fullname) {
  var filename = this._specialLibs.$index(fullname);
  if ($notnull_bool(filename == null)) {
    filename = fullname;
  }
  if ($notnull_bool(world.files.fileExists(filename))) {
    return new SourceFile(filename, world.files.readAll(filename));
  }
  else {
    world.error(('File not found: ' + filename + ''));
    return new SourceFile(filename, '');
  }
}
// ********** Code for VarMember **************
function VarMember(name) {
  this.name = name;
  // Initializers done
}
VarMember.prototype.is$VarMember = function(){return this;};
VarMember.prototype.get$name = function() { return this.name; };
VarMember.prototype.get$returnType = function() {
  return world.varType;
}
VarMember.prototype.invoke = function(context, node, target, args) {
  return new Value(this.get$returnType(), ('' + target.code + '.' + this.name + '(' + args.getCode() + ')'), false, true, false);
}
VarMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Arguments()));
}
;
// ********** Code for VarFunctionStub **************
function VarFunctionStub(name0, callArgs) {
  this.args = callArgs.toCallStubArgs();
  VarMember.call(this, name0);
  // Initializers done
}
$inherits(VarFunctionStub, VarMember);
VarFunctionStub.prototype.generate = function(code) {
  if ($notnull_bool(this.args.get$hasNames())) {
    this.generateNamed(code);
  }
  else {
    this.generatePositional(code);
  }
}
VarFunctionStub.prototype.generatePositional = function(w) {
  var arity = this.args.get$length();
  w.enterBlock(('Function.prototype.to\$' + this.name + ' = function() {'));
  w.writeln(('this.' + this.name + ' = this.\$genStub(' + arity + ');'));
  w.writeln(('this.to\$' + this.name + ' = function() { return this.' + this.name + '; };'));
  w.writeln(('return this.' + this.name + ';'));
  w.exitBlock('};');
  var argsCode = this.args.getCode();
  w.enterBlock(('Function.prototype.' + this.name + ' = function(' + argsCode + ') {'));
  w.writeln(('return this.to\$' + this.name + '()(' + argsCode + ');'));
  w.exitBlock('};');
  w.writeln(('function to\$' + this.name + '(f) { return f && f.to\$' + this.name + '(); }'));
}
VarFunctionStub.prototype.generateNamed = function(w) {
  var named = Strings.join(this.args.getNames(), '", "');
  var argsCode = this.args.getCode();
  w.enterBlock(('Function.prototype.' + this.name + ' = function(' + argsCode + ') {'));
  w.writeln(('this.' + this.name + ' = this.\$genStub(' + this.args.get$length() + ', ["' + named + '"]);'));
  w.writeln(('return this.' + this.name + '(' + argsCode + ');'));
  w.exitBlock('}');
}
// ********** Code for VarMethodStub **************
function VarMethodStub(name0, member, args, body) {
  this.member = member;
  this.args = args;
  this.body = body;
  VarMember.call(this, name0);
  // Initializers done
}
$inherits(VarMethodStub, VarMember);
VarMethodStub.prototype.get$returnType = function() {
  return $notnull_bool(this.member != null) ? this.member.get$returnType() : world.varType;
}
VarMethodStub.prototype.get$typeName = function() {
  return $notnull_bool(this.member != null) ? this.member.declaringType.get$jsname() : 'Object';
}
VarMethodStub.prototype.generate = function(code) {
  code.write(('' + this.get$typeName() + '.prototype.' + this.name + ' = '));
  this.generateBody(code);
  code.writeln(';');
}
VarMethodStub.prototype.generateBody = function(code) {
  if ($notnull_bool(this._useDirectCall(this.member, this.args))) {
    code.write(('' + this.get$typeName() + '.prototype.' + this.member.get$jsname() + ''));
  }
  else {
    code.enterBlock(('function(' + this.args.getCode() + ') {'));
    code.writeln(('return ' + this.body.code + ';'));
    code.exitBlock('}');
  }
}
VarMethodStub.prototype._useDirectCall = function(member0, args0) {
  if ($notnull_bool((member0 instanceof MethodMember) && $ne(member0.declaringType.get$library(), world.get$dom()))) {
    var method = member0;
    if ($notnull_bool(method.needsArgumentConversion(args0))) {
      return false;
    }
    for (var i = args0.get$length();
     $notnull_bool(i < method.parameters.length); i++) {
      if ($notnull_bool(method.parameters.$index(i).get$value().code != 'null')) {
        return false;
      }
    }
    return method.namesInOrder(args0);
  }
  else {
    return false;
  }
}
// ********** Code for VarMethodSet **************
function VarMethodSet(name0, members, callArgs, returnType) {
  this.members = members;
  this.returnType = returnType;
  this.args = callArgs.toCallStubArgs();
  VarMember.call(this, name0);
  // Initializers done
}
$inherits(VarMethodSet, VarMember);
VarMethodSet.prototype.get$returnType = function() { return this.returnType; };
VarMethodSet.prototype.get$baseName = function() {
  return this.members.$index(0).get$name();
}
VarMethodSet.prototype.invoke = function(context, node, target, args0) {
  this._invokeMembers(context, node);
  return VarMember.prototype.invoke.call(this, context, node, target, args0);
}
VarMethodSet.prototype._invokeMembers = function(context, node) {
  if ($notnull_bool(this._fallbackStubs != null)) return;
  this._fallbackStubs = [];
  var $list = this.members;
  for (var $i = 0;$i < $list.length; $i++) {
    var member = $list.$index($i);
    var target = new Value(member.declaringType, 'this', false, true, false);
    var result = member.invoke$4(context, node, target, this.args);
    var stub = new VarMethodStub(this.name, member, this.args, result);
    var type = member.declaringType;
    if ($notnull_bool($ne(type.get$library(), world.get$dom()) && !type.get$isObject())) {
      VarMethodSet._addVarStub((type && type.is$lang_Type()), (stub && stub.is$VarMember()));
    }
    else {
      this._fallbackStubs.add(stub);
    }
  }
  var target = new Value(world.objectType, 'this', false, true, false);
  var result = target.invokeNoSuchMethod(context, this.get$baseName(), node, this.args);
  var stub = new VarMethodStub(this.name, null, this.args, result);
  if ($notnull_bool(this._fallbackStubs.length == 0)) {
    VarMethodSet._addVarStub(world.objectType, (stub && stub.is$VarMember()));
  }
  else {
    this._fallbackStubs.add(stub);
  }
}
VarMethodSet._addVarStub = function(type, stub) {
  if ($notnull_bool(type.varStubs == null)) type.varStubs = $map([]);
  type.varStubs.$setindex(stub.name, stub);
}
VarMethodSet.prototype.generate = function(code) {
  if ($notnull_bool(this._fallbackStubs.length == 0)) return;
  code.enterBlock(('\$varMethod("' + this.name + '", {'));
  var $list = this._fallbackStubs;
  for (var $i = 0;$i < $list.length; $i++) {
    var stub = $list.$index($i);
    code.write(('"' + stub.get$typeName() + '": '));
    stub.generateBody(code);
    code.writeln(',');
  }
  code.exitBlock('});');
}
VarMethodSet.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 && $0.is$MethodGenerator()), ($1 && $1.is$lang_Node()), ($2 && $2.is$Value()), ($3 && $3.is$Arguments()));
}
;
// ********** Code for top level **************
function map(source, mapper) {
  var $0;
  var result = new ListFactory();
  if ($notnull_bool(!!(source && source.is$List))) {
    var list = source;
    result.length = list.length;
    for (var i = 0;
     $notnull_bool(i < list.length); i++) {
      result.$setindex(i, mapper.call$1(list.$index(i)));
    }
  }
  else {
    for (var $i = source.iterator(); $i.hasNext(); ) {
      var item = $i.next();
      result.add(mapper.call$1(item));
    }
  }
  return result;
}
function reduce(source, callback, initialValue) {
  var i = source.iterator();
  var current = initialValue;
  if ($notnull_bool(current == null && i.hasNext())) {
    current = i.next();
  }
  while ($notnull_bool(i.hasNext())) {
    current = callback.call$2(current, i.next());
  }
  return current;
}
function orderValuesByKeys(map0) {
  var $0;
  var keys = map0.getKeys();
  keys.sort((function (x, y) {
    return x.compareTo(y);
  })
  );
  var values = [];
  for (var $i = keys.iterator(); $i.hasNext(); ) {
    var k = $i.next();
    values.add(map0.$index(k));
  }
  return values;
}
function isMultilineString(text) {
  return text.startsWith('"""') || text.startsWith("'''");
}
function isRawMultilineString(text) {
  return text.startsWith('@"""') || text.startsWith("@'''");
}
function parseStringLiteral(lit) {
  if ($notnull_bool(lit.startsWith('@'))) {
    if ($notnull_bool(isRawMultilineString(lit))) {
      return stripLeadingNewline(lit.substring(4, lit.length - 3));
    }
    else {
      return lit.substring(2, lit.length - 1);
    }
  }
  else if ($notnull_bool(isMultilineString(lit))) {
    lit = lit.substring(3, lit.length - 3).replaceAll('\\\$', '\$');
    return stripLeadingNewline(lit);
  }
  else {
    return lit.substring(1, lit.length - 1).replaceAll('\\\$', '\$');
  }
}
function stripLeadingNewline(text) {
  if ($notnull_bool(text.startsWith('\n'))) {
    return text.substring(1);
  }
  else if ($notnull_bool(text.startsWith('\r'))) {
    if ($notnull_bool(text.startsWith('\r\n'))) {
      return text.substring(2);
    }
    else {
      return text.substring(1);
    }
  }
  else {
    return text;
  }
}
var world;
function initializeWorld(files) {
  $assert(world == null, "world == null", "world.dart", 13, 10);
  world = new World(files);
  world.init();
}
function lang_compile(homedir, args, files) {
  parseOptions(homedir, args, files);
  initializeWorld(files);
  var success = world.compile();
  if ($notnull_bool(options.outfile != null)) {
    if ($notnull_bool(success)) {
      var code = world.getGeneratedCode();
      if ($notnull_bool(!options.outfile.endsWith('.js'))) {
        code = '#!/usr/bin/env node\n' + code;
      }
      world.files.writeString(options.outfile, code);
    }
    else {
      world.files.writeString(options.outfile, "throw 'Sorry, but I could not generate reasonable code to run.\\n';");
    }
  }
  return success;
}
var options;
function parseOptions(homedir, args, files) {
  $assert(options == null, "options == null", "frog_options.dart", 10, 10);
  options = new FrogOptions(homedir, args, files);
}
function _getCallStubName(name, args) {
  var nameBuilder = new StringBufferImpl(('' + name + '\$' + args.get$bareCount() + ''));
  for (var i = args.get$bareCount();
   $notnull_bool(i < args.get$length()); i++) {
    nameBuilder.add('\$').add(args.getName(i));
  }
  return nameBuilder.toString();
}
//  ********** Library frog **************
// ********** Code for top level **************
function main() {
  var homedir = get$path().dirname(get$fs().realpathSync($assert_String(process.argv.$index(1))));
  var argv = ListFactory.ListFactory$from$factory(process.argv);
  if ($notnull_bool(lang_compile($assert_String(homedir), (argv && argv.is$List$String()), new NodeFileSystem()))) {
    var code = world.getGeneratedCode();
    if ($notnull_bool(!options.compileOnly)) {
      process.argv = [argv.$index(0), argv.$index(1)];
      process.argv.addAll(options.childArgs);
      get$vm().runInNewContext($assert_String(code), createSandbox());
    }
  }
  else {
    process.exit(1);
  }
}
Function.prototype.to$call$0 = function() {
  this.call$0 = this.$genStub(0);
  this.to$call$0 = function() { return this.call$0; };
  return this.call$0;
};
Function.prototype.call$0 = function() {
  return this.to$call$0()();
};
function to$call$0(f) { return f && f.to$call$0(); }
Function.prototype.to$call$1 = function() {
  this.call$1 = this.$genStub(1);
  this.to$call$1 = function() { return this.call$1; };
  return this.call$1;
};
Function.prototype.call$1 = function($0) {
  return this.to$call$1()($0);
};
function to$call$1(f) { return f && f.to$call$1(); }
Function.prototype.to$call$2 = function() {
  this.call$2 = this.$genStub(2);
  this.to$call$2 = function() { return this.call$2; };
  return this.call$2;
};
Function.prototype.call$2 = function($0, $1) {
  return this.to$call$2()($0, $1);
};
function to$call$2(f) { return f && f.to$call$2(); }
var const$0 = new NoMoreElementsException()/*const NoMoreElementsException()*/;
var const$133 = new Keyword("break", false)/*const Keyword("break")*/;
var const$135 = new Keyword("case", false)/*const Keyword("case")*/;
var const$137 = new Keyword("catch", false)/*const Keyword("catch")*/;
var const$139 = new Keyword("const", false)/*const Keyword("const")*/;
var const$141 = new Keyword("continue", false)/*const Keyword("continue")*/;
var const$143 = new Keyword("default", false)/*const Keyword("default")*/;
var const$145 = new Keyword("do", false)/*const Keyword("do")*/;
var const$147 = new Keyword("else", false)/*const Keyword("else")*/;
var const$149 = new Keyword("false", false)/*const Keyword("false")*/;
var const$151 = new Keyword("final", false)/*const Keyword("final")*/;
var const$153 = new Keyword("finally", false)/*const Keyword("finally")*/;
var const$155 = new Keyword("for", false)/*const Keyword("for")*/;
var const$157 = new Keyword("if", false)/*const Keyword("if")*/;
var const$159 = new Keyword("in", false)/*const Keyword("in")*/;
var const$161 = new Keyword("is", false)/*const Keyword("is")*/;
var const$163 = new Keyword("new", false)/*const Keyword("new")*/;
var const$165 = new Keyword("null", false)/*const Keyword("null")*/;
var const$167 = new Keyword("return", false)/*const Keyword("return")*/;
var const$169 = new Keyword("super", false)/*const Keyword("super")*/;
var const$171 = new Keyword("switch", false)/*const Keyword("switch")*/;
var const$173 = new Keyword("this", false)/*const Keyword("this")*/;
var const$175 = new Keyword("throw", false)/*const Keyword("throw")*/;
var const$177 = new Keyword("true", false)/*const Keyword("true")*/;
var const$179 = new Keyword("try", false)/*const Keyword("try")*/;
var const$181 = new Keyword("var", false)/*const Keyword("var")*/;
var const$183 = new Keyword("void", false)/*const Keyword("void")*/;
var const$185 = new Keyword("while", false)/*const Keyword("while")*/;
var const$187 = new Keyword("abstract", true)/*const Keyword("abstract", true)*/;
var const$189 = new Keyword("assert", true)/*const Keyword("assert", true)*/;
var const$191 = new Keyword("class", true)/*const Keyword("class", true)*/;
var const$193 = new Keyword("extends", true)/*const Keyword("extends", true)*/;
var const$195 = new Keyword("factory", true)/*const Keyword("factory", true)*/;
var const$197 = new Keyword("get", true)/*const Keyword("get", true)*/;
var const$199 = new Keyword("implements", true)/*const Keyword("implements", true)*/;
var const$2 = new StringWrapper('global scope')/*const SourceString('global scope')*/;
var const$201 = new Keyword("import", true)/*const Keyword("import", true)*/;
var const$203 = new Keyword("interface", true)/*const Keyword("interface", true)*/;
var const$205 = new Keyword("library", true)/*const Keyword("library", true)*/;
var const$207 = new Keyword("native", true)/*const Keyword("native", true)*/;
var const$209 = new Keyword("negate", true)/*const Keyword("negate", true)*/;
var const$211 = new Keyword("operator", true)/*const Keyword("operator", true)*/;
var const$213 = new Keyword("set", true)/*const Keyword("set", true)*/;
var const$215 = new Keyword("source", true)/*const Keyword("source", true)*/;
var const$217 = new Keyword("static", true)/*const Keyword("static", true)*/;
var const$219 = new Keyword("typedef", true)/*const Keyword("typedef", true)*/;
var const$221 = new IllegalAccessException()/*const IllegalAccessException()*/;
var const$226 = ImmutableList.ImmutableList$from$factory([])/*const []*/;
var const$227 = new LinkTail()/*const EmptyLink<DeclarationBuilder>()*/;
var const$228 = new StringWrapper("<")/*const SourceString("<")*/;
var const$229 = new StringWrapper(".")/*const SourceString(".")*/;
var const$230 = new StringWrapper(",")/*const SourceString(",")*/;
var const$231 = new StringWrapper(">")/*const SourceString(">")*/;
var const$232 = new StringWrapper("{")/*const SourceString("{")*/;
var const$233 = new StringWrapper("string")/*const SourceString("string")*/;
var const$234 = new StringWrapper("(")/*const SourceString("(")*/;
var const$235 = new StringWrapper(")")/*const SourceString(")")*/;
var const$236 = new StringWrapper(";")/*const SourceString(";")*/;
var const$237 = new StringWrapper("#")/*const SourceString("#")*/;
var const$238 = new StringWrapper("=")/*const SourceString("=")*/;
var const$239 = new StringWrapper("}")/*const SourceString("}")*/;
var const$240 = new StringWrapper('{')/*const SourceString('{')*/;
var const$241 = new StringWrapper("return")/*const SourceString("return")*/;
var const$242 = new StringWrapper("?")/*const SourceString("?")*/;
var const$243 = new StringWrapper(":")/*const SourceString(":")*/;
var const$244 = new StringWrapper('=')/*const SourceString('=')*/;
var const$245 = new StringWrapper(',')/*const SourceString(',')*/;
var const$246 = new StringWrapper('(')/*const SourceString('(')*/;
var const$247 = new ImmutableMap([])/*const {}*/;
var const$248 = new StringWrapper('print')/*const SourceString('print')*/;
var const$249 = new StringWrapper('+')/*const SourceString('+')*/;
var const$250 = new StringWrapper('-')/*const SourceString('-')*/;
var const$251 = new StringWrapper('*')/*const SourceString('*')*/;
var const$252 = new StringWrapper('/')/*const SourceString('/')*/;
var const$253 = new StringWrapper('~/')/*const SourceString('~/')*/;
var const$254 = new StringWrapper('void')/*const SourceString('void')*/;
var const$255 = new StringWrapper('int')/*const SourceString('int')*/;
var const$256 = new StringWrapper('Dynamic')/*const SourceString('Dynamic')*/;
var const$257 = new StringWrapper('String')/*const SourceString('String')*/;
var const$258 = new StringWrapper("+")/*const SourceString("+")*/;
var const$259 = new StringWrapper("-")/*const SourceString("-")*/;
var const$260 = new StringWrapper("*")/*const SourceString("*")*/;
var const$261 = new StringWrapper("/")/*const SourceString("/")*/;
var const$262 = new StringWrapper("~/")/*const SourceString("~/")*/;
var const$265 = new ExceptionImplementation("Internal Error (Leg): UNREACHABLE")/*const Exception("Internal Error (Leg): UNREACHABLE")*/;
var const$266 = new StringWrapper('\$add')/*const SourceString('\$add')*/;
var const$267 = new StringWrapper('\$div')/*const SourceString('\$div')*/;
var const$268 = new StringWrapper('\$mul')/*const SourceString('\$mul')*/;
var const$269 = new StringWrapper('\$sub')/*const SourceString('\$sub')*/;
var const$270 = new StringWrapper('\$tdiv')/*const SourceString('\$tdiv')*/;
var const$3 = new StringWrapper('main')/*const SourceString('main')*/;
var const$393 = ImmutableList.ImmutableList$from$factory(['NullPointerException', 'ObjectNotClosureException', 'NoSuchMethodException', 'StackOverflowException'])/*const [
      'NullPointerException', 'ObjectNotClosureException',
      'NoSuchMethodException', 'StackOverflowException']*/;
var const$5 = new EmptyQueueException()/*const EmptyQueueException()*/;
HTracer._singleton = null;
var const$222 = ImmutableList.ImmutableList$from$factory([const$133, const$135, const$137, const$139, const$141, const$143, const$145, const$147, const$149, const$151, const$153, const$155, const$157, const$159, const$161, const$163, const$165, const$167, const$169, const$171, const$173, const$175, const$177, const$179, const$181, const$183, const$185, const$187, const$189, const$191, const$193, const$195, const$197, const$199, const$201, const$203, const$205, const$207, const$209, const$211, const$213, const$215, const$217, const$219])/*const <Keyword> [
      BREAK,
      CASE,
      CATCH,
      CONST,
      CONTINUE,
      DEFAULT,
      DO,
      ELSE,
      FALSE,
      FINAL,
      FINALLY,
      FOR,
      IF,
      IN,
      IS,
      NEW,
      NULL,
      RETURN,
      SUPER,
      SWITCH,
      THIS,
      THROW,
      TRUE,
      TRY,
      VAR,
      VOID,
      WHILE,
      ABSTRACT,
      ASSERT,
      CLASS,
      EXTENDS,
      FACTORY,
      GET,
      IMPLEMENTS,
      IMPORT,
      INTERFACE,
      LIBRARY,
      NATIVE,
      NEGATE,
      OPERATOR,
      SET,
      SOURCE,
      STATIC,
      TYPEDEF ]*/;
main();
