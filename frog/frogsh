#!/usr/bin/env node
//  ********** Library dart:core **************
//  ********** Natives dart:core **************
Object.prototype.$typeNameOf = function() {
  if ((typeof(window) != 'undefined' && window.constructor.name == 'DOMWindow')
      || typeof(process) != 'undefined') { // fast-path for Chrome and Node
    return this.constructor.name;
  }
  var str = Object.prototype.toString.call(this);
  str = str.substring(8, str.length - 1);
  if (str == 'Window') str = 'DOMWindow';
  return str;
}
/**
 * Generates a dynamic call stub for a function.
 * Our goal is to create a stub method like this on-the-fly:
 *   function($0, $1, capture) { return this($0, $1, true, capture); }
 *
 * This stub then replaces the dynamic one on Function, with one that is
 * specialized for that particular function, taking into account its default
 * arguments.
 */
Function.prototype.$genStub = function(argsLength, names) {
  // Fast path: if no named arguments and arg count matches
  if (this.length == argsLength && !names) {
    return this;
  }

  function $throwArgMismatch() {
    // TODO(jmesserly): better error message
    $throw(new ClosureArgumentMismatchException());
  }

  var paramsNamed = this.$optional ? (this.$optional.length / 2) : 0;
  var paramsBare = this.length - paramsNamed;
  var argsNamed = names ? names.length : 0;
  var argsBare = argsLength - argsNamed;

  // Check we got the right number of arguments
  if (argsBare < paramsBare || argsLength > this.length ||
      argsNamed > paramsNamed) {
    return $throwArgMismatch;
  }

  // First, fill in all of the default values
  var p = new Array(paramsBare);
  if (paramsNamed) {
    p = p.concat(this.$optional.slice(paramsNamed));
  }
  // Fill in positional args
  var a = new Array(argsLength);
  for (var i = 0; i < argsBare; i++) {
    p[i] = a[i] = '$' + i;
  }
  // Then overwrite with supplied values for optional args
  var lastParameterIndex;
  var namesInOrder = true;
  for (var i = 0; i < argsNamed; i++) {
    var name = names[i];
    a[i + argsBare] = name;
    var j = this.$optional.indexOf(name);
    if (j < 0 || j >= paramsNamed) {
      return $throwArgMismatch;
    } else if (lastParameterIndex && lastParameterIndex > j) {
      namesInOrder = false;
    }
    p[j + paramsBare] = name;
    lastParameterIndex = j;
  }

  if (this.length == argsLength && namesInOrder) {
    // Fast path #2: named arguments, but they're in order.
    return this;
  }

  // Note: using Function instead of 'eval' to get a clean scope.
  // TODO(jmesserly): evaluate the performance of these stubs.
  var f = 'function(' + a.join(',') + '){return $f(' + p.join(',') + ');}';
  return new Function('$f', 'return ' + f + '').call(null, this);
}
function $notnull_bool(test) {
  if (test === true || test === false) return test;
  $throw(new TypeError(test, 'bool'));
}
function $assert(test, text, url, line, column) {
  if (typeof test == 'function') test = test();
  if (!test) $throw(new AssertError(text, url, line, column));
}
function $throw(e) {
  // If e is not a value, we can use V8's captureStackTrace utility method.
  // TODO(jmesserly): capture the stack trace on other JS engines.
  if (e && (typeof e == 'object') && Error.captureStackTrace) {
    // TODO(jmesserly): this will clobber the e.stack property
    Error.captureStackTrace(e, $throw);
  }
  throw e;
}
function $map(items) {
  var ret = new HashMapImplementation();
  for (var i=0; i < items.length;) {
    ret.$setindex(items[i++], items[i++]);
  }
  return ret;
}
Object.prototype.$index = function(i) { return this[i]; }
Array.prototype.$index = function(i) { return this[i]; }
String.prototype.$index = function(i) { return this[i]; }
Object.prototype.$setindex = function(i, value) { return this[i] = value; }
Array.prototype.$setindex = function(i, value) { return this[i] = value; }
function $add(x, y) {
  return ((typeof(x) == 'number' && typeof(y) == 'number') ||
          (typeof(x) == 'string'))
    ? x + y : x.$add(y);
}
function $eq(x, y) {
  if (x == null) return y == null;
  return (typeof(x) == 'number' && typeof(y) == 'number') ||
         (typeof(x) == 'boolean' && typeof(y) == 'boolean') ||
         (typeof(x) == 'string' && typeof(y) == 'string')
    ? x == y : x.$eq(y);
}
// TODO(jimhug): Should this or should it not match equals?
Object.prototype.$eq = function(other) { return this === other; }
function $mod(x, y) {
  if (typeof(x) == 'number' && typeof(y) == 'number') {
    var result = x % y;
    if (result == 0) {
      return 0;  // Make sure we don't return -0.0.
    } else if (result < 0) {
      if (y < 0) {
        return result - y;
      } else {
        return result + y;
      }
    }
    return result;
  } else {
    return x.$mod(y);
  }
}
function $ne(x, y) {
  if (x == null) return y != null;
  return (typeof(x) == 'number' && typeof(y) == 'number') ||
         (typeof(x) == 'boolean' && typeof(y) == 'boolean') ||
         (typeof(x) == 'string' && typeof(y) == 'string')
    ? x != y : !x.$eq(y);
}
function $truncdiv(x, y) {
  if (typeof(x) == 'number' && typeof(y) == 'number') {
    if (y == 0) $throw(new IntegerDivisionByZeroException());
    var tmp = x / y;
    return (tmp < 0) ? Math.ceil(tmp) : Math.floor(tmp);
  } else {
    return x.$truncdiv(y);
  }
}
// ********** Code for Clock **************
function Clock() {}
Clock.now = function() {
  return new Date().getTime();
}
Clock.frequency = function() {
  return 1000;
}
// ********** Code for AssertError **************
function AssertError() {}
AssertError._internal$ctor = function(failedAssertion, url, line, column) {
  this.failedAssertion = failedAssertion;
  this.url = url;
  this.line = line;
  this.column = column;
  // Initializers done
}
AssertError._internal$ctor.prototype = AssertError.prototype;
AssertError.prototype.toString = function() {
  return ("Failed assertion: '" + this.failedAssertion + "' is not true ") + ("in " + this.url + " at line " + this.line + ", column " + this.column + ".");
}
AssertError.prototype.toString$0 = function() {
  return this.toString();
};
// ********** Code for TypeError **************
TypeError._internal$ctor = function(src, dstType) {
  this.srcType = (src == null ? "Null" : src.$typeNameOf());
  this.destType = destType;
  this.toString = function() {
    return ("Failed type check: type " + this.srcType +
        " is not assignable to type" + this.dstType);
  }
}
TypeError._internal$ctor.prototype = TypeError.prototype;
// ********** Code for Object **************
Object.prototype.get$dynamic = function() {
  return this;
}
Object.prototype.noSuchMethod = function(name, args) {
  $throw(new NoSuchMethodException(this, name, args));
}
Object.prototype._get$3 = function($0, $1, $2) {
  return this.noSuchMethod("_get", [$0, $1, $2]);
};
Object.prototype._set$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("_set", [$0, $1, $2, $3]);
};
Object.prototype.accept$1 = function($0) {
  return this.noSuchMethod("accept", [$0]);
};
Object.prototype.add$1 = function($0) {
  return this.noSuchMethod("add", [$0]);
};
Object.prototype.addAll$1 = function($0) {
  return this.noSuchMethod("addAll", [$0]);
};
Object.prototype.addDirectSubtype$1 = function($0) {
  return this.noSuchMethod("addDirectSubtype", [$0]);
};
Object.prototype.addMethod$2 = function($0, $1) {
  return this.noSuchMethod("addMethod", [$0, $1]);
};
Object.prototype.addSource$1 = function($0) {
  return this.noSuchMethod("addSource", [$0]);
};
Object.prototype.appendByteStringToken$2 = function($0, $1) {
  return this.noSuchMethod("appendByteStringToken", [$0, $1]);
};
Object.prototype.assert$ArgumentNode = function() {
  $throw(new TypeError._internal$ctor(this, "ArgumentNode"));
};
Object.prototype.assert$Arguments = function() {
  $throw(new TypeError._internal$ctor(this, "Arguments"));
};
Object.prototype.assert$BeginGroupToken = function() {
  $throw(new TypeError._internal$ctor(this, "BeginGroupToken"));
};
Object.prototype.assert$BinaryExpression = function() {
  $throw(new TypeError._internal$ctor(this, "BinaryExpression"));
};
Object.prototype.assert$BlockScope = function() {
  $throw(new TypeError._internal$ctor(this, "BlockScope"));
};
Object.prototype.assert$BlockStatement = function() {
  $throw(new TypeError._internal$ctor(this, "BlockStatement"));
};
Object.prototype.assert$CallExpression = function() {
  $throw(new TypeError._internal$ctor(this, "CallExpression"));
};
Object.prototype.assert$ClassElement = function() {
  $throw(new TypeError._internal$ctor(this, "ClassElement"));
};
Object.prototype.assert$ClassNode = function() {
  $throw(new TypeError._internal$ctor(this, "ClassNode"));
};
Object.prototype.assert$CodeWriter = function() {
  $throw(new TypeError._internal$ctor(this, "CodeWriter"));
};
Object.prototype.assert$Collection_E = function() {
  $throw(new TypeError._internal$ctor(this, "Collection<E>"));
};
Object.prototype.assert$Collection_Object = function() {
  $throw(new TypeError._internal$ctor(this, "Collection<Object>"));
};
Object.prototype.assert$Collection_Type = function() {
  $throw(new TypeError._internal$ctor(this, "Collection<Type>"));
};
Object.prototype.assert$Comparable = function() {
  $throw(new TypeError._internal$ctor(this, "Comparable"));
};
Object.prototype.assert$Compiler = function() {
  $throw(new TypeError._internal$ctor(this, "Compiler"));
};
Object.prototype.assert$ConcreteMember = function() {
  $throw(new TypeError._internal$ctor(this, "ConcreteMember"));
};
Object.prototype.assert$ConcreteType = function() {
  $throw(new TypeError._internal$ctor(this, "ConcreteType"));
};
Object.prototype.assert$Date = function() {
  $throw(new TypeError._internal$ctor(this, "Date"));
};
Object.prototype.assert$DeclaredIdentifier = function() {
  $throw(new TypeError._internal$ctor(this, "DeclaredIdentifier"));
};
Object.prototype.assert$DefinedType = function() {
  $throw(new TypeError._internal$ctor(this, "DefinedType"));
};
Object.prototype.assert$Definition = function() {
  $throw(new TypeError._internal$ctor(this, "Definition"));
};
Object.prototype.assert$DotExpression = function() {
  $throw(new TypeError._internal$ctor(this, "DotExpression"));
};
Object.prototype.assert$DoubleLinkedQueueEntry_KeyValuePair_K$V = function() {
  $throw(new TypeError._internal$ctor(this, "DoubleLinkedQueueEntry<KeyValuePair<K, V>>"));
};
Object.prototype.assert$Duration = function() {
  $throw(new TypeError._internal$ctor(this, "Duration"));
};
Object.prototype.assert$Element = function() {
  $throw(new TypeError._internal$ctor(this, "Element"));
};
Object.prototype.assert$Expression = function() {
  $throw(new TypeError._internal$ctor(this, "Expression"));
};
Object.prototype.assert$ExpressionStatement = function() {
  $throw(new TypeError._internal$ctor(this, "ExpressionStatement"));
};
Object.prototype.assert$FieldMember = function() {
  $throw(new TypeError._internal$ctor(this, "FieldMember"));
};
Object.prototype.assert$FunctionDefinition = function() {
  $throw(new TypeError._internal$ctor(this, "FunctionDefinition"));
};
Object.prototype.assert$FunctionElement = function() {
  $throw(new TypeError._internal$ctor(this, "FunctionElement"));
};
Object.prototype.assert$FunctionExpression = function() {
  $throw(new TypeError._internal$ctor(this, "FunctionExpression"));
};
Object.prototype.assert$FunctionType = function() {
  $throw(new TypeError._internal$ctor(this, "FunctionType"));
};
Object.prototype.assert$FunctionTypeReference = function() {
  $throw(new TypeError._internal$ctor(this, "FunctionTypeReference"));
};
Object.prototype.assert$GenericTypeReference = function() {
  $throw(new TypeError._internal$ctor(this, "GenericTypeReference"));
};
Object.prototype.assert$GlobalValue = function() {
  $throw(new TypeError._internal$ctor(this, "GlobalValue"));
};
Object.prototype.assert$HBasicBlock = function() {
  $throw(new TypeError._internal$ctor(this, "HBasicBlock"));
};
Object.prototype.assert$HGraph = function() {
  $throw(new TypeError._internal$ctor(this, "HGraph"));
};
Object.prototype.assert$HInstruction = function() {
  $throw(new TypeError._internal$ctor(this, "HInstruction"));
};
Object.prototype.assert$HLiteral = function() {
  $throw(new TypeError._internal$ctor(this, "HLiteral"));
};
Object.prototype.assert$HLocal = function() {
  $throw(new TypeError._internal$ctor(this, "HLocal"));
};
Object.prototype.assert$HParameterValue = function() {
  $throw(new TypeError._internal$ctor(this, "HParameterValue"));
};
Object.prototype.assert$HPhi = function() {
  $throw(new TypeError._internal$ctor(this, "HPhi"));
};
Object.prototype.assert$HStatic = function() {
  $throw(new TypeError._internal$ctor(this, "HStatic"));
};
Object.prototype.assert$HTypeGuard = function() {
  $throw(new TypeError._internal$ctor(this, "HTypeGuard"));
};
Object.prototype.assert$HVisitor = function() {
  $throw(new TypeError._internal$ctor(this, "HVisitor"));
};
Object.prototype.assert$HashMapImplementation = function() {
  $throw(new TypeError._internal$ctor(this, "HashMapImplementation"));
};
Object.prototype.assert$HashSetImplementation = function() {
  $throw(new TypeError._internal$ctor(this, "HashSetImplementation"));
};
Object.prototype.assert$Identifier = function() {
  $throw(new TypeError._internal$ctor(this, "Identifier"));
};
Object.prototype.assert$IndexExpression = function() {
  $throw(new TypeError._internal$ctor(this, "IndexExpression"));
};
Object.prototype.assert$InterpStack = function() {
  $throw(new TypeError._internal$ctor(this, "InterpStack"));
};
Object.prototype.assert$Iterable = function() {
  $throw(new TypeError._internal$ctor(this, "Iterable"));
};
Object.prototype.assert$Iterator_T = function() {
  $throw(new TypeError._internal$ctor(this, "Iterator<T>"));
};
Object.prototype.assert$KeywordState = function() {
  $throw(new TypeError._internal$ctor(this, "KeywordState"));
};
Object.prototype.assert$LambdaExpression = function() {
  $throw(new TypeError._internal$ctor(this, "LambdaExpression"));
};
Object.prototype.assert$Library = function() {
  $throw(new TypeError._internal$ctor(this, "Library"));
};
Object.prototype.assert$Link_Element = function() {
  $throw(new TypeError._internal$ctor(this, "Link<Element>"));
};
Object.prototype.assert$Link_Node = function() {
  $throw(new TypeError._internal$ctor(this, "Link<Node>"));
};
Object.prototype.assert$Link_Token = function() {
  $throw(new TypeError._internal$ctor(this, "Link<Token>"));
};
Object.prototype.assert$Link_Type = function() {
  $throw(new TypeError._internal$ctor(this, "Link<Type>"));
};
Object.prototype.assert$List = function() {
  $throw(new TypeError._internal$ctor(this, "List"));
};
Object.prototype.assert$ListFactory = function() {
  $throw(new TypeError._internal$ctor(this, "ListFactory"));
};
Object.prototype.assert$List_ArgumentNode = function() {
  $throw(new TypeError._internal$ctor(this, "List<ArgumentNode>"));
};
Object.prototype.assert$List_Definition = function() {
  $throw(new TypeError._internal$ctor(this, "List<Definition>"));
};
Object.prototype.assert$List_EvaluatedValue = function() {
  $throw(new TypeError._internal$ctor(this, "List<EvaluatedValue>"));
};
Object.prototype.assert$List_GlobalValue = function() {
  $throw(new TypeError._internal$ctor(this, "List<GlobalValue>"));
};
Object.prototype.assert$List_HInstruction = function() {
  $throw(new TypeError._internal$ctor(this, "List<HInstruction>"));
};
Object.prototype.assert$List_Member = function() {
  $throw(new TypeError._internal$ctor(this, "List<Member>"));
};
Object.prototype.assert$List_ParameterType = function() {
  $throw(new TypeError._internal$ctor(this, "List<ParameterType>"));
};
Object.prototype.assert$List_String = function() {
  $throw(new TypeError._internal$ctor(this, "List<String>"));
};
Object.prototype.assert$List_Token = function() {
  $throw(new TypeError._internal$ctor(this, "List<Token>"));
};
Object.prototype.assert$List_Type = function() {
  $throw(new TypeError._internal$ctor(this, "List<Type>"));
};
Object.prototype.assert$List_Value = function() {
  $throw(new TypeError._internal$ctor(this, "List<Value>"));
};
Object.prototype.assert$List_int = function() {
  $throw(new TypeError._internal$ctor(this, "List<int>"));
};
Object.prototype.assert$LiteralString = function() {
  $throw(new TypeError._internal$ctor(this, "LiteralString"));
};
Object.prototype.assert$Map_String$Member = function() {
  $throw(new TypeError._internal$ctor(this, "Map<String, Member>"));
};
Object.prototype.assert$Member = function() {
  $throw(new TypeError._internal$ctor(this, "Member"));
};
Object.prototype.assert$MemberSet = function() {
  $throw(new TypeError._internal$ctor(this, "MemberSet"));
};
Object.prototype.assert$MethodGenerator = function() {
  $throw(new TypeError._internal$ctor(this, "MethodGenerator"));
};
Object.prototype.assert$MethodMember = function() {
  $throw(new TypeError._internal$ctor(this, "MethodMember"));
};
Object.prototype.assert$NameTypeReference = function() {
  $throw(new TypeError._internal$ctor(this, "NameTypeReference"));
};
Object.prototype.assert$Node = function() {
  $throw(new TypeError._internal$ctor(this, "Node"));
};
Object.prototype.assert$NodeList = function() {
  $throw(new TypeError._internal$ctor(this, "NodeList"));
};
Object.prototype.assert$NumImplementation = function() {
  $throw(new TypeError._internal$ctor(this, "NumImplementation"));
};
Object.prototype.assert$Operator = function() {
  $throw(new TypeError._internal$ctor(this, "Operator"));
};
Object.prototype.assert$Parameter = function() {
  $throw(new TypeError._internal$ctor(this, "Parameter"));
};
Object.prototype.assert$ParameterType = function() {
  $throw(new TypeError._internal$ctor(this, "ParameterType"));
};
Object.prototype.assert$ParenthesizedExpression = function() {
  $throw(new TypeError._internal$ctor(this, "ParenthesizedExpression"));
};
Object.prototype.assert$Pattern = function() {
  $throw(new TypeError._internal$ctor(this, "Pattern"));
};
Object.prototype.assert$PostfixExpression = function() {
  $throw(new TypeError._internal$ctor(this, "PostfixExpression"));
};
Object.prototype.assert$PropertyMember = function() {
  $throw(new TypeError._internal$ctor(this, "PropertyMember"));
};
Object.prototype.assert$SendSet = function() {
  $throw(new TypeError._internal$ctor(this, "SendSet"));
};
Object.prototype.assert$SourceFile = function() {
  $throw(new TypeError._internal$ctor(this, "SourceFile"));
};
Object.prototype.assert$SourceSpan = function() {
  $throw(new TypeError._internal$ctor(this, "SourceSpan"));
};
Object.prototype.assert$SourceString = function() {
  $throw(new TypeError._internal$ctor(this, "SourceString"));
};
Object.prototype.assert$Statement = function() {
  $throw(new TypeError._internal$ctor(this, "Statement"));
};
Object.prototype.assert$StringBuffer = function() {
  $throw(new TypeError._internal$ctor(this, "StringBuffer"));
};
Object.prototype.assert$Token = function() {
  $throw(new TypeError._internal$ctor(this, "Token"));
};
Object.prototype.assert$TreeElements = function() {
  $throw(new TypeError._internal$ctor(this, "TreeElements"));
};
Object.prototype.assert$TreeVisitor = function() {
  $throw(new TypeError._internal$ctor(this, "TreeVisitor"));
};
Object.prototype.assert$Type = function() {
  $throw(new TypeError._internal$ctor(this, "Type"));
};
Object.prototype.assert$TypeAnnotation = function() {
  $throw(new TypeError._internal$ctor(this, "TypeAnnotation"));
};
Object.prototype.assert$TypeDefinition = function() {
  $throw(new TypeError._internal$ctor(this, "TypeDefinition"));
};
Object.prototype.assert$TypeMember = function() {
  $throw(new TypeError._internal$ctor(this, "TypeMember"));
};
Object.prototype.assert$TypeReference = function() {
  $throw(new TypeError._internal$ctor(this, "TypeReference"));
};
Object.prototype.assert$Types = function() {
  $throw(new TypeError._internal$ctor(this, "Types"));
};
Object.prototype.assert$UnaryExpression = function() {
  $throw(new TypeError._internal$ctor(this, "UnaryExpression"));
};
Object.prototype.assert$Value = function() {
  $throw(new TypeError._internal$ctor(this, "Value"));
};
Object.prototype.assert$ValueSet = function() {
  $throw(new TypeError._internal$ctor(this, "ValueSet"));
};
Object.prototype.assert$ValueSetNode = function() {
  $throw(new TypeError._internal$ctor(this, "ValueSetNode"));
};
Object.prototype.assert$VarExpression = function() {
  $throw(new TypeError._internal$ctor(this, "VarExpression"));
};
Object.prototype.assert$VarFunctionStub = function() {
  $throw(new TypeError._internal$ctor(this, "VarFunctionStub"));
};
Object.prototype.assert$VarMember = function() {
  $throw(new TypeError._internal$ctor(this, "VarMember"));
};
Object.prototype.assert$VariableDefinitions = function() {
  $throw(new TypeError._internal$ctor(this, "VariableDefinitions"));
};
Object.prototype.assert$VariableElement = function() {
  $throw(new TypeError._internal$ctor(this, "VariableElement"));
};
Object.prototype.assert$Visitor = function() {
  $throw(new TypeError._internal$ctor(this, "Visitor"));
};
Object.prototype.assert$lang_Element = function() {
  $throw(new TypeError._internal$ctor(this, "Element"));
};
Object.prototype.assert$lang_Expression = function() {
  $throw(new TypeError._internal$ctor(this, "Expression"));
};
Object.prototype.assert$lang_Identifier = function() {
  $throw(new TypeError._internal$ctor(this, "Identifier"));
};
Object.prototype.assert$lang_Node = function() {
  $throw(new TypeError._internal$ctor(this, "Node"));
};
Object.prototype.assert$lang_Statement = function() {
  $throw(new TypeError._internal$ctor(this, "Statement"));
};
Object.prototype.assert$lang_Token = function() {
  $throw(new TypeError._internal$ctor(this, "Token"));
};
Object.prototype.assert$lang_Type = function() {
  $throw(new TypeError._internal$ctor(this, "Type"));
};
Object.prototype.block$0 = function() {
  return this.noSuchMethod("block", []);
};
Object.prototype.canInvoke$2 = function($0, $1) {
  return this.noSuchMethod("canInvoke", [$0, $1]);
};
Object.prototype.charCodeAt$1 = function($0) {
  return this.noSuchMethod("charCodeAt", [$0]);
};
Object.prototype.checkFirstClass$1 = function($0) {
  return this.noSuchMethod("checkFirstClass", [$0]);
};
Object.prototype.clearGenerateAtUseSite$0 = function() {
  return this.noSuchMethod("clearGenerateAtUseSite", []);
};
Object.prototype.compareTo$1 = function($0) {
  return this.noSuchMethod("compareTo", [$0]);
};
Object.prototype.computeDesiredInputType$1 = function($0) {
  return this.noSuchMethod("computeDesiredInputType", [$0]);
};
Object.prototype.computeType$2 = function($0, $1) {
  return this.noSuchMethod("computeType", [$0, $1]);
};
Object.prototype.computeValue$0 = function() {
  return this.noSuchMethod("computeValue", []);
};
Object.prototype.contains$1 = function($0) {
  return this.noSuchMethod("contains", [$0]);
};
Object.prototype.convertTo$3 = function($0, $1, $2) {
  return this.noSuchMethod("convertTo", [$0, $1, $2]);
};
Object.prototype.convertTo$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("convertTo", [$0, $1, $2, $3]);
};
Object.prototype.copyWithNewType$2 = function($0, $1) {
  return this.noSuchMethod("copyWithNewType", [$0, $1]);
};
Object.prototype.dataEquals$1 = function($0) {
  return this.noSuchMethod("dataEquals", [$0]);
};
Object.prototype.endsWith$1 = function($0) {
  return this.noSuchMethod("endsWith", [$0]);
};
Object.prototype.ensureSubtypeOf$3 = function($0, $1, $2) {
  return this.noSuchMethod("ensureSubtypeOf", [$0, $1, $2]);
};
Object.prototype.every$1 = function($0) {
  return this.noSuchMethod("every", [$0]);
};
Object.prototype.filter$1 = function($0) {
  return this.noSuchMethod("filter", [$0]);
};
Object.prototype.findTypeByName$1 = function($0) {
  return this.noSuchMethod("findTypeByName", [$0]);
};
Object.prototype.forEach$1 = function($0) {
  return this.noSuchMethod("forEach", [$0]);
};
Object.prototype.forEachPhi$1 = function($0) {
  return this.noSuchMethod("forEachPhi", [$0]);
};
Object.prototype.genValue$2 = function($0, $1) {
  return this.noSuchMethod("genValue", [$0, $1]);
};
Object.prototype.generate$1 = function($0) {
  return this.noSuchMethod("generate", [$0]);
};
Object.prototype.getBeginToken$0 = function() {
  return this.noSuchMethod("getBeginToken", []);
};
Object.prototype.getColumn$2 = function($0, $1) {
  return this.noSuchMethod("getColumn", [$0, $1]);
};
Object.prototype.getConstructor$1 = function($0) {
  return this.noSuchMethod("getConstructor", [$0]);
};
Object.prototype.getEndToken$0 = function() {
  return this.noSuchMethod("getEndToken", []);
};
Object.prototype.getFactory$2 = function($0, $1) {
  return this.noSuchMethod("getFactory", [$0, $1]);
};
Object.prototype.getKeys$0 = function() {
  return this.noSuchMethod("getKeys", []);
};
Object.prototype.getLine$1 = function($0) {
  return this.noSuchMethod("getLine", [$0]);
};
Object.prototype.getLocationMessage$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("getLocationMessage", [$0, $1, $2, $3]);
};
Object.prototype.getMember$1 = function($0) {
  return this.noSuchMethod("getMember", [$0]);
};
Object.prototype.getOrMakeConcreteType$1 = function($0) {
  return this.noSuchMethod("getOrMakeConcreteType", [$0]);
};
Object.prototype.getValues$0 = function() {
  return this.noSuchMethod("getValues", []);
};
Object.prototype.get_$3 = function($0, $1, $2) {
  return this.noSuchMethod("get_", [$0, $1, $2]);
};
Object.prototype.hasNext$0 = function() {
  return this.noSuchMethod("hasNext", []);
};
Object.prototype.hashCode$0 = function() {
  return this.noSuchMethod("hashCode", []);
};
Object.prototype.indexOf$1 = function($0) {
  return this.noSuchMethod("indexOf", [$0]);
};
Object.prototype.instanceOf$3$isTrue$forceCheck = function($0, $1, $2, isTrue, forceCheck) {
  return this.noSuchMethod("instanceOf", [$0, $1, $2, isTrue, forceCheck]);
};
Object.prototype.instanceOf$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("instanceOf", [$0, $1, $2, $3]);
};
Object.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("invoke", [$0, $1, $2, $3]);
};
Object.prototype.invoke$4$isDynamic = function($0, $1, $2, $3, isDynamic) {
  return this.noSuchMethod("invoke", [$0, $1, $2, $3, isDynamic]);
};
Object.prototype.invoke$5 = function($0, $1, $2, $3, $4) {
  return this.noSuchMethod("invoke", [$0, $1, $2, $3, $4]);
};
Object.prototype.is$List = function() {
  return false;
};
Object.prototype.is$SourceString = function() {
  return false;
};
Object.prototype.isAssignable$1 = function($0) {
  return this.noSuchMethod("isAssignable", [$0]);
};
Object.prototype.isEmpty$0 = function() {
  return this.noSuchMethod("isEmpty", []);
};
Object.prototype.isExitBlock$0 = function() {
  return this.noSuchMethod("isExitBlock", []);
};
Object.prototype.isInBasicBlock$0 = function() {
  return this.noSuchMethod("isInBasicBlock", []);
};
Object.prototype.isLiteralNumber$0 = function() {
  return this.noSuchMethod("isLiteralNumber", []);
};
Object.prototype.isLiteralString$0 = function() {
  return this.noSuchMethod("isLiteralString", []);
};
Object.prototype.isNumber$0 = function() {
  return this.noSuchMethod("isNumber", []);
};
Object.prototype.isString$0 = function() {
  return this.noSuchMethod("isString", []);
};
Object.prototype.isSubtypeOf$1 = function($0) {
  return this.noSuchMethod("isSubtypeOf", [$0]);
};
Object.prototype.isUnknown$0 = function() {
  return this.noSuchMethod("isUnknown", []);
};
Object.prototype.iterator$0 = function() {
  return this.noSuchMethod("iterator", []);
};
Object.prototype.last$0 = function() {
  return this.noSuchMethod("last", []);
};
Object.prototype.lookup$1 = function($0) {
  return this.noSuchMethod("lookup", [$0]);
};
Object.prototype.markUsed$0 = function() {
  return this.noSuchMethod("markUsed", []);
};
Object.prototype.namesInOrder$1 = function($0) {
  return this.noSuchMethod("namesInOrder", [$0]);
};
Object.prototype.needsConversion$1 = function($0) {
  return this.noSuchMethod("needsConversion", [$0]);
};
Object.prototype.next$0 = function() {
  return this.noSuchMethod("next", []);
};
Object.prototype.parseFunction$1 = function($0) {
  return this.noSuchMethod("parseFunction", [$0]);
};
Object.prototype.printOn$1 = function($0) {
  return this.noSuchMethod("printOn", [$0]);
};
Object.prototype.provideFieldSyntax$0 = function() {
  return this.noSuchMethod("provideFieldSyntax", []);
};
Object.prototype.providePropertySyntax$0 = function() {
  return this.noSuchMethod("providePropertySyntax", []);
};
Object.prototype.remove$1 = function($0) {
  return this.noSuchMethod("remove", [$0]);
};
Object.prototype.removeLast$0 = function() {
  return this.noSuchMethod("removeLast", []);
};
Object.prototype.removePhi$1 = function($0) {
  return this.noSuchMethod("removePhi", [$0]);
};
Object.prototype.replaceAll$2 = function($0, $1) {
  return this.noSuchMethod("replaceAll", [$0, $1]);
};
Object.prototype.replaceFirst$2 = function($0, $1) {
  return this.noSuchMethod("replaceFirst", [$0, $1]);
};
Object.prototype.resolve$0 = function() {
  return this.noSuchMethod("resolve", []);
};
Object.prototype.resolve$1 = function($0) {
  return this.noSuchMethod("resolve", [$0]);
};
Object.prototype.resolveMember$1 = function($0) {
  return this.noSuchMethod("resolveMember", [$0]);
};
Object.prototype.resolveTypeParams$1 = function($0) {
  return this.noSuchMethod("resolveTypeParams", [$0]);
};
Object.prototype.rewrite$2 = function($0, $1) {
  return this.noSuchMethod("rewrite", [$0, $1]);
};
Object.prototype.setDefinition$1 = function($0) {
  return this.noSuchMethod("setDefinition", [$0]);
};
Object.prototype.setGenerateAtUseSite$0 = function() {
  return this.noSuchMethod("setGenerateAtUseSite", []);
};
Object.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.noSuchMethod("set_", [$0, $1, $2, $3]);
};
Object.prototype.some$1 = function($0) {
  return this.noSuchMethod("some", [$0]);
};
Object.prototype.sort$1 = function($0) {
  return this.noSuchMethod("sort", [$0]);
};
Object.prototype.startsWith$1 = function($0) {
  return this.noSuchMethod("startsWith", [$0]);
};
Object.prototype.substring$1 = function($0) {
  return this.noSuchMethod("substring", [$0]);
};
Object.prototype.substring$2 = function($0, $1) {
  return this.noSuchMethod("substring", [$0, $1]);
};
Object.prototype.toMessageString$1 = function($0) {
  return this.noSuchMethod("toMessageString", [$0]);
};
Object.prototype.toString$0 = function() {
  return this.toString();
};
Object.prototype.visit$1 = function($0) {
  return this.noSuchMethod("visit", [$0]);
};
Object.prototype.visitPostfixExpression$1 = function($0) {
  return this.noSuchMethod("visitPostfixExpression", [$0]);
};
Object.prototype.visitSources$0 = function() {
  return this.noSuchMethod("visitSources", []);
};
Object.prototype.writeDefinition$2 = function($0, $1) {
  return this.noSuchMethod("writeDefinition", [$0, $1]);
};
function $assert_bool(x) {
  if (x == null || typeof(x) == "boolean") return x;
  $throw(new TypeError._internal$ctor(this, "bool"))
}
// ********** Code for IllegalAccessException **************
function IllegalAccessException() {
  // Initializers done
}
IllegalAccessException.prototype.toString = function() {
  return "Attempt to modify an immutable object";
}
IllegalAccessException.prototype.toString$0 = IllegalAccessException.prototype.toString;
// ********** Code for NoSuchMethodException **************
function NoSuchMethodException(_receiver, _functionName, _arguments) {
  this._receiver = _receiver;
  this._functionName = _functionName;
  this._arguments = _arguments;
  // Initializers done
}
NoSuchMethodException.prototype.toString = function() {
  var sb = new StringBufferImpl("");
  for (var i = 0;
   i < this._arguments.length; i++) {
    if (i > 0) {
      sb.add(", ");
    }
    sb.add(this._arguments.$index(i));
  }
  sb.add("]");
  return ("NoSuchMethodException - receiver: '" + this._receiver + "' ") + ("function name: '" + this._functionName + "' arguments: [" + sb + "]");
}
NoSuchMethodException.prototype.toString$0 = NoSuchMethodException.prototype.toString;
// ********** Code for ObjectNotClosureException **************
function ObjectNotClosureException() {
  // Initializers done
}
ObjectNotClosureException.prototype.toString = function() {
  return "Object is not closure";
}
ObjectNotClosureException.prototype.toString$0 = ObjectNotClosureException.prototype.toString;
// ********** Code for StackOverflowException **************
function StackOverflowException() {
  // Initializers done
}
StackOverflowException.prototype.toString = function() {
  return "Stack Overflow";
}
StackOverflowException.prototype.toString$0 = StackOverflowException.prototype.toString;
// ********** Code for BadNumberFormatException **************
function BadNumberFormatException() {}
BadNumberFormatException.prototype.toString = function() {
  return ("BadNumberFormatException: '" + this._s + "'");
}
BadNumberFormatException.prototype.toString$0 = BadNumberFormatException.prototype.toString;
// ********** Code for NullPointerException **************
function NullPointerException() {
  // Initializers done
}
NullPointerException.prototype.toString = function() {
  return "NullPointerException";
}
NullPointerException.prototype.toString$0 = NullPointerException.prototype.toString;
// ********** Code for NoMoreElementsException **************
function NoMoreElementsException() {
  // Initializers done
}
NoMoreElementsException.prototype.toString = function() {
  return "NoMoreElementsException";
}
NoMoreElementsException.prototype.toString$0 = NoMoreElementsException.prototype.toString;
// ********** Code for EmptyQueueException **************
function EmptyQueueException() {
  // Initializers done
}
EmptyQueueException.prototype.toString = function() {
  return "EmptyQueueException";
}
EmptyQueueException.prototype.toString$0 = EmptyQueueException.prototype.toString;
// ********** Code for Function **************
Function.prototype.to$call$0 = function() {
  this.call$0 = this.$genStub(0);
  this.to$call$0 = function() { return this.call$0; };
  return this.call$0;
};
Function.prototype.call$0 = function() {
  return this.to$call$0()();
};
function to$call$0(f) { return f && f.to$call$0(); }
Function.prototype.to$call$1 = function() {
  this.call$1 = this.$genStub(1);
  this.to$call$1 = function() { return this.call$1; };
  return this.call$1;
};
Function.prototype.call$1 = function($0) {
  return this.to$call$1()($0);
};
function to$call$1(f) { return f && f.to$call$1(); }
Function.prototype.to$call$2 = function() {
  this.call$2 = this.$genStub(2);
  this.to$call$2 = function() { return this.call$2; };
  return this.call$2;
};
Function.prototype.call$2 = function($0, $1) {
  return this.to$call$2()($0, $1);
};
function to$call$2(f) { return f && f.to$call$2(); }
Function.prototype.to$call$3 = function() {
  this.call$3 = this.$genStub(3);
  this.to$call$3 = function() { return this.call$3; };
  return this.call$3;
};
Function.prototype.call$3 = function($0, $1, $2) {
  return this.to$call$3()($0, $1, $2);
};
function to$call$3(f) { return f && f.to$call$3(); }
// ********** Code for Math **************
Math.parseInt = function(str) {
  var ret = parseInt(str);
    if (isNaN(ret)) $throw(new BadNumberFormatException(str));
    return ret;
}
Math.parseDouble = function(str) {
  var ret = parseFloat(str);
    if (isNaN(ret) && str != 'NaN') $throw(new BadNumberFormatException(str));
    return ret;
}
Math.min = function(a, b) {
  if (a == b) return a;
    if (a < b) {
      if (isNaN(b)) return b;
      else return a;
    }
    if (isNaN(a)) return a;
    else return b;
}
function $assert_num(x) {
  if (x == null || typeof(x) == "number") return x;
  $throw(new TypeError._internal$ctor(this, "num"))
}
function $assert_String(x) {
  if (x == null || typeof(x) == "string") return x;
  $throw(new TypeError._internal$ctor(this, "String"))
}
// ********** Code for Strings **************
function Strings() {}
Strings.String$fromCharCodes$factory = function(charCodes) {
  return StringBase.createFromCharCodes(charCodes);
}
Strings.join = function(strings, separator) {
  return StringBase.join(strings, separator);
}
// ********** Code for top level **************
function print(obj) {
  if (typeof console == 'object') {
    if (obj) obj = obj.toString();
    console.log(obj);
  } else {
    write(obj);
    write('\n');
  }
}
function _toDartException(e) {
  function attachStack(dartEx) {
    // TODO(jmesserly): setting the stack property is not a long term solution.
    var stack = e.stack;
    // The stack contains the error message, and the stack is all that is
    // printed (the exception's toString() is never called).  Make the Dart
    // exception's toString() be the dominant message.
    if (typeof stack == 'string') {
      var message = dartEx.toString();
      if (/^(Type|Range)Error:/.test(stack)) {
        // Indent JS message (it can be helpful) so new message stands out.
        stack = '    (' + stack.substring(0, stack.indexOf('\n')) + ')\n' +
                stack.substring(stack.indexOf('\n') + 1);
      }
      stack = message + '\n' + stack;
    }
    dartEx.stack = stack;
    return dartEx;
  }

  if (e instanceof TypeError) {
    switch(e.type) {
      case 'property_not_function':
      case 'called_non_callable':
        if (e.arguments[0] == null) {
          return attachStack(new NullPointerException());
        } else {
          return attachStack(new ObjectNotClosureException());
        }
        break;
      case 'non_object_property_call':
      case 'non_object_property_load':
        return attachStack(new NullPointerException());
        break;
      case 'undefined_method':
        if (e.arguments[0] == 'call' || e.arguments[0] == 'apply') {
          return attachStack(new ObjectNotClosureException());
        } else {
          // TODO(jmesserly): can this ever happen?
          // sra: Yes, seen on '$add'.
          return attachStack(new NoSuchMethodException('', e.arguments[0], []));
        }
        break;
    }
  } else if (e instanceof RangeError) {
    if (e.message.indexOf('call stack') >= 0) {
      return attachStack(new StackOverflowException());
    }
  }
  return e;
}
//  ********** Library dart:coreimpl **************
// ********** Code for ListFactory **************
ListFactory = Array;
ListFactory.prototype.assert$ListFactory = function(){return this};
ListFactory.prototype.is$List = function(){return true};
ListFactory.prototype.assert$List = function(){return this};
ListFactory.prototype.assert$List_ArgumentNode = function(){return this};
ListFactory.prototype.assert$List_Definition = function(){return this};
ListFactory.prototype.assert$List_EvaluatedValue = function(){return this};
ListFactory.prototype.assert$List_GlobalValue = function(){return this};
ListFactory.prototype.assert$List_HInstruction = function(){return this};
ListFactory.prototype.assert$List_Member = function(){return this};
ListFactory.prototype.assert$List_ParameterType = function(){return this};
ListFactory.prototype.assert$List_String = function(){return this};
ListFactory.prototype.assert$List_Token = function(){return this};
ListFactory.prototype.assert$List_Type = function(){return this};
ListFactory.prototype.assert$List_Value = function(){return this};
ListFactory.prototype.assert$List_int = function(){return this};
ListFactory.prototype.assert$Collection_E = function(){return this};
ListFactory.prototype.assert$Collection_Object = function(){return this};
ListFactory.prototype.assert$Collection_Type = function(){return this};
ListFactory.prototype.assert$Iterable = function(){return this};
ListFactory.ListFactory$from$factory = function(other) {
  var list = [];
  for (var $i = other.iterator(); $i.hasNext$0(); ) {
    var e = $i.next$0();
    list.add(e);
  }
  return (list == null ? null : list.assert$ListFactory());
}
ListFactory.prototype.add = function(value) {
  this.push(value);
}
ListFactory.prototype.addLast = function(value) {
  this.push(value);
}
ListFactory.prototype.addAll = function(collection) {
  for (var $i = collection.iterator(); $i.hasNext$0(); ) {
    var item = $i.next$0();
    this.add(item);
  }
}
ListFactory.prototype.clear = function() {
  this.length = 0;
}
ListFactory.prototype.removeLast = function() {
  return this.pop();
}
ListFactory.prototype.last = function() {
  return this[this.length - 1];
}
ListFactory.prototype.getRange = function(start, length) {
  return this.slice(start, start + length);
}
ListFactory.prototype.removeRange = function(start, length) {
  this.splice(start, length);
}
ListFactory.prototype.insertRange = function(start, length, initialValue) {
      // Splice in the values with a minimum of array allocations.
      var args = new Array(length + 2);
      args[0] = start;
      args[1] = 0;
      for (var i = 0; i < length; i++) {
        args[i + 2] = initialValue;
      }
      this.splice.apply(this, args);
      
}
ListFactory.prototype.isEmpty = function() {
  return this.length == 0;
}
ListFactory.prototype.iterator = function() {
  return new ListIterator(this);
}
ListFactory.prototype.add$1 = ListFactory.prototype.add;
ListFactory.prototype.addAll$1 = function($0) {
  return this.addAll(($0 == null ? null : $0.assert$Collection_E()));
};
ListFactory.prototype.every$1 = function($0) {
  return this.every(to$call$1($0));
};
ListFactory.prototype.filter$1 = function($0) {
  return this.filter(to$call$1($0));
};
ListFactory.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$1($0));
};
ListFactory.prototype.indexOf$1 = ListFactory.prototype.indexOf;
ListFactory.prototype.isEmpty$0 = ListFactory.prototype.isEmpty;
ListFactory.prototype.iterator$0 = ListFactory.prototype.iterator;
ListFactory.prototype.last$0 = ListFactory.prototype.last;
ListFactory.prototype.removeLast$0 = ListFactory.prototype.removeLast;
ListFactory.prototype.some$1 = function($0) {
  return this.some(to$call$1($0));
};
ListFactory.prototype.sort$1 = function($0) {
  return this.sort(to$call$2($0));
};
ListFactory_E = ListFactory;
ListFactory_HBasicBlock = ListFactory;
ListFactory_HInstruction = ListFactory;
ListFactory_K = ListFactory;
ListFactory_KeywordState = ListFactory;
ListFactory_String = ListFactory;
ListFactory_T = ListFactory;
ListFactory_V = ListFactory;
ListFactory_ValueSet = ListFactory;
ListFactory_ValueSetNode = ListFactory;
ListFactory_int = ListFactory;
// ********** Code for ListIterator **************
function ListIterator(array) {
  this._array = array;
  this._pos = 0;
  // Initializers done
}
ListIterator.prototype.assert$Iterator_T = function(){return this};
ListIterator.prototype.hasNext = function() {
  return this._array.length > this._pos;
}
ListIterator.prototype.next = function() {
  if (!this.hasNext()) {
    $throw(const$0/*const NoMoreElementsException()*/);
  }
  return this._array.$index(this._pos++);
}
ListIterator.prototype.hasNext$0 = ListIterator.prototype.hasNext;
ListIterator.prototype.next$0 = ListIterator.prototype.next;
// ********** Code for ImmutableList **************
function ImmutableList(length) {
  this._length = length;
  // Initializers done
  ListFactory_E.call(this, length);
}
/** Implements extends for Dart classes on JavaScript prototypes. */
function $inherits(child, parent) {
  if (child.prototype.__proto__) {
    child.prototype.__proto__ = parent.prototype;
  } else {
    function tmp() {};
    tmp.prototype = parent.prototype;
    child.prototype = new tmp();
    child.prototype.constructor = child;
  }
}
$inherits(ImmutableList, ListFactory_E);
ImmutableList.ImmutableList$from$factory = function(other) {
  var list = new ImmutableList(other.length);
  for (var i = 0;
   i < other.length; i++) {
    list._setindex(i, other.$index(i));
  }
  return list;
}
ImmutableList.prototype.get$length = function() {
  return this._length;
}
ImmutableList.prototype.set$length = function(length) {
  $throw(const$20/*const IllegalAccessException()*/);
}
Object.defineProperty(ImmutableList.prototype, "length", {
  get: ImmutableList.prototype.get$length,
  set: ImmutableList.prototype.set$length
});
ImmutableList.prototype._setindex = function(index, value) {
  return this[index] = value;
}
ImmutableList.prototype.$setindex = function(index, value) {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableList.prototype.removeRange = function(start, length) {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableList.prototype.insertRange = function(start, length, initialValue) {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableList.prototype.sort = function(compare) {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableList.prototype.add = function(element) {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableList.prototype.addLast = function(element) {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableList.prototype.addAll = function(elements) {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableList.prototype.clear = function() {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableList.prototype.removeLast = function() {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableList.prototype.toString = function() {
  return ListFactory.ListFactory$from$factory(this).toString();
}
ImmutableList.prototype.add$1 = ImmutableList.prototype.add;
ImmutableList.prototype.addAll$1 = function($0) {
  return this.addAll(($0 == null ? null : $0.assert$Collection_E()));
};
ImmutableList.prototype.removeLast$0 = ImmutableList.prototype.removeLast;
ImmutableList.prototype.sort$1 = function($0) {
  return this.sort(to$call$2($0));
};
ImmutableList.prototype.toString$0 = ImmutableList.prototype.toString;
// ********** Code for ImmutableMap **************
function ImmutableMap(keyValuePairs) {
  this._internal = $map([]);
  // Initializers done
  for (var i = 0;
   i < keyValuePairs.length; i += 2) {
    this._internal.$setindex(keyValuePairs.$index(i), keyValuePairs.$index(i + 1));
  }
}
ImmutableMap.prototype.assert$Map_String$Member = function(){return this};
ImmutableMap.prototype.$index = function(key) {
  return this._internal.$index(key);
}
ImmutableMap.prototype.isEmpty = function() {
  return this._internal.isEmpty();
}
ImmutableMap.prototype.get$length = function() {
  return this._internal.get$length();
}
Object.defineProperty(ImmutableMap.prototype, "length", {
  get: ImmutableMap.prototype.get$length
});
ImmutableMap.prototype.forEach = function(f) {
  this._internal.forEach(f);
}
ImmutableMap.prototype.getKeys = function() {
  return this._internal.getKeys();
}
ImmutableMap.prototype.getValues = function() {
  return this._internal.getValues();
}
ImmutableMap.prototype.containsKey = function(key) {
  return this._internal.containsKey(key);
}
ImmutableMap.prototype.$setindex = function(key, value) {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableMap.prototype.putIfAbsent = function(key, ifAbsent) {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableMap.prototype.remove = function(key) {
  $throw(const$20/*const IllegalAccessException()*/);
}
ImmutableMap.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$2($0));
};
ImmutableMap.prototype.getKeys$0 = ImmutableMap.prototype.getKeys;
ImmutableMap.prototype.getValues$0 = ImmutableMap.prototype.getValues;
ImmutableMap.prototype.isEmpty$0 = ImmutableMap.prototype.isEmpty;
ImmutableMap.prototype.remove$1 = ImmutableMap.prototype.remove;
// ********** Code for NumImplementation **************
NumImplementation = Number;
NumImplementation.prototype.assert$NumImplementation = function(){return this};
NumImplementation.prototype.assert$Comparable = function(){return this};
NumImplementation.prototype.isNaN = function() {
  return isNaN(this);
}
NumImplementation.prototype.isNegative = function() {
  return this == 0 ? (1 / this) < 0 : this < 0;
}
NumImplementation.prototype.hashCode = function() {
  return this & 0xFFFFFFF;
}
NumImplementation.prototype.toInt = function() {
  if (isNaN(this)) throw new BadNumberFormatException("NaN");
    if ((this == Infinity) || (this == -Infinity)) {
      throw new BadNumberFormatException("Infinity");
    }
    var truncated = (this < 0) ? Math.ceil(this) : Math.floor(this);

    if (truncated == -0.0) return 0;
    return truncated;
}
NumImplementation.prototype.toDouble = function() {
  return this + 0;
}
NumImplementation.prototype.compareTo = function(other) {
  var thisValue = this.toDouble();
  if (thisValue < other) {
    return -1;
  }
  else if (thisValue > other) {
    return 1;
  }
  else if (thisValue == other) {
    if (thisValue == 0) {
      var thisIsNegative = this.isNegative();
      var otherIsNegative = other.isNegative();
      if ($eq(thisIsNegative, otherIsNegative)) return 0;
      if ($notnull_bool(thisIsNegative)) return -1;
      return 1;
    }
    return 0;
  }
  else if (this.isNaN()) {
    if (other.isNaN()) {
      return 0;
    }
    return 1;
  }
  else {
    return -1;
  }
}
NumImplementation.prototype.compareTo$1 = function($0) {
  return this.compareTo(($0 == null ? null : $0.assert$NumImplementation()));
};
NumImplementation.prototype.hashCode$0 = NumImplementation.prototype.hashCode;
// ********** Code for ExceptionImplementation **************
function ExceptionImplementation(msg) {
  this._msg = msg;
  // Initializers done
}
ExceptionImplementation.prototype.toString = function() {
  return (this._msg == null) ? "Exception" : ("Exception: " + this._msg);
}
ExceptionImplementation.prototype.toString$0 = ExceptionImplementation.prototype.toString;
// ********** Code for HashMapImplementation **************
function HashMapImplementation() {
  // Initializers done
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
HashMapImplementation.prototype.assert$HashMapImplementation = function(){return this};
HashMapImplementation.prototype.assert$Map_String$Member = function(){return this};
HashMapImplementation.HashMapImplementation$from$factory = function(other) {
  var result = new HashMapImplementation();
  other.forEach((function (key, value) {
    result.$setindex(key, value);
  })
  );
  return (result == null ? null : result.assert$HashMapImplementation());
}
HashMapImplementation._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
HashMapImplementation._firstProbe = function(hashCode, length) {
  return hashCode & (length - 1);
}
HashMapImplementation._nextProbe = function(currentProbe, numberOfProbes, length) {
  return (currentProbe + numberOfProbes) & (length - 1);
}
HashMapImplementation.prototype._probeForAdding = function(key) {
  var hash = HashMapImplementation._firstProbe($assert_num(key.hashCode$0()), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  var insertionIndex = -1;
  while (true) {
    var existingKey = this._keys.$index(hash);
    if (existingKey == null) {
      if (insertionIndex < 0) return hash;
      return insertionIndex;
    }
    else if ($notnull_bool($eq(existingKey, key))) {
      return hash;
    }
    else if ((insertionIndex < 0) && (const$1/*HashMapImplementation._DELETED_KEY*/ === existingKey)) {
      insertionIndex = hash;
    }
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation.prototype._probeForLookup = function(key) {
  var hash = HashMapImplementation._firstProbe($assert_num(key.hashCode$0()), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  while (true) {
    var existingKey = this._keys.$index(hash);
    if (existingKey == null) return -1;
    if ($notnull_bool($eq(existingKey, key))) return hash;
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation.prototype._ensureCapacity = function() {
  var newNumberOfEntries = this._numberOfEntries + 1;
  if (newNumberOfEntries >= this._loadLimit) {
    this._grow(this._keys.length * 2);
    return;
  }
  var capacity = this._keys.length;
  var numberOfFreeOrDeleted = capacity - newNumberOfEntries;
  var numberOfFree = numberOfFreeOrDeleted - this._numberOfDeleted;
  if (this._numberOfDeleted > numberOfFree) {
    this._grow(this._keys.length);
  }
}
HashMapImplementation._isPowerOfTwo = function(x) {
  return ((x & (x - 1)) == 0);
}
HashMapImplementation.prototype._grow = function(newCapacity) {
  $assert(HashMapImplementation._isPowerOfTwo(newCapacity), "_isPowerOfTwo(newCapacity)", "hash_map_set.dart", 149, 12);
  var capacity = this._keys.length;
  this._loadLimit = HashMapImplementation._computeLoadLimit(newCapacity);
  var oldKeys = this._keys;
  var oldValues = this._values;
  this._keys = new ListFactory(newCapacity);
  this._values = new ListFactory(newCapacity);
  for (var i = 0;
   i < capacity; i++) {
    var key = oldKeys.$index(i);
    if (key == null || key === const$1/*HashMapImplementation._DELETED_KEY*/) {
      continue;
    }
    var value = oldValues.$index(i);
    var newIndex = this._probeForAdding(key);
    this._keys.$setindex(newIndex, key);
    this._values.$setindex(newIndex, value);
  }
  this._numberOfDeleted = 0;
}
HashMapImplementation.prototype.clear = function() {
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  var length = this._keys.length;
  for (var i = 0;
   i < length; i++) {
    this._keys.$setindex(i);
    this._values.$setindex(i);
  }
}
HashMapImplementation.prototype.$setindex = function(key, value) {
  this._ensureCapacity();
  var index = this._probeForAdding(key);
  if ((this._keys.$index(index) == null) || (this._keys.$index(index) === const$1/*HashMapImplementation._DELETED_KEY*/)) {
    this._numberOfEntries++;
  }
  this._keys.$setindex(index, key);
  this._values.$setindex(index, value);
}
HashMapImplementation.prototype.$index = function(key) {
  var index = this._probeForLookup(key);
  if (index < 0) return null;
  return this._values.$index(index);
}
HashMapImplementation.prototype.putIfAbsent = function(key, ifAbsent) {
  var index = this._probeForLookup(key);
  if (index >= 0) return this._values.$index(index);
  var value = ifAbsent();
  this.$setindex(key, value);
  return value;
}
HashMapImplementation.prototype.remove = function(key) {
  var index = this._probeForLookup(key);
  if (index >= 0) {
    this._numberOfEntries--;
    var value = this._values.$index(index);
    this._values.$setindex(index);
    this._keys.$setindex(index, const$1/*HashMapImplementation._DELETED_KEY*/);
    this._numberOfDeleted++;
    return value;
  }
  return null;
}
HashMapImplementation.prototype.isEmpty = function() {
  return this._numberOfEntries == 0;
}
HashMapImplementation.prototype.get$length = function() {
  return this._numberOfEntries;
}
Object.defineProperty(HashMapImplementation.prototype, "length", {
  get: HashMapImplementation.prototype.get$length
});
HashMapImplementation.prototype.forEach = function(f) {
  var length = this._keys.length;
  for (var i = 0;
   i < length; i++) {
    if ((this._keys.$index(i) != null) && (this._keys.$index(i) !== const$1/*HashMapImplementation._DELETED_KEY*/)) {
      f(this._keys.$index(i), this._values.$index(i));
    }
  }
}
HashMapImplementation.prototype.getKeys = function() {
  var list = new ListFactory(this.get$length());
  var i = 0;
  this.forEach(function _(key, value) {
    list.$setindex(i++, key);
  }
  );
  return list;
}
HashMapImplementation.prototype.getValues = function() {
  var list = new ListFactory(this.get$length());
  var i = 0;
  this.forEach(function _(key, value) {
    list.$setindex(i++, value);
  }
  );
  return list;
}
HashMapImplementation.prototype.containsKey = function(key) {
  return (this._probeForLookup(key) != -1);
}
HashMapImplementation.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$2($0));
};
HashMapImplementation.prototype.getKeys$0 = HashMapImplementation.prototype.getKeys;
HashMapImplementation.prototype.getValues$0 = HashMapImplementation.prototype.getValues;
HashMapImplementation.prototype.isEmpty$0 = HashMapImplementation.prototype.isEmpty;
HashMapImplementation.prototype.remove$1 = HashMapImplementation.prototype.remove;
// ********** Code for HashMapImplementation_E$E **************
function HashMapImplementation_E$E() {
  // Initializers done
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  this._loadLimit = HashMapImplementation._computeLoadLimit(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._keys = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
  this._values = new ListFactory(8/*HashMapImplementation._INITIAL_CAPACITY*/);
}
$inherits(HashMapImplementation_E$E, HashMapImplementation);
HashMapImplementation_E$E.prototype.assert$Map_String$Member = function(){return this};
HashMapImplementation_E$E._computeLoadLimit = function(capacity) {
  return $truncdiv((capacity * 3), 4);
}
HashMapImplementation_E$E._firstProbe = function(hashCode, length) {
  return hashCode & (length - 1);
}
HashMapImplementation_E$E._nextProbe = function(currentProbe, numberOfProbes, length) {
  return (currentProbe + numberOfProbes) & (length - 1);
}
HashMapImplementation_E$E.prototype._probeForAdding = function(key) {
  var hash = HashMapImplementation._firstProbe($assert_num(key.hashCode$0()), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  var insertionIndex = -1;
  while (true) {
    var existingKey = this._keys.$index(hash);
    if (existingKey == null) {
      if (insertionIndex < 0) return hash;
      return insertionIndex;
    }
    else if ($notnull_bool($eq(existingKey, key))) {
      return hash;
    }
    else if ((insertionIndex < 0) && (const$1/*HashMapImplementation._DELETED_KEY*/ === existingKey)) {
      insertionIndex = hash;
    }
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation_E$E.prototype._probeForLookup = function(key) {
  var hash = HashMapImplementation._firstProbe($assert_num(key.hashCode$0()), this._keys.length);
  var numberOfProbes = 1;
  var initialHash = hash;
  while (true) {
    var existingKey = this._keys.$index(hash);
    if (existingKey == null) return -1;
    if ($notnull_bool($eq(existingKey, key))) return hash;
    hash = HashMapImplementation._nextProbe(hash, numberOfProbes++, this._keys.length);
  }
}
HashMapImplementation_E$E.prototype._ensureCapacity = function() {
  var newNumberOfEntries = this._numberOfEntries + 1;
  if (newNumberOfEntries >= this._loadLimit) {
    this._grow(this._keys.length * 2);
    return;
  }
  var capacity = this._keys.length;
  var numberOfFreeOrDeleted = capacity - newNumberOfEntries;
  var numberOfFree = numberOfFreeOrDeleted - this._numberOfDeleted;
  if (this._numberOfDeleted > numberOfFree) {
    this._grow(this._keys.length);
  }
}
HashMapImplementation_E$E._isPowerOfTwo = function(x) {
  return ((x & (x - 1)) == 0);
}
HashMapImplementation_E$E.prototype._grow = function(newCapacity) {
  $assert(HashMapImplementation._isPowerOfTwo(newCapacity), "_isPowerOfTwo(newCapacity)", "hash_map_set.dart", 149, 12);
  var capacity = this._keys.length;
  this._loadLimit = HashMapImplementation._computeLoadLimit(newCapacity);
  var oldKeys = this._keys;
  var oldValues = this._values;
  this._keys = new ListFactory(newCapacity);
  this._values = new ListFactory(newCapacity);
  for (var i = 0;
   i < capacity; i++) {
    var key = oldKeys.$index(i);
    if (key == null || key === const$1/*HashMapImplementation._DELETED_KEY*/) {
      continue;
    }
    var value = oldValues.$index(i);
    var newIndex = this._probeForAdding(key);
    this._keys.$setindex(newIndex, key);
    this._values.$setindex(newIndex, value);
  }
  this._numberOfDeleted = 0;
}
HashMapImplementation_E$E.prototype.clear = function() {
  this._numberOfEntries = 0;
  this._numberOfDeleted = 0;
  var length = this._keys.length;
  for (var i = 0;
   i < length; i++) {
    this._keys.$setindex(i);
    this._values.$setindex(i);
  }
}
HashMapImplementation_E$E.prototype.$setindex = function(key, value) {
  this._ensureCapacity();
  var index = this._probeForAdding(key);
  if ((this._keys.$index(index) == null) || (this._keys.$index(index) === const$1/*HashMapImplementation._DELETED_KEY*/)) {
    this._numberOfEntries++;
  }
  this._keys.$setindex(index, key);
  this._values.$setindex(index, value);
}
HashMapImplementation_E$E.prototype.remove = function(key) {
  var index = this._probeForLookup(key);
  if (index >= 0) {
    this._numberOfEntries--;
    var value = this._values.$index(index);
    this._values.$setindex(index);
    this._keys.$setindex(index, const$1/*HashMapImplementation._DELETED_KEY*/);
    this._numberOfDeleted++;
    return value;
  }
  return null;
}
HashMapImplementation_E$E.prototype.isEmpty = function() {
  return this._numberOfEntries == 0;
}
HashMapImplementation_E$E.prototype.forEach = function(f) {
  var length = this._keys.length;
  for (var i = 0;
   i < length; i++) {
    if ((this._keys.$index(i) != null) && (this._keys.$index(i) !== const$1/*HashMapImplementation._DELETED_KEY*/)) {
      f(this._keys.$index(i), this._values.$index(i));
    }
  }
}
HashMapImplementation_E$E.prototype.getKeys = function() {
  var list = new ListFactory(this.get$length());
  var i = 0;
  this.forEach(function _(key, value) {
    list.$setindex(i++, key);
  }
  );
  return list;
}
HashMapImplementation_E$E.prototype.containsKey = function(key) {
  return (this._probeForLookup(key) != -1);
}
// ********** Code for HashMapImplementation_Element$HInstruction **************
function HashMapImplementation_Element$HInstruction() {}
$inherits(HashMapImplementation_Element$HInstruction, HashMapImplementation);
HashMapImplementation_Element$HInstruction.prototype.assert$Map_String$Member = function(){$throw(new TypeError._internal$ctor(this, "Map<String, Member>"))};
// ********** Code for HashMapImplementation_Element$HLocal **************
function HashMapImplementation_Element$HLocal() {}
$inherits(HashMapImplementation_Element$HLocal, HashMapImplementation);
HashMapImplementation_Element$HLocal.prototype.assert$Map_String$Member = function(){$throw(new TypeError._internal$ctor(this, "Map<String, Member>"))};
// ********** Code for HashMapImplementation_K$DoubleLinkedQueueEntry_KeyValuePair_K$V **************
function HashMapImplementation_K$DoubleLinkedQueueEntry_KeyValuePair_K$V() {}
$inherits(HashMapImplementation_K$DoubleLinkedQueueEntry_KeyValuePair_K$V, HashMapImplementation);
HashMapImplementation_K$DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype.assert$Map_String$Member = function(){$throw(new TypeError._internal$ctor(this, "Map<String, Member>"))};
// ********** Code for HashMapImplementation_String$EvaluatedValue **************
function HashMapImplementation_String$EvaluatedValue() {}
$inherits(HashMapImplementation_String$EvaluatedValue, HashMapImplementation);
HashMapImplementation_String$EvaluatedValue.prototype.assert$Map_String$Member = function(){$throw(new TypeError._internal$ctor(this, "Map<String, Member>"))};
// ********** Code for HashMapImplementation_String$int **************
function HashMapImplementation_String$int() {}
$inherits(HashMapImplementation_String$int, HashMapImplementation);
HashMapImplementation_String$int.prototype.assert$Map_String$Member = function(){$throw(new TypeError._internal$ctor(this, "Map<String, Member>"))};
// ********** Code for HashMapImplementation_int$HInstruction **************
function HashMapImplementation_int$HInstruction() {}
$inherits(HashMapImplementation_int$HInstruction, HashMapImplementation);
HashMapImplementation_int$HInstruction.prototype.assert$Map_String$Member = function(){$throw(new TypeError._internal$ctor(this, "Map<String, Member>"))};
// ********** Code for HashMapImplementation_int$String **************
function HashMapImplementation_int$String() {}
$inherits(HashMapImplementation_int$String, HashMapImplementation);
HashMapImplementation_int$String.prototype.assert$Map_String$Member = function(){$throw(new TypeError._internal$ctor(this, "Map<String, Member>"))};
// ********** Code for HashSetImplementation **************
function HashSetImplementation() {
  // Initializers done
  this._backingMap = new HashMapImplementation_E$E();
}
HashSetImplementation.prototype.assert$HashSetImplementation = function(){return this};
HashSetImplementation.prototype.assert$Collection_E = function(){return this};
HashSetImplementation.prototype.assert$Collection_Object = function(){return this};
HashSetImplementation.prototype.assert$Collection_Type = function(){return this};
HashSetImplementation.prototype.assert$Iterable = function(){return this};
HashSetImplementation.HashSetImplementation$from$factory = function(other) {
  var set = new HashSetImplementation();
  for (var $i = other.iterator(); $i.hasNext$0(); ) {
    var e = $i.next$0();
    set.add(e);
  }
  return (set == null ? null : set.assert$HashSetImplementation());
}
HashSetImplementation.prototype.clear = function() {
  this._backingMap.clear();
}
HashSetImplementation.prototype.add = function(value) {
  this._backingMap.$setindex(value, value);
}
HashSetImplementation.prototype.contains = function(value) {
  return this._backingMap.containsKey(value);
}
HashSetImplementation.prototype.remove = function(value) {
  if (!this._backingMap.containsKey(value)) return false;
  this._backingMap.remove(value);
  return true;
}
HashSetImplementation.prototype.addAll = function(collection) {
  var $this = this; // closure support
  collection.forEach(function _(value) {
    $this.add(value);
  }
  );
}
HashSetImplementation.prototype.forEach = function(f) {
  this._backingMap.forEach(function _(key, value) {
    f(key);
  }
  );
}
HashSetImplementation.prototype.filter = function(f) {
  var result = new HashSetImplementation();
  this._backingMap.forEach(function _(key, value) {
    if (f(key)) result.add(key);
  }
  );
  return result;
}
HashSetImplementation.prototype.every = function(f) {
  var keys = this._backingMap.getKeys();
  return $assert_bool(keys.every(f));
}
HashSetImplementation.prototype.some = function(f) {
  var keys = this._backingMap.getKeys();
  return $assert_bool(keys.some(f));
}
HashSetImplementation.prototype.isEmpty = function() {
  return this._backingMap.isEmpty();
}
HashSetImplementation.prototype.get$length = function() {
  return this._backingMap.get$length();
}
Object.defineProperty(HashSetImplementation.prototype, "length", {
  get: HashSetImplementation.prototype.get$length
});
HashSetImplementation.prototype.iterator = function() {
  return new HashSetIterator_E(this);
}
HashSetImplementation.prototype.add$1 = HashSetImplementation.prototype.add;
HashSetImplementation.prototype.addAll$1 = function($0) {
  return this.addAll(($0 == null ? null : $0.assert$Collection_E()));
};
HashSetImplementation.prototype.contains$1 = HashSetImplementation.prototype.contains;
HashSetImplementation.prototype.every$1 = function($0) {
  return this.every(to$call$1($0));
};
HashSetImplementation.prototype.filter$1 = function($0) {
  return this.filter(to$call$1($0));
};
HashSetImplementation.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$1($0));
};
HashSetImplementation.prototype.isEmpty$0 = HashSetImplementation.prototype.isEmpty;
HashSetImplementation.prototype.iterator$0 = HashSetImplementation.prototype.iterator;
HashSetImplementation.prototype.remove$1 = HashSetImplementation.prototype.remove;
HashSetImplementation.prototype.some$1 = function($0) {
  return this.some(to$call$1($0));
};
// ********** Code for HashSetImplementation_E **************
function HashSetImplementation_E() {}
$inherits(HashSetImplementation_E, HashSetImplementation);
HashSetImplementation_E.prototype.assert$Collection_E = function(){return this};
HashSetImplementation_E.prototype.assert$Collection_Object = function(){return this};
HashSetImplementation_E.prototype.assert$Collection_Type = function(){return this};
HashSetImplementation_E.prototype.assert$Iterable = function(){return this};
// ********** Code for HashSetImplementation_HInstruction **************
function HashSetImplementation_HInstruction() {}
$inherits(HashSetImplementation_HInstruction, HashSetImplementation);
HashSetImplementation_HInstruction.prototype.assert$Collection_E = function(){return this};
HashSetImplementation_HInstruction.prototype.assert$Collection_Object = function(){return this};
HashSetImplementation_HInstruction.prototype.assert$Collection_Type = function(){$throw(new TypeError._internal$ctor(this, "Collection<Type>"))};
HashSetImplementation_HInstruction.prototype.assert$Iterable = function(){return this};
// ********** Code for HashSetImplementation_HPhi **************
function HashSetImplementation_HPhi() {}
$inherits(HashSetImplementation_HPhi, HashSetImplementation);
HashSetImplementation_HPhi.prototype.assert$Collection_E = function(){return this};
HashSetImplementation_HPhi.prototype.assert$Collection_Object = function(){return this};
HashSetImplementation_HPhi.prototype.assert$Collection_Type = function(){$throw(new TypeError._internal$ctor(this, "Collection<Type>"))};
HashSetImplementation_HPhi.prototype.assert$Iterable = function(){return this};
// ********** Code for HashSetImplementation_String **************
function HashSetImplementation_String() {}
$inherits(HashSetImplementation_String, HashSetImplementation);
HashSetImplementation_String.prototype.assert$Collection_E = function(){return this};
HashSetImplementation_String.prototype.assert$Collection_Object = function(){return this};
HashSetImplementation_String.prototype.assert$Collection_Type = function(){$throw(new TypeError._internal$ctor(this, "Collection<Type>"))};
HashSetImplementation_String.prototype.assert$Iterable = function(){return this};
// ********** Code for HashSetImplementation_lang_Type **************
function HashSetImplementation_lang_Type() {}
$inherits(HashSetImplementation_lang_Type, HashSetImplementation);
HashSetImplementation_lang_Type.prototype.assert$Collection_E = function(){return this};
HashSetImplementation_lang_Type.prototype.assert$Collection_Object = function(){return this};
HashSetImplementation_lang_Type.prototype.assert$Collection_Type = function(){return this};
HashSetImplementation_lang_Type.prototype.assert$Iterable = function(){return this};
// ********** Code for HashSetImplementation_int **************
function HashSetImplementation_int() {}
$inherits(HashSetImplementation_int, HashSetImplementation);
HashSetImplementation_int.prototype.assert$Collection_E = function(){return this};
HashSetImplementation_int.prototype.assert$Collection_Object = function(){return this};
HashSetImplementation_int.prototype.assert$Collection_Type = function(){$throw(new TypeError._internal$ctor(this, "Collection<Type>"))};
HashSetImplementation_int.prototype.assert$Iterable = function(){return this};
// ********** Code for HashSetIterator **************
function HashSetIterator(set_) {
  this._nextValidIndex = -1;
  this._entries = set_._backingMap._keys;
  // Initializers done
  this._advance();
}
HashSetIterator.prototype.assert$Iterator_T = function(){return this};
HashSetIterator.prototype.hasNext = function() {
  if (this._nextValidIndex >= this._entries.length) return false;
  if (this._entries.$index(this._nextValidIndex) === const$1/*HashMapImplementation._DELETED_KEY*/) {
    this._advance();
  }
  return this._nextValidIndex < this._entries.length;
}
HashSetIterator.prototype.next = function() {
  if (!this.hasNext()) {
    $throw(const$0/*const NoMoreElementsException()*/);
  }
  var res = this._entries.$index(this._nextValidIndex);
  this._advance();
  return res;
}
HashSetIterator.prototype._advance = function() {
  var length = this._entries.length;
  var entry;
  var deletedKey = const$1/*HashMapImplementation._DELETED_KEY*/;
  do {
    if (++this._nextValidIndex >= length) break;
    entry = this._entries.$index(this._nextValidIndex);
  }
  while ((entry == null) || (entry === deletedKey))
}
HashSetIterator.prototype.hasNext$0 = HashSetIterator.prototype.hasNext;
HashSetIterator.prototype.next$0 = HashSetIterator.prototype.next;
// ********** Code for HashSetIterator_E **************
function HashSetIterator_E(set_) {
  this._nextValidIndex = -1;
  this._entries = set_._backingMap._keys;
  // Initializers done
  this._advance();
}
$inherits(HashSetIterator_E, HashSetIterator);
HashSetIterator_E.prototype.assert$Iterator_T = function(){return this};
HashSetIterator_E.prototype._advance = function() {
  var length = this._entries.length;
  var entry;
  var deletedKey = const$1/*HashMapImplementation._DELETED_KEY*/;
  do {
    if (++this._nextValidIndex >= length) break;
    entry = this._entries.$index(this._nextValidIndex);
  }
  while ((entry == null) || (entry === deletedKey))
}
// ********** Code for _DeletedKeySentinel **************
function _DeletedKeySentinel() {
  // Initializers done
}
// ********** Code for KeyValuePair **************
function KeyValuePair(key, value) {
  this.key = key;
  this.value = value;
  // Initializers done
}
KeyValuePair.prototype.get$value = function() { return this.value; };
KeyValuePair.prototype.set$value = function(value) { return this.value = value; };
// ********** Code for KeyValuePair_K$V **************
function KeyValuePair_K$V(key, value) {
  this.key = key;
  this.value = value;
  // Initializers done
}
$inherits(KeyValuePair_K$V, KeyValuePair);
// ********** Code for LinkedHashMapImplementation **************
function LinkedHashMapImplementation() {
  // Initializers done
  this._map = new HashMapImplementation();
  this._list = new DoubleLinkedQueue_KeyValuePair_K$V();
}
LinkedHashMapImplementation.prototype.assert$Map_String$Member = function(){return this};
LinkedHashMapImplementation.prototype.$setindex = function(key, value) {
  if (this._map.containsKey(key)) {
    this._map.$index(key).get$element().set$value(value);
  }
  else {
    this._list.addLast(new KeyValuePair_K$V(key, value));
    this._map.$setindex(key, this._list.lastEntry());
  }
}
LinkedHashMapImplementation.prototype.$index = function(key) {
  var $0;
  var entry = (($0 = this._map.$index(key)) == null ? null : $0.assert$DoubleLinkedQueueEntry_KeyValuePair_K$V());
  if (entry == null) return null;
  return entry.get$element().get$value();
}
LinkedHashMapImplementation.prototype.remove = function(key) {
  var $0;
  var entry = (($0 = this._map.remove(key)) == null ? null : $0.assert$DoubleLinkedQueueEntry_KeyValuePair_K$V());
  if (entry == null) return null;
  entry.remove();
  return entry.get$element().get$value();
}
LinkedHashMapImplementation.prototype.putIfAbsent = function(key, ifAbsent) {
  var value = this.$index(key);
  if ((this.$index(key) == null) && !(this.containsKey(key))) {
    value = ifAbsent();
    this.$setindex(key, value);
  }
  return value;
}
LinkedHashMapImplementation.prototype.getKeys = function() {
  var list = new ListFactory(this.get$length());
  var index = 0;
  this._list.forEach(function _(entry) {
    list.$setindex(index++, entry.key);
  }
  );
  $assert(index == this.get$length(), "index == length", "linked_hash_map.dart", 76, 12);
  return list;
}
LinkedHashMapImplementation.prototype.getValues = function() {
  var list = new ListFactory(this.get$length());
  var index = 0;
  this._list.forEach(function _(entry) {
    list.$setindex(index++, entry.value);
  }
  );
  $assert(index == this.get$length(), "index == length", "linked_hash_map.dart", 87, 12);
  return list;
}
LinkedHashMapImplementation.prototype.forEach = function(f) {
  this._list.forEach(function _(entry) {
    f(entry.key, entry.value);
  }
  );
}
LinkedHashMapImplementation.prototype.containsKey = function(key) {
  return this._map.containsKey(key);
}
LinkedHashMapImplementation.prototype.get$length = function() {
  return this._map.get$length();
}
Object.defineProperty(LinkedHashMapImplementation.prototype, "length", {
  get: LinkedHashMapImplementation.prototype.get$length
});
LinkedHashMapImplementation.prototype.isEmpty = function() {
  return this.get$length() == 0;
}
LinkedHashMapImplementation.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$2($0));
};
LinkedHashMapImplementation.prototype.getKeys$0 = LinkedHashMapImplementation.prototype.getKeys;
LinkedHashMapImplementation.prototype.getValues$0 = LinkedHashMapImplementation.prototype.getValues;
LinkedHashMapImplementation.prototype.isEmpty$0 = LinkedHashMapImplementation.prototype.isEmpty;
LinkedHashMapImplementation.prototype.remove$1 = LinkedHashMapImplementation.prototype.remove;
// ********** Code for LinkedHashMapImplementation_Element$String **************
function LinkedHashMapImplementation_Element$String() {}
$inherits(LinkedHashMapImplementation_Element$String, LinkedHashMapImplementation);
LinkedHashMapImplementation_Element$String.prototype.assert$Map_String$Member = function(){$throw(new TypeError._internal$ctor(this, "Map<String, Member>"))};
// ********** Code for LinkedHashMapImplementation_Node$Element **************
function LinkedHashMapImplementation_Node$Element() {}
$inherits(LinkedHashMapImplementation_Node$Element, LinkedHashMapImplementation);
LinkedHashMapImplementation_Node$Element.prototype.assert$Map_String$Member = function(){$throw(new TypeError._internal$ctor(this, "Map<String, Member>"))};
// ********** Code for LinkedHashMapImplementation_String$Keyword **************
function LinkedHashMapImplementation_String$Keyword() {}
$inherits(LinkedHashMapImplementation_String$Keyword, LinkedHashMapImplementation);
LinkedHashMapImplementation_String$Keyword.prototype.assert$Map_String$Member = function(){$throw(new TypeError._internal$ctor(this, "Map<String, Member>"))};
// ********** Code for DoubleLinkedQueueEntry **************
function DoubleLinkedQueueEntry(e) {
  // Initializers done
  this._element = e;
}
DoubleLinkedQueueEntry.prototype.assert$DoubleLinkedQueueEntry_KeyValuePair_K$V = function(){return this};
DoubleLinkedQueueEntry.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
DoubleLinkedQueueEntry.prototype.prepend = function(e) {
  new DoubleLinkedQueueEntry_E(e)._link(this._previous, this);
}
DoubleLinkedQueueEntry.prototype.remove = function() {
  this._previous._next = this._next;
  this._next._previous = this._previous;
  this._next = null;
  this._previous = null;
  return this._element;
}
DoubleLinkedQueueEntry.prototype._asNonSentinelEntry = function() {
  return this;
}
DoubleLinkedQueueEntry.prototype.previousEntry = function() {
  return this._previous._asNonSentinelEntry();
}
DoubleLinkedQueueEntry.prototype.get$element = function() {
  return this._element;
}
// ********** Code for DoubleLinkedQueueEntry_E **************
function DoubleLinkedQueueEntry_E(e) {
  // Initializers done
  this._element = e;
}
$inherits(DoubleLinkedQueueEntry_E, DoubleLinkedQueueEntry);
DoubleLinkedQueueEntry_E.prototype.assert$DoubleLinkedQueueEntry_KeyValuePair_K$V = function(){return this};
DoubleLinkedQueueEntry_E.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
DoubleLinkedQueueEntry_E.prototype.prepend = function(e) {
  new DoubleLinkedQueueEntry_E(e)._link(this._previous, this);
}
DoubleLinkedQueueEntry_E.prototype.remove = function() {
  this._previous._next = this._next;
  this._next._previous = this._previous;
  this._next = null;
  this._previous = null;
  return this._element;
}
DoubleLinkedQueueEntry_E.prototype._asNonSentinelEntry = function() {
  return this;
}
DoubleLinkedQueueEntry_E.prototype.previousEntry = function() {
  return this._previous._asNonSentinelEntry();
}
// ********** Code for DoubleLinkedQueueEntry_KeyValuePair_K$V **************
function DoubleLinkedQueueEntry_KeyValuePair_K$V(e) {
  // Initializers done
  this._element = e;
}
$inherits(DoubleLinkedQueueEntry_KeyValuePair_K$V, DoubleLinkedQueueEntry);
DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype.assert$DoubleLinkedQueueEntry_KeyValuePair_K$V = function(){return this};
DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype._link = function(p, n) {
  this._next = n;
  this._previous = p;
  p._next = this;
  n._previous = this;
}
DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype.prepend = function(e) {
  new DoubleLinkedQueueEntry_KeyValuePair_K$V(e)._link(this._previous, this);
}
DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype.remove = function() {
  this._previous._next = this._next;
  this._next._previous = this._previous;
  this._next = null;
  this._previous = null;
  return this._element;
}
DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype._asNonSentinelEntry = function() {
  return this;
}
DoubleLinkedQueueEntry_KeyValuePair_K$V.prototype.previousEntry = function() {
  var $0;
  return (($0 = this._previous._asNonSentinelEntry()) == null ? null : $0.assert$DoubleLinkedQueueEntry_KeyValuePair_K$V());
}
// ********** Code for _DoubleLinkedQueueEntrySentinel **************
function _DoubleLinkedQueueEntrySentinel() {
  // Initializers done
  DoubleLinkedQueueEntry_E.call(this, null);
  this._link(this, this);
}
$inherits(_DoubleLinkedQueueEntrySentinel, DoubleLinkedQueueEntry_E);
_DoubleLinkedQueueEntrySentinel.prototype.remove = function() {
  $throw(const$5/*const EmptyQueueException()*/);
}
_DoubleLinkedQueueEntrySentinel.prototype._asNonSentinelEntry = function() {
  return null;
}
_DoubleLinkedQueueEntrySentinel.prototype.get$element = function() {
  $throw(const$5/*const EmptyQueueException()*/);
}
// ********** Code for _DoubleLinkedQueueEntrySentinel_E **************
function _DoubleLinkedQueueEntrySentinel_E() {
  // Initializers done
  DoubleLinkedQueueEntry_E.call(this, null);
  this._link(this, this);
}
$inherits(_DoubleLinkedQueueEntrySentinel_E, _DoubleLinkedQueueEntrySentinel);
// ********** Code for _DoubleLinkedQueueEntrySentinel_KeyValuePair_K$V **************
function _DoubleLinkedQueueEntrySentinel_KeyValuePair_K$V() {
  // Initializers done
  DoubleLinkedQueueEntry_KeyValuePair_K$V.call(this, null);
  this._link(this, this);
}
$inherits(_DoubleLinkedQueueEntrySentinel_KeyValuePair_K$V, _DoubleLinkedQueueEntrySentinel);
// ********** Code for DoubleLinkedQueue **************
function DoubleLinkedQueue() {
  // Initializers done
  this._sentinel = new _DoubleLinkedQueueEntrySentinel_E();
}
DoubleLinkedQueue.prototype.assert$Collection_E = function(){return this};
DoubleLinkedQueue.prototype.assert$Collection_Object = function(){return this};
DoubleLinkedQueue.prototype.assert$Collection_Type = function(){return this};
DoubleLinkedQueue.prototype.assert$Iterable = function(){return this};
DoubleLinkedQueue.prototype.addLast = function(value) {
  this._sentinel.prepend(value);
}
DoubleLinkedQueue.prototype.add = function(value) {
  this.addLast(value);
}
DoubleLinkedQueue.prototype.addAll = function(collection) {
  for (var $i = collection.iterator(); $i.hasNext$0(); ) {
    var e = $i.next$0();
    this.add(e);
  }
}
DoubleLinkedQueue.prototype.removeLast = function() {
  return this._sentinel._previous.remove();
}
DoubleLinkedQueue.prototype.removeFirst = function() {
  return this._sentinel._next.remove();
}
DoubleLinkedQueue.prototype.last = function() {
  return this._sentinel._previous.get$element();
}
DoubleLinkedQueue.prototype.lastEntry = function() {
  return this._sentinel.previousEntry();
}
DoubleLinkedQueue.prototype.get$length = function() {
  var counter = 0;
  this.forEach(function _(element) {
    counter++;
  }
  );
  return counter;
}
Object.defineProperty(DoubleLinkedQueue.prototype, "length", {
  get: DoubleLinkedQueue.prototype.get$length
});
DoubleLinkedQueue.prototype.isEmpty = function() {
  return (this._sentinel._next === this._sentinel);
}
DoubleLinkedQueue.prototype.forEach = function(f) {
  var entry = this._sentinel._next;
  while (entry !== this._sentinel) {
    var nextEntry = entry._next;
    f(entry._element);
    entry = nextEntry;
  }
}
DoubleLinkedQueue.prototype.every = function(f) {
  var entry = this._sentinel._next;
  while (entry !== this._sentinel) {
    var nextEntry = entry._next;
    if (!f(entry._element)) return false;
    entry = nextEntry;
  }
  return true;
}
DoubleLinkedQueue.prototype.some = function(f) {
  var entry = this._sentinel._next;
  while (entry !== this._sentinel) {
    var nextEntry = entry._next;
    if (f(entry._element)) return true;
    entry = nextEntry;
  }
  return false;
}
DoubleLinkedQueue.prototype.filter = function(f) {
  var other = new DoubleLinkedQueue();
  var entry = this._sentinel._next;
  while (entry !== this._sentinel) {
    var nextEntry = entry._next;
    if (f(entry._element)) other.addLast(entry._element);
    entry = nextEntry;
  }
  return other;
}
DoubleLinkedQueue.prototype.iterator = function() {
  return new _DoubleLinkedQueueIterator_E(this._sentinel);
}
DoubleLinkedQueue.prototype.add$1 = DoubleLinkedQueue.prototype.add;
DoubleLinkedQueue.prototype.addAll$1 = function($0) {
  return this.addAll(($0 == null ? null : $0.assert$Collection_E()));
};
DoubleLinkedQueue.prototype.every$1 = function($0) {
  return this.every(to$call$1($0));
};
DoubleLinkedQueue.prototype.filter$1 = function($0) {
  return this.filter(to$call$1($0));
};
DoubleLinkedQueue.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$1($0));
};
DoubleLinkedQueue.prototype.isEmpty$0 = DoubleLinkedQueue.prototype.isEmpty;
DoubleLinkedQueue.prototype.iterator$0 = DoubleLinkedQueue.prototype.iterator;
DoubleLinkedQueue.prototype.last$0 = DoubleLinkedQueue.prototype.last;
DoubleLinkedQueue.prototype.removeLast$0 = DoubleLinkedQueue.prototype.removeLast;
DoubleLinkedQueue.prototype.some$1 = function($0) {
  return this.some(to$call$1($0));
};
// ********** Code for DoubleLinkedQueue_ClassElement **************
function DoubleLinkedQueue_ClassElement() {}
$inherits(DoubleLinkedQueue_ClassElement, DoubleLinkedQueue);
DoubleLinkedQueue_ClassElement.prototype.assert$Collection_E = function(){return this};
DoubleLinkedQueue_ClassElement.prototype.assert$Collection_Object = function(){return this};
DoubleLinkedQueue_ClassElement.prototype.assert$Collection_Type = function(){$throw(new TypeError._internal$ctor(this, "Collection<Type>"))};
DoubleLinkedQueue_ClassElement.prototype.assert$Iterable = function(){return this};
// ********** Code for DoubleLinkedQueue_E **************
function DoubleLinkedQueue_E() {}
$inherits(DoubleLinkedQueue_E, DoubleLinkedQueue);
DoubleLinkedQueue_E.prototype.assert$Collection_E = function(){return this};
DoubleLinkedQueue_E.prototype.assert$Collection_Object = function(){return this};
DoubleLinkedQueue_E.prototype.assert$Collection_Type = function(){return this};
DoubleLinkedQueue_E.prototype.assert$Iterable = function(){return this};
// ********** Code for DoubleLinkedQueue_Element **************
function DoubleLinkedQueue_Element() {}
$inherits(DoubleLinkedQueue_Element, DoubleLinkedQueue);
DoubleLinkedQueue_Element.prototype.assert$Collection_E = function(){return this};
DoubleLinkedQueue_Element.prototype.assert$Collection_Object = function(){return this};
DoubleLinkedQueue_Element.prototype.assert$Collection_Type = function(){$throw(new TypeError._internal$ctor(this, "Collection<Type>"))};
DoubleLinkedQueue_Element.prototype.assert$Iterable = function(){return this};
// ********** Code for DoubleLinkedQueue_KeyValuePair_K$V **************
function DoubleLinkedQueue_KeyValuePair_K$V() {
  // Initializers done
  this._sentinel = new _DoubleLinkedQueueEntrySentinel_KeyValuePair_K$V();
}
$inherits(DoubleLinkedQueue_KeyValuePair_K$V, DoubleLinkedQueue);
DoubleLinkedQueue_KeyValuePair_K$V.prototype.assert$Collection_E = function(){return this};
DoubleLinkedQueue_KeyValuePair_K$V.prototype.assert$Collection_Object = function(){return this};
DoubleLinkedQueue_KeyValuePair_K$V.prototype.assert$Collection_Type = function(){$throw(new TypeError._internal$ctor(this, "Collection<Type>"))};
DoubleLinkedQueue_KeyValuePair_K$V.prototype.assert$Iterable = function(){return this};
DoubleLinkedQueue_KeyValuePair_K$V.prototype.addLast = function(value) {
  this._sentinel.prepend(value);
}
DoubleLinkedQueue_KeyValuePair_K$V.prototype.lastEntry = function() {
  return this._sentinel.previousEntry();
}
DoubleLinkedQueue_KeyValuePair_K$V.prototype.forEach = function(f) {
  var entry = this._sentinel._next;
  while (entry !== this._sentinel) {
    var nextEntry = entry._next;
    f(entry._element);
    entry = nextEntry;
  }
}
// ********** Code for _DoubleLinkedQueueIterator **************
function _DoubleLinkedQueueIterator(_sentinel) {
  this._sentinel = _sentinel;
  // Initializers done
  this._currentEntry = this._sentinel;
}
_DoubleLinkedQueueIterator.prototype.assert$Iterator_T = function(){return this};
_DoubleLinkedQueueIterator.prototype.hasNext = function() {
  return this._currentEntry._next !== this._sentinel;
}
_DoubleLinkedQueueIterator.prototype.next = function() {
  if (!this.hasNext()) {
    $throw(const$0/*const NoMoreElementsException()*/);
  }
  this._currentEntry = this._currentEntry._next;
  return this._currentEntry.get$element();
}
_DoubleLinkedQueueIterator.prototype.hasNext$0 = _DoubleLinkedQueueIterator.prototype.hasNext;
_DoubleLinkedQueueIterator.prototype.next$0 = _DoubleLinkedQueueIterator.prototype.next;
// ********** Code for _DoubleLinkedQueueIterator_E **************
function _DoubleLinkedQueueIterator_E(_sentinel) {
  this._sentinel = _sentinel;
  // Initializers done
  this._currentEntry = this._sentinel;
}
$inherits(_DoubleLinkedQueueIterator_E, _DoubleLinkedQueueIterator);
_DoubleLinkedQueueIterator_E.prototype.assert$Iterator_T = function(){return this};
// ********** Code for StopwatchImplementation **************
function StopwatchImplementation() {
  this._start = null;
  this._stop = null;
  // Initializers done
}
StopwatchImplementation.prototype.start = function() {
  if (this._start == null) {
    this._start = Clock.now();
  }
  else {
    if (this._stop == null) {
      return;
    }
    this._start = Clock.now() - (this._stop - this._start);
  }
}
StopwatchImplementation.prototype.get$start = function() {
  return StopwatchImplementation.prototype.start.bind(this);
}
StopwatchImplementation.prototype.stop = function() {
  if (this._start == null) {
    return;
  }
  this._stop = Clock.now();
}
StopwatchImplementation.prototype.elapsed = function() {
  if (this._start == null) {
    return 0;
  }
  return (this._stop == null) ? (Clock.now() - this._start) : (this._stop - this._start);
}
StopwatchImplementation.prototype.elapsedInMs = function() {
  return $truncdiv((this.elapsed() * 1000), this.frequency());
}
StopwatchImplementation.prototype.frequency = function() {
  return Clock.frequency();
}
// ********** Code for StringBufferImpl **************
function StringBufferImpl(content) {
  // Initializers done
  this.clear();
  this.add(content);
}
StringBufferImpl.prototype.assert$StringBuffer = function(){return this};
StringBufferImpl.prototype.get$length = function() {
  return this._length;
}
Object.defineProperty(StringBufferImpl.prototype, "length", {
  get: StringBufferImpl.prototype.get$length
});
StringBufferImpl.prototype.isEmpty = function() {
  return this._length == 0;
}
StringBufferImpl.prototype.add = function(obj) {
  var str = $assert_String(obj.toString());
  if (str == null || str.isEmpty()) return this;
  this._buffer.add(str);
  this._length += str.length;
  return this;
}
StringBufferImpl.prototype.addAll = function(objects) {
  for (var $i = objects.iterator(); $i.hasNext$0(); ) {
    var obj = $i.next$0();
    this.add(obj);
  }
  return this;
}
StringBufferImpl.prototype.clear = function() {
  this._buffer = new ListFactory();
  this._length = 0;
  return this;
}
StringBufferImpl.prototype.toString = function() {
  if (this._buffer.length == 0) return "";
  if (this._buffer.length == 1) return $assert_String(this._buffer.$index(0));
  var result = StringBase.concatAll(this._buffer);
  this._buffer.clear();
  this._buffer.add(result);
  return result;
}
StringBufferImpl.prototype.add$1 = StringBufferImpl.prototype.add;
StringBufferImpl.prototype.addAll$1 = function($0) {
  return this.addAll(($0 == null ? null : $0.assert$Collection_Object()));
};
StringBufferImpl.prototype.isEmpty$0 = StringBufferImpl.prototype.isEmpty;
StringBufferImpl.prototype.toString$0 = StringBufferImpl.prototype.toString;
// ********** Code for StringBase **************
function StringBase() {}
StringBase.createFromCharCodes = function(charCodes) {
  if (Object.getPrototypeOf(charCodes) !== Array.prototype) {
    charCodes = new ListFactory.ListFactory$from$factory(charCodes);
  }
  return String.fromCharCode.apply(null, charCodes);
}
StringBase.join = function(strings, separator) {
  if (strings.length == 0) return '';
  var s = $assert_String(strings.$index(0));
  for (var i = 1;
   i < strings.length; i++) {
    s = s + separator + strings.$index(i);
  }
  return s;
}
StringBase.concatAll = function(strings) {
  return StringBase.join(strings, "");
}
// ********** Code for StringImplementation **************
StringImplementation = String;
StringImplementation.prototype.assert$Pattern = function(){return this};
StringImplementation.prototype.assert$Comparable = function(){return this};
StringImplementation.prototype.endsWith = function(other) {
  if (other.length > this.length) return false;
    return other == this.substring(this.length - other.length);
}
StringImplementation.prototype.startsWith = function(other) {
  if (other.length > this.length) return false;
    return other == this.substring(0, other.length);
}
StringImplementation.prototype.isEmpty = function() {
  return this.length == 0;
}
StringImplementation.prototype.contains = function(pattern, startIndex) {
  return this.indexOf(pattern, startIndex) >= 0;
}
StringImplementation.prototype.replaceFirst = function(from, to) {
  return this.replace(from, to);
}
StringImplementation.prototype.replaceAll = function(from, to) {
  if (typeof(from) == 'string' || from instanceof String) {
    from = new RegExp(from.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'g');
  }
  return this.replace(from, to);
}
StringImplementation.prototype.hashCode = function() {
  if (this.hash_ === undefined) {
      for (var i = 0; i < this.length; i++) {
        var ch = this.charCodeAt(i);
        this.hash_ += ch;
        this.hash_ += this.hash_ << 10;
        this.hash_ ^= this.hash_ >> 6;
      }

      this.hash_ += this.hash_ << 3;
      this.hash_ ^= this.hash_ >> 11;
      this.hash_ += this.hash_ << 15;
      this.hash_ = this.hash_ & ((1 << 29) - 1);
    }
    return this.hash_;
}
StringImplementation.prototype.compareTo = function(other) {
  return this == other ? 0 : this < other ? -1 : 1;
}
StringImplementation.prototype.charCodeAt$1 = function($0) {
  return this.charCodeAt($assert_num($0));
};
StringImplementation.prototype.compareTo$1 = function($0) {
  return this.compareTo($assert_String($0));
};
StringImplementation.prototype.endsWith$1 = function($0) {
  return this.endsWith($assert_String($0));
};
StringImplementation.prototype.hashCode$0 = StringImplementation.prototype.hashCode;
StringImplementation.prototype.indexOf$1 = function($0) {
  return this.indexOf($assert_String($0));
};
StringImplementation.prototype.isEmpty$0 = StringImplementation.prototype.isEmpty;
StringImplementation.prototype.replaceAll$2 = function($0, $1) {
  return this.replaceAll(($0 == null ? null : $0.assert$Pattern()), $assert_String($1));
};
StringImplementation.prototype.replaceFirst$2 = function($0, $1) {
  return this.replaceFirst(($0 == null ? null : $0.assert$Pattern()), $assert_String($1));
};
StringImplementation.prototype.startsWith$1 = function($0) {
  return this.startsWith($assert_String($0));
};
StringImplementation.prototype.substring$1 = function($0) {
  return this.substring($assert_num($0));
};
StringImplementation.prototype.substring$2 = function($0, $1) {
  return this.substring($assert_num($0), $assert_num($1));
};
// ********** Code for Collections **************
function Collections() {}
Collections.forEach = function(iterable, f) {
  for (var $i = iterable.iterator(); $i.hasNext$0(); ) {
    var e = $i.next$0();
    f(e);
  }
}
Collections.some = function(iterable, f) {
  for (var $i = iterable.iterator(); $i.hasNext$0(); ) {
    var e = $i.next$0();
    if (f(e)) return true;
  }
  return false;
}
Collections.every = function(iterable, f) {
  for (var $i = iterable.iterator(); $i.hasNext$0(); ) {
    var e = $i.next$0();
    if (!f(e)) return false;
  }
  return true;
}
Collections.filter = function(source, destination, f) {
  for (var $i = source.iterator(); $i.hasNext$0(); ) {
    var e = $i.next$0();
    if (f(e)) destination.add(e);
  }
  return destination;
}
// ********** Code for DateImplementation **************
function DateImplementation() {}
DateImplementation.fromEpoch$ctor = function(value, timeZone) {
  this.value = value;
  this.timeZone = timeZone;
  // Initializers done
}
DateImplementation.fromEpoch$ctor.prototype = DateImplementation.prototype;
DateImplementation.now$ctor = function() {
  this.timeZone = new TimeZoneImplementation.local$ctor();
  this.value = DateImplementation._now();
  // Initializers done
  this._asJs();
}
DateImplementation.now$ctor.prototype = DateImplementation.prototype;
DateImplementation.prototype.assert$Date = function(){return this};
DateImplementation.prototype.assert$Comparable = function(){return this};
DateImplementation.prototype.get$value = function() { return this.value; };
DateImplementation.prototype.get$timeZone = function() { return this.timeZone; };
DateImplementation.prototype.$eq = function(other) {
  if (!((other instanceof DateImplementation))) return false;
  return (this.value == other.get$value()) && ($eq(this.timeZone, other.get$timeZone()));
}
DateImplementation.prototype.compareTo = function(other) {
  var $0;
  return $assert_num(this.value.compareTo$1(other.value));
}
DateImplementation.prototype.get$year = function() {
  return this.isUtc ? this._asJs().getUTCFullYear() :
      this._asJs().getFullYear();
}
DateImplementation.prototype.get$month = function() {
  return this.isUtc ? this._asJs().getMonth() + 1 :
        this._asJs().getMonth() + 1;
}
DateImplementation.prototype.get$day = function() {
  return this.isUtc ? this._asJs().getUTCDate() : this._asJs().getDate()
}
DateImplementation.prototype.get$hours = function() {
  return this.isUtc ? this._asJs().getUTCHours() : this._asJs().getHours()
}
DateImplementation.prototype.get$minutes = function() {
  return this.isUtc ? this._asJs().getUTCMinutes() : this._asJs().getMinutes()
}
DateImplementation.prototype.get$seconds = function() {
  return this.isUtc ? this._asJs().getUTCSeconds() : this._asJs().getSeconds()
}
DateImplementation.prototype.get$milliseconds = function() {
  return this.isUtc ? this._asJs().getUTCMilliseconds() :
      this._asJs().getMilliseconds();
}
DateImplementation.prototype.toString = function() {
  function threeDigits(n) {
    if (n >= 100) return ("" + n);
    if (n > 10) return ("0" + n);
    return ("00" + n);
  }
  function twoDigits(n) {
    if (n >= 10) return ("" + n);
    return ("0" + n);
  }
  var m = twoDigits(this.get$month());
  var d = twoDigits(this.get$day());
  var h = twoDigits(this.get$hours());
  var min = twoDigits(this.get$minutes());
  var sec = twoDigits(this.get$seconds());
  var ms = threeDigits(this.get$milliseconds());
  if ($notnull_bool(this.timeZone.isUtc)) {
    return ("" + this.get$year() + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z");
  }
  else {
    return ("" + this.get$year() + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms);
  }
}
DateImplementation.prototype.add = function(duration) {
  return new DateImplementation.fromEpoch$ctor(this.value + duration.inMilliseconds, this.timeZone);
}
DateImplementation._now = function() {
  return new Date().valueOf();
}
DateImplementation.prototype._asJs = function() {
    if (!this.date) {
      this.date = new Date(this.value);
    }
    return this.date;
}
DateImplementation.prototype.add$1 = function($0) {
  return this.add(($0 == null ? null : $0.assert$Duration()));
};
DateImplementation.prototype.compareTo$1 = function($0) {
  return this.compareTo(($0 == null ? null : $0.assert$Date()));
};
DateImplementation.prototype.toString$0 = DateImplementation.prototype.toString;
// ********** Code for TimeZoneImplementation **************
function TimeZoneImplementation() {}
TimeZoneImplementation.local$ctor = function() {
  this.isUtc = false;
  // Initializers done
}
TimeZoneImplementation.local$ctor.prototype = TimeZoneImplementation.prototype;
TimeZoneImplementation.prototype.$eq = function(other) {
  if (!((other instanceof TimeZoneImplementation))) return false;
  return $eq(this.isUtc, other.get$isUtc());
}
TimeZoneImplementation.prototype.toString = function() {
  if ($notnull_bool(this.isUtc)) return "TimeZone (UTC)";
  return "TimeZone (Local)";
}
TimeZoneImplementation.prototype.get$isUtc = function() { return this.isUtc; };
TimeZoneImplementation.prototype.toString$0 = TimeZoneImplementation.prototype.toString;
// ********** Code for top level **************
//  ********** Library node **************
// ********** Code for process **************
// ********** Code for vm **************
vm = require('vm');
// ********** Code for fs **************
fs = require('fs');
// ********** Code for path **************
path = require('path');
// ********** Code for top level **************
function createSandbox() {
  return {'require': require, 'process': process, 'console': console,
        'setTimeout': setTimeout, 'clearTimeout': clearTimeout};
}
//  ********** Library file_system **************
// ********** Code for top level **************
function joinPaths(path1, path2) {
  var pieces = path1.split('/');
  var $list = path2.split('/');
  for (var $i = 0;$i < $list.length; $i++) {
    var piece = $list.$index($i);
    if ($notnull_bool($eq(piece, '..')) && pieces.length > 0 && $notnull_bool($ne(pieces.last$0(), '.')) && $notnull_bool($ne(pieces.last$0(), '..'))) {
      pieces.removeLast$0();
    }
    else if ($notnull_bool($ne(piece, ''))) {
      if (pieces.length > 0 && $notnull_bool($eq(pieces.last$0(), '.'))) {
        pieces.removeLast$0();
      }
      pieces.add$1(piece);
    }
  }
  return Strings.join((pieces == null ? null : pieces.assert$List_String()), '/');
}
function dirname(path) {
  var lastSlash = path.lastIndexOf('/', path.length);
  if (lastSlash == -1) {
    return '.';
  }
  else {
    return path.substring(0, lastSlash);
  }
}
function basename(path) {
  var lastSlash = path.lastIndexOf('/', path.length);
  if (lastSlash == -1) {
    return path;
  }
  else {
    return path.substring(lastSlash + 1);
  }
}
//  ********** Library file_system_node **************
// ********** Code for NodeFileSystem **************
function NodeFileSystem() {
  // Initializers done
}
NodeFileSystem.prototype.writeString = function(outfile, text) {
  fs.writeFileSync(outfile, text);
}
NodeFileSystem.prototype.readAll = function(filename) {
  return fs.readFileSync(filename, 'utf8');
}
NodeFileSystem.prototype.fileExists = function(filename) {
  return path.existsSync(filename);
}
// ********** Code for top level **************
//  ********** Library io **************
// ********** Code for top level **************
function join(strings) {
  return Strings.join(strings, '/');
}
//  ********** Library util_implementation **************
// ********** Code for LinkFactory **************
function LinkFactory() {}
LinkFactory.Link$factory = function(head, tail) {
  if (tail == null) {
    tail = new LinkTail_T();
  }
  return new LinkEntry_T(head, tail);
}
// ********** Code for LinkTail **************
function LinkTail() {
  // Initializers done
}
LinkTail.prototype.assert$Link_Element = function(){return this};
LinkTail.prototype.assert$Link_Node = function(){return this};
LinkTail.prototype.assert$Link_Token = function(){return this};
LinkTail.prototype.assert$Link_Type = function(){return this};
LinkTail.prototype.assert$Iterable = function(){return this};
LinkTail.prototype.get$head = function() {
  return null;
}
LinkTail.prototype.get$tail = function() {
  return null;
}
LinkTail.prototype.prepend = function(element) {
  return new LinkEntry_T(element, this);
}
LinkTail.prototype.iterator = function() {
  return this.toList().iterator();
}
LinkTail.prototype.printOn = function(buffer, separatedBy) {

}
LinkTail.prototype.toString = function() {
  return "[]";
}
LinkTail.prototype.toList = function() {
  return const$21/*const []*/;
}
LinkTail.prototype.isEmpty = function() {
  return true;
}
LinkTail.prototype.isEmpty$0 = LinkTail.prototype.isEmpty;
LinkTail.prototype.iterator$0 = LinkTail.prototype.iterator;
LinkTail.prototype.printOn$1 = function($0) {
  return this.printOn(($0 == null ? null : $0.assert$StringBuffer()));
};
LinkTail.prototype.toString$0 = LinkTail.prototype.toString;
// ********** Code for LinkTail_Element **************
function LinkTail_Element() {}
$inherits(LinkTail_Element, LinkTail);
LinkTail_Element.prototype.assert$Link_Element = function(){return this};
LinkTail_Element.prototype.assert$Link_Node = function(){$throw(new TypeError._internal$ctor(this, "Link<Node>"))};
LinkTail_Element.prototype.assert$Link_Token = function(){$throw(new TypeError._internal$ctor(this, "Link<Token>"))};
LinkTail_Element.prototype.assert$Link_Type = function(){$throw(new TypeError._internal$ctor(this, "Link<Type>"))};
LinkTail_Element.prototype.assert$Iterable = function(){return this};
// ********** Code for LinkTail_Node **************
function LinkTail_Node() {}
$inherits(LinkTail_Node, LinkTail);
LinkTail_Node.prototype.assert$Link_Element = function(){$throw(new TypeError._internal$ctor(this, "Link<Element>"))};
LinkTail_Node.prototype.assert$Link_Node = function(){return this};
LinkTail_Node.prototype.assert$Link_Token = function(){$throw(new TypeError._internal$ctor(this, "Link<Token>"))};
LinkTail_Node.prototype.assert$Link_Type = function(){$throw(new TypeError._internal$ctor(this, "Link<Type>"))};
LinkTail_Node.prototype.assert$Iterable = function(){return this};
// ********** Code for LinkTail_T **************
function LinkTail_T() {
  // Initializers done
}
$inherits(LinkTail_T, LinkTail);
LinkTail_T.prototype.assert$Link_Element = function(){return this};
LinkTail_T.prototype.assert$Link_Node = function(){return this};
LinkTail_T.prototype.assert$Link_Token = function(){return this};
LinkTail_T.prototype.assert$Link_Type = function(){return this};
LinkTail_T.prototype.assert$Iterable = function(){return this};
// ********** Code for LinkTail_Token **************
function LinkTail_Token() {}
$inherits(LinkTail_Token, LinkTail);
LinkTail_Token.prototype.assert$Link_Element = function(){$throw(new TypeError._internal$ctor(this, "Link<Element>"))};
LinkTail_Token.prototype.assert$Link_Node = function(){$throw(new TypeError._internal$ctor(this, "Link<Node>"))};
LinkTail_Token.prototype.assert$Link_Token = function(){return this};
LinkTail_Token.prototype.assert$Link_Type = function(){$throw(new TypeError._internal$ctor(this, "Link<Type>"))};
LinkTail_Token.prototype.assert$Iterable = function(){return this};
// ********** Code for LinkTail_Type **************
function LinkTail_Type() {}
$inherits(LinkTail_Type, LinkTail);
LinkTail_Type.prototype.assert$Link_Element = function(){$throw(new TypeError._internal$ctor(this, "Link<Element>"))};
LinkTail_Type.prototype.assert$Link_Node = function(){$throw(new TypeError._internal$ctor(this, "Link<Node>"))};
LinkTail_Type.prototype.assert$Link_Token = function(){$throw(new TypeError._internal$ctor(this, "Link<Token>"))};
LinkTail_Type.prototype.assert$Link_Type = function(){return this};
LinkTail_Type.prototype.assert$Iterable = function(){return this};
// ********** Code for LinkEntry **************
function LinkEntry(head, tail) {
  this.head = head;
  this.tail = tail;
  // Initializers done
}
LinkEntry.prototype.assert$Link_Element = function(){return this};
LinkEntry.prototype.assert$Link_Node = function(){return this};
LinkEntry.prototype.assert$Link_Token = function(){return this};
LinkEntry.prototype.assert$Link_Type = function(){return this};
LinkEntry.prototype.assert$Iterable = function(){return this};
LinkEntry.prototype.get$head = function() { return this.head; };
LinkEntry.prototype.get$tail = function() { return this.tail; };
LinkEntry.prototype.set$tail = function(value) { return this.tail = value; };
LinkEntry.prototype.prepend = function(element) {
  return new LinkEntry_T(element, this);
}
LinkEntry.prototype.iterator = function() {
  var $0;
  return (($0 = this.toList().iterator()) == null ? null : $0.assert$Iterator_T());
}
LinkEntry.prototype.printOn = function(buffer, separatedBy) {
  buffer.add(this.head == null ? 'null' : this.head);
  if (separatedBy == null) separatedBy = '';
  for (var link = this.tail;
   !$notnull_bool(link.isEmpty()); link = link.get$tail()) {
    buffer.add(separatedBy);
    buffer.add(link.get$head() == null ? 'null' : link.get$head());
  }
}
LinkEntry.prototype.toString = function() {
  var buffer = new StringBufferImpl("");
  buffer.add('[ ');
  this.printOn(buffer, ', ');
  buffer.add(' ]');
  return buffer.toString();
}
LinkEntry.prototype.isEmpty = function() {
  return false;
}
LinkEntry.prototype.toList = function() {
  var list = new ListFactory();
  for (var link = this;
   !$notnull_bool(link.isEmpty()); link = link.get$tail()) {
    list.addLast(link.get$head());
  }
  return list;
}
LinkEntry.prototype.isEmpty$0 = LinkEntry.prototype.isEmpty;
LinkEntry.prototype.iterator$0 = LinkEntry.prototype.iterator;
LinkEntry.prototype.printOn$1 = function($0) {
  return this.printOn(($0 == null ? null : $0.assert$StringBuffer()));
};
LinkEntry.prototype.toString$0 = LinkEntry.prototype.toString;
// ********** Code for LinkEntry_T **************
function LinkEntry_T(head, tail) {
  this.head = head;
  this.tail = tail;
  // Initializers done
}
$inherits(LinkEntry_T, LinkEntry);
LinkEntry_T.prototype.assert$Link_Element = function(){return this};
LinkEntry_T.prototype.assert$Link_Node = function(){return this};
LinkEntry_T.prototype.assert$Link_Token = function(){return this};
LinkEntry_T.prototype.assert$Link_Type = function(){return this};
LinkEntry_T.prototype.assert$Iterable = function(){return this};
// ********** Code for LinkBuilderImplementation **************
function LinkBuilderImplementation() {
  this.head = null
  this.lastLink = null
  // Initializers done
}
LinkBuilderImplementation.prototype.get$head = function() { return this.head; };
LinkBuilderImplementation.prototype.set$head = function(value) { return this.head = value; };
LinkBuilderImplementation.prototype.toLink = function() {
  if (this.head == null) return const$236/*const LinkTail()*/;
  this.lastLink.tail = const$236/*const LinkTail()*/;
  var link = this.head;
  this.lastLink = null;
  this.head = null;
  return link;
}
LinkBuilderImplementation.prototype.addLast = function(t) {
  var entry = new LinkEntry_T(t, null);
  if (this.head == null) {
    this.head = entry;
  }
  else {
    this.lastLink.tail = entry;
  }
  this.lastLink = entry;
}
// ********** Code for LinkBuilderImplementation_Element **************
function LinkBuilderImplementation_Element() {}
$inherits(LinkBuilderImplementation_Element, LinkBuilderImplementation);
// ********** Code for LinkBuilderImplementation_T **************
function LinkBuilderImplementation_T() {}
$inherits(LinkBuilderImplementation_T, LinkBuilderImplementation);
// ********** Code for LinkBuilderImplementation_Type **************
function LinkBuilderImplementation_Type() {}
$inherits(LinkBuilderImplementation_Type, LinkBuilderImplementation);
// ********** Code for top level **************
//  ********** Library util **************
// ********** Code for top level **************
//  ********** Library scanner_implementation **************
// ********** Code for ArrayBasedScanner **************
function ArrayBasedScanner() {
  this.groupingStack = const$22/*const EmptyLink<Token>()*/
  this.extraCharOffset = 0;
  this.tokenStart = -1;
  this.byteOffset = -1;
  this.tokens = new Token(0/*null.EOF_TOKEN*/, -1);
  // Initializers done
  AbstractScanner_S.call(this);
  this.tail = this.tokens;
}
$inherits(ArrayBasedScanner, AbstractScanner_S);
ArrayBasedScanner.prototype.get$charOffset = function() {
  return this.byteOffset + this.extraCharOffset;
}
ArrayBasedScanner.prototype.get$byteOffset = function() { return this.byteOffset; };
ArrayBasedScanner.prototype.set$byteOffset = function(value) { return this.byteOffset = value; };
ArrayBasedScanner.prototype.advance = function() {
  var next = this.nextByte();
  return next;
}
ArrayBasedScanner.prototype.select = function(choice, yes, no) {
  var next = this.advance();
  if (next === choice) {
    this.appendStringToken(1024/*null.UNKNOWN_TOKEN*/, yes);
    return this.advance();
  }
  else {
    this.appendStringToken(1024/*null.UNKNOWN_TOKEN*/, no);
    return next;
  }
}
ArrayBasedScanner.prototype.appendStringToken = function(kind, value) {
  this.tail.next = new StringToken(kind, value, this.tokenStart);
  this.tail = this.tail.next;
}
ArrayBasedScanner.prototype.appendKeywordToken = function(keyword) {
  this.tail.next = new KeywordToken(keyword, this.tokenStart);
  this.tail = this.tail.next;
}
ArrayBasedScanner.prototype.appendEofToken = function() {
  this.tail.next = new Token(0/*null.EOF_TOKEN*/, this.get$charOffset());
  this.tail = this.tail.next;
  this.tail.next = this.tail;
}
ArrayBasedScanner.prototype.beginToken = function() {
  this.tokenStart = this.get$charOffset();
}
ArrayBasedScanner.prototype.firstToken = function() {
  return this.tokens.next;
}
ArrayBasedScanner.prototype.addToCharOffset = function(offset) {
  this.extraCharOffset += offset;
}
ArrayBasedScanner.prototype.appendWhiteSpace = function(next) {

}
ArrayBasedScanner.prototype.appendBeginGroup = function(kind, value) {
  var $0;
  var token = new BeginGroupToken(kind, value, this.tokenStart);
  this.tail.next = token;
  this.tail = this.tail.next;
  while (kind !== 60/*null.LT_TOKEN*/ && !$notnull_bool(this.groupingStack.isEmpty()) && this.groupingStack.get$head().get$kind() === 60/*null.LT_TOKEN*/) {
    this.groupingStack = (($0 = this.groupingStack.get$tail()) == null ? null : $0.assert$Link_Token());
  }
  this.groupingStack = (($0 = this.groupingStack.prepend(token)) == null ? null : $0.assert$Link_Token());
}
ArrayBasedScanner.prototype.appendEndGroup = function(kind, value, openKind) {
  var $0;
  var oldTail = this.tail;
  this.appendStringToken(kind, value);
  if ($notnull_bool(this.groupingStack.isEmpty())) {
    if (openKind === 60/*null.LT_TOKEN*/) return;
    $throw(new MalformedInputException(('Unmatched ' + value)));
  }
  while (openKind !== 60/*null.LT_TOKEN*/ && !$notnull_bool(this.groupingStack.isEmpty()) && this.groupingStack.get$head().get$kind() === 60/*null.LT_TOKEN*/) {
    this.groupingStack = (($0 = this.groupingStack.get$tail()) == null ? null : $0.assert$Link_Token());
  }
  if (this.groupingStack.get$head().get$kind() !== openKind) {
    if (openKind === 60/*null.LT_TOKEN*/) return;
    $throw(new MalformedInputException(('Unmatched ' + value)));
  }
  this.groupingStack.get$head().set$endGroup(oldTail.next);
  this.groupingStack = (($0 = this.groupingStack.get$tail()) == null ? null : $0.assert$Link_Token());
}
ArrayBasedScanner.prototype.appendGtGt = function(kind, value) {
  var $0;
  var oldTail = this.tail;
  this.appendStringToken(kind, value);
  if ($notnull_bool(this.groupingStack.isEmpty())) return;
  if (this.groupingStack.get$head().get$kind() === 60/*null.LT_TOKEN*/) {
    this.groupingStack = (($0 = this.groupingStack.get$tail()) == null ? null : $0.assert$Link_Token());
  }
  if ($notnull_bool(this.groupingStack.isEmpty())) return;
  if (this.groupingStack.get$head().get$kind() === 60/*null.LT_TOKEN*/) {
    this.groupingStack.get$head().set$endGroup(oldTail.next);
    this.groupingStack = (($0 = this.groupingStack.get$tail()) == null ? null : $0.assert$Link_Token());
  }
}
ArrayBasedScanner.prototype.appendGtGtGt = function(kind, value) {
  var $0;
  var oldTail = this.tail;
  this.appendStringToken(kind, value);
  if ($notnull_bool(this.groupingStack.isEmpty())) return;
  if (this.groupingStack.get$head().get$kind() === 60/*null.LT_TOKEN*/) {
    this.groupingStack = (($0 = this.groupingStack.get$tail()) == null ? null : $0.assert$Link_Token());
  }
  if ($notnull_bool(this.groupingStack.isEmpty())) return;
  if (this.groupingStack.get$head().get$kind() === 60/*null.LT_TOKEN*/) {
    this.groupingStack = (($0 = this.groupingStack.get$tail()) == null ? null : $0.assert$Link_Token());
  }
  if ($notnull_bool(this.groupingStack.isEmpty())) return;
  if (this.groupingStack.get$head().get$kind() === 60/*null.LT_TOKEN*/) {
    this.groupingStack.get$head().set$endGroup(oldTail.next);
    this.groupingStack = (($0 = this.groupingStack.get$tail()) == null ? null : $0.assert$Link_Token());
  }
}
// ********** Code for ArrayBasedScanner_SourceString **************
function ArrayBasedScanner_SourceString() {
  this.groupingStack = const$22/*const EmptyLink<Token>()*/
  this.extraCharOffset = 0;
  this.tokenStart = -1;
  this.byteOffset = -1;
  this.tokens = new Token(0/*null.EOF_TOKEN*/, -1);
  // Initializers done
  AbstractScanner_SourceString.call(this);
  this.tail = this.tokens;
}
$inherits(ArrayBasedScanner_SourceString, ArrayBasedScanner);
// ********** Code for top level **************
//  ********** Library scanner **************
// ********** Code for ClassElementParser **************
function ClassElementParser(listener) {
  // Initializers done
  PartialParser.call(this, listener);
}
$inherits(ClassElementParser, PartialParser);
ClassElementParser.prototype.parseClassBody = function(token) {
  return this.fullParseClassBody(token);
}
// ********** Code for PartialClassElement **************
function PartialClassElement(name, beginToken, endToken) {
  this.beginToken = beginToken;
  this.endToken = endToken;
  // Initializers done
  ClassElement.call(this, name);
}
$inherits(PartialClassElement, ClassElement);
PartialClassElement.prototype.get$members = function() { return this.members; };
PartialClassElement.prototype.set$members = function(value) { return this.members = value; };
PartialClassElement.prototype.parseNode = function(canceler, logger) {
  var $0;
  var listener = new NodeListener(canceler, logger);
  var parser = new ClassElementParser(listener);
  var token = parser.parseClass(this.beginToken);
  $assert(token === this.endToken.next, "token === endToken.next", "class_element_parser.dart", 25, 12);
  var node = (($0 = listener.popNode()) == null ? null : $0.assert$ClassNode());
  $assert(listener.nodes.isEmpty(), "listener.nodes.isEmpty()", "class_element_parser.dart", 27, 12);
  $assert(listener.topLevelElements.isEmpty(), "listener.topLevelElements.isEmpty()", "class_element_parser.dart", 28, 12);
  return node;
}
// ********** Code for Keyword **************
function Keyword(syntax, isPseudo) {
  this.syntax = syntax;
  this.isPseudo = isPseudo;
  // Initializers done
}
Keyword.prototype.is$SourceString = function(){return true};
Keyword.prototype.assert$SourceString = function(){return this};
Keyword.prototype.get$syntax = function() { return this.syntax; };
Keyword.prototype.get$isPseudo = function() { return this.isPseudo; };
Keyword.get$keywords = function() {
  if ($globals.Keyword__keywords == null) {
    $globals.Keyword__keywords = Keyword.computeKeywordMap();
  }
  return $globals.Keyword__keywords;
}
Keyword.computeKeywordMap = function() {
  var result = new LinkedHashMapImplementation();
  for (var $i0 = const$119/*Keyword.values*/.iterator(); $i0.hasNext(); ) {
    var keyword = $i0.next();
    result.$setindex(keyword.syntax, keyword);
  }
  return result;
}
Keyword.prototype.hashCode = function() {
  return this.syntax.hashCode();
}
Keyword.prototype.$eq = function(other) {
  return !!(other && other.is$SourceString()) && this.toString() == other.toString$0();
}
Keyword.prototype.printOn = function(sb) {
  sb.add(this.syntax);
}
Keyword.prototype.toString = function() {
  return this.syntax;
}
Keyword.prototype.get$stringValue = function() {
  return this.syntax;
}
Keyword.prototype.hashCode$0 = Keyword.prototype.hashCode;
Keyword.prototype.printOn$1 = function($0) {
  return this.printOn(($0 == null ? null : $0.assert$StringBuffer()));
};
Keyword.prototype.toString$0 = Keyword.prototype.toString;
// ********** Code for KeywordState **************
function KeywordState() {
  // Initializers done
}
KeywordState.prototype.assert$KeywordState = function(){return this};
KeywordState.get$KEYWORD_STATE = function() {
  if ($globals.KeywordState__KEYWORD_STATE == null) {
    var strings = new ListFactory(const$119/*Keyword.values*/.get$length());
    for (var i = 0;
     i < const$119/*Keyword.values*/.get$length(); i++) {
      strings.$setindex(i, const$119/*Keyword.values*/[i].get$syntax());
    }
    strings.sort((function (a, b) {
      return a.compareTo$1(b);
    })
    );
    $globals.KeywordState__KEYWORD_STATE = KeywordState.computeKeywordStateTable(0, strings, 0, $assert_num(strings.length));
  }
  return $globals.KeywordState__KEYWORD_STATE;
}
KeywordState.computeKeywordStateTable = function(start, strings, offset, length) {
  var result = new ListFactory(26);
  $assert(length != 0, "length != 0", "keyword.dart", 161, 12);
  var chunk = 0;
  var chunkStart = -1;
  for (var i = offset;
   i < offset + length; i++) {
    if (strings.$index(i).length > start) {
      var c = $assert_num(strings.$index(i).charCodeAt$1(start));
      if (chunk != c) {
        if (chunkStart != -1) {
          result.$setindex(chunk - 97/*null.$a*/, KeywordState.computeKeywordStateTable(start + 1, strings, chunkStart, i - chunkStart));
        }
        chunkStart = i;
        chunk = c;
      }
    }
  }
  if (chunkStart != -1) {
    result.$setindex(chunk - 97/*null.$a*/, KeywordState.computeKeywordStateTable(start + 1, strings, chunkStart, offset + length - chunkStart));
  }
  else {
    $assert(length == 1, "length == 1", "keyword.dart", 183, 14);
    return new LeafKeywordState($assert_String(strings.$index(offset)));
  }
  return new ArrayKeywordState(result);
}
// ********** Code for ArrayKeywordState **************
function ArrayKeywordState(table) {
  this.table = table;
  // Initializers done
  KeywordState.call(this);
}
$inherits(ArrayKeywordState, KeywordState);
ArrayKeywordState.prototype.isLeaf = function() {
  return false;
}
ArrayKeywordState.prototype.next = function(c) {
  var $0;
  return (($0 = this.table.$index(c - 97/*null.$a*/)) == null ? null : $0.assert$KeywordState());
}
ArrayKeywordState.prototype.get$keyword = function() {
  $throw("should not be called");
}
ArrayKeywordState.prototype.toString = function() {
  var sb = new StringBufferImpl("");
  sb.add("[");
  var foo = this.table;
  for (var i = 0;
   i < foo.length; i++) {
    if ($notnull_bool($ne(foo.$index(i), null))) {
      sb.add(("" + (i + 97/*null.$a*/) + ": " + foo.$index(i) + "; "));
    }
  }
  sb.add("]");
  return sb.toString();
}
ArrayKeywordState.prototype.toString$0 = ArrayKeywordState.prototype.toString;
// ********** Code for LeafKeywordState **************
function LeafKeywordState(syntax) {
  this.keyword = Keyword.get$keywords().$index(syntax);
  // Initializers done
  KeywordState.call(this);
}
$inherits(LeafKeywordState, KeywordState);
LeafKeywordState.prototype.get$keyword = function() { return this.keyword; };
LeafKeywordState.prototype.set$keyword = function(value) { return this.keyword = value; };
LeafKeywordState.prototype.isLeaf = function() {
  return true;
}
LeafKeywordState.prototype.next = function(c) {
  return null;
}
LeafKeywordState.prototype.toString = function() {
  return this.keyword.syntax;
}
LeafKeywordState.prototype.toString$0 = LeafKeywordState.prototype.toString;
// ********** Code for Listener **************
function Listener() {
  // Initializers done
}
Listener.prototype.beginArguments = function(token) {

}
Listener.prototype.endArguments = function(count, beginToken, endToken) {

}
Listener.prototype.beginBlock = function(token) {

}
Listener.prototype.endBlock = function(count, beginToken, endToken) {

}
Listener.prototype.beginClassBody = function(token) {

}
Listener.prototype.endClassBody = function(memberCount, beginToken, endToken) {

}
Listener.prototype.beginClassDeclaration = function(token) {

}
Listener.prototype.endClassDeclaration = function(interfacesCount, beginToken, extendsKeyword, implementsKeyword, endToken) {

}
Listener.prototype.beginDoWhileStatement = function(token) {

}
Listener.prototype.endDoWhileStatement = function(doKeyword, whileKeyword, endToken) {

}
Listener.prototype.beginExpressionStatement = function(token) {

}
Listener.prototype.endExpressionStatement = function(token) {

}
Listener.prototype.beginFormalParameter = function(token) {

}
Listener.prototype.endFormalParameter = function(token) {

}
Listener.prototype.beginFormalParameters = function(token) {

}
Listener.prototype.endFormalParameters = function(count, beginToken, endToken) {

}
Listener.prototype.endField = function(beginToken, endToken) {

}
Listener.prototype.beginForStatement = function(token) {

}
Listener.prototype.endForStatement = function(beginToken, endToken) {

}
Listener.prototype.beginFunction = function(token) {

}
Listener.prototype.endFunction = function(token) {

}
Listener.prototype.beginFunctionBody = function(token) {

}
Listener.prototype.endFunctionBody = function(count, beginToken, endToken) {

}
Listener.prototype.handleNoFunctionBody = function(token) {

}
Listener.prototype.beginFunctionName = function(token) {

}
Listener.prototype.endFunctionName = function(token) {

}
Listener.prototype.beginFunctionTypeAlias = function(token) {

}
Listener.prototype.endFunctionTypeAlias = function(token) {

}
Listener.prototype.beginIfStatement = function(token) {

}
Listener.prototype.endIfStatement = function(ifToken, elseToken) {

}
Listener.prototype.beginInitializedIdentifier = function(token) {

}
Listener.prototype.endInitializedIdentifier = function() {

}
Listener.prototype.beginInitializer = function(token) {

}
Listener.prototype.endInitializer = function(assignmentOperator) {

}
Listener.prototype.beginInitializers = function(token) {

}
Listener.prototype.endInitializers = function(count, beginToken, endToken) {

}
Listener.prototype.handleNoInitializers = function() {

}
Listener.prototype.beginInterface = function(token) {

}
Listener.prototype.endInterface = function(token) {

}
Listener.prototype.beginLibraryTag = function(token) {

}
Listener.prototype.endLibraryTag = function(hasPrefix, beginToken, endToken) {

}
Listener.prototype.beginMember = function(token) {

}
Listener.prototype.endMethod = function(beginToken, endToken) {

}
Listener.prototype.beginReturnStatement = function(token) {

}
Listener.prototype.endReturnStatement = function(hasExpression, beginToken, endToken) {

}
Listener.prototype.beginSend = function(token) {

}
Listener.prototype.endSend = function(token) {

}
Listener.prototype.beginThrowStatement = function(token) {

}
Listener.prototype.endThrowStatement = function(throwToken, endToken) {

}
Listener.prototype.endRethrowStatement = function(throwToken, endToken) {

}
Listener.prototype.beginTopLevelMember = function(token) {

}
Listener.prototype.endTopLevelField = function(beginToken, endToken) {

}
Listener.prototype.endTopLevelMethod = function(beginToken, endToken) {

}
Listener.prototype.endType = function(count, beginToken, endToken) {

}
Listener.prototype.beginTypeArguments = function(token) {

}
Listener.prototype.endTypeArguments = function(count, beginToken, endToken) {

}
Listener.prototype.handleNoTypeArguments = function(token) {

}
Listener.prototype.beginVariablesDeclaration = function(token) {

}
Listener.prototype.endVariablesDeclaration = function(count, endToken) {

}
Listener.prototype.beginWhileStatement = function(token) {

}
Listener.prototype.endWhileStatement = function(whileKeyword, endToken) {

}
Listener.prototype.handleAssignmentExpression = function(token) {

}
Listener.prototype.handleBinaryExpression = function(token) {

}
Listener.prototype.handleConditionalExpression = function(question, colon) {

}
Listener.prototype.handleFinalKeyword = function(finalKeyword) {

}
Listener.prototype.handleIdentifier = function(token) {

}
Listener.prototype.handleLiteralBool = function(token) {

}
Listener.prototype.handleLiteralDouble = function(token) {

}
Listener.prototype.handleLiteralInt = function(token) {

}
Listener.prototype.handleLiteralNull = function(token) {

}
Listener.prototype.handleLiteralString = function(token) {

}
Listener.prototype.handleNoArguments = function(token) {

}
Listener.prototype.handleNoFieldInitializer = function(token) {

}
Listener.prototype.handleNoType = function(token) {

}
Listener.prototype.handleNoTypeVariables = function(token) {

}
Listener.prototype.handleParenthesizedExpression = function(token) {

}
Listener.prototype.handleSuperExpression = function(token) {

}
Listener.prototype.handleThisExpression = function(token) {

}
Listener.prototype.handleUnaryPostfixAssignmentExpression = function(token) {

}
Listener.prototype.handleUnaryPrefixExpression = function(token) {

}
Listener.prototype.handleUnaryPrefixAssignmentExpression = function(token) {

}
Listener.prototype.handleVarKeyword = function(token) {

}
Listener.prototype.handleVoidKeyword = function(token) {

}
Listener.prototype.expected = function(string, token) {
  $throw(new ParserError(("Expected '" + string + "', but got '" + token + "' @ ") + ("" + token.charOffset)));
}
Listener.prototype.expectedIdentifier = function(token) {
  $throw(new ParserError(("Expected identifier, but got '" + token + "' @ ") + ("" + token.charOffset)));
}
Listener.prototype.expectedType = function(token) {
  $throw(new ParserError(("Expected a type, but got '" + token + "' @ ") + ("" + token.charOffset)));
}
Listener.prototype.expectedBlock = function(token) {
  $throw(new ParserError(("Expected a block, but got '" + token + "' @ ") + ("" + token.charOffset)));
}
Listener.prototype.unexpected = function(token) {
  $throw(new ParserError(("Unexpected token '" + token + "' @ " + token.charOffset)));
}
// ********** Code for ParserError **************
function ParserError(reason) {
  this.reason = reason;
  // Initializers done
}
ParserError.prototype.toString = function() {
  return this.reason;
}
ParserError.prototype.toString$0 = ParserError.prototype.toString;
// ********** Code for ElementListener **************
function ElementListener(canceler) {
  this.previousIdentifier = null
  this.nodes = const$209/*const EmptyLink<Node>()*/
  this.topLevelElements = const$210/*const EmptyLink<Element>()*/
  this.canceler = canceler;
  // Initializers done
  Listener.call(this);
}
$inherits(ElementListener, Listener);
ElementListener.prototype.get$nodes = function() { return this.nodes; };
ElementListener.prototype.set$nodes = function(value) { return this.nodes = value; };
ElementListener.prototype.beginLibraryTag = function(token) {
  this.canceler.cancel("Cannot handle library tags", null, token);
}
ElementListener.prototype.endClassDeclaration = function(interfacesCount, beginToken, extendsKeyword, implementsKeyword, endToken) {
  var $0;
  this.discardNodes(interfacesCount);
  var supertype = (($0 = this.popNode()) == null ? null : $0.assert$Identifier());
  var name = (($0 = this.popNode()) == null ? null : $0.assert$Identifier());
  this.pushElement(new PartialClassElement(name.get$source(), beginToken, endToken));
}
ElementListener.prototype.endInterface = function(token) {
  this.canceler.cancel("Cannot handle interfaces", null, token);
}
ElementListener.prototype.endFunctionTypeAlias = function(token) {
  this.canceler.cancel("Cannot handle typedefs", null, token);
}
ElementListener.prototype.endTopLevelMethod = function(beginToken, endToken) {
  var $0;
  var name = (($0 = this.popNode()) == null ? null : $0.assert$Identifier());
  this.pushElement(new PartialFunctionElement(name.get$source(), beginToken, endToken));
}
ElementListener.prototype.endTopLevelField = function(beginToken, endToken) {
  var $0;
  var name = (($0 = this.popNode()) == null ? null : $0.assert$Identifier());
  this.canceler.cancel("Cannot handle fields", null, beginToken);
}
ElementListener.prototype.handleIdentifier = function(token) {
  this.pushNode(new Identifier(token));
}
ElementListener.prototype.handleNoType = function(token) {
  this.pushNode(null);
}
ElementListener.prototype.endTypeArguments = function(count, beginToken, endToken) {
  this.discardNodes(count);
}
ElementListener.prototype.handleParenthesizedExpression = function(token) {
  var $0;
  var expression = (($0 = this.popNode()) == null ? null : $0.assert$Expression());
  this.pushNode(new ParenthesizedExpression(expression, token));
}
ElementListener.prototype.discardNodes = function(count) {
  for (; count > 0; --count) {
    this.popNode();
  }
}
ElementListener.prototype.expected = function(string, token) {
  this.canceler.cancel(("Expected '" + string + "', but got '" + token + "'"), null, token);
}
ElementListener.prototype.expectedIdentifier = function(token) {
  this.canceler.cancel(("Expected identifier, but got '" + token + "'"), null, token);
}
ElementListener.prototype.expectedType = function(token) {
  this.canceler.cancel(("Expected a type, but got '" + token + "'"), null, token);
}
ElementListener.prototype.expectedBlock = function(token) {
  this.canceler.cancel(("Expected a block, but got '" + token + "'"), null, token);
}
ElementListener.prototype.unexpected = function(token) {
  this.canceler.cancel(("Unexpected token '" + token + "'"), null, token);
}
ElementListener.prototype.pushElement = function(element) {
  var $0;
  this.topLevelElements = (($0 = this.topLevelElements.prepend(element)) == null ? null : $0.assert$Link_Element());
}
ElementListener.prototype.pushNode = function(node) {
  var $0;
  this.nodes = (($0 = this.nodes.prepend(node)) == null ? null : $0.assert$Link_Node());
  if (false/*null.VERBOSE*/) this.log(("push " + this.nodes));
}
ElementListener.prototype.popNode = function() {
  var $0;
  $assert(!$notnull_bool(this.nodes.isEmpty()), "!nodes.isEmpty()", "listener.dart", 409, 12);
  var node = (($0 = this.nodes.get$head()) == null ? null : $0.assert$Node());
  this.nodes = (($0 = this.nodes.get$tail()) == null ? null : $0.assert$Link_Node());
  if (false/*null.VERBOSE*/) this.log(("pop " + this.nodes));
  return node;
}
ElementListener.prototype.log = function(message) {

}
// ********** Code for NodeListener **************
function NodeListener(canceler, logger) {
  this.memberElements = const$210/*const EmptyLink<Element>()*/
  this.logger = logger;
  // Initializers done
  ElementListener.call(this, canceler);
}
$inherits(NodeListener, ElementListener);
NodeListener.prototype.endClassDeclaration = function(interfacesCount, beginToken, extendsKeyword, implementsKeyword, endToken) {
  var $0;
  var body = (($0 = this.popNode()) == null ? null : $0.assert$NodeList());
  var interfaces = this.makeNodeList(interfacesCount, implementsKeyword, null, ",");
  var supertype = (($0 = this.popNode()) == null ? null : $0.assert$TypeAnnotation());
  var name = (($0 = this.popNode()) == null ? null : $0.assert$Identifier());
  this.pushNode(new ClassNode(name, supertype, interfaces, beginToken, extendsKeyword, endToken));
}
NodeListener.prototype.endClassBody = function(memberCount, beginToken, endToken) {
  this.pushNode(this.makeNodeList(memberCount, beginToken, endToken, null));
}
NodeListener.prototype.endFormalParameter = function(token) {
  var $0;
  var name = new NodeList.singleton$ctor(this.popNode());
  var type = (($0 = this.popNode()) == null ? null : $0.assert$TypeAnnotation());
  this.pushNode(new VariableDefinitions(type, null, name, token));
}
NodeListener.prototype.endFormalParameters = function(count, beginToken, endToken) {
  this.pushNode(this.makeNodeList(count, beginToken, endToken, ","));
}
NodeListener.prototype.endArguments = function(count, beginToken, endToken) {
  this.pushNode(this.makeNodeList(count, beginToken, endToken, ","));
}
NodeListener.prototype.handleNoArguments = function(token) {
  this.pushNode(null);
}
NodeListener.prototype.endReturnStatement = function(hasExpression, beginToken, endToken) {
  var $0;
  var expression = (($0 = $notnull_bool(hasExpression) ? this.popNode() : null) == null ? null : $0.assert$Expression());
  this.pushNode(new Return(beginToken, endToken, expression));
}
NodeListener.prototype.endExpressionStatement = function(token) {
  this.pushNode(new ExpressionStatement(this.popNode(), token));
}
NodeListener.prototype.handleOnError = function(token, error) {
  this.canceler.cancel(("internal error: '" + token.get$value() + "': " + error), null, token);
}
NodeListener.prototype.handleLiteralInt = function(token) {
  var $this = this; // closure support
  this.pushNode(new LiteralInt(token, (function (t, e) {
    return $this.handleOnError((t == null ? null : t.assert$Token()), e);
  })
  ));
}
NodeListener.prototype.handleLiteralDouble = function(token) {
  var $this = this; // closure support
  this.pushNode(new LiteralDouble(token, (function (t, e) {
    return $this.handleOnError((t == null ? null : t.assert$Token()), e);
  })
  ));
}
NodeListener.prototype.handleLiteralBool = function(token) {
  var $this = this; // closure support
  this.pushNode(new LiteralBool(token, (function (t, e) {
    return $this.handleOnError((t == null ? null : t.assert$Token()), e);
  })
  ));
}
NodeListener.prototype.handleLiteralString = function(token) {
  this.pushNode(new LiteralString(token));
}
NodeListener.prototype.handleLiteralNull = function(token) {
  this.pushNode(new LiteralNull(token));
}
NodeListener.prototype.handleBinaryExpression = function(token) {
  var argument = this.popNode();
  var receiver = this.popNode();
  if ((token.get$stringValue() === '.') && ((argument instanceof Send)) && (argument.asSend().receiver == null)) {
    this.pushNode(argument.asSend().copyWithReceiver(receiver));
  }
  else {
    var arguments = new NodeList.singleton$ctor(argument);
    this.pushNode(new Send(receiver, new Operator(token), arguments));
  }
}
NodeListener.prototype.handleAssignmentExpression = function(token) {
  var arguments = new NodeList.singleton$ctor(this.popNode());
  var node = this.popNode();
  var send = node.asSend();
  if (send == null) {
    this.canceler.cancel(('not assignable: ' + node), node);
  }
  if (!$notnull_bool(send.get$isPropertyAccess())) {
    this.canceler.cancel(('not assignable: ' + send), send);
  }
  if (send.asSendSet() != null) {
    this.canceler.cancel('chained assignment', send);
  }
  var op = new Operator(token);
  this.pushNode(new SendSet(send.receiver, send.selector, op, arguments));
}
NodeListener.prototype.handleConditionalExpression = function(question, colon) {
  var elseExpression = this.popNode();
  var thenExpression = this.popNode();
  var condition = this.popNode();
  this.pushNode(null);
  this.canceler.cancel('conditional expression not implemented yet', null, question);
}
NodeListener.prototype.endSend = function(token) {
  var $0;
  var arguments = (($0 = this.popNode()) == null ? null : $0.assert$NodeList());
  var selector = this.popNode();
  this.pushNode(new Send(null, selector, arguments));
}
NodeListener.prototype.handleVoidKeyword = function(token) {
  this.pushNode(new TypeAnnotation(new Identifier(token)));
}
NodeListener.prototype.endFunctionBody = function(count, beginToken, endToken) {
  this.pushNode(new Block(this.makeNodeList(count, beginToken, endToken, null)));
}
NodeListener.prototype.handleNoFunctionBody = function(token) {
  this.pushNode(null);
}
NodeListener.prototype.endFunction = function(token) {
  var $0;
  var body = (($0 = this.popNode()) == null ? null : $0.assert$Statement());
  var formals = this.popNode();
  var name = this.popNode();
  var type = (($0 = this.popNode()) == null ? null : $0.assert$TypeAnnotation());
  this.pushNode(new FunctionExpression(name, formals, body, type));
}
NodeListener.prototype.handleVarKeyword = function(token) {
  this.pushNode(new Identifier(token));
}
NodeListener.prototype.handleFinalKeyword = function(token) {
  this.pushNode(new Identifier(token));
}
NodeListener.prototype.endVariablesDeclaration = function(count, endToken) {
  var $0;
  var variables = this.makeNodeList(count, null, null, ",");
  var type = (($0 = this.popNode()) == null ? null : $0.assert$TypeAnnotation());
  this.pushNode(new VariableDefinitions(type, null, variables, endToken));
}
NodeListener.prototype.endInitializer = function(assignmentOperator) {
  var $0;
  var initializer = (($0 = this.popNode()) == null ? null : $0.assert$Expression());
  var arguments = new NodeList.singleton$ctor(initializer);
  var name = (($0 = this.popNode()) == null ? null : $0.assert$Expression());
  var op = new Operator(assignmentOperator);
  this.pushNode(new SendSet(null, name, op, arguments));
}
NodeListener.prototype.endIfStatement = function(ifToken, elseToken) {
  var $0;
  var elsePart = (($0 = (elseToken == null) ? null : this.popNode()) == null ? null : $0.assert$Statement());
  var thenPart = (($0 = this.popNode()) == null ? null : $0.assert$Statement());
  var condition = (($0 = this.popNode()) == null ? null : $0.assert$ParenthesizedExpression());
  this.pushNode(new If(condition, thenPart, elsePart, ifToken, elseToken));
}
NodeListener.prototype.endForStatement = function(beginToken, endToken) {
  var $0;
  var body = (($0 = this.popNode()) == null ? null : $0.assert$Statement());
  var update = (($0 = this.popNode()) == null ? null : $0.assert$Expression());
  var condition = (($0 = this.popNode()) == null ? null : $0.assert$ExpressionStatement());
  var initializer = (($0 = this.popNode()) == null ? null : $0.assert$VariableDefinitions());
  this.pushNode(new For(initializer, condition, update, body, beginToken));
}
NodeListener.prototype.endDoWhileStatement = function(doKeyword, whileKeyword, endToken) {
  var $0;
  var condition = (($0 = this.popNode()) == null ? null : $0.assert$Expression());
  var body = (($0 = this.popNode()) == null ? null : $0.assert$Statement());
  this.pushNode(new DoWhile(body, condition, doKeyword, whileKeyword, endToken));
}
NodeListener.prototype.endWhileStatement = function(whileKeyword, endToken) {
  var $0;
  var body = (($0 = this.popNode()) == null ? null : $0.assert$Statement());
  var condition = (($0 = this.popNode()) == null ? null : $0.assert$Expression());
  this.pushNode(new While(condition, body, whileKeyword));
}
NodeListener.prototype.endBlock = function(count, beginToken, endToken) {
  this.pushNode(new Block(this.makeNodeList(count, beginToken, endToken, null)));
}
NodeListener.prototype.endType = function(count, beginToken, endToken) {
  var $0;
  var type = new TypeAnnotation((($0 = this.popNode()) == null ? null : $0.assert$Identifier()));
  this.discardNodes(count - 1);
  this.pushNode(type);
}
NodeListener.prototype.endThrowStatement = function(throwToken, endToken) {
  var $0;
  var expression = (($0 = this.popNode()) == null ? null : $0.assert$Expression());
  this.pushNode(new Throw(expression, throwToken, endToken));
}
NodeListener.prototype.endRethrowStatement = function(throwToken, endToken) {
  this.pushNode(new Throw(null, throwToken, endToken));
}
NodeListener.prototype.handleUnaryPrefixExpression = function(token) {
  this.pushNode(new Send.prefix$ctor(this.popNode(), new Operator(token)));
}
NodeListener.prototype.handleSuperExpression = function(token) {
  this.pushNode(new Identifier(token));
}
NodeListener.prototype.handleThisExpression = function(token) {
  this.pushNode(new Identifier(token));
}
NodeListener.prototype.handleUnaryAssignmentExpression = function(token, isPrefix) {
  var node = this.popNode();
  var send = node.asSend();
  if (send == null) {
    this.canceler.cancel(('not assignable: ' + node), node);
  }
  if (!$notnull_bool(send.get$isPropertyAccess())) {
    this.canceler.cancel(('not assignable: ' + send), send);
  }
  if (send.asSendSet() != null) {
    this.canceler.cancel('chained assignment', send);
  }
  var op = new Operator(token);
  if ($notnull_bool(isPrefix)) {
    this.pushNode(new SendSet.prefix$ctor(send.receiver, send.selector, op));
  }
  else {
    this.pushNode(new SendSet.postfix$ctor(send.receiver, send.selector, op));
  }
}
NodeListener.prototype.handleUnaryPostfixAssignmentExpression = function(token) {
  this.handleUnaryAssignmentExpression(token, false);
}
NodeListener.prototype.handleUnaryPrefixAssignmentExpression = function(token) {
  this.handleUnaryAssignmentExpression(token, true);
}
NodeListener.prototype.endInitializers = function(count, beginToken, endToken) {
  this.discardNodes(count);
}
NodeListener.prototype.handleNoInitializers = function() {

}
NodeListener.prototype.handleNoFieldInitializer = function(token) {
  this.pushNode(null);
}
NodeListener.prototype.endField = function(beginToken, endToken) {
  var $0;
  var initializer = (($0 = this.popNode()) == null ? null : $0.assert$Expression());
  var name = (($0 = this.popNode()) == null ? null : $0.assert$Identifier());
  this.pushNode(null);
  this.canceler.cancel("fields are not implemented yet", name);
}
NodeListener.prototype.endMethod = function(beginToken, endToken) {
  var $0;
  var body = (($0 = this.popNode()) == null ? null : $0.assert$Statement());
  var name = (($0 = this.popNode()) == null ? null : $0.assert$Identifier());
  this.pushNode(new FunctionExpression(name, null, null, null));
  var methodElement = new PartialFunctionElement(name.get$source(), beginToken, endToken);
  this.memberElements = (($0 = this.memberElements.prepend(methodElement)) == null ? null : $0.assert$Link_Element());
}
NodeListener.prototype.makeNodeList = function(count, beginToken, endToken, delimiter) {
  var $0;
  var nodes = const$209/*const EmptyLink<Node>()*/;
  for (; count > 0; --count) {
    nodes = (($0 = nodes.prepend(this.popNode())) == null ? null : $0.assert$Link_Node());
  }
  var sourceDelimiter = (($0 = (delimiter == null) ? null : new StringWrapper(delimiter)) == null ? null : $0.assert$SourceString());
  return new NodeList(beginToken, nodes, endToken, sourceDelimiter);
}
NodeListener.prototype.log = function(message) {
  this.logger.log(message);
}
// ********** Code for PartialFunctionElement **************
function PartialFunctionElement(name, beginToken, endToken) {
  this.beginToken = beginToken;
  this.endToken = endToken;
  // Initializers done
  FunctionElement.call(this, name);
}
$inherits(PartialFunctionElement, FunctionElement);
PartialFunctionElement.prototype.parseNode = function(canceler, logger) {
  var $this = this; // closure support
  var $0;
  if (this.node != null) return this.node;
  this.node = (($0 = parse(canceler, logger, (function (p) {
    return p.parseFunction$1($this.beginToken);
  })
  )) == null ? null : $0.assert$FunctionExpression());
  return this.node;
}
// ********** Code for Parser **************
function Parser(listener) {
  this.listener = listener;
  // Initializers done
}
Parser.prototype.parseUnit = function(token) {
  while (token.kind !== 0/*null.EOF_TOKEN*/) {
    var value = token.get$stringValue();
    if (value === 'interface') {
      token = this.parseInterface(token);
    }
    else if (value === 'class') {
      token = this.parseClass(token);
    }
    else if (value === 'typedef') {
      token = this.parseNamedFunctionAlias(token);
    }
    else if (value === '#') {
      token = this.parseLibraryTags(token);
    }
    else {
      token = this.parseTopLevelMember(token);
    }
  }
}
Parser.prototype.parseInterface = function(token) {
  this.listener.beginInterface(token);
  token = this.parseIdentifier(token.next);
  token = this.parseTypeVariablesOpt(token);
  token = this.parseSupertypesClauseOpt(token);
  token = this.parseFactoryClauseOpt(token);
  return this.parseInterfaceBody(token);
}
Parser.prototype.parseInterfaceBody = function(token) {
  token = this.skipBlock(token);
  this.listener.endInterface(token);
  return token.next;
}
Parser.prototype.parseNamedFunctionAlias = function(token) {
  this.listener.beginFunctionTypeAlias(token);
  token = this.parseReturnTypeOpt(token.next);
  token = this.parseIdentifier(token);
  token = this.parseTypeVariablesOpt(token);
  token = this.parseFormalParameters(token);
  this.listener.endFunctionTypeAlias(token);
  return this.expect(';', token);
}
Parser.prototype.parseReturnTypeOpt = function(token) {
  if (token.get$stringValue() === 'void') {
    this.listener.handleVoidKeyword(token);
    return token.next;
  }
  else {
    return this.parseTypeOpt(token);
  }
}
Parser.prototype.parseFormalParameters = function(token) {
  var begin = token;
  this.listener.beginFormalParameters(begin);
  this.expect('(', token);
  var parameterCount = 0;
  if ($notnull_bool(this.optional(')', token.next))) {
    this.listener.endFormalParameters(parameterCount, begin, token.next);
    return token.next.next;
  }
  do {
    this.listener.beginFormalParameter(token);
    token = this.parseTypeOpt(token.next);
    token = this.parseIdentifier(token);
    this.listener.endFormalParameter(token);
    ++parameterCount;
  }
  while ($notnull_bool(this.optional(',', token)))
  this.listener.endFormalParameters(parameterCount, begin, token);
  return this.expect(')', token);
}
Parser.prototype.parseTypeOpt = function(token) {
  var kind = token.next.kind;
  if ((kind === 60/*null.LT_TOKEN*/) || (kind === 46/*null.PERIOD_TOKEN*/) || kind === 97/*null.IDENTIFIER_TOKEN*/) {
    return this.parseType(token);
  }
  else if (kind === 107/*null.KEYWORD_TOKEN*/ && $notnull_bool(token.next.get$value().get$isPseudo())) {
    return this.parseType(token);
  }
  else {
    this.listener.handleNoType(token);
    return token;
  }
}
Parser.prototype.isIdentifier = function(token) {
  var kind = token.kind;
  if (kind === 97/*null.IDENTIFIER_TOKEN*/) return true;
  if (kind === 107/*null.KEYWORD_TOKEN*/) return $assert_bool(token.get$value().get$isPseudo());
  return false;
}
Parser.prototype.parseSupertypesClauseOpt = function(token) {
  if ($notnull_bool(this.optional('extends', token))) {
    do {
      token = this.parseType(token.next);
    }
    while ($notnull_bool(this.optional(',', token)))
  }
  return token;
}
Parser.prototype.parseFactoryClauseOpt = function(token) {
  if ($notnull_bool(this.optional('factory', token))) {
    return this.parseType(token.next);
  }
  return token;
}
Parser.prototype.skipBlock = function(token) {
  if (!$notnull_bool(this.optional('{', token))) {
    return this.listener.expectedBlock(token);
  }
  var beginGroupToken = (token == null ? null : token.assert$BeginGroupToken());
  $assert(beginGroupToken.endGroup == null || beginGroupToken.endGroup.kind === 125/*null.$CLOSE_CURLY_BRACKET*/, "beginGroupToken.endGroup === null ||\n           beginGroupToken.endGroup.kind === $CLOSE_CURLY_BRACKET", "parser.dart", 127, 12);
  return beginGroupToken.endGroup;
}
Parser.prototype.skipFormals = function(token) {
  return token.endGroup;
}
Parser.prototype.parseClass = function(token) {
  var begin = token;
  this.listener.beginClassDeclaration(token);
  token = this.parseIdentifier(token.next);
  token = this.parseTypeVariablesOpt(token);
  var extendsKeyword;
  if ($notnull_bool(this.optional('extends', token))) {
    extendsKeyword = token;
    token = this.parseType(token.next);
  }
  else {
    extendsKeyword = null;
    this.listener.handleNoType(token);
  }
  var implementsKeyword;
  var interfacesCount = 0;
  if ($notnull_bool(this.optional('implements', token))) {
    do {
      token = this.parseType(token.next);
      ++interfacesCount;
    }
    while ($notnull_bool(this.optional(',', token)))
  }
  token = this.parseClassBody(token);
  this.listener.endClassDeclaration(interfacesCount, begin, extendsKeyword, implementsKeyword, token);
  return token.next;
}
Parser.prototype.parseString = function(token) {
  if (token.kind === 39/*null.STRING_TOKEN*/) {
    return token.next;
  }
  else {
    return this.listener.expected('string', token);
  }
}
Parser.prototype.parseIdentifier = function(token) {
  if ($notnull_bool(this.isIdentifier(token))) {
    this.listener.handleIdentifier(token);
  }
  else {
    this.listener.expectedIdentifier(token);
  }
  return token.next;
}
Parser.prototype.expect = function(string, token) {
  if (string !== token.get$stringValue()) {
    if (string === '>') {
      if (token.get$stringValue() === '>>') {
        var gt = new StringToken(62/*null.GT_TOKEN*/, '>', token.charOffset + 1);
        gt.next = token.next;
        return gt;
      }
      else if (token.get$stringValue() === '>>>') {
        var gtgt = new StringToken(1024/*null.UNKNOWN_TOKEN*/, '>>', token.charOffset + 1);
        gtgt.next = token.next;
        return gtgt;
      }
    }
    return this.listener.expected(string, token);
  }
  return token.next;
}
Parser.prototype.optional = function(value, token) {
  return value === token.get$stringValue();
}
Parser.prototype.parseType = function(token) {
  var begin = token;
  var identifierCount = 1;
  if ($notnull_bool(this.isIdentifier(token))) {
    token = this.parseIdentifier(token);
    while ($notnull_bool(this.optional('.', token))) {
      token = this.parseIdentifier(token.next);
      ++identifierCount;
    }
  }
  else if ($notnull_bool(this.optional('var', token))) {
    this.listener.handleVarKeyword(token);
    this.listener.endType(identifierCount, begin, token);
    return token.next;
  }
  else {
    token = this.listener.expectedType(token);
  }
  token = this.parseTypeArgumentsOpt(token);
  this.listener.endType(identifierCount, begin, token);
  return token;
}
Parser.prototype.parseTypeArgumentsOpt = function(token) {
  var $this = this; // closure support
  return this.parseStuff(token, (function (t) {
    return $this.listener.beginTypeArguments((t == null ? null : t.assert$Token()));
  })
  , (function (t) {
    return $this.parseType((t == null ? null : t.assert$Token()));
  })
  , (function (c, bt, et) {
    return $this.listener.endTypeArguments($assert_num(c), (bt == null ? null : bt.assert$Token()), (et == null ? null : et.assert$Token()));
  })
  , (function (t) {
    return $this.listener.handleNoTypeArguments((t == null ? null : t.assert$Token()));
  })
  );
}
Parser.prototype.parseTypeVariablesOpt = function(token) {
  if ($notnull_bool(this.optional('<', token))) {
    var beginGroupToken = (token == null ? null : token.assert$BeginGroupToken());
    token = beginGroupToken.endGroup.next;
  }
  this.listener.handleNoTypeVariables(token);
  return token;
}
Parser.prototype.parseStuff = function(token, beginStuff, stuffParser, endStuff, handleNoStuff) {
  var $0;
  if ($notnull_bool(this.optional('<', token))) {
    var begin = token;
    beginStuff.call$1(begin);
    var count = 0;
    do {
      token = (($0 = stuffParser.call$1(token.next)) == null ? null : $0.assert$Token());
      ++count;
    }
    while ($notnull_bool(this.optional(',', token)))
    endStuff.call$3(count, begin, token);
    return this.expect('>', token);
  }
  handleNoStuff.call$1(token);
  return token;
}
Parser.prototype.parseTopLevelMember = function(token) {
  var start = token;
  this.listener.beginTopLevelMember(token);
  token = this.skipModifiers(token);
  var peek = this.peekAfterType(token);
  while ($notnull_bool(this.isIdentifier(peek))) {
    token = peek;
    peek = this.peekAfterType(token);
  }
  token = this.parseIdentifier(token);
  var isField;
  while (true) {
    if ($notnull_bool(this.optional('(', token))) {
      isField = false;
      break;
    }
    else if ($notnull_bool(this.optional('=', token)) || $notnull_bool(this.optional(';', token))) {
      isField = true;
      break;
    }
    else {
      token = this.listener.unexpected(token);
    }
  }
  if ($notnull_bool(isField)) {
    if ($notnull_bool(this.optional('=', token))) {
      token = this.parseExpression(token.next);
    }
    this.expectSemicolon(token);
    this.listener.endTopLevelField(start, token);
  }
  else {
    token = this.skipFormals((token == null ? null : token.assert$BeginGroupToken())).next;
    token = this.parseFunctionBody(token);
    this.listener.endTopLevelMethod(start, token);
  }
  return token.next;
}
Parser.prototype.parseInitializersOpt = function(token) {
  if ($notnull_bool(this.optional(':', token))) {
    return this.parseInitializers(token);
  }
  else {
    this.listener.handleNoInitializers();
    return token;
  }
}
Parser.prototype.parseInitializers = function(token) {
  var begin = token;
  this.listener.beginInitializers(begin);
  this.expect(':', token);
  var count = 0;
  do {
    token = this.parseExpression(token.next);
    ++count;
  }
  while ($notnull_bool(this.optional(',', token)))
  this.listener.endInitializers(count, begin, token);
  return token;
}
Parser.prototype.parseLibraryTags = function(token) {
  var begin = token;
  this.listener.beginLibraryTag(token);
  token = this.parseIdentifier(token.next);
  token = this.expect('(', token);
  token = this.parseString(token);
  var hasPrefix = false;
  if ($notnull_bool(this.optional(',', token))) {
    hasPrefix = true;
    token = this.parseIdentifier(token.next);
    token = this.expect(':', token);
    token = this.parseString(token);
  }
  token = this.expect(')', token);
  this.listener.endLibraryTag(hasPrefix, begin, token);
  return this.expectSemicolon(token);
}
Parser.prototype.expectSemicolon = function(token) {
  return this.expect(';', token);
}
Parser.prototype.skipModifiers = function(token) {
  while (token.kind === 107/*null.KEYWORD_TOKEN*/) {
    var value = token.get$stringValue();
    if (value === 'void') break;
    token = token.next;
  }
  return token;
}
Parser.prototype.peekAfterType = function(token) {
  if ('void' !== token.get$stringValue() && !$notnull_bool(this.isIdentifier(token))) {
    this.listener.expectedIdentifier(token);
  }
  var peek = token.next;
  if (peek.kind === 46/*null.PERIOD_TOKEN*/) {
    if (peek.next.kind === 97/*null.IDENTIFIER_TOKEN*/) {
      peek = peek.next.next;
    }
  }
  if (peek.kind === 60/*null.LT_TOKEN*/) {
    var beginGroupToken = (peek == null ? null : peek.assert$BeginGroupToken());
    var gtToken = beginGroupToken.endGroup;
    if (gtToken != null) {
      return gtToken.next;
    }
  }
  return peek;
}
Parser.prototype.parseClassBody = function(token) {
  var begin = token;
  this.listener.beginClassBody(token);
  if (!$notnull_bool(this.optional('{', token))) {
    return this.listener.expectedBlock(token);
  }
  token = token.next;
  var count = 0;
  while (!$notnull_bool(this.optional('}', token))) {
    token = this.parseMember(token);
    ++count;
  }
  this.listener.endClassBody(count, begin, token);
  return token;
}
Parser.prototype.parseMember = function(token) {
  var start = token;
  this.listener.beginMember(token);
  token = this.skipModifiers(token);
  var peek = this.peekAfterType(token);
  while ($notnull_bool(this.isIdentifier(peek))) {
    token = peek;
    peek = this.peekAfterType(token);
  }
  token = this.parseIdentifier(token);
  var isField;
  while (true) {
    if ($notnull_bool(this.optional('(', token))) {
      isField = false;
      break;
    }
    else if ($notnull_bool(this.optional('=', token)) || $notnull_bool(this.optional(';', token))) {
      isField = true;
      break;
    }
    else {
      token = this.listener.unexpected(token);
    }
  }
  if ($notnull_bool(isField)) {
    if ($notnull_bool(this.optional('=', token))) {
      token = this.parseExpression(token.next);
    }
    else {
      this.listener.handleNoFieldInitializer(token);
    }
    this.expectSemicolon(token);
    this.listener.endField(start, token);
  }
  else {
    token = this.skipFormals((token == null ? null : token.assert$BeginGroupToken())).next;
    token = this.parseInitializersOpt(token);
    if (!$notnull_bool(this.optional(';', token))) {
      token = this.parseFunctionBody(token);
    }
    this.listener.endMethod(start, token);
  }
  return token.next;
}
Parser.prototype.parseFunction = function(token) {
  this.listener.beginFunction(token);
  token = this.skipModifiers(token);
  token = this.parseReturnTypeOpt(token);
  this.listener.beginFunctionName(token);
  token = this.parseIdentifier(token);
  this.listener.endFunctionName(token);
  token = this.parseFormalParameters(token);
  token = this.parseInitializersOpt(token);
  token = this.parseFunctionBody(token);
  this.listener.endFunction(token);
  return token.next;
}
Parser.prototype.parseFunctionBody = function(token) {
  if ($notnull_bool(this.optional(';', token))) {
    this.listener.endFunctionBody(0, null, token);
    return token.next;
  }
  var begin = token;
  var statementCount = 0;
  this.listener.beginFunctionBody(begin);
  token = this.expect('{', token);
  while (!$notnull_bool(this.optional('}', token))) {
    token = this.parseStatement(token);
    ++statementCount;
  }
  this.listener.endFunctionBody(statementCount, begin, token);
  this.expect('}', token);
  return token;
}
Parser.prototype.parseStatement = function(token) {
  var value = token.get$stringValue();
  if (token.kind === 97/*null.IDENTIFIER_TOKEN*/) {
    return this.parseExpressionStatementOrDeclaration(token);
  }
  else if (value === '{') {
    return this.parseBlock(token);
  }
  else if (value === 'return') {
    return this.parseReturnStatement(token);
  }
  else if (value === 'var') {
    return this.parseVariablesDeclaration(token);
  }
  else if (value === 'if') {
    return this.parseIfStatement(token);
  }
  else if (value === 'for') {
    return this.parseForStatement(token);
  }
  else if (value === 'throw') {
    return this.parseThrowStatement(token);
  }
  else if (value === 'void') {
    return this.parseExpressionStatementOrDeclaration(token);
  }
  else if (value === 'while') {
    return this.parseWhileStatement(token);
  }
  else if (value === 'do') {
    return this.parseDoWhileStatement(token);
  }
  else {
    return this.parseExpressionStatement(token);
  }
}
Parser.prototype.parseReturnStatement = function(token) {
  var begin = token;
  this.listener.beginReturnStatement(begin);
  $assert('return' === token.get$stringValue(), "'return' === token.stringValue", "parser.dart", 520, 12);
  token = token.next;
  if ($notnull_bool(this.optional(';', token))) {
    this.listener.endReturnStatement(false, begin, token);
  }
  else {
    token = this.parseExpression(token);
    this.listener.endReturnStatement(true, begin, token);
  }
  return this.expectSemicolon(token);
}
Parser.prototype.peekIdentifierAfterType = function(token) {
  var peek = this.peekAfterType(token);
  if (peek != null && peek.kind === 97/*null.IDENTIFIER_TOKEN*/) {
    return peek;
  }
  else {
    return null;
  }
}
Parser.prototype.parseExpressionStatementOrDeclaration = function(token) {
  var identifier = this.peekIdentifierAfterType(token);
  if (identifier != null) {
    $assert(identifier.kind === 97/*null.IDENTIFIER_TOKEN*/, "identifier.kind === IDENTIFIER_TOKEN", "parser.dart", 544, 14);
    var afterId = identifier.next;
    var afterIdKind = afterId.kind;
    if (afterIdKind === 61/*null.EQ_TOKEN*/ || afterIdKind === 59/*null.SEMICOLON_TOKEN*/) {
      return this.parseVariablesDeclaration(token);
    }
    else if (afterIdKind === 40/*null.LPAREN_TOKEN*/) {
      var beginParen = (afterId == null ? null : afterId.assert$BeginGroupToken());
      var endParen = beginParen.endGroup;
      var afterParens = endParen.next;
      if ($notnull_bool(this.optional('{', afterParens)) || $notnull_bool(this.optional('=>', afterParens))) {
        return this.parseFunction(token);
      }
    }
  }
  return this.parseExpressionStatement(token);
}
Parser.prototype.parseExpressionStatement = function(token) {
  this.listener.beginExpressionStatement(token);
  token = this.parseExpression(token);
  this.listener.endExpressionStatement(token);
  return this.expectSemicolon(token);
}
Parser.prototype.parseExpression = function(token) {
  token = this.parseConditionalExpression(token);
  if ($notnull_bool(this.isAssignmentOperator(token))) {
    var operator = token;
    token = this.parseExpression(token.next);
    this.listener.handleAssignmentExpression(operator);
  }
  return token;
}
Parser.prototype.isAssignmentOperator = function(token) {
  return 2 === this.getPrecedence(token);
}
Parser.prototype.parseConditionalExpression = function(token) {
  token = this.parseBinaryExpression(token, 4);
  if ($notnull_bool(this.optional('?', token))) {
    var question = token;
    token = this.parseExpression(token.next);
    var colon = token;
    token = this.expect(':', token);
    token = this.parseExpression(token);
    this.listener.handleConditionalExpression(question, colon);
  }
  return token;
}
Parser.prototype.parseBinaryExpression = function(token, precedence) {
  $assert(precedence >= 4, "precedence >= 4", "parser.dart", 601, 12);
  token = this.parseUnaryExpression(token);
  var tokenLevel = this.getPrecedence(token);
  for (var level = $assert_num(tokenLevel);
   level >= precedence; --level) {
    while (tokenLevel === level) {
      var operator = token;
      token = this.parseBinaryExpression(token.next, level + 1);
      this.listener.handleBinaryExpression(operator);
      tokenLevel = this.getPrecedence(token);
    }
  }
  return token;
}
Parser.prototype.getPrecedence = function(token) {
  if (token == null) return 0;
  var value = token.get$stringValue();
  if (value == null) return 0;
  if (value === '(') return 0;
  if (value === ')') return 0;
  if (value === '%=') return 2;
  if (value === '&=') return 2;
  if (value === '*=') return 2;
  if (value === '+=') return 2;
  if (value === '-=') return 2;
  if (value === '/=') return 2;
  if (value === '<<=') return 2;
  if (value === '=') return 2;
  if (value === '>>=') return 2;
  if (value === '>>>=') return 2;
  if (value === '^=') return 2;
  if (value === '|=') return 2;
  if (value === '~/=') return 2;
  if (value === '?') return 3;
  if (value === '||') return 4;
  if (value === '&&') return 5;
  if (value === '|') return 6;
  if (value === '^') return 7;
  if (value === '&') return 8;
  if (value === '!=') return 9;
  if (value === '!==') return 9;
  if (value === '==') return 9;
  if (value === '===') return 9;
  if (value === '<') return 10;
  if (value === '<=') return 10;
  if (value === '>') return 10;
  if (value === '>=') return 10;
  if (value === 'is') return 10;
  if (value === '<<') return 11;
  if (value === '>>') return 11;
  if (value === '>>>') return 11;
  if (value === '+') return 12;
  if (value === '-') return 12;
  if (value === '%') return 13;
  if (value === '*') return 13;
  if (value === '/') return 13;
  if (value === '~/') return 13;
  if (value === '.') return 14;
  return 0;
}
Parser.prototype.parseUnaryExpression = function(token) {
  var value = token.get$stringValue();
  if ((value === '!') || (value === '+') || (value === '-') || (value === '~')) {
    var operator = token;
    token = token.next;
    token = this.parseUnaryExpression(token);
    this.listener.handleUnaryPrefixExpression(operator);
  }
  else if ((value === '++') || value === '--') {
    var operator = token;
    token = token.next;
    token = this.parseUnaryExpression(token);
    this.listener.handleUnaryPrefixAssignmentExpression(operator);
  }
  else {
    token = this.parsePrimary(token);
    value = token.get$stringValue();
    if ((value === '++') || (value === '--')) {
      this.listener.handleUnaryPostfixAssignmentExpression(token);
      token = token.next;
    }
  }
  return token;
}
Parser.prototype.parsePrimary = function(token) {
  var kind = token.kind;
  if (kind === 97/*null.IDENTIFIER_TOKEN*/) {
    return this.parseSend(token);
  }
  else if (kind === 105/*null.INT_TOKEN*/) {
    return this.parseLiteralInt(token);
  }
  else if (kind === 100/*null.DOUBLE_TOKEN*/) {
    return this.parseLiteralDouble(token);
  }
  else if (kind === 39/*null.STRING_TOKEN*/) {
    return this.parseLiteralString(token);
  }
  else if (kind === 107/*null.KEYWORD_TOKEN*/) {
    {
      var value = token.get$stringValue();
      if ((value === 'true') || (value === 'false')) {
        return this.parseLiteralBool(token);
      }
      else if (value === 'null') {
        return this.parseLiteralNull(token);
      }
      else if (value === 'this') {
        return this.parseThisExpression(token);
      }
      else if (value === 'super') {
        return this.parseSuperExpression(token);
      }
      else {
        this.listener.unexpected(token);
        $throw('not yet implemented');
      }
    }
  }
  else if (kind === 40/*null.LPAREN_TOKEN*/) {
    return this.parseParenthesizedExpression(token);
  }
  else {
    this.listener.unexpected(token);
    $throw('not yet implemented');
  }
}
Parser.prototype.parseParenthesizedExpression = function(token) {
  var begin = (token == null ? null : token.assert$BeginGroupToken());
  token = this.expect('(', token);
  token = this.parseExpression(token);
  $assert(begin.endGroup === token, "begin.endGroup === token", "parser.dart", 731, 12);
  this.listener.handleParenthesizedExpression(begin);
  return this.expect(')', token);
}
Parser.prototype.parseThisExpression = function(token) {
  this.listener.handleThisExpression(token);
  token = token.next;
  if ($notnull_bool(this.optional('(', token))) {
    token = this.parseArgumentsOpt(token);
    this.listener.endSend(token);
  }
  return token;
}
Parser.prototype.parseSuperExpression = function(token) {
  this.listener.handleSuperExpression(token);
  token = token.next;
  if ($notnull_bool(this.optional('(', token))) {
    token = this.parseArgumentsOpt(token);
    this.listener.endSend(token);
  }
  return token;
}
Parser.prototype.parseLiteralInt = function(token) {
  this.listener.handleLiteralInt(token);
  return token.next;
}
Parser.prototype.parseLiteralDouble = function(token) {
  this.listener.handleLiteralDouble(token);
  return token.next;
}
Parser.prototype.parseLiteralString = function(token) {
  this.listener.handleLiteralString(token);
  return token.next;
}
Parser.prototype.parseLiteralBool = function(token) {
  this.listener.handleLiteralBool(token);
  return token.next;
}
Parser.prototype.parseLiteralNull = function(token) {
  this.listener.handleLiteralNull(token);
  return token.next;
}
Parser.prototype.parseSend = function(token) {
  this.listener.beginSend(token);
  token = this.parseIdentifier(token);
  token = this.parseArgumentsOpt(token);
  this.listener.endSend(token);
  return token;
}
Parser.prototype.parseArgumentsOpt = function(token) {
  if (!$notnull_bool(this.optional('(', token))) {
    this.listener.handleNoArguments(token);
    return token;
  }
  else {
    return this.parseArguments(token);
  }
}
Parser.prototype.parseArguments = function(token) {
  var begin = token;
  this.listener.beginArguments(begin);
  $assert('(' === token.get$stringValue(), "'(' === token.stringValue", "parser.dart", 803, 12);
  var argumentCount = 0;
  if ($notnull_bool(this.optional(')', token.next))) {
    this.listener.endArguments(argumentCount, begin, token.next);
    return token.next.next;
  }
  do {
    token = this.parseExpression(token.next);
    ++argumentCount;
  }
  while ($notnull_bool(this.optional(',', token)))
  this.listener.endArguments(argumentCount, begin, token);
  return this.expect(')', token);
}
Parser.prototype.parseVariablesDeclaration = function(token) {
  var count = 1;
  this.listener.beginVariablesDeclaration(token);
  token = this.parseFinalVarOrType(token);
  token = this.parseOptionallyInitializedIdentifier(token);
  while ($notnull_bool(this.optional(',', token))) {
    token = this.parseOptionallyInitializedIdentifier(token.next);
    ++count;
  }
  this.listener.endVariablesDeclaration(count, token);
  return this.expectSemicolon(token);
}
Parser.prototype.parseOptionallyInitializedIdentifier = function(token) {
  this.listener.beginInitializedIdentifier(token);
  token = this.parseIdentifier(token);
  if ($notnull_bool(this.optional('=', token))) {
    var assignment = token;
    this.listener.beginInitializer(token);
    token = this.parseExpression(token.next);
    this.listener.endInitializer(assignment);
  }
  this.listener.endInitializedIdentifier();
  return token;
}
Parser.prototype.parseFinalVarOrType = function(token) {
  if ('final' === token.get$stringValue()) {
    this.listener.handleFinalKeyword(token);
    return token.next;
  }
  else {
    return this.parseType(token);
  }
}
Parser.prototype.parseIfStatement = function(token) {
  var ifToken = token;
  this.listener.beginIfStatement(ifToken);
  token = this.expect('if', token);
  token = this.parseParenthesizedExpression(token);
  token = this.parseStatement(token);
  var elseToken = null;
  if ($notnull_bool(this.optional('else', token))) {
    elseToken = token;
    token = this.parseStatement(token.next);
  }
  this.listener.endIfStatement(ifToken, elseToken);
  return token;
}
Parser.prototype.parseForStatement = function(token) {
  var forToken = token;
  this.listener.beginForStatement(forToken);
  token = this.expect('for', token);
  token = this.expect('(', token);
  token = this.parseVariablesDeclaration(token);
  token = this.parseExpressionStatement(token);
  token = this.parseExpression(token);
  token = this.expect(')', token);
  token = this.parseStatement(token);
  this.listener.endForStatement(forToken, token);
  return token;
}
Parser.prototype.parseWhileStatement = function(token) {
  var whileToken = token;
  this.listener.beginWhileStatement(whileToken);
  token = this.expect('while', token);
  token = this.parseParenthesizedExpression(token);
  token = this.parseStatement(token);
  this.listener.endWhileStatement(whileToken, token);
  return token;
}
Parser.prototype.parseDoWhileStatement = function(token) {
  var doToken = token;
  this.listener.beginDoWhileStatement(doToken);
  token = this.expect('do', token);
  token = this.parseStatement(token);
  var whileToken = token;
  token = this.expect('while', token);
  token = this.parseParenthesizedExpression(token);
  this.listener.endDoWhileStatement(doToken, whileToken, token);
  return this.expectSemicolon(token);
}
Parser.prototype.parseBlock = function(token) {
  var begin = token;
  this.listener.beginBlock(begin);
  var statementCount = 0;
  token = this.expect('{', token);
  while (!$notnull_bool(this.optional('}', token))) {
    token = this.parseStatement(token);
    ++statementCount;
  }
  this.listener.endBlock(statementCount, begin, token);
  return this.expect('}', token);
}
Parser.prototype.parseThrowStatement = function(token) {
  var throwToken = token;
  this.listener.beginThrowStatement(throwToken);
  token = this.expect('throw', token);
  if ($notnull_bool(this.optional(';', token))) {
    this.listener.endRethrowStatement(throwToken, token);
    return token.next;
  }
  else {
    token = this.parseExpression(token);
    this.listener.endThrowStatement(throwToken, token);
    return this.expectSemicolon(token);
  }
}
Parser.prototype.parseFunction$1 = function($0) {
  return this.parseFunction(($0 == null ? null : $0.assert$Token()));
};
// ********** Code for ParserTask **************
function ParserTask(compiler) {
  // Initializers done
  CompilerTask.call(this, compiler);
}
$inherits(ParserTask, CompilerTask);
ParserTask.prototype.get$name = function() {
  return 'Parser';
}
ParserTask.prototype.parse = function(element) {
  var $this = this; // closure support
  var $0;
  return (($0 = this.measure((function () {
    return element.parseNode($this.compiler, $this.compiler);
  })
  )) == null ? null : $0.assert$Node());
}
// ********** Code for PartialParser **************
function PartialParser(listener) {
  // Initializers done
  Parser.call(this, listener);
}
$inherits(PartialParser, Parser);
PartialParser.prototype.parseClassBody = function(token) {
  return this.skipBlock(token);
}
PartialParser.prototype.fullParseClassBody = function(token) {
  return Parser.prototype.parseClassBody.call(this, token);
}
PartialParser.prototype.parseExpression = function(token) {
  return this.skipExpression(token);
}
PartialParser.prototype.skipExpression = function(token) {
  while (true) {
    var kind = token.kind;
    if ((token.kind === 0/*null.EOF_TOKEN*/) || (token.kind === 59/*null.SEMICOLON_TOKEN*/)) return token;
    if ((token instanceof BeginGroupToken)) {
      var begin = (token == null ? null : token.assert$BeginGroupToken());
      token = (begin.endGroup != null) ? begin.endGroup : token;
    }
    token = token.next;
  }
}
PartialParser.prototype.parseFunctionBody = function(token) {
  if ($notnull_bool(this.optional(';', token))) {
    this.listener.handleNoFunctionBody(token);
    return token;
  }
  else if ($notnull_bool(this.optional('=>', token))) {
    token = this.parseExpression(token.next);
    this.expectSemicolon(token);
    return token;
  }
  else {
    token = this.skipBlock(token);
    this.listener.handleNoFunctionBody(token);
    return token;
  }
}
// ********** Code for AbstractScanner **************
function AbstractScanner() {
  // Initializers done
}
AbstractScanner.prototype.tokenize = function() {
  var next = this.advance();
  while (next != 0/*null.$EOF*/) {
    next = this.bigSwitch(next);
  }
  this.appendEofToken();
  return this.firstToken();
}
AbstractScanner.prototype.bigSwitch = function(next) {
  this.beginToken();
  if (next === 9/*null.$TAB*/ || next === 10/*null.$LF*/ || next === 13/*null.$CR*/ || next === 32/*null.$SPACE*/) {
    this.appendWhiteSpace(next);
    return this.advance();
  }
  if (97/*null.$a*/ <= next && next <= 122/*null.$z*/) {
    return this.tokenizeKeywordOrIdentifier(next);
  }
  if ((65/*null.$A*/ <= next && next <= 90/*null.$Z*/) || next === 95/*null.$_*/ || next === 36/*null.$$*/) {
    return this.tokenizeIdentifier(next, this.get$byteOffset());
  }
  if (next === 60/*null.$LT*/) {
    return this.tokenizeLessThan(next);
  }
  if (next === 62/*null.$GT*/) {
    return this.tokenizeGreaterThan(next);
  }
  if (next === 61/*null.$EQ*/) {
    return this.tokenizeEquals(next);
  }
  if (next === 33/*null.$BANG*/) {
    return this.tokenizeExclamation(next);
  }
  if (next === 43/*null.$PLUS*/) {
    return this.tokenizePlus(next);
  }
  if (next === 45/*null.$MINUS*/) {
    return this.tokenizeMinus(next);
  }
  if (next === 42/*null.$STAR*/) {
    return this.tokenizeMultiply(next);
  }
  if (next === 37/*null.$PERCENT*/) {
    return this.tokenizePercent(next);
  }
  if (next === 38/*null.$AMPERSAND*/) {
    return this.tokenizeAmpersand(next);
  }
  if (next === 124/*null.$BAR*/) {
    return this.tokenizeBar(next);
  }
  if (next === 94/*null.$CARET*/) {
    return this.tokenizeCaret(next);
  }
  if (next === 91/*null.$OPEN_SQUARE_BRACKET*/) {
    return this.tokenizeOpenSquareBracket(next);
  }
  if (next === 126/*null.$TILDE*/) {
    return this.tokenizeTilde(next);
  }
  if (next === 92/*null.$BACKSLASH*/) {
    this.appendStringToken(92/*null.BACKSLASH_TOKEN*/, "\\");
    return this.advance();
  }
  if (next === 35/*null.$HASH*/) {
    return this.tokenizeTag(next);
  }
  if (next === 40/*null.$LPAREN*/) {
    this.appendBeginGroup(40/*null.LPAREN_TOKEN*/, "(");
    return this.advance();
  }
  if (next === 41/*null.$RPAREN*/) {
    this.appendEndGroup(41/*null.RPAREN_TOKEN*/, ")", 40/*null.LPAREN_TOKEN*/);
    return this.advance();
  }
  if (next === 44/*null.$COMMA*/) {
    this.appendStringToken(44/*null.COMMA_TOKEN*/, ",");
    return this.advance();
  }
  if (next === 58/*null.$COLON*/) {
    this.appendStringToken(58/*null.COLON_TOKEN*/, ":");
    return this.advance();
  }
  if (next === 59/*null.$SEMICOLON*/) {
    this.appendStringToken(59/*null.SEMICOLON_TOKEN*/, ";");
    return this.advance();
  }
  if (next === 63/*null.$QUESTION*/) {
    this.appendStringToken(63/*null.QUESTION_TOKEN*/, "?");
    return this.advance();
  }
  if (next === 93/*null.$CLOSE_SQUARE_BRACKET*/) {
    this.appendEndGroup(93/*null.CLOSE_SQUARE_BRACKET_TOKEN*/, "]", 91/*null.OPEN_SQUARE_BRACKET_TOKEN*/);
    return this.advance();
  }
  if (next === 96/*null.$BACKPING*/) {
    this.appendStringToken(96/*null.BACKPING_TOKEN*/, "`");
    return this.advance();
  }
  if (next === 123/*null.$OPEN_CURLY_BRACKET*/) {
    this.appendBeginGroup(123/*null.OPEN_CURLY_BRACKET_TOKEN*/, "{");
    return this.advance();
  }
  if (next === 125/*null.$CLOSE_CURLY_BRACKET*/) {
    this.appendEndGroup(125/*null.CLOSE_CURLY_BRACKET_TOKEN*/, "}", 123/*null.OPEN_CURLY_BRACKET_TOKEN*/);
    return this.advance();
  }
  if (next === 47/*null.$SLASH*/) {
    return this.tokenizeSlashOrComment(next);
  }
  if (next === 64/*null.$AT*/) {
    return this.tokenizeRawString(next);
  }
  if (next === 34/*null.$DQ*/ || next === 39/*null.$SQ*/) {
    return this.tokenizeString(next, this.get$byteOffset(), false);
  }
  if (next === 46/*null.$PERIOD*/) {
    return this.tokenizeDotOrNumber(next);
  }
  if (next === 48/*null.$0*/) {
    return this.tokenizeHexOrNumber(next);
  }
  if (next === 49/*null.$1*/ || next === 50/*null.$2*/ || next === 51/*null.$3*/ || next === 52/*null.$4*/ || next === 53/*null.$5*/ || next === 54/*null.$6*/ || next === 55/*null.$7*/ || next === 56/*null.$8*/ || next === 57/*null.$9*/) {
    return this.tokenizeNumber(next);
  }
  if (next === 0/*null.$EOF*/) {
    return 0/*null.$EOF*/;
  }
  if (next < 0x1f) {
    $throw(new MalformedInputException(this.get$charOffset()));
  }
  return this.tokenizeIdentifier(next, this.get$byteOffset());
}
AbstractScanner.prototype.tokenizeTag = function(next) {
  if (this.get$byteOffset() === 0) {
    if (this.peek() === 33/*null.$BANG*/) {
      do {
        next = this.advance();
      }
      while (next != 10/*null.$LF*/ && next != 13/*null.$CR*/)
      return next;
    }
  }
  this.appendStringToken(35/*null.HASH_TOKEN*/, "#");
  return this.advance();
}
AbstractScanner.prototype.tokenizeTilde = function(next) {
  next = this.advance();
  if (next === 47/*null.$SLASH*/) {
    return this.select(61/*null.$EQ*/, "~/=", "~/");
  }
  else {
    this.appendStringToken(126/*null.TILDE_TOKEN*/, "~");
    return next;
  }
}
AbstractScanner.prototype.tokenizeOpenSquareBracket = function(next) {
  next = this.advance();
  if (next === 93/*null.$CLOSE_SQUARE_BRACKET*/) {
    return this.select(61/*null.$EQ*/, "[]=", "[]");
  }
  else {
    this.appendBeginGroup(91/*null.OPEN_SQUARE_BRACKET_TOKEN*/, "[");
    return next;
  }
}
AbstractScanner.prototype.tokenizeCaret = function(next) {
  return this.select(61/*null.$EQ*/, "^=", "^");
}
AbstractScanner.prototype.tokenizeBar = function(next) {
  next = this.advance();
  if (next === 124/*null.$BAR*/) {
    this.appendStringToken(124/*null.BAR_TOKEN*/, "||");
    return this.advance();
  }
  else if (next === 61/*null.$EQ*/) {
    this.appendStringToken(124/*null.BAR_TOKEN*/, "|=");
    return this.advance();
  }
  else {
    this.appendStringToken(124/*null.BAR_TOKEN*/, "|");
    return next;
  }
}
AbstractScanner.prototype.tokenizeAmpersand = function(next) {
  next = this.advance();
  if (next === 38/*null.$AMPERSAND*/) {
    this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&&");
    return this.advance();
  }
  else if (next === 61/*null.$EQ*/) {
    this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&=");
    return this.advance();
  }
  else {
    this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&");
    return next;
  }
}
AbstractScanner.prototype.tokenizePercent = function(next) {
  return this.select(61/*null.$EQ*/, "%=", "%");
}
AbstractScanner.prototype.tokenizeMultiply = function(next) {
  return this.select(61/*null.$EQ*/, "*=", "*");
}
AbstractScanner.prototype.tokenizeMinus = function(next) {
  next = this.advance();
  if (next === 45/*null.$MINUS*/) {
    this.appendStringToken(45/*null.MINUS_TOKEN*/, "--");
    return this.advance();
  }
  else if (next === 61/*null.$EQ*/) {
    this.appendStringToken(45/*null.MINUS_TOKEN*/, "-=");
    return this.advance();
  }
  else {
    this.appendStringToken(45/*null.MINUS_TOKEN*/, "-");
    return next;
  }
}
AbstractScanner.prototype.tokenizePlus = function(next) {
  next = this.advance();
  if (43/*null.$PLUS*/ === next) {
    this.appendStringToken(43/*null.PLUS_TOKEN*/, "++");
    return this.advance();
  }
  else if (61/*null.$EQ*/ === next) {
    this.appendStringToken(43/*null.PLUS_TOKEN*/, "+=");
    return this.advance();
  }
  else {
    this.appendStringToken(43/*null.PLUS_TOKEN*/, "+");
    return next;
  }
}
AbstractScanner.prototype.tokenizeExclamation = function(next) {
  next = this.advance();
  if (next === 61/*null.$EQ*/) {
    return this.select(61/*null.$EQ*/, "!==", "!=");
  }
  this.appendStringToken(33/*null.BANG_TOKEN*/, "!");
  return next;
}
AbstractScanner.prototype.tokenizeEquals = function(next) {
  next = this.advance();
  if (next === 61/*null.$EQ*/) {
    return this.select(61/*null.$EQ*/, "===", "==");
  }
  else if (next === 62/*null.$GT*/) {
    this.appendStringToken(190/*null.FUNCTION_TOKEN*/, "=>");
    return this.advance();
  }
  this.appendStringToken(61/*null.EQ_TOKEN*/, "=");
  return next;
}
AbstractScanner.prototype.tokenizeGreaterThan = function(next) {
  next = this.advance();
  if (61/*null.$EQ*/ === next) {
    this.appendStringToken(62/*null.GT_TOKEN*/, ">=");
    return this.advance();
  }
  else if (62/*null.$GT*/ === next) {
    next = this.advance();
    if (61/*null.$EQ*/ === next) {
      this.appendStringToken(62/*null.GT_TOKEN*/, ">>=");
      return this.advance();
    }
    else if (62/*null.$GT*/ === next) {
      next = this.advance();
      if (next === 61/*null.$EQ*/) {
        this.appendStringToken(62/*null.GT_TOKEN*/, ">>>=");
        return this.advance();
      }
      else {
        this.appendGtGtGt(62/*null.GT_TOKEN*/, ">>>");
        return next;
      }
    }
    else {
      this.appendGtGt(62/*null.GT_TOKEN*/, ">>");
      return next;
    }
  }
  else {
    this.appendEndGroup(62/*null.GT_TOKEN*/, ">", 60/*null.LT_TOKEN*/);
    return next;
  }
}
AbstractScanner.prototype.tokenizeLessThan = function(next) {
  next = this.advance();
  if (61/*null.$EQ*/ === next) {
    this.appendStringToken(188/*null.LT_EQ_TOKEN*/, "<=");
    return this.advance();
  }
  else if (60/*null.$LT*/ === next) {
    return this.select(61/*null.$EQ*/, "<<=", "<<");
  }
  else {
    this.appendBeginGroup(60/*null.LT_TOKEN*/, "<");
    return next;
  }
}
AbstractScanner.prototype.tokenizeNumber = function(next) {
  var $0;
  var start = this.get$byteOffset();
  while (true) {
    next = this.advance();
    if (48/*null.$0*/ <= next && next <= 57/*null.$9*/) {
      continue;
    }
    else if (next === 46/*null.$PERIOD*/) {
      return this.tokenizeFractionPart(this.advance(), start);
    }
    else if (next === 101/*null.$e*/ || next === 69/*null.$E*/ || next === 100/*null.$d*/ || next === 68/*null.$D*/) {
      return this.tokenizeFractionPart(next, start);
    }
    else {
      this.appendByteStringToken$2(105/*null.INT_TOKEN*/, this.asciiString(start));
      return next;
    }
  }
}
AbstractScanner.prototype.tokenizeHexOrNumber = function(next) {
  var x = this.peek();
  if (x === 120/*null.$x*/ || x === 88/*null.$X*/) {
    this.advance();
    return this.tokenizeHex(x);
  }
  return this.tokenizeNumber(next);
}
AbstractScanner.prototype.tokenizeHex = function(next) {
  var $0;
  var start = this.get$byteOffset();
  var hasDigits = false;
  while (true) {
    next = this.advance();
    if ((48/*null.$0*/ <= next && next <= 57/*null.$9*/) || (65/*null.$A*/ <= next && next <= 70/*null.$F*/) || (97/*null.$a*/ <= next && next <= 102/*null.$f*/)) {
      hasDigits = true;
    }
    else {
      if (!$notnull_bool(hasDigits)) {
        $throw(new MalformedInputException(this.get$charOffset()));
      }
      this.appendByteStringToken$2(120/*null.HEXADECIMAL_TOKEN*/, this.asciiString(start));
      return next;
    }
  }
}
AbstractScanner.prototype.tokenizeDotOrNumber = function(next) {
  var start = this.get$byteOffset();
  next = this.advance();
  if ((48/*null.$0*/ <= next && next <= 57/*null.$9*/)) {
    return this.tokenizeFractionPart(next, start);
  }
  else if (46/*null.$PERIOD*/ === next) {
    return this.select(46/*null.$PERIOD*/, "...", "..");
  }
  else {
    this.appendStringToken(46/*null.PERIOD_TOKEN*/, ".");
    return next;
  }
}
AbstractScanner.prototype.tokenizeFractionPart = function(next, start) {
  var $0;
  var done = false;
  LOOP:
  while (!$notnull_bool(done)) {
    if (48/*null.$0*/ <= next && next <= 57/*null.$9*/) {
    }
    else if (101/*null.$e*/ === next || 69/*null.$E*/ === next) {
      next = this.tokenizeExponent(this.advance());
      done = true;
      continue LOOP;
    }
    else {
      done = true;
      continue LOOP;
    }
    next = this.advance();
  }
  if (next === 100/*null.$d*/ || next === 68/*null.$D*/) {
    next = this.advance();
  }
  this.appendByteStringToken$2(100/*null.DOUBLE_TOKEN*/, this.asciiString(start));
  return next;
}
AbstractScanner.prototype.tokenizeExponent = function(next) {
  if (next === 43/*null.$PLUS*/ || next === 45/*null.$MINUS*/) {
    next = this.advance();
  }
  var hasDigits = false;
  while (true) {
    if (48/*null.$0*/ <= next && next <= 57/*null.$9*/) {
      hasDigits = true;
    }
    else {
      if (!$notnull_bool(hasDigits)) {
        $throw(new MalformedInputException(this.get$charOffset()));
      }
      return next;
    }
    next = this.advance();
  }
}
AbstractScanner.prototype.tokenizeSlashOrComment = function(next) {
  next = this.advance();
  if (42/*null.$STAR*/ === next) {
    return this.tokenizeMultiLineComment(next);
  }
  else if (47/*null.$SLASH*/ === next) {
    return this.tokenizeSingleLineComment(next);
  }
  else if (61/*null.$EQ*/ === next) {
    this.appendStringToken(47/*null.SLASH_TOKEN*/, "/=");
    return this.advance();
  }
  else {
    this.appendStringToken(47/*null.SLASH_TOKEN*/, "/");
    return next;
  }
}
AbstractScanner.prototype.tokenizeSingleLineComment = function(next) {
  while (true) {
    next = this.advance();
    if (10/*null.$LF*/ === next || 13/*null.$CR*/ === next || 0/*null.$EOF*/ === next) {
      return next;
    }
  }
}
AbstractScanner.prototype.tokenizeMultiLineComment = function(next) {
  next = this.advance();
  while (true) {
    if (0/*null.$EOF*/ === next) {
      return next;
    }
    else if (42/*null.$STAR*/ === next) {
      next = this.advance();
      if (next === 47/*null.$SLASH*/) {
        return this.advance();
      }
      else if (next === 0/*null.$EOF*/) {
        return next;
      }
    }
    else {
      next = this.advance();
    }
  }
}
AbstractScanner.prototype.tokenizeKeywordOrIdentifier = function(next) {
  var state = KeywordState.get$KEYWORD_STATE();
  var start = this.get$byteOffset();
  while (state != null && 97/*null.$a*/ <= next && next <= 122/*null.$z*/) {
    state = state.next(next);
    next = this.advance();
  }
  if (state == null || !$notnull_bool(state.isLeaf())) {
    return this.tokenizeIdentifier(next, start);
  }
  if ((65/*null.$A*/ <= next && next <= 90/*null.$Z*/) || (48/*null.$0*/ <= next && next <= 57/*null.$9*/) || next === 95/*null.$_*/ || next === 36/*null.$$*/) {
    return this.tokenizeIdentifier(next, start);
  }
  else if (next < 128) {
    this.appendKeywordToken(state.get$keyword());
    return next;
  }
  else {
    return this.tokenizeIdentifier(next, start);
  }
}
AbstractScanner.prototype.tokenizeIdentifier = function(next, start) {
  var $0;
  var isAscii = true;
  while (true) {
    if ((97/*null.$a*/ <= next && next <= 122/*null.$z*/) || (65/*null.$A*/ <= next && next <= 90/*null.$Z*/) || (48/*null.$0*/ <= next && next <= 57/*null.$9*/) || next === 95/*null.$_*/ || next === 36/*null.$$*/) {
      next = this.advance();
    }
    else if (next < 128) {
      if ($notnull_bool(isAscii)) {
        this.appendByteStringToken$2(97/*null.IDENTIFIER_TOKEN*/, this.asciiString(start));
      }
      else {
        this.appendByteStringToken$2(97/*null.IDENTIFIER_TOKEN*/, this.utf8String(start, -1));
      }
      return next;
    }
    else {
      var nonAsciiStart = this.get$byteOffset();
      do {
        next = this.nextByte();
      }
      while (next > 127)
      var string = this.utf8String(nonAsciiStart, -1).toString$0();
      isAscii = false;
      var byteLength = nonAsciiStart - this.get$byteOffset();
      this.addToCharOffset(string.length - byteLength);
    }
  }
}
AbstractScanner.prototype.tokenizeRawString = function(next) {
  var start = this.get$byteOffset();
  next = this.advance();
  if (next === 34/*null.$DQ*/ || next === 39/*null.$SQ*/) {
    return this.tokenizeString(next, start, true);
  }
  else {
    $throw(new MalformedInputException(this.get$charOffset()));
  }
}
AbstractScanner.prototype.tokenizeString = function(next, start, raw) {
  var $0;
  var q = next;
  next = this.advance();
  if (q === next) {
    next = this.advance();
    if (q === next) {
      return this.tokenizeMultiLineString(q, start, raw);
    }
    else {
      this.appendByteStringToken$2(39/*null.STRING_TOKEN*/, this.utf8String(start, -1));
      return next;
    }
  }
  if ($notnull_bool(raw)) {
    return this.tokenizeSingleLineRawString(next, q, start);
  }
  else {
    return this.tokenizeSingleLineString(next, q, start);
  }
}
AbstractScanner.prototype.tokenizeSingleLineString = function(next, q1, start) {
  var $0;
  while (next != 0/*null.$EOF*/) {
    if (next === q1) {
      this.appendByteStringToken$2(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
      return this.advance();
    }
    else if (next === 92/*null.$BACKSLASH*/) {
      next = this.advance();
      if (next === 0/*null.$EOF*/) {
        $throw(new MalformedInputException(this.get$charOffset()));
      }
    }
    else if (next === 10/*null.$LF*/ || next === 13/*null.$CR*/) {
      $throw(new MalformedInputException(this.get$charOffset()));
    }
    next = this.advance();
  }
  $throw(new MalformedInputException(this.get$charOffset()));
}
AbstractScanner.prototype.tokenizeSingleLineRawString = function(next, q1, start) {
  var $0;
  next = this.advance();
  while (next != 0/*null.$EOF*/) {
    if (next === q1) {
      this.appendByteStringToken$2(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
      return this.advance();
    }
    else if (next === 10/*null.$LF*/ || next === 13/*null.$CR*/) {
      $throw(new MalformedInputException(this.get$charOffset()));
    }
    next = this.advance();
  }
  $throw(new MalformedInputException(this.get$charOffset()));
}
AbstractScanner.prototype.tokenizeMultiLineString = function(q, start, raw) {
  var $0;
  var next = this.advance();
  while (next != 0/*null.$EOF*/) {
    if (next === q) {
      next = this.advance();
      if (next === q) {
        next = this.advance();
        if (next === q) {
          this.appendByteStringToken$2(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
          return this.advance();
        }
      }
    }
    next = this.advance();
  }
  return next;
}
AbstractScanner.prototype.appendByteStringToken$2 = function($0, $1) {
  return this.appendByteStringToken($assert_num($0), $1);
};
// ********** Code for AbstractScanner_S **************
function AbstractScanner_S() {
  // Initializers done
}
$inherits(AbstractScanner_S, AbstractScanner);
// ********** Code for AbstractScanner_SourceString **************
function AbstractScanner_SourceString() {
  // Initializers done
}
$inherits(AbstractScanner_SourceString, AbstractScanner);
AbstractScanner_SourceString.prototype.tokenize = function() {
  var next = this.advance();
  while (next != 0/*null.$EOF*/) {
    next = this.bigSwitch(next);
  }
  this.appendEofToken();
  return this.firstToken();
}
AbstractScanner_SourceString.prototype.bigSwitch = function(next) {
  this.beginToken();
  if (next === 9/*null.$TAB*/ || next === 10/*null.$LF*/ || next === 13/*null.$CR*/ || next === 32/*null.$SPACE*/) {
    this.appendWhiteSpace(next);
    return this.advance();
  }
  if (97/*null.$a*/ <= next && next <= 122/*null.$z*/) {
    return this.tokenizeKeywordOrIdentifier(next);
  }
  if ((65/*null.$A*/ <= next && next <= 90/*null.$Z*/) || next === 95/*null.$_*/ || next === 36/*null.$$*/) {
    return this.tokenizeIdentifier(next, this.get$byteOffset());
  }
  if (next === 60/*null.$LT*/) {
    return this.tokenizeLessThan(next);
  }
  if (next === 62/*null.$GT*/) {
    return this.tokenizeGreaterThan(next);
  }
  if (next === 61/*null.$EQ*/) {
    return this.tokenizeEquals(next);
  }
  if (next === 33/*null.$BANG*/) {
    return this.tokenizeExclamation(next);
  }
  if (next === 43/*null.$PLUS*/) {
    return this.tokenizePlus(next);
  }
  if (next === 45/*null.$MINUS*/) {
    return this.tokenizeMinus(next);
  }
  if (next === 42/*null.$STAR*/) {
    return this.tokenizeMultiply(next);
  }
  if (next === 37/*null.$PERCENT*/) {
    return this.tokenizePercent(next);
  }
  if (next === 38/*null.$AMPERSAND*/) {
    return this.tokenizeAmpersand(next);
  }
  if (next === 124/*null.$BAR*/) {
    return this.tokenizeBar(next);
  }
  if (next === 94/*null.$CARET*/) {
    return this.tokenizeCaret(next);
  }
  if (next === 91/*null.$OPEN_SQUARE_BRACKET*/) {
    return this.tokenizeOpenSquareBracket(next);
  }
  if (next === 126/*null.$TILDE*/) {
    return this.tokenizeTilde(next);
  }
  if (next === 92/*null.$BACKSLASH*/) {
    this.appendStringToken(92/*null.BACKSLASH_TOKEN*/, "\\");
    return this.advance();
  }
  if (next === 35/*null.$HASH*/) {
    return this.tokenizeTag(next);
  }
  if (next === 40/*null.$LPAREN*/) {
    this.appendBeginGroup(40/*null.LPAREN_TOKEN*/, "(");
    return this.advance();
  }
  if (next === 41/*null.$RPAREN*/) {
    this.appendEndGroup(41/*null.RPAREN_TOKEN*/, ")", 40/*null.LPAREN_TOKEN*/);
    return this.advance();
  }
  if (next === 44/*null.$COMMA*/) {
    this.appendStringToken(44/*null.COMMA_TOKEN*/, ",");
    return this.advance();
  }
  if (next === 58/*null.$COLON*/) {
    this.appendStringToken(58/*null.COLON_TOKEN*/, ":");
    return this.advance();
  }
  if (next === 59/*null.$SEMICOLON*/) {
    this.appendStringToken(59/*null.SEMICOLON_TOKEN*/, ";");
    return this.advance();
  }
  if (next === 63/*null.$QUESTION*/) {
    this.appendStringToken(63/*null.QUESTION_TOKEN*/, "?");
    return this.advance();
  }
  if (next === 93/*null.$CLOSE_SQUARE_BRACKET*/) {
    this.appendEndGroup(93/*null.CLOSE_SQUARE_BRACKET_TOKEN*/, "]", 91/*null.OPEN_SQUARE_BRACKET_TOKEN*/);
    return this.advance();
  }
  if (next === 96/*null.$BACKPING*/) {
    this.appendStringToken(96/*null.BACKPING_TOKEN*/, "`");
    return this.advance();
  }
  if (next === 123/*null.$OPEN_CURLY_BRACKET*/) {
    this.appendBeginGroup(123/*null.OPEN_CURLY_BRACKET_TOKEN*/, "{");
    return this.advance();
  }
  if (next === 125/*null.$CLOSE_CURLY_BRACKET*/) {
    this.appendEndGroup(125/*null.CLOSE_CURLY_BRACKET_TOKEN*/, "}", 123/*null.OPEN_CURLY_BRACKET_TOKEN*/);
    return this.advance();
  }
  if (next === 47/*null.$SLASH*/) {
    return this.tokenizeSlashOrComment(next);
  }
  if (next === 64/*null.$AT*/) {
    return this.tokenizeRawString(next);
  }
  if (next === 34/*null.$DQ*/ || next === 39/*null.$SQ*/) {
    return this.tokenizeString(next, this.get$byteOffset(), false);
  }
  if (next === 46/*null.$PERIOD*/) {
    return this.tokenizeDotOrNumber(next);
  }
  if (next === 48/*null.$0*/) {
    return this.tokenizeHexOrNumber(next);
  }
  if (next === 49/*null.$1*/ || next === 50/*null.$2*/ || next === 51/*null.$3*/ || next === 52/*null.$4*/ || next === 53/*null.$5*/ || next === 54/*null.$6*/ || next === 55/*null.$7*/ || next === 56/*null.$8*/ || next === 57/*null.$9*/) {
    return this.tokenizeNumber(next);
  }
  if (next === 0/*null.$EOF*/) {
    return 0/*null.$EOF*/;
  }
  if (next < 0x1f) {
    $throw(new MalformedInputException(this.get$charOffset()));
  }
  return this.tokenizeIdentifier(next, this.get$byteOffset());
}
AbstractScanner_SourceString.prototype.tokenizeTag = function(next) {
  if (this.get$byteOffset() === 0) {
    if (this.peek() === 33/*null.$BANG*/) {
      do {
        next = this.advance();
      }
      while (next != 10/*null.$LF*/ && next != 13/*null.$CR*/)
      return next;
    }
  }
  this.appendStringToken(35/*null.HASH_TOKEN*/, "#");
  return this.advance();
}
AbstractScanner_SourceString.prototype.tokenizeTilde = function(next) {
  next = this.advance();
  if (next === 47/*null.$SLASH*/) {
    return this.select(61/*null.$EQ*/, "~/=", "~/");
  }
  else {
    this.appendStringToken(126/*null.TILDE_TOKEN*/, "~");
    return next;
  }
}
AbstractScanner_SourceString.prototype.tokenizeOpenSquareBracket = function(next) {
  next = this.advance();
  if (next === 93/*null.$CLOSE_SQUARE_BRACKET*/) {
    return this.select(61/*null.$EQ*/, "[]=", "[]");
  }
  else {
    this.appendBeginGroup(91/*null.OPEN_SQUARE_BRACKET_TOKEN*/, "[");
    return next;
  }
}
AbstractScanner_SourceString.prototype.tokenizeCaret = function(next) {
  return this.select(61/*null.$EQ*/, "^=", "^");
}
AbstractScanner_SourceString.prototype.tokenizeBar = function(next) {
  next = this.advance();
  if (next === 124/*null.$BAR*/) {
    this.appendStringToken(124/*null.BAR_TOKEN*/, "||");
    return this.advance();
  }
  else if (next === 61/*null.$EQ*/) {
    this.appendStringToken(124/*null.BAR_TOKEN*/, "|=");
    return this.advance();
  }
  else {
    this.appendStringToken(124/*null.BAR_TOKEN*/, "|");
    return next;
  }
}
AbstractScanner_SourceString.prototype.tokenizeAmpersand = function(next) {
  next = this.advance();
  if (next === 38/*null.$AMPERSAND*/) {
    this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&&");
    return this.advance();
  }
  else if (next === 61/*null.$EQ*/) {
    this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&=");
    return this.advance();
  }
  else {
    this.appendStringToken(38/*null.AMPERSAND_TOKEN*/, "&");
    return next;
  }
}
AbstractScanner_SourceString.prototype.tokenizePercent = function(next) {
  return this.select(61/*null.$EQ*/, "%=", "%");
}
AbstractScanner_SourceString.prototype.tokenizeMultiply = function(next) {
  return this.select(61/*null.$EQ*/, "*=", "*");
}
AbstractScanner_SourceString.prototype.tokenizeMinus = function(next) {
  next = this.advance();
  if (next === 45/*null.$MINUS*/) {
    this.appendStringToken(45/*null.MINUS_TOKEN*/, "--");
    return this.advance();
  }
  else if (next === 61/*null.$EQ*/) {
    this.appendStringToken(45/*null.MINUS_TOKEN*/, "-=");
    return this.advance();
  }
  else {
    this.appendStringToken(45/*null.MINUS_TOKEN*/, "-");
    return next;
  }
}
AbstractScanner_SourceString.prototype.tokenizePlus = function(next) {
  next = this.advance();
  if (43/*null.$PLUS*/ === next) {
    this.appendStringToken(43/*null.PLUS_TOKEN*/, "++");
    return this.advance();
  }
  else if (61/*null.$EQ*/ === next) {
    this.appendStringToken(43/*null.PLUS_TOKEN*/, "+=");
    return this.advance();
  }
  else {
    this.appendStringToken(43/*null.PLUS_TOKEN*/, "+");
    return next;
  }
}
AbstractScanner_SourceString.prototype.tokenizeExclamation = function(next) {
  next = this.advance();
  if (next === 61/*null.$EQ*/) {
    return this.select(61/*null.$EQ*/, "!==", "!=");
  }
  this.appendStringToken(33/*null.BANG_TOKEN*/, "!");
  return next;
}
AbstractScanner_SourceString.prototype.tokenizeEquals = function(next) {
  next = this.advance();
  if (next === 61/*null.$EQ*/) {
    return this.select(61/*null.$EQ*/, "===", "==");
  }
  else if (next === 62/*null.$GT*/) {
    this.appendStringToken(190/*null.FUNCTION_TOKEN*/, "=>");
    return this.advance();
  }
  this.appendStringToken(61/*null.EQ_TOKEN*/, "=");
  return next;
}
AbstractScanner_SourceString.prototype.tokenizeGreaterThan = function(next) {
  next = this.advance();
  if (61/*null.$EQ*/ === next) {
    this.appendStringToken(62/*null.GT_TOKEN*/, ">=");
    return this.advance();
  }
  else if (62/*null.$GT*/ === next) {
    next = this.advance();
    if (61/*null.$EQ*/ === next) {
      this.appendStringToken(62/*null.GT_TOKEN*/, ">>=");
      return this.advance();
    }
    else if (62/*null.$GT*/ === next) {
      next = this.advance();
      if (next === 61/*null.$EQ*/) {
        this.appendStringToken(62/*null.GT_TOKEN*/, ">>>=");
        return this.advance();
      }
      else {
        this.appendGtGtGt(62/*null.GT_TOKEN*/, ">>>");
        return next;
      }
    }
    else {
      this.appendGtGt(62/*null.GT_TOKEN*/, ">>");
      return next;
    }
  }
  else {
    this.appendEndGroup(62/*null.GT_TOKEN*/, ">", 60/*null.LT_TOKEN*/);
    return next;
  }
}
AbstractScanner_SourceString.prototype.tokenizeLessThan = function(next) {
  next = this.advance();
  if (61/*null.$EQ*/ === next) {
    this.appendStringToken(188/*null.LT_EQ_TOKEN*/, "<=");
    return this.advance();
  }
  else if (60/*null.$LT*/ === next) {
    return this.select(61/*null.$EQ*/, "<<=", "<<");
  }
  else {
    this.appendBeginGroup(60/*null.LT_TOKEN*/, "<");
    return next;
  }
}
AbstractScanner_SourceString.prototype.tokenizeNumber = function(next) {
  var start = this.get$byteOffset();
  while (true) {
    next = this.advance();
    if (48/*null.$0*/ <= next && next <= 57/*null.$9*/) {
      continue;
    }
    else if (next === 46/*null.$PERIOD*/) {
      return this.tokenizeFractionPart(this.advance(), start);
    }
    else if (next === 101/*null.$e*/ || next === 69/*null.$E*/ || next === 100/*null.$d*/ || next === 68/*null.$D*/) {
      return this.tokenizeFractionPart(next, start);
    }
    else {
      this.appendByteStringToken(105/*null.INT_TOKEN*/, this.asciiString(start));
      return next;
    }
  }
}
AbstractScanner_SourceString.prototype.tokenizeHexOrNumber = function(next) {
  var x = this.peek();
  if (x === 120/*null.$x*/ || x === 88/*null.$X*/) {
    this.advance();
    return this.tokenizeHex(x);
  }
  return this.tokenizeNumber(next);
}
AbstractScanner_SourceString.prototype.tokenizeHex = function(next) {
  var start = this.get$byteOffset();
  var hasDigits = false;
  while (true) {
    next = this.advance();
    if ((48/*null.$0*/ <= next && next <= 57/*null.$9*/) || (65/*null.$A*/ <= next && next <= 70/*null.$F*/) || (97/*null.$a*/ <= next && next <= 102/*null.$f*/)) {
      hasDigits = true;
    }
    else {
      if (!$notnull_bool(hasDigits)) {
        $throw(new MalformedInputException(this.get$charOffset()));
      }
      this.appendByteStringToken(120/*null.HEXADECIMAL_TOKEN*/, this.asciiString(start));
      return next;
    }
  }
}
AbstractScanner_SourceString.prototype.tokenizeDotOrNumber = function(next) {
  var start = this.get$byteOffset();
  next = this.advance();
  if ((48/*null.$0*/ <= next && next <= 57/*null.$9*/)) {
    return this.tokenizeFractionPart(next, start);
  }
  else if (46/*null.$PERIOD*/ === next) {
    return this.select(46/*null.$PERIOD*/, "...", "..");
  }
  else {
    this.appendStringToken(46/*null.PERIOD_TOKEN*/, ".");
    return next;
  }
}
AbstractScanner_SourceString.prototype.tokenizeFractionPart = function(next, start) {
  var done = false;
  LOOP:
  while (!$notnull_bool(done)) {
    if (48/*null.$0*/ <= next && next <= 57/*null.$9*/) {
    }
    else if (101/*null.$e*/ === next || 69/*null.$E*/ === next) {
      next = this.tokenizeExponent(this.advance());
      done = true;
      continue LOOP;
    }
    else {
      done = true;
      continue LOOP;
    }
    next = this.advance();
  }
  if (next === 100/*null.$d*/ || next === 68/*null.$D*/) {
    next = this.advance();
  }
  this.appendByteStringToken(100/*null.DOUBLE_TOKEN*/, this.asciiString(start));
  return next;
}
AbstractScanner_SourceString.prototype.tokenizeExponent = function(next) {
  if (next === 43/*null.$PLUS*/ || next === 45/*null.$MINUS*/) {
    next = this.advance();
  }
  var hasDigits = false;
  while (true) {
    if (48/*null.$0*/ <= next && next <= 57/*null.$9*/) {
      hasDigits = true;
    }
    else {
      if (!$notnull_bool(hasDigits)) {
        $throw(new MalformedInputException(this.get$charOffset()));
      }
      return next;
    }
    next = this.advance();
  }
}
AbstractScanner_SourceString.prototype.tokenizeSlashOrComment = function(next) {
  next = this.advance();
  if (42/*null.$STAR*/ === next) {
    return this.tokenizeMultiLineComment(next);
  }
  else if (47/*null.$SLASH*/ === next) {
    return this.tokenizeSingleLineComment(next);
  }
  else if (61/*null.$EQ*/ === next) {
    this.appendStringToken(47/*null.SLASH_TOKEN*/, "/=");
    return this.advance();
  }
  else {
    this.appendStringToken(47/*null.SLASH_TOKEN*/, "/");
    return next;
  }
}
AbstractScanner_SourceString.prototype.tokenizeSingleLineComment = function(next) {
  while (true) {
    next = this.advance();
    if (10/*null.$LF*/ === next || 13/*null.$CR*/ === next || 0/*null.$EOF*/ === next) {
      return next;
    }
  }
}
AbstractScanner_SourceString.prototype.tokenizeMultiLineComment = function(next) {
  next = this.advance();
  while (true) {
    if (0/*null.$EOF*/ === next) {
      return next;
    }
    else if (42/*null.$STAR*/ === next) {
      next = this.advance();
      if (next === 47/*null.$SLASH*/) {
        return this.advance();
      }
      else if (next === 0/*null.$EOF*/) {
        return next;
      }
    }
    else {
      next = this.advance();
    }
  }
}
AbstractScanner_SourceString.prototype.tokenizeKeywordOrIdentifier = function(next) {
  var state = KeywordState.get$KEYWORD_STATE();
  var start = this.get$byteOffset();
  while (state != null && 97/*null.$a*/ <= next && next <= 122/*null.$z*/) {
    state = state.next(next);
    next = this.advance();
  }
  if (state == null || !$notnull_bool(state.isLeaf())) {
    return this.tokenizeIdentifier(next, start);
  }
  if ((65/*null.$A*/ <= next && next <= 90/*null.$Z*/) || (48/*null.$0*/ <= next && next <= 57/*null.$9*/) || next === 95/*null.$_*/ || next === 36/*null.$$*/) {
    return this.tokenizeIdentifier(next, start);
  }
  else if (next < 128) {
    this.appendKeywordToken(state.get$keyword());
    return next;
  }
  else {
    return this.tokenizeIdentifier(next, start);
  }
}
AbstractScanner_SourceString.prototype.tokenizeIdentifier = function(next, start) {
  var isAscii = true;
  while (true) {
    if ((97/*null.$a*/ <= next && next <= 122/*null.$z*/) || (65/*null.$A*/ <= next && next <= 90/*null.$Z*/) || (48/*null.$0*/ <= next && next <= 57/*null.$9*/) || next === 95/*null.$_*/ || next === 36/*null.$$*/) {
      next = this.advance();
    }
    else if (next < 128) {
      if ($notnull_bool(isAscii)) {
        this.appendByteStringToken(97/*null.IDENTIFIER_TOKEN*/, this.asciiString(start));
      }
      else {
        this.appendByteStringToken(97/*null.IDENTIFIER_TOKEN*/, this.utf8String(start, -1));
      }
      return next;
    }
    else {
      var nonAsciiStart = this.get$byteOffset();
      do {
        next = this.nextByte();
      }
      while (next > 127)
      var string = this.utf8String(nonAsciiStart, -1).toString();
      isAscii = false;
      var byteLength = nonAsciiStart - this.get$byteOffset();
      this.addToCharOffset(string.length - byteLength);
    }
  }
}
AbstractScanner_SourceString.prototype.tokenizeRawString = function(next) {
  var start = this.get$byteOffset();
  next = this.advance();
  if (next === 34/*null.$DQ*/ || next === 39/*null.$SQ*/) {
    return this.tokenizeString(next, start, true);
  }
  else {
    $throw(new MalformedInputException(this.get$charOffset()));
  }
}
AbstractScanner_SourceString.prototype.tokenizeString = function(next, start, raw) {
  var q = next;
  next = this.advance();
  if (q === next) {
    next = this.advance();
    if (q === next) {
      return this.tokenizeMultiLineString(q, start, raw);
    }
    else {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, -1));
      return next;
    }
  }
  if ($notnull_bool(raw)) {
    return this.tokenizeSingleLineRawString(next, q, start);
  }
  else {
    return this.tokenizeSingleLineString(next, q, start);
  }
}
AbstractScanner_SourceString.prototype.tokenizeSingleLineString = function(next, q1, start) {
  while (next != 0/*null.$EOF*/) {
    if (next === q1) {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
      return this.advance();
    }
    else if (next === 92/*null.$BACKSLASH*/) {
      next = this.advance();
      if (next === 0/*null.$EOF*/) {
        $throw(new MalformedInputException(this.get$charOffset()));
      }
    }
    else if (next === 10/*null.$LF*/ || next === 13/*null.$CR*/) {
      $throw(new MalformedInputException(this.get$charOffset()));
    }
    next = this.advance();
  }
  $throw(new MalformedInputException(this.get$charOffset()));
}
AbstractScanner_SourceString.prototype.tokenizeSingleLineRawString = function(next, q1, start) {
  next = this.advance();
  while (next != 0/*null.$EOF*/) {
    if (next === q1) {
      this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
      return this.advance();
    }
    else if (next === 10/*null.$LF*/ || next === 13/*null.$CR*/) {
      $throw(new MalformedInputException(this.get$charOffset()));
    }
    next = this.advance();
  }
  $throw(new MalformedInputException(this.get$charOffset()));
}
AbstractScanner_SourceString.prototype.tokenizeMultiLineString = function(q, start, raw) {
  var next = this.advance();
  while (next != 0/*null.$EOF*/) {
    if (next === q) {
      next = this.advance();
      if (next === q) {
        next = this.advance();
        if (next === q) {
          this.appendByteStringToken(39/*null.STRING_TOKEN*/, this.utf8String(start, 0));
          return this.advance();
        }
      }
    }
    next = this.advance();
  }
  return next;
}
// ********** Code for MalformedInputException **************
function MalformedInputException(message) {
  this.message = message;
  // Initializers done
}
MalformedInputException.prototype.toString = function() {
  return this.message.toString$0();
}
MalformedInputException.prototype.toString$0 = MalformedInputException.prototype.toString;
// ********** Code for ScannerTask **************
function ScannerTask(compiler) {
  // Initializers done
  CompilerTask.call(this, compiler);
}
$inherits(ScannerTask, CompilerTask);
ScannerTask.prototype.get$name = function() {
  return 'Scanner';
}
ScannerTask.prototype.scan = function(script) {
  var $this = this; // closure support
  this.measure((function () {
    var $0;
    var elements = $this.scanElements(script.get$text());
    for (var link = elements;
     !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Element())) {
      $this.compiler.universe.define((($0 = link.get$head()) == null ? null : $0.assert$Element()));
    }
  })
  );
}
ScannerTask.prototype.scanElements = function(text) {
  var tokens = new StringScanner(text).tokenize();
  var listener = new ElementListener(this.compiler);
  var parser = new PartialParser(listener);
  parser.parseUnit(tokens);
  return listener.topLevelElements;
}
// ********** Code for StringScanner **************
function StringScanner(string) {
  this.string = string;
  // Initializers done
  ArrayBasedScanner_SourceString.call(this);
}
$inherits(StringScanner, ArrayBasedScanner_SourceString);
StringScanner.prototype.nextByte = function() {
  return this.charAt(++this.byteOffset);
}
StringScanner.prototype.peek = function() {
  return this.charAt(this.byteOffset + 1);
}
StringScanner.prototype.charAt = function(index) {
  return (this.string.length > $assert_num(index)) ? this.string.charCodeAt($assert_num(index)) : 0/*null.$EOF*/;
}
StringScanner.prototype.asciiString = function(start) {
  return new SubstringWrapper(this.string, start, this.byteOffset);
}
StringScanner.prototype.utf8String = function(start, offset) {
  return new SubstringWrapper(this.string, start, this.byteOffset + offset + 1);
}
StringScanner.prototype.appendByteStringToken = function(kind, value) {
  this.tail.next = new StringToken.fromSource$ctor(kind, value, this.tokenStart);
  this.tail = this.tail.next;
}
StringScanner.prototype.appendByteStringToken$2 = function($0, $1) {
  return this.appendByteStringToken($assert_num($0), ($1 == null ? null : $1.assert$SourceString()));
};
// ********** Code for SubstringWrapper **************
function SubstringWrapper(internalString, begin, end) {
  this.internalString = internalString;
  this.begin = begin;
  this.end = end;
  // Initializers done
}
SubstringWrapper.prototype.is$SourceString = function(){return true};
SubstringWrapper.prototype.assert$SourceString = function(){return this};
SubstringWrapper.prototype.get$end = function() { return this.end; };
SubstringWrapper.prototype.hashCode = function() {
  return this.toString().hashCode();
}
SubstringWrapper.prototype.$eq = function(other) {
  return !!(other && other.is$SourceString()) && this.toString() == other.toString$0();
}
SubstringWrapper.prototype.printOn = function(sb) {
  sb.add(this);
}
SubstringWrapper.prototype.toString = function() {
  return this.internalString.substring(this.begin, this.end);
}
SubstringWrapper.prototype.get$stringValue = function() {
  return this.toString();
}
SubstringWrapper.prototype.hashCode$0 = SubstringWrapper.prototype.hashCode;
SubstringWrapper.prototype.printOn$1 = function($0) {
  return this.printOn(($0 == null ? null : $0.assert$StringBuffer()));
};
SubstringWrapper.prototype.toString$0 = SubstringWrapper.prototype.toString;
// ********** Code for Token **************
function Token(kind, charOffset) {
  this.kind = kind;
  this.charOffset = charOffset;
  // Initializers done
}
Token.prototype.assert$Token = function(){return this};
Token.prototype.get$kind = function() { return this.kind; };
Token.prototype.get$charOffset = function() { return this.charOffset; };
Token.prototype.get$value = function() {
  return const$121/*const SourceString('EOF')*/;
}
Token.prototype.get$stringValue = function() {
  return 'EOF';
}
Token.prototype.toString = function() {
  return Strings.String$fromCharCodes$factory([this.kind]);
}
Token.prototype.next$0 = function() {
  return this.next();
};
Token.prototype.toString$0 = Token.prototype.toString;
// ********** Code for KeywordToken **************
function KeywordToken(value, charOffset) {
  this.value = value;
  // Initializers done
  Token.call(this, 107/*null.KEYWORD_TOKEN*/, charOffset);
}
$inherits(KeywordToken, Token);
KeywordToken.prototype.get$value = function() { return this.value; };
KeywordToken.prototype.get$stringValue = function() {
  return this.value.syntax;
}
KeywordToken.prototype.toString = function() {
  return this.value.syntax;
}
KeywordToken.prototype.toString$0 = KeywordToken.prototype.toString;
// ********** Code for StringToken **************
function StringToken(kind, value, charOffset) {
  // Initializers done
  StringToken.fromSource$ctor.call(this, kind, new StringWrapper(value), charOffset);
}
StringToken.fromSource$ctor = function(kind, value, charOffset) {
  this.value = value;
  // Initializers done
  Token.call(this, kind, charOffset);
}
StringToken.fromSource$ctor.prototype = StringToken.prototype;
$inherits(StringToken, Token);
StringToken.prototype.get$value = function() { return this.value; };
StringToken.prototype.get$stringValue = function() {
  return this.value.get$stringValue();
}
StringToken.prototype.toString = function() {
  return this.value.toString();
}
StringToken.prototype.toString$0 = StringToken.prototype.toString;
// ********** Code for StringWrapper **************
function StringWrapper(stringValue) {
  this.stringValue = stringValue;
  // Initializers done
}
StringWrapper.prototype.is$SourceString = function(){return true};
StringWrapper.prototype.assert$SourceString = function(){return this};
StringWrapper.prototype.get$stringValue = function() { return this.stringValue; };
StringWrapper.prototype.hashCode = function() {
  return this.stringValue.hashCode();
}
StringWrapper.prototype.$eq = function(other) {
  return !!(other && other.is$SourceString()) && this.toString() == other.toString$0();
}
StringWrapper.prototype.printOn = function(sb) {
  sb.add(this.stringValue);
}
StringWrapper.prototype.toString = function() {
  return this.stringValue;
}
StringWrapper.prototype.hashCode$0 = StringWrapper.prototype.hashCode;
StringWrapper.prototype.printOn$1 = function($0) {
  return this.printOn(($0 == null ? null : $0.assert$StringBuffer()));
};
StringWrapper.prototype.toString$0 = StringWrapper.prototype.toString;
// ********** Code for BeginGroupToken **************
function BeginGroupToken(kind, value, charOffset) {
  // Initializers done
  StringToken.call(this, kind, value, charOffset);
}
$inherits(BeginGroupToken, StringToken);
BeginGroupToken.prototype.assert$BeginGroupToken = function(){return this};
BeginGroupToken.prototype.get$endGroup = function() { return this.endGroup; };
BeginGroupToken.prototype.set$endGroup = function(value) { return this.endGroup = value; };
// ********** Code for top level **************
function parse(canceler, logger, doParse) {
  var listener = new NodeListener(canceler, logger);
  doParse(new Parser(listener));
  var node = listener.popNode();
  $assert(listener.nodes.isEmpty(), "listener.nodes.isEmpty()", "listener.dart", 744, 10);
  return node;
}
//  ********** Library tree **************
// ********** Code for Node **************
function Node() {
  this._hashCode = ++$globals.Node__HASH_COUNTER;
  // Initializers done
}
Node.prototype.assert$Node = function(){return this};
Node.prototype.hashCode = function() {
  return this._hashCode;
}
Node.prototype.toString = function() {
  return this.unparse();
}
Node.prototype.getObjectDescription = function() {
  return Object.prototype.toString.call(this);
}
Node.prototype.unparse = function() {
  var unparser = new Unparser(false);
  try {
    return unparser.unparse(this);
  } catch (e) {
    e = _toDartException(e);
    return ('<<unparse error: ' + this.getObjectDescription() + ': ' + unparser.sb + '>>');
  }
}
Node.prototype.asOperator = function() {
  return null;
}
Node.prototype.asSend = function() {
  return null;
}
Node.prototype.asSendSet = function() {
  return null;
}
Node.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
Node.prototype.getBeginToken$0 = Node.prototype.getBeginToken;
Node.prototype.getEndToken$0 = Node.prototype.getEndToken;
Node.prototype.hashCode$0 = Node.prototype.hashCode;
Node.prototype.toString$0 = Node.prototype.toString;
// ********** Code for ClassNode **************
function ClassNode(name, superclass, interfaces, beginToken, extendsKeyword, endToken) {
  this.name = name;
  this.superclass = superclass;
  this.interfaces = interfaces;
  this.beginToken = beginToken;
  this.extendsKeyword = extendsKeyword;
  this.endToken = endToken;
  // Initializers done
  Node.call(this);
}
$inherits(ClassNode, Node);
ClassNode.prototype.assert$ClassNode = function(){return this};
ClassNode.prototype.get$name = function() { return this.name; };
ClassNode.prototype.get$interfaces = function() { return this.interfaces; };
ClassNode.prototype.accept = function(visitor) {
  return visitor.visitClassNode(this);
}
ClassNode.prototype.get$isInterface = function() {
  return this.beginToken.get$stringValue() === 'interface';
}
ClassNode.prototype.get$isClass = function() {
  return !$notnull_bool(this.get$isInterface());
}
ClassNode.prototype.getBeginToken = function() {
  return this.beginToken;
}
ClassNode.prototype.getEndToken = function() {
  return this.endToken;
}
ClassNode.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
ClassNode.prototype.getBeginToken$0 = ClassNode.prototype.getBeginToken;
ClassNode.prototype.getEndToken$0 = ClassNode.prototype.getEndToken;
// ********** Code for Expression **************
function Expression() {
  // Initializers done
  Node.call(this);
}
$inherits(Expression, Node);
Expression.prototype.assert$Expression = function(){return this};
// ********** Code for Statement **************
function Statement() {
  // Initializers done
  Node.call(this);
}
$inherits(Statement, Node);
Statement.prototype.assert$Statement = function(){return this};
// ********** Code for Send **************
function Send(receiver, selector, argumentsNode) {
  this.receiver = receiver;
  this.selector = selector;
  this.argumentsNode = argumentsNode;
  // Initializers done
  Expression.call(this);
}
Send.postfix$ctor = function(receiver, selector) {
  this.receiver = receiver;
  this.selector = selector;
  this.argumentsNode = new Postfix();
  // Initializers done
  Expression.call(this);
}
Send.postfix$ctor.prototype = Send.prototype;
Send.prefix$ctor = function(receiver, selector) {
  this.receiver = receiver;
  this.selector = selector;
  this.argumentsNode = new Prefix();
  // Initializers done
  Expression.call(this);
}
Send.prefix$ctor.prototype = Send.prototype;
$inherits(Send, Expression);
Send.prototype.get$arguments = function() {
  return this.argumentsNode.get$nodes();
}
Send.prototype.asSend = function() {
  return this;
}
Send.prototype.accept = function(visitor) {
  return visitor.visitSend(this);
}
Send.prototype.get$isOperator = function() {
  return (this.selector instanceof Operator);
}
Send.prototype.get$isPropertyAccess = function() {
  return this.argumentsNode == null;
}
Send.prototype.get$isFunctionObjectInvocation = function() {
  return this.selector == null;
}
Send.prototype.get$isPrefix = function() {
  return (this.argumentsNode instanceof Prefix);
}
Send.prototype.get$isPostfix = function() {
  return (this.argumentsNode instanceof Postfix);
}
Send.prototype.getBeginToken = function() {
  return firstBeginToken(this.receiver, this.selector);
}
Send.prototype.getEndToken = function() {
  var $0;
  var token;
  if (this.argumentsNode != null) token = this.argumentsNode.getEndToken();
  if (token != null) return token;
  if (this.selector != null) {
    return (($0 = this.selector.getEndToken()) == null ? null : $0.assert$Token());
  }
  return (($0 = this.receiver.getBeginToken()) == null ? null : $0.assert$Token());
}
Send.prototype.copyWithReceiver = function(receiver) {
  return new Send(receiver, this.selector, this.argumentsNode);
}
Send.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
Send.prototype.getBeginToken$0 = Send.prototype.getBeginToken;
Send.prototype.getEndToken$0 = Send.prototype.getEndToken;
// ********** Code for Postfix **************
function Postfix() {
  // Initializers done
  NodeList.call(this);
}
$inherits(Postfix, NodeList);
// ********** Code for Prefix **************
function Prefix() {
  // Initializers done
  NodeList.call(this);
}
$inherits(Prefix, NodeList);
// ********** Code for SendSet **************
function SendSet(receiver, selector, assignmentOperator, argumentsNode) {
  this.assignmentOperator = assignmentOperator;
  // Initializers done
  Send.call(this, receiver, selector, argumentsNode);
}
SendSet.postfix$ctor = function(receiver, selector, assignmentOperator) {
  this.assignmentOperator = assignmentOperator;
  // Initializers done
  Send.postfix$ctor.call(this, receiver, selector);
}
SendSet.postfix$ctor.prototype = SendSet.prototype;
SendSet.prefix$ctor = function(receiver, selector, assignmentOperator) {
  this.assignmentOperator = assignmentOperator;
  // Initializers done
  Send.prefix$ctor.call(this, receiver, selector);
}
SendSet.prefix$ctor.prototype = SendSet.prototype;
$inherits(SendSet, Send);
SendSet.prototype.assert$SendSet = function(){return this};
SendSet.prototype.asSendSet = function() {
  return this;
}
SendSet.prototype.accept = function(visitor) {
  return visitor.visitSendSet(this);
}
SendSet.prototype.copyWithReceiver = function(receiver) {
  $throw('not implemented');
}
SendSet.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
// ********** Code for NodeList **************
function NodeList(beginToken, nodes, endToken, delimiter) {
  this.beginToken = beginToken;
  this.endToken = endToken;
  this.delimiter = delimiter;
  this._nodes = nodes;
  // Initializers done
  Node.call(this);
}
NodeList.singleton$ctor = function(node) {
  // Initializers done
  NodeList.call(this, null, LinkFactory.Link$factory(node));
}
NodeList.singleton$ctor.prototype = NodeList.prototype;
$inherits(NodeList, Node);
NodeList.prototype.assert$NodeList = function(){return this};
NodeList.prototype.get$nodes = function() {
  var $0;
  return (($0 = this._nodes != null ? this._nodes : const$209/*const EmptyLink<Node>()*/) == null ? null : $0.assert$Link_Node());
}
NodeList.prototype.accept = function(visitor) {
  return visitor.visitNodeList(this);
}
NodeList.prototype.getBeginToken = function() {
  var $0;
  if (this.beginToken != null) return this.beginToken;
  if (this.get$nodes() != null) {
    for (var link = this.get$nodes();
     !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
      if (link.get$head().getBeginToken$0() != null) {
        return (($0 = link.get$head().getBeginToken$0()) == null ? null : $0.assert$Token());
      }
      if (link.get$head().getEndToken$0() != null) {
        return (($0 = link.get$head().getEndToken$0()) == null ? null : $0.assert$Token());
      }
    }
  }
  return this.endToken;
}
NodeList.prototype.getEndToken = function() {
  var $0;
  if (this.endToken != null) return this.endToken;
  if (this.get$nodes() != null) {
    var link = this.get$nodes();
    if ($notnull_bool(link.isEmpty())) return this.beginToken;
    while (!$notnull_bool(link.get$tail().isEmpty$0())) link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node());
    if (link.get$head().getEndToken$0() != null) return (($0 = link.get$head().getEndToken$0()) == null ? null : $0.assert$Token());
    if (link.get$head().getBeginToken$0() != null) return (($0 = link.get$head().getBeginToken$0()) == null ? null : $0.assert$Token());
  }
  return this.beginToken;
}
NodeList.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
NodeList.prototype.getBeginToken$0 = NodeList.prototype.getBeginToken;
NodeList.prototype.getEndToken$0 = NodeList.prototype.getEndToken;
// ********** Code for Block **************
function Block(statements) {
  this.statements = statements;
  // Initializers done
  Statement.call(this);
}
$inherits(Block, Statement);
Block.prototype.get$statements = function() { return this.statements; };
Block.prototype.accept = function(visitor) {
  return visitor.visitBlock(this);
}
Block.prototype.getBeginToken = function() {
  return this.statements.getBeginToken();
}
Block.prototype.getEndToken = function() {
  return this.statements.getEndToken();
}
Block.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
Block.prototype.getBeginToken$0 = Block.prototype.getBeginToken;
Block.prototype.getEndToken$0 = Block.prototype.getEndToken;
// ********** Code for If **************
function If(condition, thenPart, elsePart, ifToken, elseToken) {
  this.condition = condition;
  this.thenPart = thenPart;
  this.elsePart = elsePart;
  this.ifToken = ifToken;
  this.elseToken = elseToken;
  // Initializers done
  Statement.call(this);
}
$inherits(If, Statement);
If.prototype.get$hasElsePart = function() {
  return this.elsePart != null;
}
If.prototype.accept = function(visitor) {
  return visitor.visitIf(this);
}
If.prototype.getBeginToken = function() {
  return this.ifToken;
}
If.prototype.getEndToken = function() {
  if (this.elsePart == null) return this.thenPart.getEndToken();
  return this.elsePart.getEndToken();
}
If.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
If.prototype.getBeginToken$0 = If.prototype.getBeginToken;
If.prototype.getEndToken$0 = If.prototype.getEndToken;
// ********** Code for For **************
function For(initializer, conditionStatement, update, body, forToken) {
  this.initializer = initializer;
  this.conditionStatement = conditionStatement;
  this.update = update;
  this.forToken = forToken;
  // Initializers done
  Loop.call(this, body);
}
$inherits(For, Loop);
For.prototype.get$condition = function() {
  return this.conditionStatement.expression;
}
For.prototype.accept = function(visitor) {
  return visitor.visitFor(this);
}
For.prototype.getBeginToken = function() {
  return this.forToken;
}
For.prototype.getEndToken = function() {
  return this.body.getEndToken();
}
For.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
For.prototype.getBeginToken$0 = For.prototype.getBeginToken;
For.prototype.getEndToken$0 = For.prototype.getEndToken;
// ********** Code for FunctionExpression **************
function FunctionExpression(name, parameters, body, returnType) {
  this.name = name;
  this.parameters = parameters;
  this.body = body;
  this.returnType = returnType;
  // Initializers done
  Expression.call(this);
}
$inherits(FunctionExpression, Expression);
FunctionExpression.prototype.assert$FunctionExpression = function(){return this};
FunctionExpression.prototype.get$name = function() { return this.name; };
FunctionExpression.prototype.get$parameters = function() { return this.parameters; };
FunctionExpression.prototype.get$body = function() { return this.body; };
FunctionExpression.prototype.get$returnType = function() { return this.returnType; };
FunctionExpression.prototype.accept = function(visitor) {
  return visitor.visitFunctionExpression(this);
}
FunctionExpression.prototype.getBeginToken = function() {
  return firstBeginToken(this.returnType, this.name);
}
FunctionExpression.prototype.getEndToken = function() {
  return this.body.getEndToken();
}
FunctionExpression.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
FunctionExpression.prototype.getBeginToken$0 = FunctionExpression.prototype.getBeginToken;
FunctionExpression.prototype.getEndToken$0 = FunctionExpression.prototype.getEndToken;
// ********** Code for Literal **************
function Literal(token, handler) {
  this.token = token;
  this.handler = handler;
  // Initializers done
  Expression.call(this);
}
$inherits(Literal, Expression);
Literal.prototype.getBeginToken = function() {
  return this.token;
}
Literal.prototype.getEndToken = function() {
  return this.token;
}
Literal.prototype.getBeginToken$0 = Literal.prototype.getBeginToken;
Literal.prototype.getEndToken$0 = Literal.prototype.getEndToken;
// ********** Code for Literal_SourceString **************
function Literal_SourceString(token, handler) {
  this.token = token;
  this.handler = handler;
  // Initializers done
  Expression.call(this);
}
$inherits(Literal_SourceString, Literal);
// ********** Code for Literal_bool **************
function Literal_bool(token, handler) {
  this.token = token;
  this.handler = handler;
  // Initializers done
  Expression.call(this);
}
$inherits(Literal_bool, Literal);
// ********** Code for Literal_double **************
function Literal_double(token, handler) {
  this.token = token;
  this.handler = handler;
  // Initializers done
  Expression.call(this);
}
$inherits(Literal_double, Literal);
// ********** Code for Literal_int **************
function Literal_int(token, handler) {
  this.token = token;
  this.handler = handler;
  // Initializers done
  Expression.call(this);
}
$inherits(Literal_int, Literal);
// ********** Code for LiteralInt **************
function LiteralInt(token, handler) {
  // Initializers done
  Literal_int.call(this, token, handler);
}
$inherits(LiteralInt, Literal_int);
LiteralInt.prototype.get$value = function() {
  try {
    return Math.parseInt(this.token.get$value().toString$0());
  } catch (ex) {
    ex = _toDartException(ex);
    if (!(ex instanceof BadNumberFormatException)) throw ex;
    (this.handler)(this.token, ex);
  }
}
LiteralInt.prototype.accept = function(visitor) {
  return visitor.visitLiteralInt(this);
}
LiteralInt.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
// ********** Code for LiteralDouble **************
function LiteralDouble(token, handler) {
  // Initializers done
  Literal_double.call(this, token, handler);
}
$inherits(LiteralDouble, Literal_double);
LiteralDouble.prototype.get$value = function() {
  try {
    return Math.parseDouble(this.token.get$value().toString$0());
  } catch (ex) {
    ex = _toDartException(ex);
    if (!(ex instanceof BadNumberFormatException)) throw ex;
    (this.handler)(this.token, ex);
  }
}
LiteralDouble.prototype.accept = function(visitor) {
  return visitor.visitLiteralDouble(this);
}
LiteralDouble.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
// ********** Code for LiteralBool **************
function LiteralBool(token, handler) {
  // Initializers done
  Literal_bool.call(this, token, handler);
}
$inherits(LiteralBool, Literal_bool);
LiteralBool.prototype.get$value = function() {
  switch (this.token.get$value()) {
    case const$75/*Keyword.TRUE*/:

      return true;

    case const$47/*Keyword.FALSE*/:

      return false;

    default:

      (this.handler)(this.token, ("not a bool " + this.token.get$value()));

  }
}
LiteralBool.prototype.accept = function(visitor) {
  return visitor.visitLiteralBool(this);
}
LiteralBool.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
// ********** Code for LiteralString **************
function LiteralString(token) {
  // Initializers done
  Literal_SourceString.call(this, token, to$call$2(null));
}
$inherits(LiteralString, Literal_SourceString);
LiteralString.prototype.assert$LiteralString = function(){return this};
LiteralString.prototype.get$value = function() {
  var $0;
  return (($0 = this.token.get$value()) == null ? null : $0.assert$SourceString());
}
LiteralString.prototype.accept = function(visitor) {
  return visitor.visitLiteralString(this);
}
LiteralString.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
// ********** Code for LiteralNull **************
function LiteralNull(token) {
  // Initializers done
  Literal_SourceString.call(this, token, to$call$2(null));
}
$inherits(LiteralNull, Literal_SourceString);
LiteralNull.prototype.get$value = function() {
  return null;
}
LiteralNull.prototype.accept = function(visitor) {
  return visitor.visitLiteralNull(this);
}
LiteralNull.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
// ********** Code for Identifier **************
function Identifier(token) {
  this.token = token;
  // Initializers done
  Expression.call(this);
}
$inherits(Identifier, Expression);
Identifier.prototype.assert$Identifier = function(){return this};
Identifier.prototype.get$source = function() {
  var $0;
  return (($0 = this.token.get$value()) == null ? null : $0.assert$SourceString());
}
Identifier.prototype.accept = function(visitor) {
  return visitor.visitIdentifier(this);
}
Identifier.prototype.getBeginToken = function() {
  return this.token;
}
Identifier.prototype.getEndToken = function() {
  return this.token;
}
Identifier.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
Identifier.prototype.getBeginToken$0 = Identifier.prototype.getBeginToken;
Identifier.prototype.getEndToken$0 = Identifier.prototype.getEndToken;
// ********** Code for Operator **************
function Operator(token) {
  // Initializers done
  Identifier.call(this, token);
}
$inherits(Operator, Identifier);
Operator.prototype.assert$Operator = function(){return this};
Operator.prototype.asOperator = function() {
  return this;
}
Operator.prototype.accept = function(visitor) {
  return visitor.visitOperator(this);
}
Operator.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
// ********** Code for Return **************
function Return(beginToken, endToken, expression) {
  this.beginToken = beginToken;
  this.endToken = endToken;
  this.expression = expression;
  // Initializers done
  Statement.call(this);
}
$inherits(Return, Statement);
Return.prototype.get$hasExpression = function() {
  return this.expression != null;
}
Return.prototype.accept = function(visitor) {
  return visitor.visitReturn(this);
}
Return.prototype.getBeginToken = function() {
  return this.beginToken;
}
Return.prototype.getEndToken = function() {
  return this.endToken;
}
Return.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
Return.prototype.getBeginToken$0 = Return.prototype.getBeginToken;
Return.prototype.getEndToken$0 = Return.prototype.getEndToken;
// ********** Code for ExpressionStatement **************
function ExpressionStatement(expression, endToken) {
  this.expression = expression;
  this.endToken = endToken;
  // Initializers done
  Statement.call(this);
}
$inherits(ExpressionStatement, Statement);
ExpressionStatement.prototype.assert$ExpressionStatement = function(){return this};
ExpressionStatement.prototype.accept = function(visitor) {
  return visitor.visitExpressionStatement(this);
}
ExpressionStatement.prototype.getBeginToken = function() {
  var $0;
  return (($0 = this.expression.getBeginToken()) == null ? null : $0.assert$Token());
}
ExpressionStatement.prototype.getEndToken = function() {
  return this.endToken;
}
ExpressionStatement.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
ExpressionStatement.prototype.getBeginToken$0 = ExpressionStatement.prototype.getBeginToken;
ExpressionStatement.prototype.getEndToken$0 = ExpressionStatement.prototype.getEndToken;
// ********** Code for Throw **************
function Throw(expression, throwToken, endToken) {
  this.expression = expression;
  this.throwToken = throwToken;
  this.endToken = endToken;
  // Initializers done
  Statement.call(this);
}
$inherits(Throw, Statement);
Throw.prototype.accept = function(visitor) {
  return visitor.visitThrow(this);
}
Throw.prototype.getBeginToken = function() {
  return this.throwToken;
}
Throw.prototype.getEndToken = function() {
  return this.endToken;
}
Throw.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
Throw.prototype.getBeginToken$0 = Throw.prototype.getBeginToken;
Throw.prototype.getEndToken$0 = Throw.prototype.getEndToken;
// ********** Code for TypeAnnotation **************
function TypeAnnotation(typeName) {
  this.typeName = typeName;
  // Initializers done
  Node.call(this);
}
$inherits(TypeAnnotation, Node);
TypeAnnotation.prototype.assert$TypeAnnotation = function(){return this};
TypeAnnotation.prototype.accept = function(visitor) {
  return visitor.visitTypeAnnotation(this);
}
TypeAnnotation.prototype.getBeginToken = function() {
  var $0;
  return (($0 = this.typeName.getBeginToken()) == null ? null : $0.assert$Token());
}
TypeAnnotation.prototype.getEndToken = function() {
  var $0;
  return (($0 = this.typeName.getEndToken()) == null ? null : $0.assert$Token());
}
TypeAnnotation.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
TypeAnnotation.prototype.getBeginToken$0 = TypeAnnotation.prototype.getBeginToken;
TypeAnnotation.prototype.getEndToken$0 = TypeAnnotation.prototype.getEndToken;
// ********** Code for VariableDefinitions **************
function VariableDefinitions(type, modifiers, definitions, endToken) {
  this.type = type;
  this.modifiers = modifiers;
  this.definitions = definitions;
  this.endToken = endToken;
  // Initializers done
  Statement.call(this);
}
$inherits(VariableDefinitions, Statement);
VariableDefinitions.prototype.assert$VariableDefinitions = function(){return this};
VariableDefinitions.prototype.get$type = function() { return this.type; };
VariableDefinitions.prototype.get$definitions = function() { return this.definitions; };
VariableDefinitions.prototype.accept = function(visitor) {
  return visitor.visitVariableDefinitions(this);
}
VariableDefinitions.prototype.getBeginToken = function() {
  return firstBeginToken(this.type, this.definitions);
}
VariableDefinitions.prototype.getEndToken = function() {
  return this.endToken;
}
VariableDefinitions.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
VariableDefinitions.prototype.getBeginToken$0 = VariableDefinitions.prototype.getBeginToken;
VariableDefinitions.prototype.getEndToken$0 = VariableDefinitions.prototype.getEndToken;
// ********** Code for Loop **************
function Loop(body) {
  this.body = body;
  // Initializers done
  Statement.call(this);
}
$inherits(Loop, Statement);
Loop.prototype.get$body = function() { return this.body; };
// ********** Code for DoWhile **************
function DoWhile(body, condition, doKeyword, whileKeyword, endToken) {
  this.condition = condition;
  this.doKeyword = doKeyword;
  this.whileKeyword = whileKeyword;
  this.endToken = endToken;
  // Initializers done
  Loop.call(this, body);
}
$inherits(DoWhile, Loop);
DoWhile.prototype.accept = function(visitor) {
  return visitor.visitDoWhile(this);
}
DoWhile.prototype.getBeginToken = function() {
  return this.doKeyword;
}
DoWhile.prototype.getEndToken = function() {
  return this.endToken;
}
DoWhile.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
DoWhile.prototype.getBeginToken$0 = DoWhile.prototype.getBeginToken;
DoWhile.prototype.getEndToken$0 = DoWhile.prototype.getEndToken;
// ********** Code for While **************
function While(condition, body, whileKeyword) {
  this.condition = condition;
  this.whileKeyword = whileKeyword;
  // Initializers done
  Loop.call(this, body);
}
$inherits(While, Loop);
While.prototype.accept = function(visitor) {
  return visitor.visitWhile(this);
}
While.prototype.getBeginToken = function() {
  return this.whileKeyword;
}
While.prototype.getEndToken = function() {
  return this.body.getEndToken();
}
While.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
While.prototype.getBeginToken$0 = While.prototype.getBeginToken;
While.prototype.getEndToken$0 = While.prototype.getEndToken;
// ********** Code for ParenthesizedExpression **************
function ParenthesizedExpression(expression, beginToken) {
  this.expression = expression;
  this.beginToken = beginToken;
  // Initializers done
  Expression.call(this);
}
$inherits(ParenthesizedExpression, Expression);
ParenthesizedExpression.prototype.assert$ParenthesizedExpression = function(){return this};
ParenthesizedExpression.prototype.accept = function(visitor) {
  return visitor.visitParenthesizedExpression(this);
}
ParenthesizedExpression.prototype.getBeginToken = function() {
  return this.beginToken;
}
ParenthesizedExpression.prototype.getEndToken = function() {
  return this.beginToken.endGroup;
}
ParenthesizedExpression.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$Visitor()));
};
ParenthesizedExpression.prototype.getBeginToken$0 = ParenthesizedExpression.prototype.getBeginToken;
ParenthesizedExpression.prototype.getEndToken$0 = ParenthesizedExpression.prototype.getEndToken;
// ********** Code for Unparser **************
function Unparser(printDebugInfo) {
  this.printDebugInfo = printDebugInfo;
  // Initializers done
}
Unparser.prototype.assert$Visitor = function(){return this};
Unparser.prototype.unparse = function(node) {
  this.sb = new StringBufferImpl("");
  this.visit(node);
  return this.sb.toString();
}
Unparser.prototype.add = function(string) {
  string.printOn(this.sb);
}
Unparser.prototype.visit = function(node) {
  if (node != null) {
    if ($notnull_bool(this.printDebugInfo)) this.sb.add(('[' + node.getObjectDescription() + ': '));
    node.accept(this);
    if ($notnull_bool(this.printDebugInfo)) this.sb.add(']');
  }
  else if ($notnull_bool(this.printDebugInfo)) {
    this.sb.add('[null]');
  }
}
Unparser.prototype.visitBlock = function(node) {
  this.visit(node.statements);
}
Unparser.prototype.visitClassNode = function(node) {
  node.beginToken.get$value().printOn$1(this.sb);
  this.sb.add(' ');
  this.visit(node.name);
  this.sb.add(' ');
  if (node.extendsKeyword != null) {
    node.extendsKeyword.get$value().printOn$1(this.sb);
    this.sb.add(' ');
    this.visit(node.superclass);
    this.sb.add(' ');
  }
  this.visit(node.interfaces);
  this.sb.add('{\n');
  this.sb.add('}\n');
}
Unparser.prototype.visitExpressionStatement = function(node) {
  var $0;
  this.visit(node.expression);
  this.add((($0 = node.endToken.get$value()) == null ? null : $0.assert$SourceString()));
}
Unparser.prototype.visitFor = function(node) {
  node.forToken.get$value().printOn$1(this.sb);
  this.sb.add('(');
  this.visit(node.initializer);
  this.visit(node.conditionStatement);
  this.visit(node.update);
  this.sb.add(')');
  this.visit(node.body);
}
Unparser.prototype.visitFunctionExpression = function(node) {
  if (node.returnType != null) {
    this.visit(node.returnType);
    this.sb.add(' ');
  }
  this.visit(node.name);
  this.visit(node.parameters);
  this.visit(node.body);
}
Unparser.prototype.visitIdentifier = function(node) {
  var $0;
  this.add((($0 = node.token.get$value()) == null ? null : $0.assert$SourceString()));
}
Unparser.prototype.visitIf = function(node) {
  var $0;
  this.add((($0 = node.ifToken.get$value()) == null ? null : $0.assert$SourceString()));
  this.visit(node.condition);
  this.visit(node.thenPart);
  if ($notnull_bool(node.get$hasElsePart())) {
    this.add((($0 = node.elseToken.get$value()) == null ? null : $0.assert$SourceString()));
    this.visit(node.elsePart);
  }
}
Unparser.prototype.visitLiteralBool = function(node) {
  var $0;
  this.add((($0 = node.token.get$value()) == null ? null : $0.assert$SourceString()));
}
Unparser.prototype.visitLiteralDouble = function(node) {
  var $0;
  this.add((($0 = node.token.get$value()) == null ? null : $0.assert$SourceString()));
}
Unparser.prototype.visitLiteralInt = function(node) {
  var $0;
  this.add((($0 = node.token.get$value()) == null ? null : $0.assert$SourceString()));
}
Unparser.prototype.visitLiteralString = function(node) {
  var $0;
  this.add((($0 = node.token.get$value()) == null ? null : $0.assert$SourceString()));
}
Unparser.prototype.visitLiteralNull = function(node) {
  var $0;
  this.add((($0 = node.token.get$value()) == null ? null : $0.assert$SourceString()));
}
Unparser.prototype.visitNodeList = function(node) {
  var $0;
  if (node.beginToken != null) this.add((($0 = node.beginToken.get$value()) == null ? null : $0.assert$SourceString()));
  if (node.get$nodes() != null) {
    node.get$nodes().printOn(this.sb, node.delimiter);
  }
  if (node.endToken != null) this.add((($0 = node.endToken.get$value()) == null ? null : $0.assert$SourceString()));
}
Unparser.prototype.visitOperator = function(node) {
  this.visitIdentifier(node);
}
Unparser.prototype.visitReturn = function(node) {
  var $0;
  this.add((($0 = node.beginToken.get$value()) == null ? null : $0.assert$SourceString()));
  if ($notnull_bool(node.get$hasExpression())) {
    this.sb.add(' ');
    this.visit(node.expression);
  }
  this.add((($0 = node.endToken.get$value()) == null ? null : $0.assert$SourceString()));
}
Unparser.prototype.visitSend = function(node) {
  if ($notnull_bool(node.get$isPrefix())) {
    this.visit(node.selector);
  }
  if (node.receiver != null) {
    this.visit(node.receiver);
    if (!(node.selector instanceof Operator)) this.sb.add('.');
  }
  if (!$notnull_bool(node.get$isPrefix())) {
    this.visit(node.selector);
  }
  this.visit(node.argumentsNode);
}
Unparser.prototype.visitSendSet = function(node) {
  var $0;
  if (node.receiver != null) {
    this.visit(node.receiver);
    this.sb.add('.');
  }
  this.visit(node.selector);
  this.add((($0 = node.assignmentOperator.token.get$value()) == null ? null : $0.assert$SourceString()));
  this.visit(node.argumentsNode);
}
Unparser.prototype.visitThrow = function(node) {
  node.throwToken.get$value().printOn$1(this.sb);
  if (node.expression != null) {
    this.visit(node.expression);
  }
  node.endToken.get$value().printOn$1(this.sb);
}
Unparser.prototype.visitTypeAnnotation = function(node) {
  this.visit(node.typeName);
}
Unparser.prototype.visitVariableDefinitions = function(node) {
  var $0;
  if (node.type != null) {
    this.visit(node.type);
  }
  else {
    this.sb.add('var');
  }
  this.sb.add(' ');
  this.visit(node.definitions);
  if ($notnull_bool($eq(node.endToken.get$value(), const$223/*const SourceString(';')*/))) {
    this.add((($0 = node.endToken.get$value()) == null ? null : $0.assert$SourceString()));
  }
}
Unparser.prototype.visitDoWhile = function(node) {
  var $0;
  this.add((($0 = node.doKeyword.get$value()) == null ? null : $0.assert$SourceString()));
  this.sb.add(' ');
  this.visit(node.body);
  this.sb.add(' ');
  this.add((($0 = node.whileKeyword.get$value()) == null ? null : $0.assert$SourceString()));
  this.sb.add(' ');
  this.visit(node.condition);
  this.sb.add(node.endToken.get$value());
}
Unparser.prototype.visitWhile = function(node) {
  var $0;
  this.add((($0 = node.whileKeyword.get$value()) == null ? null : $0.assert$SourceString()));
  this.sb.add(' ');
  this.visit(node.condition);
  this.sb.add(' ');
  this.visit(node.body);
}
Unparser.prototype.visitParenthesizedExpression = function(node) {
  var $0;
  this.add((($0 = node.getBeginToken().get$value()) == null ? null : $0.assert$SourceString()));
  this.visit(node.expression);
  this.add((($0 = node.getEndToken().get$value()) == null ? null : $0.assert$SourceString()));
}
Unparser.prototype.add$1 = function($0) {
  return this.add(($0 == null ? null : $0.assert$SourceString()));
};
Unparser.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$Node()));
};
// ********** Code for AbstractVisitor **************
function AbstractVisitor() {
  // Initializers done
}
AbstractVisitor.prototype.assert$Visitor = function(){return this};
AbstractVisitor.prototype.visitExpression = function(node) {
  return this.visitNode(node);
}
AbstractVisitor.prototype.visitIdentifier = function(node) {
  return this.visitExpression(node);
}
AbstractVisitor.prototype.visitLiteral = function(node) {
  return this.visitExpression(node);
}
AbstractVisitor.prototype.visitLoop = function(node) {
  return this.visitStatement(node);
}
AbstractVisitor.prototype.visitSend = function(node) {
  return this.visitExpression(node);
}
AbstractVisitor.prototype.visitStatement = function(node) {
  return this.visitNode(node);
}
// ********** Code for AbstractVisitor_Element **************
function AbstractVisitor_Element() {
  // Initializers done
}
$inherits(AbstractVisitor_Element, AbstractVisitor);
AbstractVisitor_Element.prototype.assert$Visitor = function(){return this};
AbstractVisitor_Element.prototype.visitClassNode = function(node) {
  var $0;
  return (($0 = this.visitNode(node)) == null ? null : $0.assert$Element());
}
AbstractVisitor_Element.prototype.visitTypeAnnotation = function(node) {
  var $0;
  return (($0 = this.visitNode(node)) == null ? null : $0.assert$Element());
}
// ********** Code for AbstractVisitor_SourceString **************
function AbstractVisitor_SourceString() {
  // Initializers done
}
$inherits(AbstractVisitor_SourceString, AbstractVisitor);
AbstractVisitor_SourceString.prototype.assert$Visitor = function(){return this};
// ********** Code for AbstractVisitor_Type **************
function AbstractVisitor_Type() {
  // Initializers done
}
$inherits(AbstractVisitor_Type, AbstractVisitor);
AbstractVisitor_Type.prototype.assert$Visitor = function(){return this};
AbstractVisitor_Type.prototype.visitBlock = function(node) {
  return this.visitStatement(node);
}
AbstractVisitor_Type.prototype.visitDoWhile = function(node) {
  return this.visitLoop(node);
}
AbstractVisitor_Type.prototype.visitExpression = function(node) {
  var $0;
  return (($0 = this.visitNode(node)) == null ? null : $0.assert$Type());
}
AbstractVisitor_Type.prototype.visitExpressionStatement = function(node) {
  return this.visitStatement(node);
}
AbstractVisitor_Type.prototype.visitFor = function(node) {
  return this.visitStatement(node);
}
AbstractVisitor_Type.prototype.visitFunctionExpression = function(node) {
  return this.visitExpression(node);
}
AbstractVisitor_Type.prototype.visitIdentifier = function(node) {
  return this.visitExpression(node);
}
AbstractVisitor_Type.prototype.visitIf = function(node) {
  return this.visitStatement(node);
}
AbstractVisitor_Type.prototype.visitLiteral = function(node) {
  return this.visitExpression(node);
}
AbstractVisitor_Type.prototype.visitLiteralBool = function(node) {
  return this.visitLiteral(node);
}
AbstractVisitor_Type.prototype.visitLiteralDouble = function(node) {
  return this.visitLiteral(node);
}
AbstractVisitor_Type.prototype.visitLiteralInt = function(node) {
  return this.visitLiteral(node);
}
AbstractVisitor_Type.prototype.visitLiteralNull = function(node) {
  return this.visitLiteral(node);
}
AbstractVisitor_Type.prototype.visitLiteralString = function(node) {
  return this.visitLiteral(node);
}
AbstractVisitor_Type.prototype.visitLoop = function(node) {
  return this.visitStatement(node);
}
AbstractVisitor_Type.prototype.visitNodeList = function(node) {
  var $0;
  return (($0 = this.visitNode(node)) == null ? null : $0.assert$Type());
}
AbstractVisitor_Type.prototype.visitOperator = function(node) {
  var $0;
  return (($0 = this.visitIdentifier(node)) == null ? null : $0.assert$Type());
}
AbstractVisitor_Type.prototype.visitParenthesizedExpression = function(node) {
  return this.visitExpression(node);
}
AbstractVisitor_Type.prototype.visitReturn = function(node) {
  return this.visitStatement(node);
}
AbstractVisitor_Type.prototype.visitSend = function(node) {
  return this.visitExpression(node);
}
AbstractVisitor_Type.prototype.visitSendSet = function(node) {
  return this.visitSend(node);
}
AbstractVisitor_Type.prototype.visitStatement = function(node) {
  var $0;
  return (($0 = this.visitNode(node)) == null ? null : $0.assert$Type());
}
AbstractVisitor_Type.prototype.visitThrow = function(node) {
  return this.visitStatement(node);
}
AbstractVisitor_Type.prototype.visitVariableDefinitions = function(node) {
  return this.visitStatement(node);
}
AbstractVisitor_Type.prototype.visitWhile = function(node) {
  return this.visitLoop(node);
}
// ********** Code for top level **************
function firstBeginToken(first, second) {
  var $0;
  return (($0 = (first != null) ? first.getBeginToken() : second.getBeginToken()) == null ? null : $0.assert$Token());
}
//  ********** Library elements **************
// ********** Code for ElementKind **************
function ElementKind(id) {
  this.id = id;
  // Initializers done
}
ElementKind.prototype.get$id = function() { return this.id; };
ElementKind.prototype.toString = function() {
  return this.id;
}
ElementKind.prototype.toString$0 = ElementKind.prototype.toString;
// ********** Code for Element **************
function Element(name, kind, enclosingElement) {
  this.name = name;
  this.kind = kind;
  this.enclosingElement = enclosingElement;
  // Initializers done
}
Element.prototype.assert$Element = function(){return this};
Element.prototype.get$name = function() { return this.name; };
Element.prototype.get$kind = function() { return this.kind; };
Element.prototype.get$enclosingElement = function() { return this.enclosingElement; };
Element.prototype.hashCode = function() {
  return this.name.hashCode();
}
Element.prototype.computeType$2 = function($0, $1) {
  return this.computeType(($0 == null ? null : $0.assert$Compiler()), ($1 == null ? null : $1.assert$Types()));
};
Element.prototype.hashCode$0 = Element.prototype.hashCode;
// ********** Code for VariableElement **************
function VariableElement(node, typeAnnotation, kind, name, enclosingElement) {
  this.node = node;
  this.typeAnnotation = typeAnnotation;
  // Initializers done
  Element.call(this, name, kind, enclosingElement);
}
$inherits(VariableElement, Element);
VariableElement.prototype.assert$VariableElement = function(){return this};
VariableElement.prototype.get$type = function() { return this.type; };
VariableElement.prototype.set$type = function(value) { return this.type = value; };
VariableElement.prototype.parseNode = function(canceler, logger) {
  return this.node;
}
VariableElement.prototype.computeType = function(compiler, types) {
  if (this.type != null) return this.type;
  this.type = getType(this.typeAnnotation, types);
  return this.type;
}
VariableElement.prototype.computeType$2 = function($0, $1) {
  return this.computeType(($0 == null ? null : $0.assert$Compiler()), ($1 == null ? null : $1.assert$Types()));
};
// ********** Code for ForeignElement **************
function ForeignElement(name) {
  // Initializers done
  Element.call(this, name, const$219, null);
}
$inherits(ForeignElement, Element);
ForeignElement.prototype.computeType = function(compiler, types) {
  return types.dynamicType;
}
ForeignElement.prototype.computeType$2 = function($0, $1) {
  return this.computeType(($0 == null ? null : $0.assert$Compiler()), ($1 == null ? null : $1.assert$Types()));
};
// ********** Code for FunctionElement **************
function FunctionElement(name) {
  // Initializers done
  Element.call(this, name, const$216, null);
}
FunctionElement.node$ctor = function(node, enclosing) {
  this.node = node;
  // Initializers done
  Element.call(this, node.name.get$dynamic().get$source(), const$216, enclosing);
}
FunctionElement.node$ctor.prototype = FunctionElement.prototype;
$inherits(FunctionElement, Element);
FunctionElement.prototype.assert$FunctionElement = function(){return this};
FunctionElement.prototype.get$parameters = function() { return this.parameters; };
FunctionElement.prototype.set$parameters = function(value) { return this.parameters = value; };
FunctionElement.prototype.get$type = function() { return this.type; };
FunctionElement.prototype.set$type = function(value) { return this.type = value; };
FunctionElement.prototype.computeType = function(compiler, types) {
  var $0;
  if (this.type != null) return (($0 = this.type) == null ? null : $0.assert$FunctionType());
  if (this.parameters == null) compiler.resolveSignature(this);
  var node = (($0 = this.parseNode(compiler, compiler)) == null ? null : $0.assert$FunctionExpression());
  var returnType = getType(node.returnType, types);
  if (returnType == null) compiler.cancel(('unknown type ' + node.returnType));
  var parameterTypes = new LinkBuilderImplementation();
  for (var link = this.parameters;
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Element())) {
    parameterTypes.addLast(link.get$head().computeType$2(compiler, types));
  }
  this.type = new FunctionType(returnType, (($0 = parameterTypes.toLink()) == null ? null : $0.assert$Link_Type()));
  return (($0 = this.type) == null ? null : $0.assert$FunctionType());
}
FunctionElement.prototype.parseNode = function(canceler, logger) {
  return this.node;
}
FunctionElement.prototype.computeType$2 = function($0, $1) {
  return this.computeType(($0 == null ? null : $0.assert$Compiler()), $1);
};
// ********** Code for ClassElement **************
function ClassElement(name) {
  this.interfaces = const$213/*const EmptyLink<Type>()*/
  this.isResolved = false
  // Initializers done
  Element.call(this, name, const$214, null);
}
$inherits(ClassElement, Element);
ClassElement.prototype.assert$ClassElement = function(){return this};
ClassElement.prototype.get$type = function() { return this.type; };
ClassElement.prototype.set$type = function(value) { return this.type = value; };
ClassElement.prototype.get$interfaces = function() { return this.interfaces; };
ClassElement.prototype.set$interfaces = function(value) { return this.interfaces = value; };
ClassElement.prototype.computeType = function(compiler, types) {
  if (this.type == null) {
    this.type = new SimpleType(this.name, this);
  }
  return this.type;
}
ClassElement.prototype.resolve = function(compiler) {
  if ($notnull_bool(this.isResolved)) return;
  compiler.resolveType(this);
  this.isResolved = true;
}
ClassElement.prototype.computeType$2 = ClassElement.prototype.computeType;
ClassElement.prototype.resolve$1 = function($0) {
  return this.resolve(($0 == null ? null : $0.assert$Compiler()));
};
// ********** Code for top level **************
function getType(annotation, types) {
  var $0;
  if (annotation == null || annotation.typeName == null) {
    return (($0 = types.get$dynamicType()) == null ? null : $0.assert$Type());
  }
  return (($0 = types.lookup$1(annotation.typeName.get$source())) == null ? null : $0.assert$Type());
}
//  ********** Library ssa **************
// ********** Code for SsaBuilderTask **************
function SsaBuilderTask(compiler) {
  // Initializers done
  CompilerTask.call(this, compiler);
}
$inherits(SsaBuilderTask, CompilerTask);
SsaBuilderTask.prototype.get$name = function() {
  return 'SSA builder';
}
SsaBuilderTask.prototype.build = function(tree, elements) {
  var $this = this; // closure support
  var $0;
  return (($0 = this.measure((function () {
    var $0;
    var function_ = (tree == null ? null : tree.assert$FunctionExpression());
    $globals.HInstruction_idCounter = 0;
    var graph = $this.compileMethod(function_.parameters, function_.body, elements);
    $assert(graph.isValid(), "graph.isValid()", "builder.dart", 15, 14);
    if (false/*null.GENERATE_SSA_TRACE*/) {
      var name = (($0 = function_.name) == null ? null : $0.assert$Identifier());
      HTracer.HTracer$singleton$factory().traceCompilation(name.get$source().toString());
      HTracer.HTracer$singleton$factory().traceGraph('builder', graph);
    }
    return graph;
  })
  )) == null ? null : $0.assert$HGraph());
}
SsaBuilderTask.prototype.compileMethod = function(parameters, body, elements) {
  var builder = new SsaBuilder(this.compiler, elements);
  var graph = builder.build(parameters, body);
  return graph;
}
// ********** Code for SsaBuilder **************
function SsaBuilder(compiler, elements) {
  this.compiler = compiler;
  this.elements = elements;
  // Initializers done
}
SsaBuilder.prototype.assert$Visitor = function(){return this};
SsaBuilder.prototype.get$definitions = function() { return this.definitions; };
SsaBuilder.prototype.set$definitions = function(value) { return this.definitions = value; };
SsaBuilder.prototype.build = function(parameters, body) {
  this.stack = new ListFactory();
  this.definitions = new HashMapImplementation();
  this.graph = new HGraph();
  var block = this.graph.addNewBlock();
  this.open(this.graph.entry);
  this.visitParameterValues(parameters);
  this.close(new HGoto()).addSuccessor(block);
  this.open(block);
  body.accept(this);
  if (!$notnull_bool(this.isAborted())) this.close(new HGoto()).addSuccessor(this.graph.exit);
  this.graph.finalize();
  return this.graph;
}
SsaBuilder.prototype.open = function(block) {
  block.open();
  this.current = block;
}
SsaBuilder.prototype.close = function(end) {
  var result = this.current;
  this.current.close(end);
  this.current = null;
  return result;
}
SsaBuilder.prototype.goto = function(from, to) {
  from.close(new HGoto());
  from.addSuccessor(to);
}
SsaBuilder.prototype.isAborted = function() {
  return this.current == null;
}
SsaBuilder.prototype.add = function(instruction) {
  this.current.add(instruction);
}
SsaBuilder.prototype.push = function(instruction) {
  this.add(instruction);
  this.stack.add(instruction);
}
SsaBuilder.prototype.pop = function() {
  var $0;
  return (($0 = this.stack.removeLast()) == null ? null : $0.assert$HInstruction());
}
SsaBuilder.prototype.popBoolified = function() {
  var boolified = new HBoolify(this.pop());
  this.add(boolified);
  return boolified;
}
SsaBuilder.prototype.guard = function(type, value) {
  if (type != null) {
    if ($notnull_bool($eq(type.toString(), 'int'))) {
      value = new HTypeGuard(2/*HInstruction.TYPE_NUMBER*/, value);
      this.add(value);
    }
    else if ($notnull_bool($eq(type.toString(), 'String'))) {
      value = new HTypeGuard(3/*HInstruction.TYPE_STRING*/, value);
      this.add(value);
    }
  }
  return value;
}
SsaBuilder.prototype.visit = function(node) {
  if (node != null) node.accept(this);
}
SsaBuilder.prototype.visitParameterValues = function(parameters) {
  var $0;
  var parameterIndex = 0;
  for (var link = parameters.get$nodes();
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
    var container = (($0 = link.get$head()) == null ? null : $0.assert$VariableDefinitions());
    var identifierLink = container.definitions.get$nodes();
    $assert(!$notnull_bool(identifierLink.isEmpty()) && $notnull_bool(identifierLink.get$tail().isEmpty$0()), "!identifierLink.isEmpty() && identifierLink.tail.isEmpty()", "builder.dart", 135, 14);
    if (!(identifierLink.get$head() instanceof Identifier)) {
      this.compiler.unimplemented("SsaBuilder.visitParameterValues non-identifier");
    }
    var parameterId = (($0 = identifierLink.get$head()) == null ? null : $0.assert$Identifier());
    var element = (($0 = this.elements.$index(parameterId)) == null ? null : $0.assert$VariableElement());
    var parameter = new HParameterValue(element);
    this.add(parameter);
    this.definitions.$setindex(element, this.guard(element.type, parameter));
  }
}
SsaBuilder.prototype.visitBlock = function(node) {
  var $0;
  for (var link = node.statements.get$nodes();
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
    this.visit((($0 = link.get$head()) == null ? null : $0.assert$Node()));
    if ($notnull_bool(this.isAborted())) {
      if (!this.stack.isEmpty()) this.compiler.cancel('non-empty instruction stack');
      return;
    }
  }
  $assert(!$notnull_bool(this.current.isClosed()), "!current.isClosed()", "builder.dart", 158, 12);
  if (!this.stack.isEmpty()) this.compiler.cancel('non-empty instruction stack');
}
SsaBuilder.prototype.visitClassNode = function(node) {
  unreachable();
}
SsaBuilder.prototype.visitExpressionStatement = function(node) {
  this.visit(node.expression);
  this.pop();
}
SsaBuilder.prototype.startLoop = function() {
  var $this = this; // closure support
  $assert(!$notnull_bool(this.isAborted()), "!isAborted()", "builder.dart", 178, 12);
  var previousBlock = this.close(new HGoto());
  var definitionsCopy = HashMapImplementation.HashMapImplementation$from$factory(this.definitions);
  var loopBlock = this.graph.addNewLoopHeaderBlock();
  previousBlock.addSuccessor(loopBlock);
  this.open(loopBlock);
  definitionsCopy.forEach((function (element, instruction) {
    var phi = new HPhi.singleInput$ctor(element, instruction);
    loopBlock.addPhi(phi);
    $this.definitions.$setindex(element, phi);
  })
  );
  return definitionsCopy;
}
SsaBuilder.prototype.endLoop = function(loopEntry, branchBlock, doUpdateDefinitions, exitDefinitions) {
  var $this = this; // closure support
  loopEntry.forEachPhi((function (phi) {
    var $0;
    var element = phi.element;
    var postLoopDefinition = (($0 = $this.definitions.$index(element)) == null ? null : $0.assert$HInstruction());
    phi.addInput(postLoopDefinition);
    if ($notnull_bool(doUpdateDefinitions) && phi.inputs.$index(0) !== postLoopDefinition && exitDefinitions.containsKey(element)) {
      exitDefinitions.$setindex(element, postLoopDefinition);
    }
  })
  );
  var loopExitBlock = this.graph.addNewBlock();
  $assert(branchBlock.successors.length == 1, "branchBlock.successors.length == 1", "builder.dart", 220, 12);
  branchBlock.addSuccessor(loopExitBlock);
  this.open(loopExitBlock);
  this.definitions = exitDefinitions;
}
SsaBuilder.prototype.visitLoop = function(initializer, condition, update, body) {
  $assert(condition != null && body != null, "condition !== null && body !== null", "builder.dart", 229, 12);
  if (initializer != null) this.visit(initializer);
  $assert(!$notnull_bool(this.isAborted()), "!isAborted()", "builder.dart", 232, 12);
  var initializerDefinitions = this.startLoop();
  var conditionBlock = this.current;
  this.visit(condition);
  var conditionExitBlock = this.close(new HLoopBranch(this.popBoolified()));
  var conditionDefinitions = HashMapImplementation.HashMapImplementation$from$factory(this.definitions);
  var bodyBlock = this.graph.addNewBlock();
  conditionExitBlock.addSuccessor(bodyBlock);
  this.open(bodyBlock);
  this.visit(body);
  if ($notnull_bool(this.isAborted())) {
    this.compiler.unimplemented("SsaBuilder for loop with aborting body");
  }
  bodyBlock = this.close(new HGoto());
  var updateBlock = this.graph.addNewBlock();
  bodyBlock.addSuccessor(updateBlock);
  this.open(updateBlock);
  if (update != null) {
    this.visit(update);
    $assert(!$notnull_bool(this.isAborted()), "!isAborted()", "builder.dart", 262, 14);
    var updateInstruction = this.pop();
  }
  updateBlock = this.close(new HGoto());
  updateBlock.addSuccessor(conditionBlock);
  conditionBlock.postProcessLoopHeader();
  this.endLoop(conditionBlock, conditionExitBlock, false, conditionDefinitions);
}
SsaBuilder.prototype.visitFor = function(node) {
  var $0;
  $assert(node.initializer != null && node.get$condition() != null && node.update != null && node.body != null, "node.initializer !== null && node.condition !== null &&\n           node.update !== null && node.body !== null", "builder.dart", 275, 12);
  this.visitLoop(node.initializer, node.get$condition(), (($0 = node.update) == null ? null : $0.assert$Expression()), node.body);
}
SsaBuilder.prototype.visitWhile = function(node) {
  this.visitLoop(null, node.condition, null, node.body);
}
SsaBuilder.prototype.visitDoWhile = function(node) {
  var entryDefinitions = this.startLoop();
  var loopEntryBlock = this.current;
  this.visit(node.body);
  if ($notnull_bool(this.isAborted())) {
    this.compiler.unimplemented("SsaBuilder for loop with aborting body");
  }
  var bodyExitBlock = this.close(new HGoto());
  var conditionBlock = this.graph.addNewBlock();
  bodyExitBlock.addSuccessor(conditionBlock);
  this.open(conditionBlock);
  this.visit(node.condition);
  $assert(!$notnull_bool(this.isAborted()), "!isAborted()", "builder.dart", 300, 12);
  conditionBlock = this.close(new HLoopBranch(this.popBoolified()));
  conditionBlock.addSuccessor(loopEntryBlock);
  loopEntryBlock.postProcessLoopHeader();
  this.endLoop(loopEntryBlock, conditionBlock, true, entryDefinitions);
}
SsaBuilder.prototype.visitFunctionExpression = function(node) {
  this.compiler.unimplemented('SsaBuilder.visitFunctionExpression');
}
SsaBuilder.prototype.visitIdentifier = function(node) {
  var $0;
  var element = (($0 = this.elements.$index(node)) == null ? null : $0.assert$Element());
  this.compiler.ensure(element != null);
  var def = (($0 = this.definitions.$index(element)) == null ? null : $0.assert$HInstruction());
  $assert(def != null, "def !== null", "builder.dart", 317, 12);
  this.stack.add(def);
}
SsaBuilder.prototype.joinDefinitions = function(joinBlock, incoming1, incoming2) {
  var joinedDefinitions = new HashMapImplementation();
  incoming1.forEach((function (element, instruction) {
    var $0;
    var other = (($0 = incoming2.$index(element)) == null ? null : $0.assert$HInstruction());
    if (other == null) return;
    if (instruction === other) {
      joinedDefinitions.$setindex(element, instruction);
    }
    else {
      var phi = new HPhi.manyInputs$ctor(element, [instruction, other]);
      joinBlock.addPhi((phi == null ? null : phi.assert$HPhi()));
      joinedDefinitions.$setindex(element, phi);
    }
  })
  );
  return joinedDefinitions;
}
SsaBuilder.prototype.visitIf = function(node) {
  var hasElse = node.get$hasElsePart();
  this.visit(node.condition);
  var conditionBlock = this.close(new HIf(this.popBoolified(), hasElse));
  var conditionDefinitions = HashMapImplementation.HashMapImplementation$from$factory(this.definitions);
  var thenBlock = this.graph.addNewBlock();
  conditionBlock.addSuccessor(thenBlock);
  this.open(thenBlock);
  this.visit(node.thenPart);
  thenBlock = this.current;
  var thenDefinitions = this.definitions;
  this.definitions = conditionDefinitions;
  var elseBlock = null;
  if ($notnull_bool(hasElse)) {
    elseBlock = this.graph.addNewBlock();
    conditionBlock.addSuccessor(elseBlock);
    this.open(elseBlock);
    this.visit(node.elsePart);
    elseBlock = this.current;
  }
  if (thenBlock == null && elseBlock == null && $notnull_bool(hasElse)) {
    this.current = null;
  }
  else {
    var joinBlock = this.graph.addNewBlock();
    if (thenBlock != null) this.goto(thenBlock, joinBlock);
    if (elseBlock != null) this.goto(elseBlock, joinBlock);
    else if (!$notnull_bool(hasElse)) conditionBlock.addSuccessor(joinBlock);
    this.open(joinBlock);
    if (joinBlock.predecessors.length == 2) {
      this.definitions = this.joinDefinitions(joinBlock, thenDefinitions, this.definitions);
    }
  }
}
SsaBuilder.prototype.unquote = function(literal) {
  var str = ('' + literal.get$value());
  this.compiler.ensure(str[0] == '@');
  var quotes = 1;
  var quote = str[1];
  while (str[quotes + 1] === quote) quotes++;
  return new StringWrapper(str.substring(quotes + 1, str.length - quotes));
}
SsaBuilder.prototype.visitLogicalAndOr = function(node, op) {
  var isAnd = $assert_bool(($eq(const$278/*const SourceString("&&")*/, op.get$source())));
  this.visit(node.receiver);
  var boolifiedLeft = this.popBoolified();
  var condition;
  if ($notnull_bool(isAnd)) {
    condition = boolifiedLeft;
  }
  else {
    condition = new HNot(boolifiedLeft);
    this.add(condition);
  }
  var leftBlock = this.close(new HIf(condition, false));
  var leftDefinitions = HashMapImplementation.HashMapImplementation$from$factory(this.definitions);
  var rightBlock = this.graph.addNewBlock();
  leftBlock.addSuccessor(rightBlock);
  this.open(rightBlock);
  this.visit(node.argumentsNode);
  var boolifiedRight = this.popBoolified();
  rightBlock = this.close(new HGoto());
  var joinBlock = this.graph.addNewBlock();
  leftBlock.addSuccessor(joinBlock);
  rightBlock.addSuccessor(joinBlock);
  this.open(joinBlock);
  this.definitions = this.joinDefinitions(joinBlock, leftDefinitions, this.definitions);
  var result = new HPhi.manyInputs$ctor(null, [boolifiedLeft, boolifiedRight]);
  joinBlock.addPhi(result);
  this.stack.add(result);
}
SsaBuilder.prototype.visitLogicalNot = function(node) {
  $assert((node.argumentsNode instanceof Prefix), "node.argumentsNode is Prefix", "builder.dart", 449, 12);
  this.visit(node.receiver);
  var not = new HNot(this.popBoolified());
  this.push(not);
}
SsaBuilder.prototype.visitUnary = function(node, op, element) {
  $assert((node.argumentsNode instanceof Prefix), "node.argumentsNode is Prefix", "builder.dart", 456, 12);
  this.visit(node.receiver);
  var operand = this.pop();
  switch (op.get$source().get$stringValue()) {
    case "-":

      this.push(new HNegate(element, operand));
      break;

    case "~":

      this.push(new HBitNot(element, operand));
      break;

    default:

      unreachable();

  }
}
SsaBuilder.prototype.visitBinary = function(left, op, right, element) {
  switch (op.get$source().get$stringValue()) {
    case "+":
    case "++":
    case "+=":

      this.push(new HAdd(element, left, right));
      break;

    case "-":
    case "--":
    case "-=":

      this.push(new HSubtract(element, left, right));
      break;

    case "*":
    case "*=":

      this.push(new HMultiply(element, left, right));
      break;

    case "/":
    case "/=":

      this.push(new HDivide(element, left, right));
      break;

    case "~/":
    case "~/=":

      this.push(new HTruncatingDivide(element, left, right));
      break;

    case "%":
    case "%=":

      this.push(new HModulo(element, left, right));
      break;

    case "<<":
    case "<<=":

      this.push(new HShiftLeft(element, left, right));
      break;

    case ">>":
    case ">>=":

      this.push(new HShiftRight(element, left, right));
      break;

    case "|":
    case "|=":

      this.push(new HBitOr(element, left, right));
      break;

    case "&":
    case "&=":

      this.push(new HBitAnd(element, left, right));
      break;

    case "^":
    case "^=":

      this.push(new HBitXor(element, left, right));
      break;

    case "==":

      this.push(new HEquals(element, left, right));
      break;

    case "<":

      this.push(new HLess(element, left, right));
      break;

    case "<=":

      this.push(new HLessEqual(element, left, right));
      break;

    case ">":

      this.push(new HGreater(element, left, right));
      break;

    case ">=":

      this.push(new HGreaterEqual(element, left, right));
      break;

    default:

      this.compiler.unimplemented("SsaBuilder.visitBinary");

  }
}
SsaBuilder.prototype.visitSend = function(node) {
  var $0;
  var element = (($0 = this.elements.$index(node)) == null ? null : $0.assert$Element());
  if ((node.selector instanceof Operator)) {
    var op = (($0 = node.selector) == null ? null : $0.assert$Operator());
    if ($notnull_bool($eq(const$278/*const SourceString("&&")*/, op.get$source())) || $notnull_bool($eq(const$279/*const SourceString("||")*/, op.get$source()))) {
      this.visitLogicalAndOr(node, op);
    }
    else if ($notnull_bool($eq(const$280/*const SourceString("!")*/, op.get$source()))) {
      this.visitLogicalNot(node);
    }
    else if ((node.argumentsNode instanceof Prefix) || (node.argumentsNode instanceof Postfix)) {
      this.visitUnary(node, op, element);
    }
    else {
      this.visit(node.receiver);
      this.visit(node.argumentsNode);
      var right = this.pop();
      var left = this.pop();
      this.visitBinary((left == null ? null : left.assert$HInstruction()), op, (right == null ? null : right.assert$HInstruction()), element);
    }
  }
  else if ($notnull_bool(node.get$isPropertyAccess())) {
    if (node.receiver != null) {
      this.compiler.unimplemented("SsaBuilder.visitSend with receiver");
    }
    var instruction = (($0 = this.definitions.$index(element)) == null ? null : $0.assert$HInstruction());
    $assert(instruction != null, "instruction !== null", "builder.dart", 528, 14);
    this.stack.add(instruction);
  }
  else {
    if (element == null) {
      this.compiler.unimplemented("SsaBuilder.visitSend with receiver");
    }
    var link = node.get$arguments();
    if (element.kind === const$219/*ElementKind.FOREIGN*/) {
      link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node());
    }
    var arguments = [];
    for (; !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
      this.visit((($0 = link.get$head()) == null ? null : $0.assert$Node()));
      arguments.add$1(this.pop());
    }
    if (element.kind === const$219/*ElementKind.FOREIGN*/) {
      var literal = (($0 = node.get$arguments().get$head()) == null ? null : $0.assert$LiteralString());
      this.compiler.ensure((literal instanceof LiteralString));
      this.push(new HForeign(arguments, this.unquote(literal)));
    }
    else {
      this.push(new HInvoke(element, arguments));
    }
  }
}
SsaBuilder.prototype.updateDefinition = function(node, value) {
  var $0;
  var element = (($0 = this.elements.$index(node)) == null ? null : $0.assert$VariableElement());
  value = this.guard(element.type, value);
  this.definitions.$setindex(element, value);
  return value;
}
SsaBuilder.prototype.visitSendSet = function(node) {
  var $0;
  if (node.receiver != null) {
    this.compiler.unimplemented("SsaBuilder: property access");
  }
  var op = node.assignmentOperator;
  if ($notnull_bool($eq(const$281/*const SourceString("=")*/, op.get$source()))) {
    var link = node.get$arguments();
    $assert(!$notnull_bool(link.isEmpty()) && $notnull_bool(link.get$tail().isEmpty$0()), "!link.isEmpty() && link.tail.isEmpty()", "builder.dart", 570, 14);
    this.visit((($0 = link.get$head()) == null ? null : $0.assert$Node()));
    this.stack.add(this.updateDefinition(node, this.pop()));
  }
  else {
    $assert($notnull_bool($eq(const$284/*const SourceString("++")*/, op.get$source())) || $notnull_bool($eq(const$285/*const SourceString("--")*/, op.get$source())) || node.assignmentOperator.get$source().get$stringValue().endsWith("="), "const SourceString(\"++\") == op.source ||\n             const SourceString(\"--\") == op.source ||\n             node.assignmentOperator.source.stringValue.endsWith(\"=\")", "builder.dart", 574, 14);
    var isCompoundAssignment = !$notnull_bool(node.get$arguments().isEmpty());
    var isPrefix = !$notnull_bool(node.get$isPostfix());
    var getter = (($0 = this.elements.$index(node.selector)) == null ? null : $0.assert$Element());
    var left = (($0 = this.definitions.$index(getter)) == null ? null : $0.assert$HInstruction());
    var right;
    if ($notnull_bool(isCompoundAssignment)) {
      this.visit(node.argumentsNode);
      right = this.pop();
    }
    else {
      right = new HLiteral(1);
      this.add(right);
    }
    var opElement = (($0 = this.elements.$index(op)) == null ? null : $0.assert$Element());
    this.visitBinary(left, op, right, opElement);
    var operation = this.pop();
    $assert(operation != null, "operation !== null", "builder.dart", 592, 14);
    operation = this.updateDefinition(node, operation);
    if ($notnull_bool(isPrefix)) {
      this.stack.add(operation);
    }
    else {
      this.stack.add(left);
    }
  }
}
SsaBuilder.prototype.visitLiteralInt = function(node) {
  this.push(new HLiteral(node.get$value()));
}
SsaBuilder.prototype.visitLiteralDouble = function(node) {
  this.push(new HLiteral(node.get$value()));
}
SsaBuilder.prototype.visitLiteralBool = function(node) {
  this.push(new HLiteral(node.get$value()));
}
SsaBuilder.prototype.visitLiteralString = function(node) {
  this.push(new HLiteral(node.get$value()));
}
SsaBuilder.prototype.visitLiteralNull = function(node) {
  this.push(new HLiteral(null));
}
SsaBuilder.prototype.visitNodeList = function(node) {
  var $0;
  for (var link = node.get$nodes();
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
    this.visit((($0 = link.get$head()) == null ? null : $0.assert$Node()));
  }
}
SsaBuilder.prototype.visitParenthesizedExpression = function(node) {
  this.visit(node.expression);
}
SsaBuilder.prototype.visitOperator = function(node) {
  unreachable();
}
SsaBuilder.prototype.visitReturn = function(node) {
  var value;
  if (node.expression == null) {
    value = new HLiteral(null);
    this.add(value);
  }
  else {
    this.visit(node.expression);
    value = this.pop();
  }
  this.close(new HReturn(value)).addSuccessor(this.graph.exit);
}
SsaBuilder.prototype.visitThrow = function(node) {
  if (node.expression == null) {
    this.compiler.unimplemented("SsaBuilder: throw without expression");
  }
  this.visit(node.expression);
  this.close(new HThrow(this.pop()));
}
SsaBuilder.prototype.visitTypeAnnotation = function(node) {

}
SsaBuilder.prototype.visitVariableDefinitions = function(node) {
  var $0;
  for (var link = node.definitions.get$nodes();
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
    var definition = (($0 = link.get$head()) == null ? null : $0.assert$Node());
    if ((definition instanceof Identifier)) {
      var initialValue = new HLiteral(null);
      this.add(initialValue);
      this.updateDefinition(definition, initialValue);
    }
    else {
      $assert((definition instanceof SendSet), "definition is SendSet", "builder.dart", 672, 16);
      this.visitSendSet((definition == null ? null : definition.assert$SendSet()));
      this.pop();
    }
  }
}
SsaBuilder.prototype.add$1 = function($0) {
  return this.add(($0 == null ? null : $0.assert$HInstruction()));
};
SsaBuilder.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$Node()));
};
// ********** Code for SsaCodeGeneratorTask **************
function SsaCodeGeneratorTask(compiler) {
  // Initializers done
  CompilerTask.call(this, compiler);
}
$inherits(SsaCodeGeneratorTask, CompilerTask);
SsaCodeGeneratorTask.prototype.get$name = function() {
  return 'SSA code generator';
}
SsaCodeGeneratorTask.prototype.generate = function(function_, graph) {
  var $this = this; // closure support
  return $assert_String(this.measure((function () {
    var $0;
    var parameterNames = new LinkedHashMapImplementation();
    for (var link = function_.parameters;
     !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Element())) {
      var element = (($0 = link.get$head()) == null ? null : $0.assert$Element());
      parameterNames.$setindex(element, JsNames.getValid(('' + element.name)));
    }
    var code = $this.generateMethod(function_.name, parameterNames, graph);
    return code;
  })
  ));
}
SsaCodeGeneratorTask.prototype.preGenerateMethod = function(graph) {
  if (false/*null.GENERATE_SSA_TRACE*/) {
    HTracer.HTracer$singleton$factory().traceGraph("codegen", graph);
  }
  new SsaPhiEliminator().visitGraph(graph);
  if (false/*null.GENERATE_SSA_TRACE*/) {
    HTracer.HTracer$singleton$factory().traceGraph("no-phi", graph);
  }
  new SsaTypeGuardUnuser().visitGraph(graph);
}
SsaCodeGeneratorTask.prototype.generateMethod = function(methodName, parameterNames, graph) {
  var $0;
  this.preGenerateMethod(graph);
  var buffer = new StringBufferImpl("");
  var codegen = new SsaCodeGenerator(this.compiler, buffer, parameterNames);
  codegen.visitGraph(graph);
  var parameters = new StringBufferImpl("");
  var names = (($0 = parameterNames.getValues()) == null ? null : $0.assert$List_String());
  for (var i = 0;
   i < $assert_num(names.length); i++) {
    if (i != 0) parameters.add(', ');
    parameters.add(names.$index(i));
  }
  return ('function ' + methodName + '(' + parameters + ') {\n' + buffer + '}\n');
}
// ********** Code for SsaCodeGenerator **************
function SsaCodeGenerator(compiler, buffer, parameterNames) {
  this.indent = 0
  this.compiler = compiler;
  this.buffer = buffer;
  this.parameterNames = parameterNames;
  this.names = new HashMapImplementation();
  this.prefixes = new HashMapImplementation();
  // Initializers done
  var $list = this.parameterNames.getValues();
  for (var $i = this.parameterNames.getValues().iterator$0(); $i.hasNext$0(); ) {
    var name = $i.next$0();
    this.prefixes.$setindex(name, 0);
  }
}
SsaCodeGenerator.prototype.assert$HVisitor = function(){return this};
SsaCodeGenerator.prototype.get$names = function() { return this.names; };
SsaCodeGenerator.prototype.visitGraph = function(graph) {
  this.currentGraph = graph;
  this.indent++;
  this.visitBasicBlock(graph.entry);
}
SsaCodeGenerator.prototype.parameter = function(parameter) {
  return $assert_String(this.parameterNames.$index(parameter.element));
}
SsaCodeGenerator.prototype.temporary = function(instruction) {
  var $0, $1;
  var id = instruction.id;
  var name = $assert_String(this.names.$index(id));
  if (name != null) return name;
  var prefix = 't';
  if (!this.prefixes.containsKey(prefix)) this.prefixes.$setindex(prefix, 0);
  return this.newName(id, ('' + prefix + ((($0 = this.prefixes).$setindex(prefix, ($1 = $0.$index(prefix)) + 1), $1))));
}
SsaCodeGenerator.prototype.local = function(local) {
  var $0, $1;
  var element = local.element;
  if (element != null && $eq(element.kind, const$232/*ElementKind.PARAMETER*/)) {
    return $assert_String(this.parameterNames.$index(element));
  }
  var id = local.id;
  var name = $assert_String(this.names.$index(id));
  if (name != null) return name;
  var prefix;
  if (element != null) {
    prefix = element.name.get$stringValue();
  }
  else {
    prefix = 'v';
  }
  if (!this.prefixes.containsKey(prefix)) {
    this.prefixes.$setindex(prefix, 0);
    return this.newName(id, prefix);
  }
  else {
    return this.newName(id, ('' + prefix + '_' + ((($0 = this.prefixes).$setindex(prefix, ($1 = $0.$index(prefix)) + 1), $1))));
  }
}
SsaCodeGenerator.prototype.get$local = function() {
  return SsaCodeGenerator.prototype.local.bind(this);
}
SsaCodeGenerator.prototype.newName = function(id, name) {
  var result = JsNames.getValid(name);
  this.names.$setindex(id, result);
  return result;
}
SsaCodeGenerator.prototype.invoke = function(element, arguments) {
  var $0;
  this.buffer.add(('' + element.name + '('));
  for (var i = 0;
   i < arguments.length; i++) {
    if (i != 0) this.buffer.add(', ');
    this.use((($0 = arguments.$index(i)) == null ? null : $0.assert$HInstruction()));
  }
  this.buffer.add(")");
}
SsaCodeGenerator.prototype.define = function(instruction) {
  this.buffer.add(('var ' + this.temporary(instruction) + ' = '));
  this.visit(instruction);
}
SsaCodeGenerator.prototype.use = function(argument) {
  if ($notnull_bool(argument.generateAtUseSite())) {
    this.visit(argument);
  }
  else {
    this.buffer.add(this.temporary(argument));
  }
}
SsaCodeGenerator.prototype.visit = function(node) {
  return node.accept$1(this);
}
SsaCodeGenerator.prototype.visitBasicBlock = function(node) {
  if ($notnull_bool(node.isLoopHeader())) {
    this.addIndentation();
    this.buffer.add('while (true) {\n');
    this.indent++;
  }
  this.currentBlock = node;
  var instruction = node.first;
  while (instruction != null) {
    if ((instruction instanceof HGoto) || (instruction instanceof HExit)) {
      this.visit(instruction);
    }
    else if (!$notnull_bool(instruction.generateAtUseSite())) {
      this.addIndentation();
      if (instruction.usedBy.isEmpty() || (instruction instanceof HLocal)) {
        this.visit(instruction);
      }
      else {
        this.define(instruction);
      }
      if (!(instruction instanceof HControlFlow)) {
        this.buffer.add(';\n');
      }
    }
    instruction = instruction.next;
  }
}
SsaCodeGenerator.prototype.visitInvokeBinary = function(node, useOperator, op) {
  var $0;
  if ($notnull_bool(useOperator)) {
    this.buffer.add('(');
    this.use((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
    this.buffer.add((' ' + op + ' '));
    this.use((($0 = node.inputs.$index(1)) == null ? null : $0.assert$HInstruction()));
    this.buffer.add(')');
  }
  else {
    this.visitInvoke(node);
  }
}
SsaCodeGenerator.prototype.visitInvokeUnary = function(node, useOperator, op) {
  var $0;
  if ($notnull_bool(useOperator)) {
    this.buffer.add(('(' + op));
    this.use((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
    this.buffer.add(')');
  }
  else {
    this.visitInvoke(node);
  }
}
SsaCodeGenerator.prototype.visitAdd = function(node) {
  return this.visitInvokeBinary(node, node.builtin, '+');
}
SsaCodeGenerator.prototype.visitDivide = function(node) {
  return this.visitInvokeBinary(node, node.builtin, '/');
}
SsaCodeGenerator.prototype.visitMultiply = function(node) {
  return this.visitInvokeBinary(node, node.builtin, '*');
}
SsaCodeGenerator.prototype.visitSubtract = function(node) {
  return this.visitInvokeBinary(node, node.builtin, '-');
}
SsaCodeGenerator.prototype.visitTruncatingDivide = function(node) {
  return this.visitInvoke(node);
}
SsaCodeGenerator.prototype.visitModulo = function(node) {
  return this.visitInvoke(node);
}
SsaCodeGenerator.prototype.visitBitAnd = function(node) {
  return this.visitInvoke(node);
}
SsaCodeGenerator.prototype.visitBitNot = function(node) {
  return this.visitInvoke(node);
}
SsaCodeGenerator.prototype.visitBitOr = function(node) {
  return this.visitInvoke(node);
}
SsaCodeGenerator.prototype.visitBitXor = function(node) {
  return this.visitInvoke(node);
}
SsaCodeGenerator.prototype.visitShiftLeft = function(node) {
  return this.visitInvoke(node);
}
SsaCodeGenerator.prototype.visitShiftRight = function(node) {
  return this.visitInvoke(node);
}
SsaCodeGenerator.prototype.visitNegate = function(node) {
  return this.visitInvokeUnary(node, node.builtin, '-');
}
SsaCodeGenerator.prototype.visitEquals = function(node) {
  return this.visitInvokeBinary(node, node.builtin, '===');
}
SsaCodeGenerator.prototype.visitLess = function(node) {
  return this.visitInvokeBinary(node, node.builtin, '<');
}
SsaCodeGenerator.prototype.visitLessEqual = function(node) {
  return this.visitInvokeBinary(node, node.builtin, '<=');
}
SsaCodeGenerator.prototype.visitGreater = function(node) {
  return this.visitInvokeBinary(node, node.builtin, '>');
}
SsaCodeGenerator.prototype.visitGreaterEqual = function(node) {
  return this.visitInvokeBinary(node, node.builtin, '>=');
}
SsaCodeGenerator.prototype.visitBoolify = function(node) {
  var $0;
  $assert(node.inputs.length == 1, "node.inputs.length == 1", "codegen.dart", 248, 12);
  this.buffer.add('(');
  this.use((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
  this.buffer.add(' === true)');
}
SsaCodeGenerator.prototype.visitExit = function(node) {

}
SsaCodeGenerator.prototype.visitGoto = function(node) {
  var $0;
  $assert(this.currentBlock.successors.length == 1, "currentBlock.successors.length == 1", "codegen.dart", 259, 12);
  var dominated = this.currentBlock.dominatedBlocks;
  if (dominated.isEmpty()) return;
  if (dominated.length > 2) unreachable();
  if (dominated.length == 2 && this.currentBlock !== this.currentGraph.entry) {
    unreachable();
  }
  $assert($eq(dominated.$index(0), this.currentBlock.successors.$index(0)), "dominated[0] == currentBlock.successors[0]", "codegen.dart", 271, 12);
  this.visitBasicBlock((($0 = dominated.$index(0)) == null ? null : $0.assert$HBasicBlock()));
}
SsaCodeGenerator.prototype.visitIf = function(node) {
  var $0;
  var ifBlock = this.currentBlock;
  this.buffer.add('if (');
  this.use((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
  this.buffer.add(') {\n');
  this.indent++;
  var dominated = this.currentBlock.dominatedBlocks;
  $assert(dominated.$index(0) === ifBlock.successors.$index(0), "dominated[0] === ifBlock.successors[0]", "codegen.dart", 284, 12);
  this.visitBasicBlock((($0 = ifBlock.successors.$index(0)) == null ? null : $0.assert$HBasicBlock()));
  this.indent--;
  this.addIndentation();
  var nextDominatedIndex;
  if ($notnull_bool(node.hasElse)) {
    $assert(dominated.$index(1) === ifBlock.successors.$index(1), "dominated[1] === ifBlock.successors[1]", "codegen.dart", 290, 14);
    this.buffer.add('} else {\n');
    this.indent++;
    this.visitBasicBlock((($0 = ifBlock.successors.$index(1)) == null ? null : $0.assert$HBasicBlock()));
    this.indent--;
    this.addIndentation();
    this.buffer.add("}\n");
  }
  else {
    this.buffer.add("}\n");
  }
  if ($notnull_bool(node.hasElse) && dominated.length == 3) {
    this.visitBasicBlock((($0 = dominated.$index(2)) == null ? null : $0.assert$HBasicBlock()));
  }
  else if ($notnull_bool(node.hasElse)) {
    $assert(dominated.length == 2, "dominated.length == 2", "codegen.dart", 318, 14);
    return;
  }
  else if (!$notnull_bool(node.hasElse) && dominated.length == 2) {
    $assert(!$notnull_bool(dominated.$index(1).isExitBlock$0()), "!dominated[1].isExitBlock()", "codegen.dart", 323, 14);
    this.visitBasicBlock((($0 = dominated.$index(1)) == null ? null : $0.assert$HBasicBlock()));
  }
  else {
    $assert(!$notnull_bool(node.hasElse), "!node.hasElse", "codegen.dart", 328, 14);
    $assert(dominated.length == 3, "dominated.length == 3", "codegen.dart", 329, 14);
    $assert(dominated.$index(2).isExitBlock$0(), "dominated[2].isExitBlock()", "codegen.dart", 330, 14);
    this.visitBasicBlock((($0 = dominated.$index(1)) == null ? null : $0.assert$HBasicBlock()));
    this.visitBasicBlock((($0 = dominated.$index(2)) == null ? null : $0.assert$HBasicBlock()));
  }
}
SsaCodeGenerator.prototype.visitInvoke = function(node) {
  this.compiler.worklist.add(node.element);
  this.invoke(node.element, node.inputs);
}
SsaCodeGenerator.prototype.visitForeign = function(node) {
  var $0;
  var code = ('' + node.code);
  var inputs = node.inputs;
  for (var i = 0;
   i < inputs.length; i++) {
    var input = (($0 = inputs.$index(i)) == null ? null : $0.assert$HInstruction());
    var name = null;
    if ((input instanceof HParameterValue)) {
      name = this.parameter((input == null ? null : input.assert$HParameterValue()));
    }
    else {
      $assert(!$notnull_bool(input.generateAtUseSite()), "!input.generateAtUseSite()", "codegen.dart", 350, 16);
      name = this.temporary(input);
    }
    code = code.replaceAll(('\$' + i), name);
  }
  this.buffer.add(('(' + code + ')'));
}
SsaCodeGenerator.prototype.visitLiteral = function(node) {
  if (node.value == null) {
    this.buffer.add("(void 0)");
  }
  else if ((typeof(node.value) == 'number') && node.value < 0) {
    this.buffer.add(('(' + node.value + ')'));
  }
  else {
    this.buffer.add(node.value);
  }
}
SsaCodeGenerator.prototype.visitLoopBranch = function(node) {
  var $0;
  var branchBlock = this.currentBlock;
  this.buffer.add('if (!(');
  this.use((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
  this.buffer.add(')) break;\n');
  var dominated = this.currentBlock.dominatedBlocks;
  var loopSuccessor;
  if (dominated.length == 1) {
    $assert(branchBlock.successors.$index(0).get$id() < branchBlock.id, "branchBlock.successors[0].id < branchBlock.id", "codegen.dart", 378, 14);
    $assert(dominated.$index(0) === branchBlock.successors.$index(1), "dominated[0] === branchBlock.successors[1]", "codegen.dart", 379, 14);
  }
  else {
    $assert(dominated.length == 2, "dominated.length == 2", "codegen.dart", 383, 14);
    $assert(dominated.$index(0) === branchBlock.successors.$index(0), "dominated[0] === branchBlock.successors[0]", "codegen.dart", 384, 14);
    $assert(dominated.$index(1) === branchBlock.successors.$index(1), "dominated[1] === branchBlock.successors[1]", "codegen.dart", 385, 14);
    this.visit(dominated.$index(0));
  }
  this.indent--;
  this.addIndentation();
  this.buffer.add('}\n');
  this.visit(branchBlock.successors.$index(1));
}
SsaCodeGenerator.prototype.visitNot = function(node) {
  var $0;
  $assert(node.inputs.length == 1, "node.inputs.length == 1", "codegen.dart", 395, 12);
  this.buffer.add('(!');
  this.use((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
  this.buffer.add(')');
}
SsaCodeGenerator.prototype.visitParameterValue = function(node) {
  this.buffer.add(this.parameter(node));
}
SsaCodeGenerator.prototype.visitPhi = function(node) {
  unreachable();
}
SsaCodeGenerator.prototype.visitReturn = function(node) {
  var $0;
  $assert(node.inputs.length == 1, "node.inputs.length == 1", "codegen.dart", 411, 12);
  var input = (($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction());
  if ($notnull_bool(input.isLiteralNull())) {
    this.buffer.add('return;\n');
  }
  else {
    this.buffer.add('return ');
    this.use((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
    this.buffer.add(';\n');
  }
}
SsaCodeGenerator.prototype.visitThrow = function(node) {
  var $0;
  this.buffer.add('throw ');
  this.use((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
  this.buffer.add(';\n');
}
SsaCodeGenerator.prototype.visitTypeGuard = function(node) {
  var $0;
  var name;
  if ($notnull_bool(node.isNumber())) {
    name = const$301/*const SourceString('guard\$num')*/;
  }
  else if ($notnull_bool(node.isString())) {
    name = const$302/*const SourceString('guard\$string')*/;
  }
  else {
    unreachable();
  }
  var element = this.compiler.universe.find(name);
  this.compiler.worklist.add(element);
  this.buffer.add(('' + name + '('));
  this.use((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
  this.buffer.add(')');
}
SsaCodeGenerator.prototype.addIndentation = function() {
  for (var i = 0;
   i < this.indent; i++) {
    this.buffer.add('  ');
  }
}
SsaCodeGenerator.prototype.visitStore = function(node) {
  if (node.get$local().declaredBy === node) {
    this.buffer.add('var ');
  }
  this.buffer.add(('' + this.local(node.get$local()) + ' = '));
  this.use(node.get$value());
}
SsaCodeGenerator.prototype.visitLoad = function(node) {
  this.buffer.add(('' + this.local(node.get$local())));
}
SsaCodeGenerator.prototype.visitLocal = function(node) {
  this.buffer.add(('var ' + this.local(node)));
}
SsaCodeGenerator.prototype.visit$1 = SsaCodeGenerator.prototype.visit;
// ********** Code for JsNames **************
function JsNames() {}
JsNames.get$reserved = function() {
  if ($globals.JsNames__reserved == null) {
    $globals.JsNames__reserved = new HashSetImplementation();
    $globals.JsNames__reserved.addAll(const$295/*JsNames.reservedPropertySymbols*/);
    $globals.JsNames__reserved.addAll(const$297/*JsNames.reservedGlobalSymbols*/);
    $globals.JsNames__reserved.addAll(const$299/*JsNames.javaScriptKeywords*/);
  }
  return $globals.JsNames__reserved;
}
JsNames.getValid = function(name) {
  if (JsNames.get$reserved().contains(name)) {
    name = ('\$' + name);
    $assert(!JsNames.get$reserved().contains(name), "!reserved.contains(name)", "js_names.dart", 171, 14);
  }
  else if (name.contains("$")) {
    name = name.replaceAll("$", "_$");
  }
  return name;
}
// ********** Code for HGraphVisitor **************
function HGraphVisitor() {
  // Initializers done
}
HGraphVisitor.prototype.visitDominatorTree = function(graph) {
  var $this = this; // closure support
  function visitBasicBlockAndSuccessors(block) {
    var $0;
    $this.visitBasicBlock(block);
    var dominated = block.dominatedBlocks;
    for (var i = 0;
     i < dominated.length; i++) {
      visitBasicBlockAndSuccessors((($0 = dominated.$index(i)) == null ? null : $0.assert$HBasicBlock()));
    }
  }
  visitBasicBlockAndSuccessors(graph.entry);
}
HGraphVisitor.prototype.visitPostDominatorTree = function(graph) {
  var $this = this; // closure support
  function visitBasicBlockAndSuccessors(block) {
    var $0;
    var dominated = block.dominatedBlocks;
    for (var i = dominated.length - 1;
     i >= 0; i--) {
      visitBasicBlockAndSuccessors((($0 = dominated.$index(i)) == null ? null : $0.assert$HBasicBlock()));
    }
    $this.visitBasicBlock(block);
  }
  visitBasicBlockAndSuccessors(graph.entry);
}
// ********** Code for HInstructionVisitor **************
function HInstructionVisitor() {
  // Initializers done
  HGraphVisitor.call(this);
}
$inherits(HInstructionVisitor, HGraphVisitor);
HInstructionVisitor.prototype.visitBasicBlock = function(node) {
  var $this = this; // closure support
  function visitInstructionList(list) {
    var instruction = list.first;
    while (instruction != null) {
      $this.visitInstruction(instruction);
      instruction = instruction.next;
      $assert($ne(instruction, list.first), "instruction != list.first", "nodes.dart", 84, 16);
    }
  }
  this.currentBlock = node;
  visitInstructionList(node);
}
// ********** Code for HGraph **************
function HGraph() {
  this.blocks = new ListFactory();
  // Initializers done
  this.entry = this.addNewBlock();
  this.exit = new HBasicBlock();
}
HGraph.prototype.assert$HGraph = function(){return this};
HGraph.prototype.addBlock = function(block) {
  var id = this.blocks.length;
  block.id = id;
  this.blocks.add(block);
  $assert(this.blocks.$index(id) === block, "blocks[id] === block", "nodes.dart", 109, 12);
}
HGraph.prototype.addNewBlock = function() {
  var result = new HBasicBlock();
  this.addBlock(result);
  return result;
}
HGraph.prototype.addNewLoopHeaderBlock = function() {
  var result = this.addNewBlock();
  result.loopInformation = new HLoopInformation(result);
  return result;
}
HGraph.prototype.finalize = function() {
  this.addBlock(this.exit);
  this.exit.open();
  this.exit.close(new HExit());
  this.assignDominators();
}
HGraph.prototype.assignDominators = function() {
  var $0;
  for (var i = 0, length = this.blocks.length;
   i < length; i++) {
    var block = (($0 = this.blocks.$index(i)) == null ? null : $0.assert$HBasicBlock());
    var predecessors = block.predecessors;
    if ($notnull_bool(block.isLoopHeader())) {
      $assert(predecessors.length >= 2, "predecessors.length >= 2", "nodes.dart", 139, 16);
      block.assignCommonDominator((($0 = predecessors.$index(0)) == null ? null : $0.assert$HBasicBlock()));
    }
    else {
      for (var j = predecessors.length - 1;
       j >= 0; j--) {
        block.assignCommonDominator((($0 = predecessors.$index(j)) == null ? null : $0.assert$HBasicBlock()));
      }
    }
  }
}
HGraph.prototype.isValid = function() {
  var validator = new HValidator();
  validator.visitGraph(this);
  return validator.isValid;
}
// ********** Code for HBaseVisitor **************
function HBaseVisitor() {
  // Initializers done
  HGraphVisitor.call(this);
}
$inherits(HBaseVisitor, HGraphVisitor);
HBaseVisitor.prototype.assert$HVisitor = function(){return this};
HBaseVisitor.prototype.visitBasicBlock = function(node) {
  this.currentBlock = node;
  var instruction = node.first;
  while (instruction != null) {
    instruction.accept(this);
    instruction = instruction.next;
  }
}
HBaseVisitor.prototype.visitInstruction = function(HInstruction) {

}
HBaseVisitor.prototype.visitArithmetic = function(node) {
  return this.visitInvoke(node);
}
HBaseVisitor.prototype.visitBinaryArithmetic = function(node) {
  return this.visitArithmetic(node);
}
HBaseVisitor.prototype.visitBinaryBitOp = function(node) {
  return this.visitBinaryArithmetic(node);
}
HBaseVisitor.prototype.visitUnaryArithmetic = function(node) {
  return this.visitArithmetic(node);
}
HBaseVisitor.prototype.visitConditionalBranch = function(node) {
  return this.visitControlFlow(node);
}
HBaseVisitor.prototype.visitControlFlow = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitRelational = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitAdd = function(node) {
  return this.visitBinaryArithmetic(node);
}
HBaseVisitor.prototype.visitBitAnd = function(node) {
  return this.visitBinaryBitOp(node);
}
HBaseVisitor.prototype.visitBitNot = function(node) {
  return this.visitUnaryArithmetic(node);
}
HBaseVisitor.prototype.visitBitOr = function(node) {
  return this.visitBinaryBitOp(node);
}
HBaseVisitor.prototype.visitBitXor = function(node) {
  return this.visitBinaryBitOp(node);
}
HBaseVisitor.prototype.visitBoolify = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitDivide = function(node) {
  return this.visitBinaryArithmetic(node);
}
HBaseVisitor.prototype.visitEquals = function(node) {
  return this.visitRelational(node);
}
HBaseVisitor.prototype.visitExit = function(node) {
  return this.visitControlFlow(node);
}
HBaseVisitor.prototype.visitForeign = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitGoto = function(node) {
  return this.visitControlFlow(node);
}
HBaseVisitor.prototype.visitGreater = function(node) {
  return this.visitRelational(node);
}
HBaseVisitor.prototype.visitGreaterEqual = function(node) {
  return this.visitRelational(node);
}
HBaseVisitor.prototype.visitIf = function(node) {
  return this.visitConditionalBranch(node);
}
HBaseVisitor.prototype.visitInvoke = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitLess = function(node) {
  return this.visitRelational(node);
}
HBaseVisitor.prototype.visitLessEqual = function(node) {
  return this.visitRelational(node);
}
HBaseVisitor.prototype.visitLoad = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitLocal = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitLiteral = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitLoopBranch = function(node) {
  return this.visitConditionalBranch(node);
}
HBaseVisitor.prototype.visitModulo = function(node) {
  return this.visitBinaryArithmetic(node);
}
HBaseVisitor.prototype.visitNegate = function(node) {
  return this.visitUnaryArithmetic(node);
}
HBaseVisitor.prototype.visitNot = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitPhi = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitMultiply = function(node) {
  return this.visitBinaryArithmetic(node);
}
HBaseVisitor.prototype.visitParameterValue = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitReturn = function(node) {
  return this.visitControlFlow(node);
}
HBaseVisitor.prototype.visitShiftRight = function(node) {
  return this.visitBinaryBitOp(node);
}
HBaseVisitor.prototype.visitShiftLeft = function(node) {
  return this.visitBinaryBitOp(node);
}
HBaseVisitor.prototype.visitSubtract = function(node) {
  return this.visitBinaryArithmetic(node);
}
HBaseVisitor.prototype.visitStore = function(node) {
  return this.visitInstruction(node);
}
HBaseVisitor.prototype.visitThrow = function(node) {
  return this.visitControlFlow(node);
}
HBaseVisitor.prototype.visitTruncatingDivide = function(node) {
  return this.visitBinaryArithmetic(node);
}
HBaseVisitor.prototype.visitTypeGuard = function(node) {
  return this.visitInstruction(node);
}
// ********** Code for HInstructionList **************
function HInstructionList() {
  this.first = null
  this.last = null
  // Initializers done
}
HInstructionList.prototype.get$first = function() { return this.first; };
HInstructionList.prototype.set$first = function(value) { return this.first = value; };
HInstructionList.prototype.isEmpty = function() {
  return this.first == null;
}
HInstructionList.prototype.addAfter = function(cursor, instruction) {
  if (cursor == null) {
    $assert(this.isEmpty(), "isEmpty()", "nodes.dart", 227, 14);
    this.first = this.last = instruction;
  }
  else if (cursor === this.last) {
    this.last.next = instruction;
    instruction.previous = this.last;
    this.last = instruction;
  }
  else {
    instruction.previous = cursor;
    instruction.next = cursor.next;
    cursor.next.previous = instruction;
    cursor.next = instruction;
  }
}
HInstructionList.prototype.addBefore = function(cursor, instruction) {
  if (cursor == null) {
    $assert(this.isEmpty(), "isEmpty()", "nodes.dart", 243, 14);
    this.first = this.last = instruction;
  }
  else if (cursor === this.first) {
    this.first.previous = instruction;
    instruction.next = this.first;
    this.first = instruction;
  }
  else {
    instruction.next = cursor;
    instruction.previous = cursor.previous;
    cursor.previous.next = instruction;
    cursor.previous = instruction;
  }
}
HInstructionList.prototype.detach = function(instruction) {
  $assert(this.contains(instruction), "contains(instruction)", "nodes.dart", 258, 12);
  $assert(instruction.isInBasicBlock(), "instruction.isInBasicBlock()", "nodes.dart", 259, 12);
  if (instruction.previous == null) {
    this.first = instruction.next;
  }
  else {
    instruction.previous.next = instruction.next;
  }
  if (instruction.next == null) {
    this.last = instruction.previous;
  }
  else {
    instruction.next.previous = instruction.previous;
  }
  instruction.previous = null;
  instruction.next = null;
}
HInstructionList.prototype.remove = function(instruction) {
  $assert(instruction.usedBy.isEmpty(), "instruction.usedBy.isEmpty()", "nodes.dart", 275, 12);
  this.detach(instruction);
}
HInstructionList.prototype.contains = function(instruction) {
  var cursor = this.first;
  while (cursor != null) {
    if (cursor === instruction) return true;
    cursor = cursor.next;
  }
  return false;
}
HInstructionList.prototype.contains$1 = function($0) {
  return this.contains(($0 == null ? null : $0.assert$HInstruction()));
};
HInstructionList.prototype.isEmpty$0 = HInstructionList.prototype.isEmpty;
HInstructionList.prototype.last$0 = function() {
  return this.last();
};
HInstructionList.prototype.remove$1 = function($0) {
  return this.remove(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HBasicBlock **************
function HBasicBlock() {
  this.status = 0/*HBasicBlock.STATUS_NEW*/
  this.loopInformation = null
  this.parentLoopHeader = null
  this.dominator = null
  // Initializers done
  HBasicBlock.withId$ctor.call(this, null);
}
HBasicBlock.withId$ctor = function(id) {
  this.status = 0/*HBasicBlock.STATUS_NEW*/
  this.loopInformation = null
  this.parentLoopHeader = null
  this.dominator = null
  this.id = id;
  this.phis = new HInstructionList();
  this.predecessors = [];
  this.successors = const$21/*const []*/;
  this.dominatedBlocks = [];
  // Initializers done
  HInstructionList.call(this);
}
HBasicBlock.withId$ctor.prototype = HBasicBlock.prototype;
$inherits(HBasicBlock, HInstructionList);
HBasicBlock.prototype.assert$HBasicBlock = function(){return this};
HBasicBlock.prototype.get$id = function() { return this.id; };
HBasicBlock.prototype.set$id = function(value) { return this.id = value; };
HBasicBlock.prototype.get$phis = function() { return this.phis; };
HBasicBlock.prototype.set$phis = function(value) { return this.phis = value; };
HBasicBlock.prototype.isNew = function() {
  return this.status == 0/*HBasicBlock.STATUS_NEW*/;
}
HBasicBlock.prototype.isOpen = function() {
  return this.status == 1/*HBasicBlock.STATUS_OPEN*/;
}
HBasicBlock.prototype.isClosed = function() {
  return this.status == 2/*HBasicBlock.STATUS_CLOSED*/;
}
HBasicBlock.prototype.get$isClosed = function() {
  return HBasicBlock.prototype.isClosed.bind(this);
}
HBasicBlock.prototype.isLoopHeader = function() {
  return this.loopInformation != null;
}
HBasicBlock.prototype.open = function() {
  $assert(this.isNew(), "isNew()", "nodes.dart", 325, 12);
  this.status = 1/*HBasicBlock.STATUS_OPEN*/;
}
HBasicBlock.prototype.close = function(end) {
  $assert(this.isOpen(), "isOpen()", "nodes.dart", 330, 12);
  this.addAfter(this.last, end);
  this.status = 2/*HBasicBlock.STATUS_CLOSED*/;
}
HBasicBlock.prototype.accept = function(visitor) {
  return visitor.visitBasicBlock(this);
}
HBasicBlock.prototype.addAtEntry = function(instruction) {
  $assert(this.isClosed(), "isClosed()", "nodes.dart", 349, 12);
  $assert(!(instruction instanceof HPhi), "instruction is !HPhi", "nodes.dart", 350, 12);
  HInstructionList.prototype.addBefore.call(this, this.first, instruction);
  instruction.notifyAddedToBlock(this);
}
HBasicBlock.prototype.addAtExit = function(instruction) {
  $assert(this.isClosed(), "isClosed()", "nodes.dart", 356, 12);
  $assert((this.last instanceof HControlFlow), "last is HControlFlow", "nodes.dart", 357, 12);
  $assert(!(instruction instanceof HPhi), "instruction is !HPhi", "nodes.dart", 358, 12);
  HInstructionList.prototype.addBefore.call(this, this.last, instruction);
  instruction.notifyAddedToBlock(this);
}
HBasicBlock.prototype.moveAtExit = function(instruction) {
  $assert(!(instruction instanceof HPhi), "instruction is !HPhi", "nodes.dart", 364, 12);
  $assert(instruction.isInBasicBlock(), "instruction.isInBasicBlock()", "nodes.dart", 365, 12);
  $assert(this.isClosed(), "isClosed()", "nodes.dart", 366, 12);
  $assert((this.last instanceof HControlFlow), "last is HControlFlow", "nodes.dart", 367, 12);
  HInstructionList.prototype.addBefore.call(this, this.last, instruction);
  instruction.block = this;
  $assert(this.isValid(), "isValid()", "nodes.dart", 370, 12);
}
HBasicBlock.prototype.add = function(instruction) {
  $assert(!(instruction instanceof HControlFlow), "instruction is !HControlFlow", "nodes.dart", 374, 12);
  $assert(!(instruction instanceof HPhi), "instruction is !HPhi", "nodes.dart", 375, 12);
  HInstructionList.prototype.addAfter.call(this, this.last, instruction);
  instruction.notifyAddedToBlock(this);
}
HBasicBlock.prototype.addPhi = function(phi) {
  this.phis.addAfter(this.phis.last, phi);
  phi.notifyAddedToBlock(this);
}
HBasicBlock.prototype.removePhi = function(phi) {
  this.phis.remove(phi);
  phi.notifyRemovedFromBlock(this);
}
HBasicBlock.prototype.addAfter = function(cursor, instruction) {
  $assert(!(cursor instanceof HPhi), "cursor is !HPhi", "nodes.dart", 391, 12);
  $assert(!(instruction instanceof HPhi), "instruction is !HPhi", "nodes.dart", 392, 12);
  $assert($notnull_bool(this.isOpen()) || $notnull_bool(this.isClosed()), "isOpen() || isClosed()", "nodes.dart", 393, 12);
  HInstructionList.prototype.addAfter.call(this, cursor, instruction);
  instruction.notifyAddedToBlock(this);
}
HBasicBlock.prototype.addBefore = function(cursor, instruction) {
  $assert(!(cursor instanceof HPhi), "cursor is !HPhi", "nodes.dart", 399, 12);
  $assert(!(instruction instanceof HPhi), "instruction is !HPhi", "nodes.dart", 400, 12);
  $assert($notnull_bool(this.isOpen()) || $notnull_bool(this.isClosed()), "isOpen() || isClosed()", "nodes.dart", 401, 12);
  HInstructionList.prototype.addBefore.call(this, cursor, instruction);
  instruction.notifyAddedToBlock(this);
}
HBasicBlock.prototype.remove = function(instruction) {
  $assert($notnull_bool(this.isOpen()) || $notnull_bool(this.isClosed()), "isOpen() || isClosed()", "nodes.dart", 407, 12);
  $assert(!(instruction instanceof HPhi), "instruction is !HPhi", "nodes.dart", 408, 12);
  HInstructionList.prototype.remove.call(this, instruction);
  instruction.notifyRemovedFromBlock(this);
}
HBasicBlock.prototype.addSuccessor = function(block) {
  $assert($notnull_bool(this.isClosed()) && ($notnull_bool(block.isNew()) || block.id < this.id), "isClosed() && (block.isNew() || block.id < id)", "nodes.dart", 415, 12);
  if (this.successors.isEmpty()) {
    this.successors = [block];
  }
  else {
    this.successors.add(block);
  }
  block.predecessors.add(this);
}
HBasicBlock.prototype.postProcessLoopHeader = function() {
  var $0;
  $assert(this.isLoopHeader(), "isLoopHeader()", "nodes.dart", 425, 12);
  for (var i = 1, length = this.predecessors.length;
   i < length; i++) {
    this.loopInformation.addBackEdge((($0 = this.predecessors.$index(i)) == null ? null : $0.assert$HBasicBlock()));
  }
}
HBasicBlock.prototype.rewrite = function(from, to) {
  var $list = from.usedBy;
  for (var $i = 0;$i < $list.length; $i++) {
    var use = $list.$index($i);
    HBasicBlock.rewriteInput(use, from, to);
  }
  to.usedBy.addAll(from.usedBy);
  from.usedBy.clear();
}
HBasicBlock.rewriteInput = function(instruction, from, to) {
  var inputs = instruction.inputs;
  for (var i = 0;
   i < inputs.length; i++) {
    if (inputs.$index(i) === from) inputs.$setindex(i, to);
  }
}
HBasicBlock.prototype.isExitBlock = function() {
  return this.first === this.last && (this.first instanceof HExit);
}
HBasicBlock.prototype.addDominatedBlock = function(block) {
  $assert(this.isClosed(), "isClosed()", "nodes.dart", 459, 12);
  $assert(this.id != null && block.id != null, "id !== null && block.id !== null", "nodes.dart", 460, 12);
  $assert(this.dominatedBlocks.indexOf(block) < 0, "dominatedBlocks.indexOf(block) < 0", "nodes.dart", 461, 12);
  var index = this.dominatedBlocks.length;
  while (index > 0 && this.dominatedBlocks.$index(index - 1).get$id() > block.id) {
    index--;
  }
  if (index == this.dominatedBlocks.length) {
    this.dominatedBlocks.add(block);
  }
  else {
    this.dominatedBlocks.insertRange(index, 1, block);
  }
  $assert(block.dominator == null, "block.dominator === null", "nodes.dart", 474, 12);
  block.dominator = this;
}
HBasicBlock.prototype.removeDominatedBlock = function(block) {
  $assert(this.isClosed(), "isClosed()", "nodes.dart", 479, 12);
  $assert(this.id != null && block.id != null, "id !== null && block.id !== null", "nodes.dart", 480, 12);
  var index = this.dominatedBlocks.indexOf(block);
  $assert(index >= 0, "index >= 0", "nodes.dart", 482, 12);
  if (index == this.dominatedBlocks.length - 1) {
    this.dominatedBlocks.removeLast();
  }
  else {
    this.dominatedBlocks.removeRange(index, 1);
  }
  $assert(block.dominator === this, "block.dominator === this", "nodes.dart", 488, 12);
  block.dominator = null;
}
HBasicBlock.prototype.assignCommonDominator = function(predecessor) {
  $assert(this.isClosed(), "isClosed()", "nodes.dart", 493, 12);
  if (this.dominator == null) {
    predecessor.addDominatedBlock(this);
  }
  else if (predecessor.dominator != null) {
    var first = this.dominator;
    var second = predecessor;
    while (first !== second) {
      if (first.id > second.id) {
        first = first.dominator;
      }
      else {
        second = second.dominator;
      }
      $assert(first != null && second != null, "first !== null && second !== null", "nodes.dart", 510, 16);
    }
    if (this.dominator !== first) {
      this.dominator.removeDominatedBlock(this);
      first.addDominatedBlock(this);
    }
  }
}
HBasicBlock.prototype.forEachPhi = function(f) {
  var $0;
  var current = (($0 = this.phis.first) == null ? null : $0.assert$HPhi());
  while (current != null) {
    f(current);
    current = (($0 = current.next) == null ? null : $0.assert$HPhi());
  }
}
HBasicBlock.prototype.isValid = function() {
  $assert(this.isClosed(), "isClosed()", "nodes.dart", 528, 12);
  var validator = new HValidator();
  validator.visitBasicBlock(this);
  return validator.isValid;
}
HBasicBlock.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HBasicBlock.prototype.add$1 = function($0) {
  return this.add(($0 == null ? null : $0.assert$HInstruction()));
};
HBasicBlock.prototype.forEachPhi$1 = function($0) {
  return this.forEachPhi(to$call$1($0));
};
HBasicBlock.prototype.isExitBlock$0 = HBasicBlock.prototype.isExitBlock;
HBasicBlock.prototype.remove$1 = function($0) {
  return this.remove(($0 == null ? null : $0.assert$HInstruction()));
};
HBasicBlock.prototype.removePhi$1 = function($0) {
  return this.removePhi(($0 == null ? null : $0.assert$HPhi()));
};
HBasicBlock.prototype.rewrite$2 = function($0, $1) {
  return this.rewrite(($0 == null ? null : $0.assert$HInstruction()), ($1 == null ? null : $1.assert$HInstruction()));
};
// ********** Code for HLoopInformation **************
function HLoopInformation(header) {
  this.header = header;
  this.blocks = new ListFactory();
  this.backEdges = new ListFactory();
  // Initializers done
}
HLoopInformation.prototype.addBackEdge = function(predecessor) {
  this.backEdges.add(predecessor);
  this.addBlock(predecessor);
}
HLoopInformation.prototype.addBlock = function(block) {
  var $0;
  if (block === this.header) return;
  var parentHeader = block.parentLoopHeader;
  if (parentHeader === this.header) {
  }
  else if (parentHeader != null) {
    this.addBlock(parentHeader);
  }
  else {
    block.parentLoopHeader = this.header;
    this.blocks.add(block);
    for (var i = 0, length = block.predecessors.length;
     i < length; i++) {
      this.addBlock((($0 = block.predecessors.$index(i)) == null ? null : $0.assert$HBasicBlock()));
    }
  }
}
HLoopInformation.prototype.getLastBackEdge = function() {
  var $0;
  var maxId = -1;
  var result = null;
  for (var i = 0, length = this.backEdges.length;
   i < length; i++) {
    var current = (($0 = this.backEdges.$index(i)) == null ? null : $0.assert$HBasicBlock());
    if (current.id > maxId) {
      maxId = current.id;
      result = current;
    }
  }
  return result;
}
// ********** Code for HInstruction **************
function HInstruction(inputs) {
  this.previous = null
  this.next = null
  this.flags = 0
  this.type = 0/*HInstruction.TYPE_UNKNOWN*/
  this.inputs = inputs;
  this.id = $globals.HInstruction_idCounter++;
  this.usedBy = [];
  // Initializers done
}
HInstruction.prototype.assert$HInstruction = function(){return this};
HInstruction.prototype.get$id = function() { return this.id; };
HInstruction.prototype.get$inputs = function() { return this.inputs; };
HInstruction.prototype.get$usedBy = function() { return this.usedBy; };
HInstruction.prototype.get$previous = function() { return this.previous; };
HInstruction.prototype.set$previous = function(value) { return this.previous = value; };
HInstruction.prototype.get$type = function() { return this.type; };
HInstruction.prototype.set$type = function(value) { return this.type = value; };
HInstruction.prototype.hashCode = function() {
  return this.id;
}
HInstruction.prototype.getFlag = function(position) {
  return (this.flags & (1 << position)) != 0;
}
HInstruction.prototype.setFlag = function(position) {
  this.flags |= (1 << position);
}
HInstruction.prototype.clearFlag = function(position) {
  this.flags &= ~(1 << position);
}
HInstruction.computeDependsOnFlags = function(flags) {
  return flags << 1/*HInstruction.FLAG_CHANGES_COUNT*/;
}
HInstruction.prototype.getChangesFlags = function() {
  return this.flags & (1)/*((1 << FLAG_CHANGES_COUNT) - 1)*/;
}
HInstruction.prototype.hasSideEffects = function() {
  return this.getChangesFlags() != 0;
}
HInstruction.prototype.prepareGvn = function() {
  this.setAllSideEffects();
}
HInstruction.prototype.setAllSideEffects = function() {
  this.flags |= (1)/*((1 << FLAG_CHANGES_COUNT) - 1)*/;
}
HInstruction.prototype.generateAtUseSite = function() {
  return this.getFlag(2/*HInstruction.FLAG_GENERATE_AT_USE_SITE*/);
}
HInstruction.prototype.setGenerateAtUseSite = function() {
  this.setFlag(2/*HInstruction.FLAG_GENERATE_AT_USE_SITE*/);
}
HInstruction.prototype.clearGenerateAtUseSite = function() {
  this.clearFlag(2/*HInstruction.FLAG_GENERATE_AT_USE_SITE*/);
}
HInstruction.prototype.useGvn = function() {
  return this.getFlag(3/*HInstruction.FLAG_USE_GVN*/);
}
HInstruction.prototype.setUseGvn = function() {
  this.setFlag(3/*HInstruction.FLAG_USE_GVN*/);
}
HInstruction.prototype.isUnknown = function() {
  return this.type == 0/*HInstruction.TYPE_UNKNOWN*/ || this.type == 4/*HInstruction.TYPE_CONFLICT*/;
}
HInstruction.prototype.isBoolean = function() {
  return this.type == 1/*HInstruction.TYPE_BOOLEAN*/;
}
HInstruction.prototype.isNumber = function() {
  return this.type == 2/*HInstruction.TYPE_NUMBER*/;
}
HInstruction.prototype.isString = function() {
  return this.type == 3/*HInstruction.TYPE_STRING*/;
}
HInstruction.prototype.get$isString = function() {
  return HInstruction.prototype.isString.bind(this);
}
HInstruction.prototype.computeType = function() {
  return this.computeDesiredType();
}
HInstruction.prototype.computeDesiredType = function() {
  var candidateType = 0/*HInstruction.TYPE_UNKNOWN*/;
  var $list = this.usedBy;
  for (var $i = 0;$i < $list.length; $i++) {
    var user = $list.$index($i);
    var type = $assert_num(user.computeDesiredInputType$1(this));
    if (candidateType == 0/*HInstruction.TYPE_UNKNOWN*/) {
      candidateType = type;
    }
    else if (type != 0/*HInstruction.TYPE_UNKNOWN*/ && candidateType != type) {
      candidateType = 0/*HInstruction.TYPE_UNKNOWN*/;
      break;
    }
  }
  return candidateType;
}
HInstruction.prototype.computeDesiredInputType = function(input) {
  return 0/*HInstruction.TYPE_UNKNOWN*/;
}
HInstruction.prototype.hasExpectedType = function() {
  return false;
}
HInstruction.prototype.computeInputsType = function() {
  var seenUnknown = false;
  var candidateType = -1;
  for (var i = 0, length = this.inputs.length;
   i < length; i++) {
    var inputType = $assert_num(this.inputs.$index(i).get$type());
    if (inputType == 0/*HInstruction.TYPE_UNKNOWN*/) {
      seenUnknown = true;
    }
    else if (candidateType == -1) {
      candidateType = inputType;
    }
    else if (candidateType != inputType) {
      return 4/*HInstruction.TYPE_CONFLICT*/;
    }
  }
  if ($notnull_bool(seenUnknown)) return 0/*HInstruction.TYPE_UNKNOWN*/;
  return candidateType;
}
HInstruction.prototype.updateType = function() {
  if (this.type == 4/*HInstruction.TYPE_CONFLICT*/) return false;
  var newType = this.computeType();
  var changed = (this.type != newType);
  if (this.type == 0/*HInstruction.TYPE_UNKNOWN*/) {
    this.type = newType;
    return changed;
  }
  else if ($notnull_bool(changed)) {
    this.type = 4/*HInstruction.TYPE_CONFLICT*/;
    return changed;
  }
  return false;
}
HInstruction.prototype.isInBasicBlock = function() {
  return this.block != null;
}
HInstruction.prototype.equals = function(other) {
  $assert($notnull_bool(this.useGvn()) && $notnull_bool(other.useGvn()), "useGvn() && other.useGvn()", "nodes.dart", 724, 12);
  if (!$notnull_bool(this.typeEquals(other))) return false;
  if (this.flags != other.flags) return false;
  var inputsLength = this.inputs.length;
  var otherInputs = other.inputs;
  if (inputsLength != otherInputs.length) return false;
  for (var i = 0;
   i < inputsLength; i++) {
    if (this.inputs.$index(i) !== otherInputs.$index(i)) return false;
  }
  return $assert_bool(this.dataEquals$1(other));
}
HInstruction.prototype.typeEquals = function(other) {
  return false;
}
HInstruction.prototype.dataEquals = function(other) {
  return false;
}
HInstruction.prototype.notifyAddedToBlock = function(block) {
  $assert(!$notnull_bool(this.isInBasicBlock()), "!isInBasicBlock()", "nodes.dart", 747, 12);
  $assert(this.block == null, "this.block === null", "nodes.dart", 748, 12);
  for (var i = 0;
   i < this.inputs.length; i++) {
    $assert(this.inputs.$index(i).isInBasicBlock$0(), "inputs[i].isInBasicBlock()", "nodes.dart", 751, 14);
    this.inputs.$index(i).get$usedBy().add$1(this);
  }
  this.block = block;
  $assert(this.isValid(), "isValid()", "nodes.dart", 755, 12);
}
HInstruction.prototype.notifyRemovedFromBlock = function(block) {
  var $0;
  $assert(this.isInBasicBlock(), "isInBasicBlock()", "nodes.dart", 759, 12);
  $assert(this.usedBy.isEmpty(), "usedBy.isEmpty()", "nodes.dart", 760, 12);
  $assert(this.block === block, "this.block === block", "nodes.dart", 761, 12);
  for (var i = 0;
   i < this.inputs.length; i++) {
    var inputUsedBy = (($0 = this.inputs.$index(i).get$usedBy()) == null ? null : $0.assert$List());
    for (var j = 0;
     j < inputUsedBy.length; j++) {
      if (inputUsedBy.$index(j) === this) {
        inputUsedBy.$setindex(j, inputUsedBy.$index(inputUsedBy.length - 1));
        inputUsedBy.removeLast();
        break;
      }
    }
  }
  this.block = null;
  $assert(this.isValid(), "isValid()", "nodes.dart", 775, 12);
}
HInstruction.prototype.isLiteralNull = function() {
  return false;
}
HInstruction.prototype.isLiteralNumber = function() {
  return false;
}
HInstruction.prototype.isLiteralString = function() {
  return false;
}
HInstruction.prototype.isValid = function() {
  var validator = new HValidator();
  validator.currentBlock = this.block;
  validator.visitInstruction(this);
  return validator.isValid;
}
HInstruction.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HInstruction.prototype.block$0 = function() {
  return this.block();
};
HInstruction.prototype.clearGenerateAtUseSite$0 = HInstruction.prototype.clearGenerateAtUseSite;
HInstruction.prototype.computeDesiredInputType$1 = function($0) {
  return this.computeDesiredInputType(($0 == null ? null : $0.assert$HInstruction()));
};
HInstruction.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
HInstruction.prototype.hashCode$0 = HInstruction.prototype.hashCode;
HInstruction.prototype.isInBasicBlock$0 = HInstruction.prototype.isInBasicBlock;
HInstruction.prototype.isLiteralNumber$0 = HInstruction.prototype.isLiteralNumber;
HInstruction.prototype.isLiteralString$0 = HInstruction.prototype.isLiteralString;
HInstruction.prototype.isNumber$0 = HInstruction.prototype.isNumber;
HInstruction.prototype.isString$0 = HInstruction.prototype.isString;
HInstruction.prototype.isUnknown$0 = HInstruction.prototype.isUnknown;
HInstruction.prototype.next$0 = function() {
  return this.next();
};
HInstruction.prototype.setGenerateAtUseSite$0 = HInstruction.prototype.setGenerateAtUseSite;
// ********** Code for HBoolify **************
function HBoolify(value) {
  // Initializers done
  HInstruction.call(this, [value]);
}
$inherits(HBoolify, HInstruction);
HBoolify.prototype.prepareGvn = function() {
  $assert(!$notnull_bool(this.hasSideEffects()), "!hasSideEffects()", "nodes.dart", 793, 12);
  this.setUseGvn();
}
HBoolify.prototype.computeType = function() {
  return 1/*HInstruction.TYPE_BOOLEAN*/;
}
HBoolify.prototype.hasExpectedType = function() {
  return true;
}
HBoolify.prototype.accept = function(visitor) {
  return visitor.visitBoolify(this);
}
HBoolify.prototype.typeEquals = function(other) {
  return (other instanceof HBoolify);
}
HBoolify.prototype.dataEquals = function(other) {
  return true;
}
HBoolify.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HBoolify.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HTypeGuard **************
function HTypeGuard(type, value) {
  // Initializers done
  HInstruction.call(this, [value]);
  this.type = $assert_num(type);
}
$inherits(HTypeGuard, HInstruction);
HTypeGuard.prototype.assert$HTypeGuard = function(){return this};
HTypeGuard.prototype.prepareGvn = function() {
  $assert(!$notnull_bool(this.hasSideEffects()), "!hasSideEffects()", "nodes.dart", 811, 12);
  this.setUseGvn();
}
HTypeGuard.prototype.computeType = function() {
  return this.type;
}
HTypeGuard.prototype.hasExpectedType = function() {
  return true;
}
HTypeGuard.prototype.accept = function(visitor) {
  return visitor.visitTypeGuard(this);
}
HTypeGuard.prototype.typeEquals = function(other) {
  return (other instanceof HTypeGuard);
}
HTypeGuard.prototype.dataEquals = function(other) {
  return this.type == other.type;
}
HTypeGuard.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HTypeGuard.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HTypeGuard()));
};
// ********** Code for HConditionalBranch **************
function HConditionalBranch(inputs) {
  // Initializers done
  HControlFlow.call(this, inputs);
}
$inherits(HConditionalBranch, HControlFlow);
HConditionalBranch.prototype.toString$0 = HConditionalBranch.prototype.toString;
// ********** Code for HControlFlow **************
function HControlFlow(inputs) {
  // Initializers done
  HInstruction.call(this, inputs);
}
$inherits(HControlFlow, HInstruction);
HControlFlow.prototype.toString$0 = HControlFlow.prototype.toString;
// ********** Code for HInvoke **************
function HInvoke(element, inputs) {
  this.element = element;
  // Initializers done
  HInstruction.call(this, inputs);
}
$inherits(HInvoke, HInstruction);
HInvoke.prototype.get$element = function() { return this.element; };
HInvoke.prototype.toString = function() {
  return ('invoke: ' + this.element.name);
}
HInvoke.prototype.accept = function(visitor) {
  return visitor.visitInvoke(this);
}
HInvoke.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HInvoke.prototype.toString$0 = HInvoke.prototype.toString;
// ********** Code for HForeign **************
function HForeign(inputs, code) {
  this.code = code;
  // Initializers done
  HInstruction.call(this, inputs);
}
$inherits(HForeign, HInstruction);
HForeign.prototype.get$code = function() { return this.code; };
HForeign.prototype.accept = function(visitor) {
  return visitor.visitForeign(this);
}
HForeign.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
// ********** Code for HArithmetic **************
function HArithmetic(element, inputs) {
  this.builtin = false
  // Initializers done
  HInvoke.call(this, element, inputs);
}
$inherits(HArithmetic, HInvoke);
HArithmetic.prototype.prepareGvn = function() {
  if ($notnull_bool(this.builtin)) {
    $assert(!$notnull_bool(this.hasSideEffects()), "!hasSideEffects()", "nodes.dart", 855, 14);
    this.setUseGvn();
  }
  else {
    this.setAllSideEffects();
  }
}
HArithmetic.prototype.computeType = function() {
  var type = this.computeInputsType();
  this.builtin = (type == 2/*HInstruction.TYPE_NUMBER*/);
  if ($notnull_bool(this.inputs.$index(0).isNumber$0())) return 2/*HInstruction.TYPE_NUMBER*/;
  if (type != 0/*HInstruction.TYPE_UNKNOWN*/) return type;
  return HInstruction.prototype.computeType.call(this);
}
HArithmetic.prototype.computeDesiredInputType = function(input) {
  return $notnull_bool(this.inputs.$index(0).isNumber$0()) ? 2/*HInstruction.TYPE_NUMBER*/ : 0/*HInstruction.TYPE_UNKNOWN*/;
}
HArithmetic.prototype.hasExpectedType = function() {
  return this.type == 2/*HInstruction.TYPE_NUMBER*/;
}
HArithmetic.prototype.computeDesiredInputType$1 = function($0) {
  return this.computeDesiredInputType(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HBinaryArithmetic **************
function HBinaryArithmetic(element, left, right) {
  // Initializers done
  HArithmetic.call(this, element, [left, right]);
}
$inherits(HBinaryArithmetic, HArithmetic);
HBinaryArithmetic.prototype.fold = function() {
  var $0;
  if ($notnull_bool(this.inputs.$index(0).isLiteralNumber$0()) && $notnull_bool(this.inputs.$index(1).isLiteralNumber$0())) {
    var op1 = (($0 = this.inputs.$index(0)) == null ? null : $0.assert$HLiteral());
    var op2 = (($0 = this.inputs.$index(1)) == null ? null : $0.assert$HLiteral());
    return new HLiteral(this.evaluate($assert_num(op1.value), $assert_num(op2.value)));
  }
  return this;
}
// ********** Code for HAdd **************
function HAdd(element, left, right) {
  // Initializers done
  HBinaryArithmetic.call(this, element, left, right);
}
$inherits(HAdd, HBinaryArithmetic);
HAdd.prototype.accept = function(visitor) {
  return visitor.visitAdd(this);
}
HAdd.prototype.evaluate = function(a, b) {
  return a + b;
}
HAdd.prototype.typeEquals = function(other) {
  return (other instanceof HAdd);
}
HAdd.prototype.dataEquals = function(other) {
  return true;
}
HAdd.prototype.computeType = function() {
  var type = this.computeInputsType();
  this.builtin = (type == 2/*HInstruction.TYPE_NUMBER*/ || type == 3/*HInstruction.TYPE_STRING*/);
  if ($notnull_bool(this.inputs.$index(0).isNumber$0())) return 2/*HInstruction.TYPE_NUMBER*/;
  if ($notnull_bool(this.inputs.$index(0).isString$0())) return 3/*HInstruction.TYPE_STRING*/;
  return 0/*HInstruction.TYPE_UNKNOWN*/;
}
HAdd.prototype.computeDesiredInputType = function(input) {
  if ($notnull_bool(this.inputs.$index(0).isString$0())) return 3/*HInstruction.TYPE_STRING*/;
  if ($notnull_bool(this.inputs.$index(0).isNumber$0())) return 2/*HInstruction.TYPE_NUMBER*/;
  return 0/*HInstruction.TYPE_UNKNOWN*/;
}
HAdd.prototype.hasExpectedType = function() {
  if ($notnull_bool(this.inputs.$index(0).isNumber$0())) return this.type == 2/*HInstruction.TYPE_NUMBER*/;
  if ($notnull_bool(this.inputs.$index(0).isString$0())) return this.type == 3/*HInstruction.TYPE_STRING*/;
  return this.type == 0/*HInstruction.TYPE_UNKNOWN*/;
}
HAdd.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HAdd.prototype.computeDesiredInputType$1 = function($0) {
  return this.computeDesiredInputType(($0 == null ? null : $0.assert$HInstruction()));
};
HAdd.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HDivide **************
function HDivide(element, left, right) {
  // Initializers done
  HBinaryArithmetic.call(this, element, left, right);
}
$inherits(HDivide, HBinaryArithmetic);
HDivide.prototype.accept = function(visitor) {
  return visitor.visitDivide(this);
}
HDivide.prototype.evaluate = function(a, b) {
  return a / b;
}
HDivide.prototype.typeEquals = function(other) {
  return (other instanceof HDivide);
}
HDivide.prototype.dataEquals = function(other) {
  return true;
}
HDivide.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HDivide.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HModulo **************
function HModulo(element, left, right) {
  // Initializers done
  HBinaryArithmetic.call(this, element, left, right);
}
$inherits(HModulo, HBinaryArithmetic);
HModulo.prototype.accept = function(visitor) {
  return visitor.visitModulo(this);
}
HModulo.prototype.evaluate = function(a, b) {
  return $mod(a, b);
}
HModulo.prototype.typeEquals = function(other) {
  return (other instanceof HModulo);
}
HModulo.prototype.dataEquals = function(other) {
  return true;
}
HModulo.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HModulo.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HMultiply **************
function HMultiply(element, left, right) {
  // Initializers done
  HBinaryArithmetic.call(this, element, left, right);
}
$inherits(HMultiply, HBinaryArithmetic);
HMultiply.prototype.accept = function(visitor) {
  return visitor.visitMultiply(this);
}
HMultiply.prototype.evaluate = function(a, b) {
  return a * b;
}
HMultiply.prototype.typeEquals = function(other) {
  return (other instanceof HMultiply);
}
HMultiply.prototype.dataEquals = function(other) {
  return true;
}
HMultiply.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HMultiply.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HSubtract **************
function HSubtract(element, left, right) {
  // Initializers done
  HBinaryArithmetic.call(this, element, left, right);
}
$inherits(HSubtract, HBinaryArithmetic);
HSubtract.prototype.accept = function(visitor) {
  return visitor.visitSubtract(this);
}
HSubtract.prototype.evaluate = function(a, b) {
  return a - b;
}
HSubtract.prototype.typeEquals = function(other) {
  return (other instanceof HSubtract);
}
HSubtract.prototype.dataEquals = function(other) {
  return true;
}
HSubtract.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HSubtract.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HTruncatingDivide **************
function HTruncatingDivide(element, left, right) {
  // Initializers done
  HBinaryArithmetic.call(this, element, left, right);
}
$inherits(HTruncatingDivide, HBinaryArithmetic);
HTruncatingDivide.prototype.accept = function(visitor) {
  return visitor.visitTruncatingDivide(this);
}
HTruncatingDivide.prototype.fold = function() {
  if ($notnull_bool(this.inputs.$index(1).isLiteralNumber$0()) && $notnull_bool($eq(this.inputs.$index(1).get$dynamic().get$value(), 0))) {
    return this;
  }
  return HBinaryArithmetic.prototype.fold.call(this);
}
HTruncatingDivide.prototype.evaluate = function(a, b) {
  return $truncdiv(a, b);
}
HTruncatingDivide.prototype.typeEquals = function(other) {
  return (other instanceof HTruncatingDivide);
}
HTruncatingDivide.prototype.dataEquals = function(other) {
  return true;
}
HTruncatingDivide.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HTruncatingDivide.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HBinaryBitOp **************
function HBinaryBitOp(element, left, right) {
  // Initializers done
  HBinaryArithmetic.call(this, element, left, right);
}
$inherits(HBinaryBitOp, HBinaryArithmetic);
HBinaryBitOp.prototype.fold = function() {
  var $0;
  if ($notnull_bool(this.inputs.$index(0).isLiteralNumber$0()) && $notnull_bool(this.inputs.$index(1).isLiteralNumber$0())) {
    var op1 = (($0 = this.inputs.$index(0)) == null ? null : $0.assert$HLiteral());
    var op2 = (($0 = this.inputs.$index(1)) == null ? null : $0.assert$HLiteral());
    if ((typeof(op1.value) == 'number') && (typeof(op2.value) == 'number')) {
      return new HLiteral(this.evaluate($assert_num(op1.value), $assert_num(op2.value)));
    }
  }
  return this;
}
// ********** Code for HShiftLeft **************
function HShiftLeft(element, left, right) {
  // Initializers done
  HBinaryBitOp.call(this, element, left, right);
}
$inherits(HShiftLeft, HBinaryBitOp);
HShiftLeft.prototype.accept = function(visitor) {
  return visitor.visitShiftLeft(this);
}
HShiftLeft.prototype.fold = function() {
  var $0;
  if ($notnull_bool(this.inputs.$index(1).isLiteralNumber$0())) {
    var MAX_SHIFT_LEFT_AMOUNT = 50;
    var op2 = (($0 = this.inputs.$index(1)) == null ? null : $0.assert$HLiteral());
    if (op2.value < 0 || op2.value > MAX_SHIFT_LEFT_AMOUNT) return this;
  }
  return HBinaryBitOp.prototype.fold.call(this);
}
HShiftLeft.prototype.evaluate = function(a, b) {
  return a << b;
}
HShiftLeft.prototype.typeEquals = function(other) {
  return (other instanceof HShiftLeft);
}
HShiftLeft.prototype.dataEquals = function(other) {
  return true;
}
HShiftLeft.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HShiftLeft.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HShiftRight **************
function HShiftRight(element, left, right) {
  // Initializers done
  HBinaryBitOp.call(this, element, left, right);
}
$inherits(HShiftRight, HBinaryBitOp);
HShiftRight.prototype.accept = function(visitor) {
  return visitor.visitShiftRight(this);
}
HShiftRight.prototype.fold = function() {
  var $0;
  if ($notnull_bool(this.inputs.$index(1).isLiteralNumber$0())) {
    var op2 = (($0 = this.inputs.$index(1)) == null ? null : $0.assert$HLiteral());
    if (op2.value < 0) return this;
  }
  return HBinaryBitOp.prototype.fold.call(this);
}
HShiftRight.prototype.evaluate = function(a, b) {
  return a >> b;
}
HShiftRight.prototype.typeEquals = function(other) {
  return (other instanceof HShiftRight);
}
HShiftRight.prototype.dataEquals = function(other) {
  return true;
}
HShiftRight.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HShiftRight.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HBitOr **************
function HBitOr(element, left, right) {
  // Initializers done
  HBinaryBitOp.call(this, element, left, right);
}
$inherits(HBitOr, HBinaryBitOp);
HBitOr.prototype.accept = function(visitor) {
  return visitor.visitBitOr(this);
}
HBitOr.prototype.evaluate = function(a, b) {
  return a | b;
}
HBitOr.prototype.typeEquals = function(other) {
  return (other instanceof HBitOr);
}
HBitOr.prototype.dataEquals = function(other) {
  return true;
}
HBitOr.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HBitOr.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HBitAnd **************
function HBitAnd(element, left, right) {
  // Initializers done
  HBinaryBitOp.call(this, element, left, right);
}
$inherits(HBitAnd, HBinaryBitOp);
HBitAnd.prototype.accept = function(visitor) {
  return visitor.visitBitAnd(this);
}
HBitAnd.prototype.evaluate = function(a, b) {
  return a & b;
}
HBitAnd.prototype.typeEquals = function(other) {
  return (other instanceof HBitAnd);
}
HBitAnd.prototype.dataEquals = function(other) {
  return true;
}
HBitAnd.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HBitAnd.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HBitXor **************
function HBitXor(element, left, right) {
  // Initializers done
  HBinaryBitOp.call(this, element, left, right);
}
$inherits(HBitXor, HBinaryBitOp);
HBitXor.prototype.accept = function(visitor) {
  return visitor.visitBitXor(this);
}
HBitXor.prototype.evaluate = function(a, b) {
  return a ^ b;
}
HBitXor.prototype.typeEquals = function(other) {
  return (other instanceof HBitXor);
}
HBitXor.prototype.dataEquals = function(other) {
  return true;
}
HBitXor.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HBitXor.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HUnaryArithmetic **************
function HUnaryArithmetic(element, input) {
  // Initializers done
  HArithmetic.call(this, element, [input]);
}
$inherits(HUnaryArithmetic, HArithmetic);
// ********** Code for HNegate **************
function HNegate(element, input) {
  // Initializers done
  HUnaryArithmetic.call(this, element, input);
}
$inherits(HNegate, HUnaryArithmetic);
HNegate.prototype.accept = function(visitor) {
  return visitor.visitNegate(this);
}
HNegate.prototype.fold = function() {
  var $0;
  if ($notnull_bool(this.inputs.$index(0).isLiteralNumber$0())) {
    var input = (($0 = this.inputs.$index(0)) == null ? null : $0.assert$HLiteral());
    return new HLiteral(this.evaluate($assert_num(input.value)));
  }
  return this;
}
HNegate.prototype.evaluate = function(a) {
  return -a;
}
HNegate.prototype.typeEquals = function(other) {
  return (other instanceof HNegate);
}
HNegate.prototype.dataEquals = function(other) {
  return true;
}
HNegate.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HNegate.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HBitNot **************
function HBitNot(element, input) {
  // Initializers done
  HUnaryArithmetic.call(this, element, input);
}
$inherits(HBitNot, HUnaryArithmetic);
HBitNot.prototype.accept = function(visitor) {
  return visitor.visitBitNot(this);
}
HBitNot.prototype.fold = function() {
  var $0;
  if ($notnull_bool(this.inputs.$index(0).isLiteralNumber$0())) {
    var input = (($0 = this.inputs.$index(0)) == null ? null : $0.assert$HLiteral());
    if ((typeof(input.value) == 'number')) return new HLiteral(this.evaluate($assert_num(input.value)));
  }
  return this;
}
HBitNot.prototype.evaluate = function(a) {
  return ~a;
}
HBitNot.prototype.typeEquals = function(other) {
  return (other instanceof HBitNot);
}
HBitNot.prototype.dataEquals = function(other) {
  return true;
}
HBitNot.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HBitNot.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HExit **************
function HExit() {
  // Initializers done
  HControlFlow.call(this, const$21/*const []*/);
}
$inherits(HExit, HControlFlow);
HExit.prototype.toString = function() {
  return 'exit';
}
HExit.prototype.accept = function(visitor) {
  return visitor.visitExit(this);
}
HExit.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HExit.prototype.toString$0 = HExit.prototype.toString;
// ********** Code for HGoto **************
function HGoto() {
  // Initializers done
  HControlFlow.call(this, const$21/*const []*/);
}
$inherits(HGoto, HControlFlow);
HGoto.prototype.toString = function() {
  return 'goto';
}
HGoto.prototype.accept = function(visitor) {
  return visitor.visitGoto(this);
}
HGoto.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HGoto.prototype.toString$0 = HGoto.prototype.toString;
// ********** Code for HIf **************
function HIf(condition, hasElse) {
  this.hasElse = hasElse;
  // Initializers done
  HConditionalBranch.call(this, [condition]);
}
$inherits(HIf, HConditionalBranch);
HIf.prototype.toString = function() {
  return 'if';
}
HIf.prototype.accept = function(visitor) {
  return visitor.visitIf(this);
}
HIf.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HIf.prototype.toString$0 = HIf.prototype.toString;
// ********** Code for HLoopBranch **************
function HLoopBranch(condition) {
  // Initializers done
  HConditionalBranch.call(this, [condition]);
}
$inherits(HLoopBranch, HConditionalBranch);
HLoopBranch.prototype.toString = function() {
  return 'loop-branch';
}
HLoopBranch.prototype.accept = function(visitor) {
  return visitor.visitLoopBranch(this);
}
HLoopBranch.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HLoopBranch.prototype.toString$0 = HLoopBranch.prototype.toString;
// ********** Code for HLiteral **************
function HLiteral(value) {
  this.value = value;
  // Initializers done
  HInstruction.call(this, []);
}
$inherits(HLiteral, HInstruction);
HLiteral.prototype.assert$HLiteral = function(){return this};
HLiteral.prototype.get$value = function() { return this.value; };
HLiteral.prototype.prepareGvn = function() {
  $assert(!$notnull_bool(this.hasSideEffects()), "!hasSideEffects()", "nodes.dart", 1139, 12);
  this.setUseGvn();
  this.setGenerateAtUseSite();
}
HLiteral.prototype.toString = function() {
  return ('literal: ' + this.value);
}
HLiteral.prototype.accept = function(visitor) {
  return visitor.visitLiteral(this);
}
HLiteral.prototype.computeType = function() {
  if ($notnull_bool(this.isLiteralNumber())) {
    return 2/*HInstruction.TYPE_NUMBER*/;
  }
  else if ($notnull_bool(this.isLiteralBoolean())) {
    return 1/*HInstruction.TYPE_BOOLEAN*/;
  }
  else if ($notnull_bool(this.isLiteralString())) {
    return 3/*HInstruction.TYPE_STRING*/;
  }
  else {
    return 0/*HInstruction.TYPE_UNKNOWN*/;
  }
}
HLiteral.prototype.hasExpectedType = function() {
  return true;
}
HLiteral.prototype.isLiteralBoolean = function() {
  return (typeof(this.value) == 'boolean');
}
HLiteral.prototype.isLiteralNull = function() {
  return this.value == null;
}
HLiteral.prototype.isLiteralNumber = function() {
  return (typeof(this.value) == 'number');
}
HLiteral.prototype.isLiteralString = function() {
  var $0;
  return !!(($0 = this.value) && $0.is$SourceString());
}
HLiteral.prototype.typeEquals = function(other) {
  return (other instanceof HLiteral);
}
HLiteral.prototype.dataEquals = function(other) {
  return $assert_bool($eq(this.value, other.value));
}
HLiteral.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HLiteral.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HLiteral()));
};
HLiteral.prototype.isLiteralNumber$0 = HLiteral.prototype.isLiteralNumber;
HLiteral.prototype.isLiteralString$0 = HLiteral.prototype.isLiteralString;
HLiteral.prototype.toString$0 = HLiteral.prototype.toString;
// ********** Code for HNot **************
function HNot(value) {
  // Initializers done
  HInstruction.call(this, [value]);
}
$inherits(HNot, HInstruction);
HNot.prototype.prepareGvn = function() {
  $assert(!$notnull_bool(this.hasSideEffects()), "!hasSideEffects()", "nodes.dart", 1171, 12);
  this.setUseGvn();
}
HNot.prototype.computeType = function() {
  return 1/*HInstruction.TYPE_BOOLEAN*/;
}
HNot.prototype.hasExpectedType = function() {
  return true;
}
HNot.prototype.accept = function(visitor) {
  return visitor.visitNot(this);
}
HNot.prototype.typeEquals = function(other) {
  return (other instanceof HNot);
}
HNot.prototype.dataEquals = function(other) {
  return true;
}
HNot.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HNot.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HParameterValue **************
function HParameterValue(element) {
  this.element = element;
  // Initializers done
  HInstruction.call(this, []);
  this.setGenerateAtUseSite();
}
$inherits(HParameterValue, HInstruction);
HParameterValue.prototype.assert$HParameterValue = function(){return this};
HParameterValue.prototype.get$element = function() { return this.element; };
HParameterValue.prototype.prepareGvn = function() {
  $assert(!$notnull_bool(this.hasSideEffects()), "!hasSideEffects()", "nodes.dart", 1191, 12);
}
HParameterValue.prototype.toString = function() {
  return ('parameter ' + this.element.name);
}
HParameterValue.prototype.accept = function(visitor) {
  return visitor.visitParameterValue(this);
}
HParameterValue.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HParameterValue.prototype.toString$0 = HParameterValue.prototype.toString;
// ********** Code for HPhi **************
function HPhi() {}
HPhi.singleInput$ctor = function(element, input) {
  this.element = element;
  // Initializers done
  HInstruction.call(this, [input]);
}
HPhi.singleInput$ctor.prototype = HPhi.prototype;
HPhi.manyInputs$ctor = function(element, inputs) {
  this.element = element;
  // Initializers done
  HInstruction.call(this, inputs);
}
HPhi.manyInputs$ctor.prototype = HPhi.prototype;
$inherits(HPhi, HInstruction);
HPhi.prototype.assert$HPhi = function(){return this};
HPhi.prototype.get$element = function() { return this.element; };
HPhi.prototype.addInput = function(input) {
  $assert(this.isInBasicBlock(), "isInBasicBlock()", "nodes.dart", 1208, 12);
  this.inputs.add(input);
  input.usedBy.add(this);
}
HPhi.prototype.computeType = function() {
  var type = this.computeInputsType();
  if (type != 0/*HInstruction.TYPE_UNKNOWN*/) return type;
  return HInstruction.prototype.computeType.call(this);
}
HPhi.prototype.computeDesiredInputType = function(input) {
  return this.type;
}
HPhi.prototype.hasExpectedType = function() {
  for (var i = 0;
   i < this.inputs.length; i++) {
    if (this.inputs.$index(i).get$type() !== this.type) return false;
  }
  return true;
}
HPhi.prototype.updateTypeForLoopPhi = function() {
  $assert(this.block.isLoopHeader(), "block.isLoopHeader()", "nodes.dart", 1231, 12);
  if ($notnull_bool(this.inputs.$index(0).isUnknown$0())) return false;
  this.type = $assert_num(this.inputs.$index(0).get$type());
  return true;
}
HPhi.prototype.toString = function() {
  return 'phi';
}
HPhi.prototype.accept = function(visitor) {
  return visitor.visitPhi(this);
}
HPhi.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HPhi.prototype.computeDesiredInputType$1 = function($0) {
  return this.computeDesiredInputType(($0 == null ? null : $0.assert$HInstruction()));
};
HPhi.prototype.toString$0 = HPhi.prototype.toString;
// ********** Code for HRelational **************
function HRelational(element, left, right) {
  this.builtin = false
  // Initializers done
  HInvoke.call(this, element, [left, right]);
}
$inherits(HRelational, HInvoke);
HRelational.prototype.prepareGvn = function() {
  if ($notnull_bool(this.builtin)) {
    $assert(!$notnull_bool(this.hasSideEffects()), "!hasSideEffects()", "nodes.dart", 1251, 14);
    this.setUseGvn();
  }
  else {
    this.setAllSideEffects();
  }
}
HRelational.prototype.computeType = function() {
  this.builtin = this.computeInputsType() == 2/*HInstruction.TYPE_NUMBER*/;
  if ($notnull_bool(this.inputs.$index(0).isNumber$0())) return 1/*HInstruction.TYPE_BOOLEAN*/;
  if (this.type != 0/*HInstruction.TYPE_UNKNOWN*/) return this.type;
  return HInstruction.prototype.computeType.call(this);
}
HRelational.prototype.computeDesiredInputType = function(input) {
  return $notnull_bool(this.inputs.$index(0).isNumber$0()) ? 2/*HInstruction.TYPE_NUMBER*/ : 0/*HInstruction.TYPE_UNKNOWN*/;
}
HRelational.prototype.hasExpectedType = function() {
  return this.type == 1/*HInstruction.TYPE_BOOLEAN*/;
}
HRelational.prototype.computeDesiredInputType$1 = function($0) {
  return this.computeDesiredInputType(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HEquals **************
function HEquals(element, left, right) {
  // Initializers done
  HRelational.call(this, element, left, right);
}
$inherits(HEquals, HRelational);
HEquals.prototype.evaluate = function(a, b) {
  return a == b;
}
HEquals.prototype.accept = function(visitor) {
  return visitor.visitEquals(this);
}
HEquals.prototype.typeEquals = function(other) {
  return (other instanceof HEquals);
}
HEquals.prototype.dataEquals = function(other) {
  return true;
}
HEquals.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HEquals.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HGreater **************
function HGreater(element, left, right) {
  // Initializers done
  HRelational.call(this, element, left, right);
}
$inherits(HGreater, HRelational);
HGreater.prototype.evaluate = function(a, b) {
  return a > b;
}
HGreater.prototype.accept = function(visitor) {
  return visitor.visitGreater(this);
}
HGreater.prototype.typeEquals = function(other) {
  return (other instanceof HGreater);
}
HGreater.prototype.dataEquals = function(other) {
  return true;
}
HGreater.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HGreater.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HGreaterEqual **************
function HGreaterEqual(element, left, right) {
  // Initializers done
  HRelational.call(this, element, left, right);
}
$inherits(HGreaterEqual, HRelational);
HGreaterEqual.prototype.evaluate = function(a, b) {
  return a >= b;
}
HGreaterEqual.prototype.accept = function(visitor) {
  return visitor.visitGreaterEqual(this);
}
HGreaterEqual.prototype.typeEquals = function(other) {
  return (other instanceof HGreaterEqual);
}
HGreaterEqual.prototype.dataEquals = function(other) {
  return true;
}
HGreaterEqual.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HGreaterEqual.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HLess **************
function HLess(element, left, right) {
  // Initializers done
  HRelational.call(this, element, left, right);
}
$inherits(HLess, HRelational);
HLess.prototype.evaluate = function(a, b) {
  return a < b;
}
HLess.prototype.accept = function(visitor) {
  return visitor.visitLess(this);
}
HLess.prototype.typeEquals = function(other) {
  return (other instanceof HLess);
}
HLess.prototype.dataEquals = function(other) {
  return true;
}
HLess.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HLess.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HLessEqual **************
function HLessEqual(element, left, right) {
  // Initializers done
  HRelational.call(this, element, left, right);
}
$inherits(HLessEqual, HRelational);
HLessEqual.prototype.evaluate = function(a, b) {
  return a <= b;
}
HLessEqual.prototype.accept = function(visitor) {
  return visitor.visitLessEqual(this);
}
HLessEqual.prototype.typeEquals = function(other) {
  return (other instanceof HLessEqual);
}
HLessEqual.prototype.dataEquals = function(other) {
  return true;
}
HLessEqual.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HLessEqual.prototype.dataEquals$1 = function($0) {
  return this.dataEquals(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HReturn **************
function HReturn(value) {
  // Initializers done
  HControlFlow.call(this, [value]);
}
$inherits(HReturn, HControlFlow);
HReturn.prototype.toString = function() {
  return 'return';
}
HReturn.prototype.accept = function(visitor) {
  return visitor.visitReturn(this);
}
HReturn.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HReturn.prototype.toString$0 = HReturn.prototype.toString;
// ********** Code for HThrow **************
function HThrow(value) {
  // Initializers done
  HControlFlow.call(this, [value]);
}
$inherits(HThrow, HControlFlow);
HThrow.prototype.toString = function() {
  return 'throw';
}
HThrow.prototype.accept = function(visitor) {
  return visitor.visitThrow(this);
}
HThrow.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HThrow.prototype.toString$0 = HThrow.prototype.toString;
// ********** Code for HNonSsaInstruction **************
function HNonSsaInstruction(inputs) {
  // Initializers done
  HInstruction.call(this, inputs);
}
$inherits(HNonSsaInstruction, HInstruction);
HNonSsaInstruction.prototype.prepareGvn = function() {
  unreachable();
}
HNonSsaInstruction.prototype.useGvn = function() {
  unreachable();
}
// ********** Code for HLoad **************
function HLoad(local, type) {
  // Initializers done
  HNonSsaInstruction.call(this, [local]);
  this.type = $assert_num(type);
}
$inherits(HLoad, HNonSsaInstruction);
HLoad.prototype.get$local = function() {
  var $0;
  return (($0 = this.inputs.$index(0)) == null ? null : $0.assert$HLocal());
}
HLoad.prototype.toString = function() {
  return 'load';
}
HLoad.prototype.accept = function(visitor) {
  return visitor.visitLoad(this);
}
HLoad.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HLoad.prototype.toString$0 = HLoad.prototype.toString;
// ********** Code for HStore **************
function HStore(local, value) {
  // Initializers done
  HNonSsaInstruction.call(this, [local, value]);
}
$inherits(HStore, HNonSsaInstruction);
HStore.prototype.get$local = function() {
  var $0;
  return (($0 = this.inputs.$index(0)) == null ? null : $0.assert$HLocal());
}
HStore.prototype.get$value = function() {
  var $0;
  return (($0 = this.inputs.$index(1)) == null ? null : $0.assert$HInstruction());
}
HStore.prototype.toString = function() {
  return 'store';
}
HStore.prototype.accept = function(visitor) {
  return visitor.visitStore(this);
}
HStore.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HStore.prototype.toString$0 = HStore.prototype.toString;
// ********** Code for HLocal **************
function HLocal(element) {
  this.element = element;
  // Initializers done
  HNonSsaInstruction.call(this, []);
  this.declaredBy = this;
}
$inherits(HLocal, HNonSsaInstruction);
HLocal.prototype.assert$HLocal = function(){return this};
HLocal.prototype.get$element = function() { return this.element; };
HLocal.prototype.set$element = function(value) { return this.element = value; };
HLocal.prototype.toString = function() {
  return 'local';
}
HLocal.prototype.accept = function(visitor) {
  return visitor.visitLocal(this);
}
HLocal.prototype.accept$1 = function($0) {
  return this.accept(($0 == null ? null : $0.assert$HVisitor()));
};
HLocal.prototype.toString$0 = HLocal.prototype.toString;
// ********** Code for SsaOptimizerTask **************
function SsaOptimizerTask(compiler) {
  // Initializers done
  CompilerTask.call(this, compiler);
}
$inherits(SsaOptimizerTask, CompilerTask);
SsaOptimizerTask.prototype.get$name = function() {
  return 'SSA optimizer';
}
SsaOptimizerTask.prototype.optimize = function(graph) {
  var $this = this; // closure support
  this.measure((function () {
    new SsaTypePropagator().visitGraph(graph);
    new SsaConstantFolder().visitGraph(graph);
    new SsaRedundantPhiEliminator().visitGraph(graph);
    new SsaDeadPhiEliminator().visitGraph(graph);
    new SsaGlobalValueNumberer($this.compiler).visitGraph(graph);
    new SsaCodeMotion().visitGraph(graph);
    new SsaDeadCodeEliminator().visitGraph(graph);
    new SsaInstructionMerger().visitGraph(graph);
  })
  );
}
// ********** Code for SsaConstantFolder **************
function SsaConstantFolder() {
  // Initializers done
  HBaseVisitor.call(this);
}
$inherits(SsaConstantFolder, HBaseVisitor);
SsaConstantFolder.prototype.visitGraph = function(graph) {
  this.visitDominatorTree(graph);
}
SsaConstantFolder.prototype.visitBasicBlock = function(block) {
  var $0;
  var instruction = block.first;
  while (instruction != null) {
    var next = instruction.next;
    var replacement = (($0 = instruction.accept(this)) == null ? null : $0.assert$HInstruction());
    if (replacement !== instruction) {
      if (!$notnull_bool(replacement.isInBasicBlock())) {
        block.addAfter(instruction, replacement);
      }
      block.rewrite(instruction, replacement);
      block.remove(instruction);
    }
    instruction = next;
  }
}
SsaConstantFolder.prototype.visitInstruction = function(node) {
  return node;
}
SsaConstantFolder.prototype.visitBoolify = function(node) {
  var $0;
  var inputs = node.inputs;
  $assert(inputs.length == 1, "inputs.length == 1", "optimize.dart", 57, 12);
  var input = (($0 = inputs.$index(0)) == null ? null : $0.assert$HInstruction());
  if ($notnull_bool(input.isBoolean())) return input;
  if (!$notnull_bool(input.isUnknown())) return new HLiteral(false);
  return node;
}
SsaConstantFolder.prototype.visitNot = function(node) {
  var $0;
  var inputs = node.inputs;
  $assert(inputs.length == 1, "inputs.length == 1", "optimize.dart", 67, 12);
  var input = (($0 = inputs.$index(0)) == null ? null : $0.assert$HInstruction());
  if ((input instanceof HLiteral)) {
    var literal = (input == null ? null : input.assert$HLiteral());
    return new HLiteral(literal.value !== true);
  }
  return node;
}
SsaConstantFolder.prototype.visitArithmetic = function(node) {
  return node.fold();
}
SsaConstantFolder.prototype.visitAdd = function(node) {
  var $0;
  if ($notnull_bool(node.inputs.$index(0).isLiteralString$0()) && (node.inputs.$index(1) instanceof HLiteral)) {
    var op1 = (($0 = node.inputs.$index(0)) == null ? null : $0.assert$HLiteral());
    var op2 = (($0 = node.inputs.$index(1)) == null ? null : $0.assert$HLiteral());
    return new HLiteral(new StringWrapper(("" + op1.value + " + " + op2.value)));
  }
  return this.visitArithmetic(node);
}
SsaConstantFolder.prototype.visitRelational = function(node) {
  var $0;
  var inputs = node.inputs;
  $assert(inputs.length == 2, "inputs.length == 2", "optimize.dart", 94, 12);
  if ($notnull_bool(inputs.$index(0).isLiteralNumber$0()) && $notnull_bool(inputs.$index(1).isLiteralNumber$0())) {
    var op1 = (($0 = inputs.$index(0)) == null ? null : $0.assert$HLiteral());
    var op2 = (($0 = inputs.$index(1)) == null ? null : $0.assert$HLiteral());
    var folded = node.evaluate($assert_num(op1.value), $assert_num(op2.value));
    return new HLiteral(folded);
  }
  return node;
}
SsaConstantFolder.prototype.visitEquals = function(node) {
  var $0;
  var inputs = node.inputs;
  if ((inputs.$index(0) instanceof HLiteral) && (inputs.$index(1) instanceof HLiteral)) {
    var op1 = (($0 = inputs.$index(0)) == null ? null : $0.assert$HLiteral());
    var op2 = (($0 = inputs.$index(1)) == null ? null : $0.assert$HLiteral());
    return new HLiteral($eq(op1.value, op2.value));
  }
  return node;
}
SsaConstantFolder.prototype.visitTypeGuard = function(node) {
  var $0;
  var value = (($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction());
  return (($0 = (value.type == node.type) ? value : node) == null ? null : $0.assert$HInstruction());
}
// ********** Code for SsaTypePropagator **************
function SsaTypePropagator() {
  this.workmap = new HashMapImplementation();
  this.worklist = new ListFactory();
  // Initializers done
  HGraphVisitor.call(this);
}
$inherits(SsaTypePropagator, HGraphVisitor);
SsaTypePropagator.prototype.visitGraph = function(graph) {
  this.visitDominatorTree(graph);
  this.processWorklist();
  new TypeGuardInserter().visitGraph(graph);
}
SsaTypePropagator.prototype.visitBasicBlock = function(block) {
  var $this = this; // closure support
  if ($notnull_bool(block.isLoopHeader())) {
    block.forEachPhi((function (phi) {
      if ($notnull_bool(phi.updateTypeForLoopPhi())) $this.addToWorklist(phi);
    })
    );
  }
  else {
    block.forEachPhi((function (phi) {
      if ($notnull_bool(phi.updateType())) $this.addUsersAndInputsToWorklist(phi);
    })
    );
  }
  var instruction = block.first;
  while (instruction != null) {
    if ($notnull_bool(instruction.updateType())) this.addUsersAndInputsToWorklist(instruction);
    instruction = instruction.next;
  }
}
SsaTypePropagator.prototype.processWorklist = function() {
  var $0;
  while (!this.worklist.isEmpty()) {
    var id = $assert_num(this.worklist.removeLast());
    var instruction = (($0 = this.workmap.$index(id)) == null ? null : $0.assert$HInstruction());
    $assert(instruction != null, "instruction !== null", "optimize.dart", 157, 14);
    this.workmap.remove(id);
    if ($notnull_bool(instruction.updateType())) this.addUsersAndInputsToWorklist(instruction);
  }
}
SsaTypePropagator.prototype.addUsersAndInputsToWorklist = function(instruction) {
  var $0;
  for (var i = 0, length = instruction.usedBy.length;
   i < length; i++) {
    this.addToWorklist((($0 = instruction.usedBy.$index(i)) == null ? null : $0.assert$HInstruction()));
  }
  for (var i = 0, length = instruction.inputs.length;
   i < length; i++) {
    this.addToWorklist((($0 = instruction.inputs.$index(i)) == null ? null : $0.assert$HInstruction()));
  }
}
SsaTypePropagator.prototype.addToWorklist = function(instruction) {
  var id = instruction.id;
  if (!this.workmap.containsKey(id)) {
    this.worklist.add(id);
    this.workmap.$setindex(id, instruction);
  }
}
// ********** Code for TypeGuardInserter **************
function TypeGuardInserter() {
  // Initializers done
  HGraphVisitor.call(this);
}
$inherits(TypeGuardInserter, HGraphVisitor);
TypeGuardInserter.prototype.visitGraph = function(graph) {
  this.visitDominatorTree(graph);
}
TypeGuardInserter.prototype.visitBasicBlock = function(block) {
  var instruction = block.phis.first;
  while (instruction != null) {
    instruction = this.tryInsertGuard(instruction, block.first);
  }
  instruction = block.first;
  while (instruction != null) {
    instruction = this.tryInsertGuard(instruction, instruction);
  }
}
TypeGuardInserter.prototype.tryInsertGuard = function(instruction, insertionPoint) {
  if (!$notnull_bool(instruction.isUnknown()) && !$notnull_bool(instruction.hasExpectedType())) {
    var guard = new HTypeGuard(instruction.type, instruction);
    instruction.type = 0/*HInstruction.TYPE_UNKNOWN*/;
    instruction.block.rewrite(instruction, guard);
    insertionPoint.block.addAfter(insertionPoint, guard);
    return guard.next;
  }
  return instruction.next;
}
// ********** Code for SsaDeadCodeEliminator **************
function SsaDeadCodeEliminator() {
  // Initializers done
  HGraphVisitor.call(this);
}
$inherits(SsaDeadCodeEliminator, HGraphVisitor);
SsaDeadCodeEliminator.isDeadCode = function(instruction) {
  return !$notnull_bool(instruction.hasSideEffects()) && instruction.usedBy.isEmpty();
}
SsaDeadCodeEliminator.prototype.visitGraph = function(graph) {
  this.visitPostDominatorTree(graph);
}
SsaDeadCodeEliminator.prototype.visitBasicBlock = function(block) {
  var instruction = block.last;
  while (instruction != null) {
    var previous = instruction.previous;
    if ($notnull_bool(SsaDeadCodeEliminator.isDeadCode(instruction))) block.remove(instruction);
    instruction = (previous == null ? null : previous.assert$HInstruction());
  }
}
// ********** Code for SsaDeadPhiEliminator **************
function SsaDeadPhiEliminator() {
  // Initializers done
}
SsaDeadPhiEliminator.prototype.visitGraph = function(graph) {
  var $0;
  var worklist = [];
  var livePhis = new HashSetImplementation();
  var $list = graph.blocks;
  for (var $i = 0;$i < $list.length; $i++) {
    var block = $list.$index($i);
    block.forEachPhi$1((function (phi) {
      var $list0 = phi.usedBy;
      for (var $i0 = 0;$i0 < $list0.length; $i0++) {
        var user = $list0.$index($i0);
        if (!(user instanceof HPhi)) {
          worklist.add(phi);
          livePhis.add(phi);
          break;
        }
      }
    })
    );
  }
  while (!worklist.isEmpty()) {
    var phi = (($0 = worklist.removeLast()) == null ? null : $0.assert$HPhi());
    var $list = phi.inputs;
    for (var $i = 0;$i < $list.length; $i++) {
      var input = $list.$index($i);
      if ((input instanceof HPhi) && !livePhis.contains(input)) {
        worklist.add(input);
        livePhis.add(input);
      }
    }
  }
  var $list = graph.blocks;
  for (var $i = 0;$i < $list.length; $i++) {
    var block = $list.$index($i);
    var current = (($0 = block.get$phis().get$first()) == null ? null : $0.assert$HPhi());
    var next = null;
    while (current != null) {
      next = (($0 = current.next) == null ? null : $0.assert$HPhi());
      if (!livePhis.contains(current)) block.removePhi$1(current);
      current = next;
    }
  }
}
// ********** Code for SsaRedundantPhiEliminator **************
function SsaRedundantPhiEliminator() {
  // Initializers done
}
SsaRedundantPhiEliminator.prototype.visitGraph = function(graph) {
  var $0;
  var worklist = [];
  var $list = graph.blocks;
  for (var $i = 0;$i < $list.length; $i++) {
    var block = $list.$index($i);
    block.forEachPhi$1((function (phi) {
      return worklist.add(phi);
    })
    );
  }
  while (!worklist.isEmpty()) {
    var phi = (($0 = worklist.removeLast()) == null ? null : $0.assert$HPhi());
    if (!$notnull_bool(phi.isInBasicBlock())) continue;
    $assert(phi.inputs.$index(0) !== phi, "phi.inputs[0] !== phi", "optimize.dart", 296, 14);
    var candidate = (($0 = phi.inputs.$index(0)) == null ? null : $0.assert$HInstruction());
    for (var i = 1;
     i < phi.inputs.length; i++) {
      var input = (($0 = phi.inputs.$index(i)) == null ? null : $0.assert$HInstruction());
      if (input !== candidate && input !== phi) {
        candidate = null;
        break;
      }
    }
    if (candidate == null) continue;
    var $list = phi.usedBy;
    for (var $i = 0;$i < $list.length; $i++) {
      var user = $list.$index($i);
      if ((user instanceof HPhi)) worklist.add(user);
    }
    phi.block.rewrite(phi, candidate);
    phi.block.removePhi(phi);
  }
}
// ********** Code for SsaGlobalValueNumberer **************
function SsaGlobalValueNumberer(compiler) {
  this.compiler = compiler;
  this.visited = new HashSetImplementation();
  // Initializers done
}
SsaGlobalValueNumberer.prototype.visitGraph = function(graph) {
  this.computeChangesFlags(graph);
  this.moveLoopInvariantCode(graph);
  this.visitBasicBlock(graph.entry, new ValueSet());
}
SsaGlobalValueNumberer.prototype.moveLoopInvariantCode = function(graph) {
  var $0;
  for (var i = graph.blocks.length - 1;
   i >= 0; i--) {
    var block = (($0 = graph.blocks.$index(i)) == null ? null : $0.assert$HBasicBlock());
    if ($notnull_bool(block.isLoopHeader())) {
      var changesFlags = $assert_num(this.loopChangesFlags.$index(block.id));
      var last = block.loopInformation.getLastBackEdge();
      for (var j = block.id;
       j <= last.id; j++) {
        this.moveLoopInvariantCodeFromBlock((($0 = graph.blocks.$index(j)) == null ? null : $0.assert$HBasicBlock()), block, changesFlags);
      }
    }
  }
}
SsaGlobalValueNumberer.prototype.moveLoopInvariantCodeFromBlock = function(block, loopHeader, changesFlags) {
  var $0;
  var preheader = (($0 = loopHeader.predecessors.$index(0)) == null ? null : $0.assert$HBasicBlock());
  var dependsFlags = HInstruction.computeDependsOnFlags(changesFlags);
  var instruction = block.first;
  while (instruction != null) {
    var next = instruction.next;
    if ($notnull_bool(instruction.useGvn()) && (instruction.flags & dependsFlags) == 0) {
      var loopInvariantInputs = true;
      var inputs = instruction.inputs;
      for (var i = 0, length = inputs.length;
       i < length; i++) {
        if ($notnull_bool(this.isInputDefinedAfterDominator((($0 = inputs.$index(i)) == null ? null : $0.assert$HInstruction()), preheader))) {
          loopInvariantInputs = false;
          break;
        }
      }
      if ($notnull_bool(loopInvariantInputs)) {
        block.detach(instruction);
        preheader.moveAtExit(instruction);
      }
    }
    instruction = next;
  }
}
SsaGlobalValueNumberer.prototype.isInputDefinedAfterDominator = function(input, dominator) {
  return input.block.id > dominator.id;
}
SsaGlobalValueNumberer.prototype.visitBasicBlock = function(block, values) {
  var $0;
  var instruction = block.first;
  while (instruction != null) {
    var next = instruction.next;
    var flags = instruction.getChangesFlags();
    if (flags != 0) {
      $assert(!$notnull_bool(instruction.useGvn()), "!instruction.useGvn()", "optimize.dart", 391, 16);
      values.kill(flags);
    }
    else if ($notnull_bool(instruction.useGvn())) {
      var other = values.lookup(instruction);
      if (other != null) {
        $assert($notnull_bool(other.equals(instruction)) && $notnull_bool(instruction.equals(other)), "other.equals(instruction) && instruction.equals(other)", "optimize.dart", 396, 18);
        block.rewrite(instruction, other);
        block.remove(instruction);
      }
      else {
        values.add(instruction);
      }
    }
    instruction = next;
  }
  var dominatedBlocks = block.dominatedBlocks;
  for (var i = 0, length = dominatedBlocks.length;
   i < length; i++) {
    var dominated = (($0 = dominatedBlocks.$index(i)) == null ? null : $0.assert$HBasicBlock());
    var successorValues = (i == length - 1) ? values : values.copy();
    $assert(block.id < dominated.id, "block.id < dominated.id", "optimize.dart", 416, 14);
    if (!$notnull_bool(successorValues.isEmpty()) && block.id + 1 < dominated.id) {
      this.visited.clear();
      var changesFlags = this.getChangesFlagsForDominatedBlock(block, dominated);
      successorValues.kill(changesFlags);
    }
    this.visitBasicBlock(dominated, successorValues);
  }
}
SsaGlobalValueNumberer.prototype.computeChangesFlags = function(graph) {
  var $0, $1;
  var length = graph.blocks.length;
  this.blockChangesFlags = new ListFactory(length);
  this.loopChangesFlags = new ListFactory(length);
  for (var i = 0;
   i < length; i++) this.loopChangesFlags.$setindex(i, 0);
  for (var i = length - 1;
   i >= 0; i--) {
    var block = (($0 = graph.blocks.$index(i)) == null ? null : $0.assert$HBasicBlock());
    var id = block.id;
    var changesFlags = 0;
    var instruction = block.first;
    while (instruction != null) {
      instruction.prepareGvn();
      changesFlags |= instruction.getChangesFlags();
      instruction = instruction.next;
    }
    $assert(this.blockChangesFlags.$index(id) == null, "blockChangesFlags[id] === null", "optimize.dart", 449, 14);
    this.blockChangesFlags.$setindex(id, changesFlags);
    if ($notnull_bool(block.isLoopHeader())) {
      ($0 = this.loopChangesFlags).$setindex(id, $0.$index(id) | changesFlags);
    }
    var parentLoopHeader = block.parentLoopHeader;
    if (parentLoopHeader != null) {
      ($0 = this.loopChangesFlags).$setindex(($1 = parentLoopHeader.id), $0.$index($1) | $assert_num($notnull_bool((block.isLoopHeader())) ? this.loopChangesFlags.$index(id) : changesFlags));
    }
  }
}
SsaGlobalValueNumberer.prototype.getChangesFlagsForDominatedBlock = function(dominator, dominated) {
  var $0;
  var changesFlags = 0;
  var predecessors = dominated.predecessors;
  for (var i = 0, length = predecessors.length;
   i < length; i++) {
    var block = (($0 = predecessors.$index(i)) == null ? null : $0.assert$HBasicBlock());
    var id = block.id;
    if (dominator.id < id && id < dominated.id && !this.visited.contains(id)) {
      this.visited.add(id);
      changesFlags |= $assert_num(this.blockChangesFlags.$index(id));
      changesFlags |= this.getChangesFlagsForDominatedBlock(dominator, block);
    }
  }
  return changesFlags;
}
// ********** Code for SsaCodeMotion **************
function SsaCodeMotion() {
  // Initializers done
  HBaseVisitor.call(this);
}
$inherits(SsaCodeMotion, HBaseVisitor);
SsaCodeMotion.prototype.get$values = function() { return this.values; };
SsaCodeMotion.prototype.set$values = function(value) { return this.values = value; };
SsaCodeMotion.prototype.visitGraph = function(graph) {
  this.values = new ListFactory(graph.blocks.length);
  for (var i = 0;
   i < graph.blocks.length; i++) {
    this.values.$setindex(graph.blocks.$index(i).get$id(), new ValueSet());
  }
  this.visitPostDominatorTree(graph);
}
SsaCodeMotion.prototype.visitBasicBlock = function(block) {
  var $0;
  var successors = block.successors;
  if (successors.length != 0) {
    var instructions = (($0 = this.values.$index(successors.$index(0).get$id())) == null ? null : $0.assert$ValueSet());
    for (var i = 1;
     i < successors.length; i++) {
      var other = (($0 = this.values.$index(successors.$index(i).get$id())) == null ? null : $0.assert$ValueSet());
      instructions = instructions.intersection(other);
    }
    if (!$notnull_bool(instructions.isEmpty())) {
      var list = instructions.toList();
      for (var $i = 0;$i < list.length; $i++) {
        var instruction = list.$index($i);
        instruction.block.detach(instruction);
        block.moveAtExit(instruction);
        for (var $i0 = 0;$i0 < successors.length; $i0++) {
          var successor = successors.$index($i0);
          var toRewrite = (($0 = this.values.$index(successor.get$id()).lookup$1(instruction)) == null ? null : $0.assert$HInstruction());
          if ($ne(toRewrite, instruction)) {
            successor.rewrite$2(toRewrite, instruction);
            successor.remove$1(toRewrite);
          }
        }
      }
    }
  }
  if (block.predecessors.length != 1) return;
  var set_ = (($0 = this.values.$index(block.id)) == null ? null : $0.assert$ValueSet());
  var instruction = block.first;
  var flags = 0;
  while (instruction != null) {
    var dependsFlags = HInstruction.computeDependsOnFlags(flags);
    flags |= instruction.getChangesFlags();
    var current = instruction;
    instruction = instruction.next;
    if (!$notnull_bool(current.useGvn())) continue;
    if ((current.flags & dependsFlags) != 0) continue;
    var canBeMoved = true;
    var $list = current.inputs;
    for (var $i = 0;$i < $list.length; $i++) {
      var input = $list.$index($i);
      if ($eq(input.block, block)) {
        canBeMoved = false;
        break;
      }
    }
    if (!$notnull_bool(canBeMoved)) continue;
    set_.add(current);
  }
}
// ********** Code for SsaInstructionMerger **************
function SsaInstructionMerger() {
  this.markedByMerger = new HashSetImplementation();
  // Initializers done
  HInstructionVisitor.call(this);
}
$inherits(SsaInstructionMerger, HInstructionVisitor);
SsaInstructionMerger.prototype.visitGraph = function(graph) {
  this.visitDominatorTree(graph);
}
SsaInstructionMerger.prototype.typeGuardCheck = function(input) {
  var remarkTypeGuardInput = false;
  remarkTypeGuardInput = this.markedByMerger.contains(input.inputs.$index(0));
  if ($notnull_bool(remarkTypeGuardInput)) input.inputs.$index(0).clearGenerateAtUseSite$0();
  return remarkTypeGuardInput;
}
SsaInstructionMerger.prototype.visitInstruction = function(node) {
  var $0;
  if ((node instanceof HForeign)) return;
  var inputs = node.inputs;
  var previousUnused = node.previous;
  var i = inputs.length - 1;
  for (; i >= 0; i--) {
    if (previousUnused == null) break;
    var input = (($0 = inputs.$index(i)) == null ? null : $0.assert$HInstruction());
    if (input.usedBy.length != 1) break;
    if (input !== previousUnused) break;
    var remarkTypeGuardInput = false;
    if ((input instanceof HTypeGuard)) remarkTypeGuardInput = this.typeGuardCheck((input == null ? null : input.assert$HTypeGuard()));
    if (!$notnull_bool(input.generateAtUseSite())) {
      this.markedByMerger.add(input);
      input.setGenerateAtUseSite();
    }
    if ($notnull_bool(remarkTypeGuardInput)) input.inputs.$index(0).setGenerateAtUseSite$0();
    previousUnused = previousUnused.previous;
  }
  for (; i >= 0; i--) {
    var input = (($0 = inputs.$index(i)) == null ? null : $0.assert$HInstruction());
    if ((input instanceof HTypeGuard)) this.typeGuardCheck((input == null ? null : input.assert$HTypeGuard()));
  }
}
// ********** Code for SsaTypeGuardUnuser **************
function SsaTypeGuardUnuser() {
  // Initializers done
  HBaseVisitor.call(this);
}
$inherits(SsaTypeGuardUnuser, HBaseVisitor);
SsaTypeGuardUnuser.prototype.visitGraph = function(graph) {
  this.visitDominatorTree(graph);
}
SsaTypeGuardUnuser.prototype.visitTypeGuard = function(node) {
  var $0;
  if ($notnull_bool(node.generateAtUseSite())) return;
  this.currentBlock.rewrite(node, (($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
}
// ********** Code for SsaPhiEliminator **************
function SsaPhiEliminator() {
  // Initializers done
  HGraphVisitor.call(this);
}
$inherits(SsaPhiEliminator, HGraphVisitor);
SsaPhiEliminator.prototype.visitGraph = function(graph) {
  this.entry = graph.entry;
  this.namedLocals = new HashMapImplementation();
  this.visitDominatorTree(graph);
}
SsaPhiEliminator.prototype.addStore = function(predecessor, dominator, local, value) {
  var store = new HStore(local, value);
  var current = predecessor;
  do {
    if (value.block === current) {
      var insertBefore = null;
      if ((value instanceof HPhi)) {
        insertBefore = current.first;
      }
      else {
        insertBefore = value.next;
      }
      if ((insertBefore instanceof HStore) && insertBefore.get$dynamic().get$local() === local) {
        $assert(store.get$value() === value, "store.value === value", "phi_eliminator.dart", 39, 18);
        store = null;
      }
      else {
        current.addBefore(insertBefore, store);
      }
      if (value.usedBy.length == 2) {
        value.setGenerateAtUseSite();
      }
      return store;
    }
    current = current.dominator;
  }
  while ($ne(current, dominator) && !$notnull_bool(current.isLoopHeader()))
  $assert(store != null, "store !== null", "phi_eliminator.dart", 58, 12);
  predecessor.addAtExit(store);
  return store;
}
SsaPhiEliminator.prototype.visitBasicBlock = function(block) {
  var $0;
  this.currentBlock = block;
  var loads = [];
  var phi = (($0 = block.phis.first) == null ? null : $0.assert$HPhi());
  while (phi != null) {
    var next = (($0 = phi.next) == null ? null : $0.assert$HPhi());
    this.visitPhi(phi, loads);
    phi = next;
  }
}
SsaPhiEliminator.prototype.visitPhi = function(phi, loads) {
  var $this = this; // closure support
  var $0;
  $assert(phi != null, "phi !== null", "phi_eliminator.dart", 75, 12);
  var local;
  if (phi.element != null) {
    local = (($0 = this.namedLocals.putIfAbsent(phi.element, (function () {
      var local0 = new HLocal(phi.element);
      $this.entry.addAtEntry(local0);
      if (phi.element.kind === const$232/*ElementKind.PARAMETER*/) {
        $this.entry.detach(local0);
      }
      return local0;
    })
    )) == null ? null : $0.assert$HLocal());
  }
  else {
    local = new HLocal(null);
    this.entry.addAtEntry(local);
  }
  var predecessors = this.currentBlock.predecessors;
  var stores = [];
  for (var i = 0, len = predecessors.length;
   i < len; i++) {
    var value = (($0 = phi.inputs.$index(i)) == null ? null : $0.assert$HInstruction());
    if ((value instanceof HLoad) && value.get$dynamic().get$local() === local) continue;
    if (((value instanceof HPhi)) && (local.element != null) && (value.get$dynamic().get$element() === local.element)) continue;
    var store = this.addStore((($0 = predecessors.$index(i)) == null ? null : $0.assert$HBasicBlock()), this.currentBlock.dominator, local, value);
    if (store != null) {
      if (local.declaredBy === local) {
        var storeBlock = store.block;
        if (storeBlock === this.entry || storeBlock === this.entry.successors.$index(0)) {
          this.entry.detach(local);
          local.declaredBy = store;
        }
      }
      stores.add(store);
    }
  }
  var load = new HLoad(local, phi.type);
  loads.add(load);
  this.currentBlock.addAtEntry(load);
  this.currentBlock.rewrite(phi, load);
  this.currentBlock.removePhi(phi);
  if (!$notnull_bool(this.currentBlock.isLoopHeader()) || !$notnull_bool(this.hasLoopPhiAsInput(stores, loads))) {
    load.setGenerateAtUseSite();
  }
}
SsaPhiEliminator.prototype.hasLoopPhiAsInput = function(stores, loads) {
  $assert(this.currentBlock.isLoopHeader(), "currentBlock.isLoopHeader()", "phi_eliminator.dart", 146, 12);
  for (var $i = 0;$i < stores.length; $i++) {
    var store = stores.$index($i);
    var value = store.get$value();
    if ((value instanceof HPhi) && $eq(value.block, this.currentBlock)) {
      return true;
    }
    else if ((value instanceof HLoad) && loads.indexOf(value) != -1) {
      return true;
    }
  }
  return false;
}
// ********** Code for HTracer **************
function HTracer() {}
HTracer._internal$ctor = function() {
  this.indent = 0
  this.output = new StringBufferImpl("");
  // Initializers done
  HGraphVisitor.call(this);
}
HTracer._internal$ctor.prototype = HTracer.prototype;
$inherits(HTracer, HGraphVisitor);
HTracer.HTracer$singleton$factory = function() {
  if ($globals.HTracer__singleton == null) $globals.HTracer__singleton = new HTracer._internal$ctor();
  return $globals.HTracer__singleton;
}
HTracer.prototype.traceCompilation = function(methodName) {
  var $this = this; // closure support
  this.tag("compilation", (function () {
    $this.printProperty("name", methodName);
    $this.printProperty("method", methodName);
    $this.printProperty("date", new DateImplementation.now$ctor().value);
  })
  );
}
HTracer.prototype.traceGraph = function(name, graph) {
  var $this = this; // closure support
  this.tag("cfg", (function () {
    $this.printProperty("name", name);
    $this.visitDominatorTree(graph);
  })
  );
}
HTracer.prototype.addPredecessors = function(block) {
  if (block.predecessors.isEmpty()) {
    this.printEmptyProperty("predecessors");
  }
  else {
    this.addIndent();
    this.add("predecessors");
    var $list = block.predecessors;
    for (var $i = 0;$i < $list.length; $i++) {
      var predecessor = $list.$index($i);
      this.add((' "B' + predecessor.id + '"'));
    }
    this.add("\n");
  }
}
HTracer.prototype.addSuccessors = function(block) {
  if (block.successors.isEmpty()) {
    this.printEmptyProperty("successors");
  }
  else {
    this.addIndent();
    this.add("successors");
    var $list = block.successors;
    for (var $i = 0;$i < $list.length; $i++) {
      var successor = $list.$index($i);
      this.add((' "B' + successor.id + '"'));
    }
    this.add("\n");
  }
}
HTracer.prototype.addInstructions = function(stringifier, list) {
  for (var instruction = list.first;
   instruction != null; instruction = instruction.next) {
    var bci = 0;
    var uses = instruction.usedBy.length;
    this.addIndent();
    var temporaryId = stringifier.temporaryId(instruction);
    var instructionString = $assert_String(stringifier.visit(instruction));
    this.add(("" + bci + " " + uses + " " + temporaryId + " " + instructionString + " <|@\n"));
  }
}
HTracer.prototype.visitBasicBlock = function(block) {
  var $this = this; // closure support
  var stringifier = new HInstructionStringifier(block);
  $assert(block.id != null, "block.id !== null", "tracer.dart", 73, 12);
  this.tag("block", (function () {
    $this.printProperty("name", ("B" + block.id));
    $this.printProperty("from_bci", -1);
    $this.printProperty("to_bci", -1);
    $this.addPredecessors(block);
    $this.addSuccessors(block);
    $this.printEmptyProperty("xhandlers");
    $this.printEmptyProperty("flags");
    if (block.dominator != null) {
      $this.printProperty("dominator", ("B" + block.dominator.id));
    }
    $this.tag("states", (function () {
      $this.tag("locals", (function () {
        $this.printProperty("size", 0);
        $this.printProperty("method", "None");
        block.forEachPhi((function (phi) {
          var $0;
          var phiId = stringifier.temporaryId((phi == null ? null : phi.assert$HInstruction()));
          var inputId1 = stringifier.temporaryId((($0 = phi.get$inputs().$index(0)) == null ? null : $0.assert$HInstruction()));
          var inputId2 = stringifier.temporaryId((($0 = phi.get$inputs().$index(1)) == null ? null : $0.assert$HInstruction()));
          $this.print(("" + phi.get$id() + " " + phiId + " [ " + inputId1 + " " + inputId2 + " ]"));
        })
        );
      })
      );
    })
    );
    $this.tag("HIR", (function () {
      $this.addInstructions(stringifier, block.phis);
      $this.addInstructions(stringifier, block);
    })
    );
  })
  );
}
HTracer.prototype.tag = function(tagName, f) {
  this.print(("begin_" + tagName));
  this.indent++;
  f.call$0();
  this.indent--;
  this.print(("end_" + tagName));
}
HTracer.prototype.print = function(string) {
  this.addIndent();
  this.add(string);
  this.add("\n");
}
HTracer.prototype.printEmptyProperty = function(propertyName) {
  this.print(propertyName);
}
HTracer.prototype.printProperty = function(propertyName, value) {
  if ((typeof(value) == 'number')) {
    this.print(("" + propertyName + " " + value));
  }
  else {
    this.print(('' + propertyName + ' "' + value + '"'));
  }
}
HTracer.prototype.add = function(string) {
  this.output.add(string);
}
HTracer.prototype.addIndent = function() {
  for (var i = 0;
   i < this.indent; i++) {
    this.add("  ");
  }
}
HTracer.prototype.toString = function() {
  return this.output.toString();
}
HTracer.prototype.add$1 = function($0) {
  return this.add($assert_String($0));
};
HTracer.prototype.toString$0 = HTracer.prototype.toString;
// ********** Code for HInstructionStringifier **************
function HInstructionStringifier(currentBlock) {
  this.currentBlock = currentBlock;
  // Initializers done
}
HInstructionStringifier.prototype.assert$HVisitor = function(){return this};
HInstructionStringifier.prototype.visit = function(node) {
  return node.accept(this);
}
HInstructionStringifier.prototype.visitBasicBlock = function(node) {
  unreachable();
}
HInstructionStringifier.prototype.temporaryId = function(instruction) {
  var prefix;
  switch (instruction.type) {
    case 1/*HInstruction.TYPE_BOOLEAN*/:

      prefix = 'b';
      break;

    case 2/*HInstruction.TYPE_NUMBER*/:

      prefix = 'n';
      break;

    case 3/*HInstruction.TYPE_STRING*/:

      prefix = 's';
      break;

    case 0/*HInstruction.TYPE_UNKNOWN*/:

      prefix = 'v';
      break;

    case 4/*HInstruction.TYPE_CONFLICT*/:

      prefix = 'c';
      break;

    default:

      unreachable();

  }
  return ("" + prefix + instruction.id);
}
HInstructionStringifier.prototype.visitBoolify = function(node) {
  var $0;
  return ("Boolify: " + this.temporaryId((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction())));
}
HInstructionStringifier.prototype.visitAdd = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitBitAnd = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitBitNot = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitBitOr = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitBitXor = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitDivide = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitEquals = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitExit = function(node) {
  return "exit";
}
HInstructionStringifier.prototype.visitGoto = function(node) {
  var $0;
  var target = (($0 = this.currentBlock.successors.$index(0)) == null ? null : $0.assert$HBasicBlock());
  return ("Goto: (B" + target.id + ")");
}
HInstructionStringifier.prototype.visitGreater = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitGreaterEqual = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitIf = function(node) {
  var $0;
  var thenBlock = (($0 = this.currentBlock.successors.$index(0)) == null ? null : $0.assert$HBasicBlock());
  var elseBlock = (($0 = this.currentBlock.successors.$index(1)) == null ? null : $0.assert$HBasicBlock());
  var conditionId = this.temporaryId((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
  return ("If (" + conditionId + "): (B" + thenBlock.id + ") else (B" + elseBlock.id + ")");
}
HInstructionStringifier.prototype.visitGenericInvoke = function(invokeType, functionName, arguments) {
  var $0;
  var argumentsString = new StringBufferImpl("");
  for (var i = 0;
   i < arguments.length; i++) {
    if (i != 0) argumentsString.add(", ");
    argumentsString.add(this.temporaryId((($0 = arguments.$index(i)) == null ? null : $0.assert$HInstruction())));
  }
  return ("" + invokeType + ": " + functionName + "(" + argumentsString + ")");
}
HInstructionStringifier.prototype.visitInvoke = function(invoke) {
  var target = ("" + invoke.element.name);
  var arguments = invoke.inputs;
  return this.visitGenericInvoke("Invoke", target, arguments);
}
HInstructionStringifier.prototype.visitForeign = function(foreign) {
  return this.visitGenericInvoke("Foreign", ("" + foreign.code), foreign.inputs);
}
HInstructionStringifier.prototype.visitLess = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitLessEqual = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitLiteral = function(literal) {
  return ("Literal " + literal.value);
}
HInstructionStringifier.prototype.visitLoad = function(node) {
  var $0;
  return ("Load: " + this.temporaryId((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction())));
}
HInstructionStringifier.prototype.visitLocal = function(node) {
  if (node.element != null) {
    return ("Local: " + node.element.name.get$stringValue());
  }
  else {
    return "Local";
  }
}
HInstructionStringifier.prototype.visitLoopBranch = function(branch) {
  var $0;
  var bodyBlock = (($0 = this.currentBlock.successors.$index(0)) == null ? null : $0.assert$HBasicBlock());
  var exitBlock = (($0 = this.currentBlock.successors.$index(1)) == null ? null : $0.assert$HBasicBlock());
  var conditionId = this.temporaryId((($0 = branch.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
  return ("While (" + conditionId + "): (B" + bodyBlock.id + ") then (B" + exitBlock.id + ")");
}
HInstructionStringifier.prototype.visitModulo = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitMultiply = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitNegate = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitNot = function(node) {
  var $0;
  return ("Not: " + this.temporaryId((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction())));
}
HInstructionStringifier.prototype.visitParameterValue = function(node) {
  return ("p" + node.element.name);
}
HInstructionStringifier.prototype.visitPhi = function(phi) {
  var $0;
  return ("Phi(" + this.temporaryId((($0 = phi.inputs.$index(0)) == null ? null : $0.assert$HInstruction())) + ", " + this.temporaryId((($0 = phi.inputs.$index(1)) == null ? null : $0.assert$HInstruction())) + ")");
}
HInstructionStringifier.prototype.visitReturn = function(node) {
  var $0;
  return ("Return " + this.temporaryId((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction())));
}
HInstructionStringifier.prototype.visitShiftLeft = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitShiftRight = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitStore = function(node) {
  var $0;
  var localId = this.temporaryId((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction()));
  var valueId = this.temporaryId((($0 = node.inputs.$index(1)) == null ? null : $0.assert$HInstruction()));
  return ("Store: " + localId + " := " + valueId);
}
HInstructionStringifier.prototype.visitSubtract = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitThrow = function(node) {
  var $0;
  return ("Throw " + this.temporaryId((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction())));
}
HInstructionStringifier.prototype.visitTruncatingDivide = function(node) {
  return this.visitInvoke(node);
}
HInstructionStringifier.prototype.visitTypeGuard = function(node) {
  var $0;
  var type;
  switch (node.type) {
    case 1/*HInstruction.TYPE_BOOLEAN*/:

      type = "bool";
      break;

    case 2/*HInstruction.TYPE_NUMBER*/:

      type = "number";
      break;

    default:

      unreachable();

  }
  return ("TypeGuard: " + this.temporaryId((($0 = node.inputs.$index(0)) == null ? null : $0.assert$HInstruction())) + " is " + type);
}
HInstructionStringifier.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for HValidator **************
function HValidator() {
  this.isValid = true
  // Initializers done
  HInstructionVisitor.call(this);
}
$inherits(HValidator, HInstructionVisitor);
HValidator.prototype.visitGraph = function(graph) {
  this.graph = graph;
  this.visitDominatorTree(graph);
}
HValidator.prototype.markInvalid = function(reason) {
  print(reason);
  this.isValid = false;
}
HValidator.prototype.visitBasicBlock = function(block) {
  this.currentBlock = block;
  if (!$notnull_bool(this.isValid)) return;
  if (block.first == null || block.last == null) {
    this.markInvalid("empty block");
  }
  if (!(block.last instanceof HControlFlow)) {
    this.markInvalid("block ends with non-tail node.");
  }
  if ((block.last instanceof HIf) && block.successors.length != 2) {
    this.markInvalid("If node without two successors");
  }
  if ((block.last instanceof HConditionalBranch) && block.successors.length != 2) {
    this.markInvalid("Conditional node without two successors");
  }
  if ((block.last instanceof HGoto) && block.successors.length != 1) {
    this.markInvalid("Goto node without one successor");
  }
  if ((block.last instanceof HReturn) && (block.successors.length != 1 || !$notnull_bool(block.successors.$index(0).isExitBlock$0()))) {
    this.markInvalid("Return node with > 1 succesor or not going to exit-block");
  }
  if ((block.last instanceof HExit) && !block.successors.isEmpty()) {
    this.markInvalid("Exit block with successor");
  }
  if ((block.last instanceof HThrow) && !block.successors.isEmpty()) {
    this.markInvalid("Throw block with successor");
  }
  if (block.successors.isEmpty() && !(block.last instanceof HThrow) && !$notnull_bool(block.isExitBlock())) {
    this.markInvalid("Non-exit or throw block without successor");
  }
  if (block.id == null) this.markInvalid("block without id");
  var $list = block.successors;
  for (var $i = 0;$i < $list.length; $i++) {
    var successor = $list.$index($i);
    if (!$notnull_bool(this.isValid)) break;
    if (successor.id == null) this.markInvalid("successor without id");
    if (successor.id <= block.id && !$notnull_bool(successor.isLoopHeader())) {
      this.markInvalid("successor with lower id, but not a loop-header");
    }
  }
  var lastId = 0;
  var $list = block.dominatedBlocks;
  for (var $i = 0;$i < $list.length; $i++) {
    var dominated = $list.$index($i);
    if (!$notnull_bool(this.isValid)) break;
    if (dominated.dominator !== block) {
      this.markInvalid("dominated block not pointing back");
    }
    if (dominated.id == null || dominated.id <= lastId) {
      this.markInvalid("dominated.id === null or dominated has <= id");
    }
    lastId = dominated.id;
  }
  if (!$notnull_bool(this.isValid)) return;
  block.forEachPhi(this.get$visitInstruction());
  HInstructionVisitor.prototype.visitBasicBlock.call(this, block);
}
HValidator.countInstruction = function(instructions, instruction) {
  var result = 0;
  for (var i = 0;
   i < instructions.length; i++) {
    if (instructions.$index(i) === instruction) result++;
  }
  return result;
}
HValidator.everyInstruction = function(instructions, f) {
  var copy = ListFactory.ListFactory$from$factory(instructions);
  for (var i = 0;
   i < $assert_num(copy.length); i++) {
    var current = copy.$index(i);
    if (current == null) continue;
    var count = 1;
    for (var j = i + 1;
     j < $assert_num(copy.length); j++) {
      if (copy.$index(j) === current) {
        copy.$setindex(j);
        count++;
      }
    }
    if (!$notnull_bool(f.call$2(current, count))) return false;
  }
  return true;
}
HValidator.prototype.visitInstruction = function(instruction) {
  var $this = this; // closure support
  function hasCorrectInputs(instruction) {
    var $0;
    var inBasicBlock = $assert_bool(instruction.isInBasicBlock$0());
    return HValidator.everyInstruction((($0 = instruction.get$inputs()) == null ? null : $0.assert$List_HInstruction()), (function (input, count) {
      var $0;
      if ($notnull_bool(inBasicBlock)) {
        return HValidator.countInstruction((($0 = input.get$usedBy()) == null ? null : $0.assert$List_HInstruction()), (instruction == null ? null : instruction.assert$HInstruction())) == count;
      }
      else {
        return HValidator.countInstruction((($0 = input.get$usedBy()) == null ? null : $0.assert$List_HInstruction()), (instruction == null ? null : instruction.assert$HInstruction())) == 0;
      }
    })
    );
  }
  function hasCorrectUses(instruction) {
    var $0;
    if (!$notnull_bool(instruction.isInBasicBlock$0())) return true;
    return HValidator.everyInstruction((($0 = instruction.get$usedBy()) == null ? null : $0.assert$List_HInstruction()), (function (use, count) {
      var $0;
      return HValidator.countInstruction((($0 = use.get$inputs()) == null ? null : $0.assert$List_HInstruction()), (instruction == null ? null : instruction.assert$HInstruction())) == count;
    })
    );
  }
  if (instruction.block !== this.currentBlock) {
    this.markInvalid("Instruction in wrong block");
  }
  if (!$notnull_bool(hasCorrectInputs(instruction))) {
    this.markInvalid("Incorrect inputs");
  }
  if (!$notnull_bool(hasCorrectUses(instruction))) {
    this.markInvalid("Incorrect uses");
  }
}
HValidator.prototype.get$visitInstruction = function() {
  return HValidator.prototype.visitInstruction.bind(this);
}
// ********** Code for ValueSet **************
function ValueSet() {
  this.size = 0
  this.table = new ListFactory(1);
  // Initializers done
}
ValueSet.prototype.assert$ValueSet = function(){return this};
ValueSet.prototype.isEmpty = function() {
  return this.size == 0;
}
ValueSet.prototype.get$length = function() {
  return this.size;
}
Object.defineProperty(ValueSet.prototype, "length", {
  get: ValueSet.prototype.get$length
});
ValueSet.prototype.add = function(instruction) {
  $assert(this.lookup(instruction) == null, "lookup(instruction) === null", "value_set.dart", 16, 12);
  var index = this.tableIndexForInstruction(instruction);
  this.table.$setindex(index, new ValueSetNode(instruction, this.table.$index(index)));
  this.size++;
}
ValueSet.prototype.lookup = function(instruction) {
  var $0;
  var index = this.tableIndexForInstruction(instruction);
  for (var node = (($0 = this.table.$index(index)) == null ? null : $0.assert$ValueSetNode());
   node != null; node = node.next) {
    var cached = node.value;
    if ($notnull_bool(cached.equals(instruction))) return cached;
  }
  return null;
}
ValueSet.prototype.kill = function(flags) {
  var $0;
  var depends = HInstruction.computeDependsOnFlags(flags);
  for (var i = 0, length = this.table.length;
   i < length; i++) {
    var previous = null;
    var current = (($0 = this.table.$index(i)) == null ? null : $0.assert$ValueSetNode());
    while (current != null) {
      var next = current.next;
      var cached = current.value;
      if ((cached.flags & depends) != 0) {
        if (previous == null) {
          this.table.$setindex(i, next);
        }
        else {
          previous.next = next;
        }
        this.size--;
      }
      else {
        previous = current;
      }
      current = next;
    }
  }
}
ValueSet.prototype.copyTo = function(other) {
  var $0;
  for (var i = 0, length = this.table.length;
   i < length; i++) {
    var current = (($0 = this.table.$index(i)) == null ? null : $0.assert$ValueSetNode());
    while (current != null) {
      other.add$1(current.value);
      current = current.next;
    }
  }
  return other;
}
ValueSet.prototype.copy = function() {
  var $0;
  return (($0 = this.copyTo(new ValueSet())) == null ? null : $0.assert$ValueSet());
}
ValueSet.prototype.intersection = function(other) {
  var $0;
  if (this.size > other.size) return other.intersection(this);
  var result = new ValueSet();
  for (var i = 0, length = this.table.length;
   i < length; i++) {
    var current = (($0 = this.table.$index(i)) == null ? null : $0.assert$ValueSetNode());
    while (current != null) {
      var value = current.value;
      if (other.lookup(value) != null) {
        result.add(value);
      }
      current = current.next;
    }
  }
  return result;
}
ValueSet.prototype.toList = function() {
  var $0;
  return (($0 = this.copyTo([])) == null ? null : $0.assert$List_HInstruction());
}
ValueSet.prototype.tableIndexForInstruction = function(instruction) {
  return 0;
}
ValueSet.prototype.add$1 = function($0) {
  return this.add(($0 == null ? null : $0.assert$HInstruction()));
};
ValueSet.prototype.isEmpty$0 = ValueSet.prototype.isEmpty;
ValueSet.prototype.lookup$1 = function($0) {
  return this.lookup(($0 == null ? null : $0.assert$HInstruction()));
};
// ********** Code for ValueSetNode **************
function ValueSetNode(value, next) {
  this.value = value;
  this.next = next;
  // Initializers done
}
ValueSetNode.prototype.assert$ValueSetNode = function(){return this};
ValueSetNode.prototype.get$value = function() { return this.value; };
ValueSetNode.prototype.next$0 = function() {
  return this.next();
};
// ********** Code for top level **************
//  ********** Library leg **************
// ********** Code for Compiler **************
function Compiler(script) {
  this.script = script;
  // Initializers done
  this.universe = new Universe();
  this.worklist = new DoubleLinkedQueue();
  this.scanner = new ScannerTask(this);
  this.parser = new ParserTask(this);
  this.resolver = new ResolverTask(this);
  this.checker = new TypeCheckerTask(this);
  this.builder = new SsaBuilderTask(this);
  this.optimizer = new SsaOptimizerTask(this);
  this.generator = new SsaCodeGeneratorTask(this);
  this.tasks = [this.scanner, this.parser, this.resolver, this.checker, this.builder, this.optimizer, this.generator];
}
Compiler.prototype.assert$Compiler = function(){return this};
Compiler.prototype.get$generator = function() { return this.generator; };
Compiler.prototype.set$generator = function(value) { return this.generator = value; };
Compiler.prototype.ensure = function(condition) {
  if (!$notnull_bool(condition)) this.cancel('failed assertion in leg');
}
Compiler.prototype.unimplemented = function(methodName) {
  this.cancel(("" + methodName + " not implemented"));
}
Compiler.prototype.cancel = function(reason, node, token, instruction) {
  $throw(new CompilerCancelledException(reason));
}
Compiler.prototype.log = function(message) {

}
Compiler.prototype.run = function() {
  try {
    this.runCompiler();
  } catch (exception) {
    exception = _toDartException(exception);
    if (!(exception instanceof CompilerCancelledException)) throw exception;
    this.log(exception.toString());
    this.log('compilation failed');
    return false;
  }
  if (false/*null.GENERATE_SSA_TRACE*/) {
    print("------------------");
    print(HTracer.HTracer$singleton$factory());
    print("------------------");
  }
  this.log('compilation succeeded');
  return true;
}
Compiler.prototype.scanCoreLibrary = function() {
  var fileName = join([this.get$legDirectory(), 'lib', 'core.dart']);
  this.scanner.scan(this.readScript(fileName));
  var element = new ForeignElement(const$218/*const SourceString('JS')*/);
  this.universe.define(element);
}
Compiler.prototype.runCompiler = function() {
  var $0;
  this.scanCoreLibrary();
  this.scanner.scan(this.script);
  var element = this.universe.find(const$221/*Compiler.MAIN*/);
  if (element == null) this.cancel(('Could not find ' + const$221/*Compiler.MAIN*/));
  this.compileMethod(element);
  while (!this.worklist.isEmpty()) {
    this.compileMethod((($0 = this.worklist.removeLast()) == null ? null : $0.assert$Element()));
  }
}
Compiler.prototype.compileMethod = function(element) {
  var code = $assert_String(this.universe.generatedCode.$index(element));
  if (code != null) return code;
  var tree = this.parser.parse(element);
  var elements = this.resolver.resolve((tree == null ? null : tree.assert$FunctionExpression()));
  this.checker.check(tree, elements);
  var graph = this.builder.build(tree, elements);
  this.optimizer.optimize(graph);
  code = this.generator.generate((element == null ? null : element.assert$FunctionElement()), graph);
  this.universe.addGeneratedCode(element, code);
  return code;
}
Compiler.prototype.resolveType = function(element) {
  var $0;
  this.resolver.resolveType((($0 = this.parser.parse(element)) == null ? null : $0.assert$ClassNode()));
}
Compiler.prototype.resolveSignature = function(element) {
  var $0;
  this.resolver.resolveSignature((($0 = this.parser.parse(element)) == null ? null : $0.assert$FunctionExpression()));
}
Compiler.prototype.getGeneratedCode = function() {
  var $0;
  var buffer = new StringBufferImpl("");
  var codeBlocks = (($0 = this.universe.generatedCode.getValues()) == null ? null : $0.assert$List_String());
  for (var i = codeBlocks.length - 1;
   i >= 0; i--) {
    buffer.add(codeBlocks.$index(i));
  }
  buffer.add('main();\n');
  return buffer.toString();
}
Compiler.prototype.reportWarning = function(node, message) {

}
Compiler.prototype.reportError = function(node, message) {

}
Compiler.prototype.readScript = function(filename) {
  this.unimplemented('Compiler.readScript');
}
Compiler.prototype.get$legDirectory = function() {
  this.unimplemented('Compiler.legDirectory');
}
// ********** Code for CompilerTask **************
function CompilerTask(compiler) {
  this.compiler = compiler;
  this.watch = new StopwatchImplementation();
  // Initializers done
}
CompilerTask.prototype.get$name = function() {
  return 'Unknown task';
}
CompilerTask.prototype.get$timing = function() {
  return this.watch.elapsedInMs();
}
CompilerTask.prototype.measure = function(action) {
  this.watch.start();
  var result = action.call$0();
  this.watch.stop();
  return result;
}
// ********** Code for CompilerCancelledException **************
function CompilerCancelledException(reason) {
  this.reason = reason;
  // Initializers done
}
CompilerCancelledException.prototype.toString = function() {
  var banner = 'compiler cancelled';
  return (this.reason != null) ? ('' + banner + ': ' + this.reason) : ('' + banner);
}
CompilerCancelledException.prototype.toString$0 = CompilerCancelledException.prototype.toString;
// ********** Code for TreeElements **************
function TreeElements() {
  this.map = new LinkedHashMapImplementation();
  // Initializers done
}
TreeElements.prototype.assert$TreeElements = function(){return this};
TreeElements.prototype.$setindex = function(node, element) {
  return this.map.$setindex(node, element);
}
TreeElements.prototype.$index = function(node) {
  return this.map.$index(node);
}
// ********** Code for ResolverTask **************
function ResolverTask(compiler) {
  this.toResolve = new DoubleLinkedQueue();
  // Initializers done
  CompilerTask.call(this, compiler);
}
$inherits(ResolverTask, CompilerTask);
ResolverTask.prototype.get$name = function() {
  return 'Resolver';
}
ResolverTask.prototype.resolve = function(tree) {
  var $this = this; // closure support
  var $0;
  return (($0 = this.measure((function () {
    var visitor = new SignatureResolverVisitor($this.compiler);
    visitor.visit(tree);
    visitor = new FullResolverVisitor.from$ctor(visitor);
    visitor.visit(tree.body);
    while (!$this.toResolve.isEmpty()) {
      $this.toResolve.removeFirst().resolve$1($this.compiler);
    }
    return visitor.mapping;
  })
  )) == null ? null : $0.assert$TreeElements());
}
ResolverTask.prototype.resolveType = function(tree) {
  var $this = this; // closure support
  this.measure((function () {
    var visitor = new ClassResolverVisitor($this.compiler);
    visitor.visit(tree);
  })
  );
}
ResolverTask.prototype.resolveSignature = function(node) {
  var $this = this; // closure support
  this.measure((function () {
    var visitor = new SignatureResolverVisitor($this.compiler);
    visitor.visitFunctionExpression(node);
  })
  );
}
ResolverTask.prototype.resolve$1 = function($0) {
  return this.resolve(($0 == null ? null : $0.assert$FunctionExpression()));
};
// ********** Code for ResolverVisitor **************
function ResolverVisitor(compiler) {
  this.compiler = compiler;
  this.mapping = new TreeElements();
  this.context = new Scope(new TopScope(compiler.universe));
  // Initializers done
}
ResolverVisitor.from$ctor = function(other) {
  this.compiler = other.compiler;
  this.mapping = other.mapping;
  this.context = other.context;
  // Initializers done
}
ResolverVisitor.from$ctor.prototype = ResolverVisitor.prototype;
ResolverVisitor.prototype.assert$Visitor = function(){return this};
ResolverVisitor.prototype.error = function(node, kind, arguments) {
  var error = new ResolutionError(kind, (arguments == null ? null : arguments.assert$List_Type()));
  this.compiler.reportError(node, error);
}
ResolverVisitor.prototype.warning = function(node, kind, arguments) {
  var warning = new ResolutionWarning(kind, (arguments == null ? null : arguments.assert$List_Type()));
  this.compiler.reportWarning(node, warning);
}
ResolverVisitor.prototype.cancel = function(node, message) {
  this.compiler.cancel(message);
}
ResolverVisitor.prototype.visit = function(node) {
  if (node == null) return null;
  return node.accept(this);
}
ResolverVisitor.prototype.visitIdentifier = function(node) {
  var element = this.context.lookup(node.get$source());
  if (element == null) {
    this.error(node, const$225/*MessageKind.CANNOT_RESOLVE*/, [node]);
  }
  return this.useElement(node, element);
}
ResolverVisitor.prototype.visitTypeAnnotation = function(node) {
  var name = node.typeName;
  if ($notnull_bool($eq(name.get$source(), const$227/*const SourceString('var')*/))) return null;
  if ($notnull_bool($eq(name.get$source(), const$6/*const SourceString('void')*/))) return null;
  var element = this.context.lookup(name.get$source());
  if (element == null) {
    this.warning(node, const$228/*MessageKind.CANNOT_RESOLVE_TYPE*/, [name]);
  }
  else if (element.kind !== const$214/*ElementKind.CLASS*/) {
    this.warning(node, const$230/*MessageKind.NOT_A_TYPE*/, [name]);
  }
  else {
    var cls = (element == null ? null : element.assert$ClassElement());
    this.compiler.resolver.toResolve.add(element);
  }
  return this.useElement(node, element);
}
ResolverVisitor.prototype.defineElement = function(node, element) {
  this.compiler.ensure(element != null);
  this.mapping.$setindex(node, element);
  var existing = this.context.add(element);
  if ($ne(existing, element)) {
    this.error(node, const$234/*MessageKind.DUPLICATE_DEFINITION*/, [node]);
  }
  return element;
}
ResolverVisitor.prototype.useElement = function(node, element) {
  if (element == null) return null;
  this.mapping.$setindex(node, element);
  return element;
}
ResolverVisitor.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$Node()));
};
// ********** Code for SignatureResolverVisitor **************
function SignatureResolverVisitor(compiler) {
  // Initializers done
  ResolverVisitor.call(this, compiler);
}
$inherits(SignatureResolverVisitor, ResolverVisitor);
SignatureResolverVisitor.prototype.visitFunctionExpression = function(node) {
  var $0;
  var enclosingElement = (($0 = this.context.lookup((($0 = node.name.get$dynamic().get$source()) == null ? null : $0.assert$SourceString()))) == null ? null : $0.assert$FunctionElement());
  this.useElement(node, enclosingElement);
  this.context = new Scope.enclosing$ctor(this.context, enclosingElement);
  if (enclosingElement.parameters == null) {
    var visitor = new ParametersVisitor(this);
    visitor.visit(node.parameters);
    enclosingElement.parameters = (($0 = visitor.elements.toLink()) == null ? null : $0.assert$Link_Element());
  }
  else {
    var parameterNodes = node.parameters.get$nodes();
    for (var link = enclosingElement.parameters;
     !$notnull_bool(link.isEmpty()) && !$notnull_bool(parameterNodes.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Element()), parameterNodes = (($0 = parameterNodes.get$tail()) == null ? null : $0.assert$Link_Node())) {
      this.defineElement((($0 = parameterNodes.get$head().get$definitions().get$nodes().get$head()) == null ? null : $0.assert$Node()), (($0 = link.get$head()) == null ? null : $0.assert$Element()));
    }
  }
  return enclosingElement;
}
// ********** Code for FullResolverVisitor **************
function FullResolverVisitor() {}
FullResolverVisitor.from$ctor = function(other) {
  // Initializers done
  ResolverVisitor.from$ctor.call(this, other);
}
FullResolverVisitor.from$ctor.prototype = FullResolverVisitor.prototype;
$inherits(FullResolverVisitor, ResolverVisitor);
FullResolverVisitor.prototype.visitClassNode = function(node) {
  this.cancel(node, "shouldn't be called");
}
FullResolverVisitor.prototype.visitIn = function(node, scope) {
  var $0;
  this.context = scope;
  var element = (($0 = this.visit(node)) == null ? null : $0.assert$Element());
  this.context = this.context.parent;
  return element;
}
FullResolverVisitor.prototype.visitBlock = function(node) {
  this.visitIn(node.statements, new Scope(this.context));
}
FullResolverVisitor.prototype.visitDoWhile = function(node) {
  this.visitIn(node.body, new Scope(this.context));
  this.visit(node.condition);
}
FullResolverVisitor.prototype.visitExpressionStatement = function(node) {
  this.visit(node.expression);
}
FullResolverVisitor.prototype.visitFor = function(node) {
  var scope = new Scope(this.context);
  this.visitIn(node.initializer, scope);
  this.visitIn(node.get$condition(), scope);
  this.visitIn(node.update, scope);
  this.visitIn(node.body, scope);
}
FullResolverVisitor.prototype.visitFunctionExpression = function(node) {
  var $0;
  this.visit(node.returnType);
  var enclosingElement = new FunctionElement.node$ctor(node, this.context.enclosingElement);
  this.defineElement(node, enclosingElement);
  this.context = new Scope.enclosing$ctor(this.context, enclosingElement);
  var visitor = new ParametersVisitor(this);
  visitor.visit(node.parameters);
  enclosingElement.parameters = (($0 = visitor.elements.toLink()) == null ? null : $0.assert$Link_Element());
  this.visit(node.body);
  this.context = this.context.parent;
  return enclosingElement;
}
FullResolverVisitor.prototype.visitIf = function(node) {
  this.visit(node.condition);
  this.visit(node.thenPart);
  this.visit(node.elsePart);
}
FullResolverVisitor.prototype.potentiallyMapOperatorToMethodName = function(name, isPrefix) {
  if ($notnull_bool(isPrefix)) {
    if (name.get$stringValue() === '-') return const$237/*const SourceString('neg')*/;
    if (name.get$stringValue() === '~') return const$238/*const SourceString('not')*/;
    if (name.get$stringValue() === '!') return name;
    unreachable();
  }
  if (name.get$stringValue() === '+') return const$240/*const SourceString('add')*/;
  if (name.get$stringValue() === '-') return const$241/*const SourceString('sub')*/;
  if (name.get$stringValue() === '*') return const$242/*const SourceString('mul')*/;
  if (name.get$stringValue() === '/') return const$243/*const SourceString('div')*/;
  if (name.get$stringValue() === '~/') return const$244/*const SourceString('tdiv')*/;
  if (name.get$stringValue() === '%') return const$245/*const SourceString('mod')*/;
  if (name.get$stringValue() === '<<') return const$246/*const SourceString('shl')*/;
  if (name.get$stringValue() === '>>') return const$247/*const SourceString('shr')*/;
  if (name.get$stringValue() === '|') return const$248/*const SourceString('or')*/;
  if (name.get$stringValue() === '&') return const$249/*const SourceString('and')*/;
  if (name.get$stringValue() === '^') return const$250/*const SourceString('xor')*/;
  if (name.get$stringValue() === '==') return const$251/*const SourceString('eq')*/;
  if (name.get$stringValue() === '<') return const$252/*const SourceString('lt')*/;
  if (name.get$stringValue() === '<=') return const$253/*const SourceString('le')*/;
  if (name.get$stringValue() === '>') return const$254/*const SourceString('gt')*/;
  if (name.get$stringValue() === '>=') return const$255/*const SourceString('ge')*/;
  return name;
}
FullResolverVisitor.prototype.mapAssignmentOperatorToMethodName = function(name) {
  if (name.get$stringValue() === '+=') return const$240/*const SourceString('add')*/;
  if (name.get$stringValue() === '-=') return const$241/*const SourceString('sub')*/;
  if (name.get$stringValue() === '*=') return const$242/*const SourceString('mul')*/;
  if (name.get$stringValue() === '/=') return const$243/*const SourceString('div')*/;
  if (name.get$stringValue() === '~/=') return const$244/*const SourceString('tdiv')*/;
  if (name.get$stringValue() === '%=') return const$245/*const SourceString('mod')*/;
  if (name.get$stringValue() === '<<=') return const$246/*const SourceString('shl')*/;
  if (name.get$stringValue() === '>>=') return const$247/*const SourceString('shr')*/;
  if (name.get$stringValue() === '|=') return const$248/*const SourceString('or')*/;
  if (name.get$stringValue() === '&=') return const$249/*const SourceString('and')*/;
  if (name.get$stringValue() === '^=') return const$250/*const SourceString('xor')*/;
  if (name.get$stringValue() === '++') return const$240/*const SourceString('add')*/;
  if (name.get$stringValue() === '--') return const$241/*const SourceString('sub')*/;
  this.compiler.unimplemented(("mapAssignmentOperatorToMethodName: " + name));
}
FullResolverVisitor.prototype.visitSend = function(node) {
  var $0;
  var receiver = (($0 = this.visit(node.receiver)) == null ? null : $0.assert$Element());
  var identifier = (($0 = node.selector) == null ? null : $0.assert$Identifier());
  var target = null;
  if (receiver == null || (identifier instanceof Operator)) {
    var name = this.potentiallyMapOperatorToMethodName(identifier.get$source(), node.get$isPrefix());
    target = this.context.lookup(name);
    if (target == null && !((name.get$stringValue() === '&&' || name.get$stringValue() === '||' || name.get$stringValue() === '!'))) {
      this.error(node, const$225/*MessageKind.CANNOT_RESOLVE*/, [name]);
    }
    this.useElement(node, target);
  }
  else {
  }
  this.visit(node.argumentsNode);
  return target;
}
FullResolverVisitor.prototype.visitSendSet = function(node) {
  var $0;
  var receiver = (($0 = this.visit(node.receiver)) == null ? null : $0.assert$Element());
  var selector = (($0 = node.selector) == null ? null : $0.assert$Identifier());
  if (receiver != null) {
    this.compiler.unimplemented('Resolver: property access');
  }
  var target = this.context.lookup(selector.get$source());
  if (target == null) {
    this.error(node, const$225/*MessageKind.CANNOT_RESOLVE*/, [node]);
  }
  var op = node.assignmentOperator;
  if (op.get$source().get$stringValue() !== '=') {
    var name = this.mapAssignmentOperatorToMethodName(op.get$source());
    var operatorElement = this.context.lookup(name);
    this.useElement(op, operatorElement);
    var getter = this.context.lookup(selector.get$source());
    this.useElement(selector, getter);
  }
  this.visit(node.argumentsNode);
  return this.useElement(node, target);
}
FullResolverVisitor.prototype.visitLiteralInt = function(node) {

}
FullResolverVisitor.prototype.visitLiteralDouble = function(node) {

}
FullResolverVisitor.prototype.visitLiteralBool = function(node) {

}
FullResolverVisitor.prototype.visitLiteralString = function(node) {

}
FullResolverVisitor.prototype.visitLiteralNull = function(node) {

}
FullResolverVisitor.prototype.visitNodeList = function(node) {
  var $0;
  for (var link = node.get$nodes();
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
    this.visit((($0 = link.get$head()) == null ? null : $0.assert$Node()));
  }
}
FullResolverVisitor.prototype.visitOperator = function(node) {
  this.cancel(node, "Unimplemented");
}
FullResolverVisitor.prototype.visitReturn = function(node) {
  this.visit(node.expression);
}
FullResolverVisitor.prototype.visitThrow = function(node) {
  this.visit(node.expression);
}
FullResolverVisitor.prototype.visitVariableDefinitions = function(node) {
  this.visit(node.type);
  var visitor = new VariableDefinitionsVisitor(node, this, const$256/*ElementKind.VARIABLE*/);
  visitor.visit(node.definitions);
}
FullResolverVisitor.prototype.visitWhile = function(node) {
  this.visit(node.condition);
  this.visitIn(node.body, new Scope(this.context));
}
FullResolverVisitor.prototype.visitParenthesizedExpression = function(node) {
  this.visit(node.expression);
}
// ********** Code for ClassResolverVisitor **************
function ClassResolverVisitor(compiler) {
  this.compiler = compiler;
  this.context = new TopScope(compiler.universe);
  // Initializers done
  AbstractVisitor_Type.call(this);
}
$inherits(ClassResolverVisitor, AbstractVisitor_Type);
ClassResolverVisitor.prototype.visitClassNode = function(node) {
  var $0;
  var element = (($0 = this.context.lookup(node.name.get$source())) == null ? null : $0.assert$ClassElement());
  this.compiler.ensure(element != null);
  this.compiler.ensure(!$notnull_bool(element.isResolved));
  element.supertype = this.visit(node.superclass);
  for (var link = node.interfaces.get$nodes();
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
    element.interfaces = (($0 = element.interfaces.prepend(this.visit((($0 = link.get$head()) == null ? null : $0.assert$Node())))) == null ? null : $0.assert$Link_Type());
  }
  return element.computeType(this.compiler, null);
}
ClassResolverVisitor.prototype.visitTypeAnnotation = function(node) {
  var $0;
  var name = node.typeName;
  var element = this.context.lookup(name.get$source());
  if (element == null) {
    this.compiler.reportError(node, new ResolutionError(const$228/*MessageKind.CANNOT_RESOLVE_TYPE*/, [name]));
  }
  else if (element.kind !== const$214/*ElementKind.CLASS*/) {
    this.compiler.reportError(node, new ResolutionError(const$230/*MessageKind.NOT_A_TYPE*/, [name]));
  }
  else {
    this.compiler.resolver.toResolve.add(element);
    return (($0 = element.computeType(this.compiler, null)) == null ? null : $0.assert$Type());
  }
  return null;
}
ClassResolverVisitor.prototype.visit = function(node) {
  var $0;
  if (node == null) return null;
  return (($0 = node.accept(this)) == null ? null : $0.assert$Type());
}
ClassResolverVisitor.prototype.visitNode = function(node) {
  this.compiler.cancel('internal error');
}
ClassResolverVisitor.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$Node()));
};
// ********** Code for VariableDefinitionsVisitor **************
function VariableDefinitionsVisitor(definitions, resolver, kind) {
  this.definitions = definitions;
  this.resolver = resolver;
  this.kind = kind;
  // Initializers done
  AbstractVisitor_SourceString.call(this);
}
$inherits(VariableDefinitionsVisitor, AbstractVisitor_SourceString);
VariableDefinitionsVisitor.prototype.get$definitions = function() { return this.definitions; };
VariableDefinitionsVisitor.prototype.set$definitions = function(value) { return this.definitions = value; };
VariableDefinitionsVisitor.prototype.get$kind = function() { return this.kind; };
VariableDefinitionsVisitor.prototype.set$kind = function(value) { return this.kind = value; };
VariableDefinitionsVisitor.prototype.visitSendSet = function(node) {
  var $0;
  $assert(node.get$arguments().get$tail().isEmpty$0(), "node.arguments.tail.isEmpty()", "resolver.dart", 424, 12);
  if (node.receiver != null) {
    this.resolver.cancel(node, "receiver on a variable definition not implemented");
  }
  var selector = (($0 = node.selector) == null ? null : $0.assert$Identifier());
  this.resolver.visit((($0 = node.get$arguments().get$head()) == null ? null : $0.assert$Node()));
  return (($0 = this.visit(node.selector)) == null ? null : $0.assert$SourceString());
}
VariableDefinitionsVisitor.prototype.visitIdentifier = function(node) {
  return node.get$source();
}
VariableDefinitionsVisitor.prototype.visitNodeList = function(node) {
  var $0;
  for (var link = node.get$nodes();
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
    var name = (($0 = this.visit((($0 = link.get$head()) == null ? null : $0.assert$Node()))) == null ? null : $0.assert$SourceString());
    var element = new VariableElement((($0 = link.get$head()) == null ? null : $0.assert$Node()), this.definitions.type, this.kind, name, this.resolver.context.enclosingElement);
    this.resolver.defineElement((($0 = link.get$head()) == null ? null : $0.assert$Node()), element);
  }
}
VariableDefinitionsVisitor.prototype.visit = function(node) {
  return node.accept(this);
}
VariableDefinitionsVisitor.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$Node()));
};
// ********** Code for ParametersVisitor **************
function ParametersVisitor(resolver) {
  this.resolver = resolver;
  this.elements = new LinkBuilderImplementation();
  // Initializers done
  AbstractVisitor_Element.call(this);
}
$inherits(ParametersVisitor, AbstractVisitor_Element);
ParametersVisitor.prototype.visitNodeList = function(node) {
  var $0;
  for (var link = node.get$nodes();
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
    this.elements.addLast(this.visit((($0 = link.get$head()) == null ? null : $0.assert$Node())));
  }
}
ParametersVisitor.prototype.visitVariableDefinitions = function(node) {
  var $0;
  this.resolver.visit(node.type);
  var visitor = new VariableDefinitionsVisitor(node, this.resolver, const$232/*ElementKind.PARAMETER*/);
  visitor.visit(node.definitions);
  return this.resolver.mapping.$index((($0 = node.definitions.get$nodes().get$head()) == null ? null : $0.assert$Node()));
}
ParametersVisitor.prototype.visit = function(node) {
  return node.accept(this);
}
ParametersVisitor.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$Node()));
};
// ********** Code for Scope **************
function Scope(parent) {
  // Initializers done
  Scope.enclosing$ctor.call(this, parent, parent.enclosingElement);
}
Scope.top$ctor = function() {
  this.parent = null;
  this.elements = const$224/*const {}*/;
  this.enclosingElement = null;
  // Initializers done
}
Scope.top$ctor.prototype = Scope.prototype;
Scope.enclosing$ctor = function(parent, enclosingElement) {
  this.parent = parent;
  this.enclosingElement = enclosingElement;
  this.elements = $map([]);
  // Initializers done
}
Scope.enclosing$ctor.prototype = Scope.prototype;
Scope.prototype.get$parent = function() { return this.parent; };
Scope.prototype.get$enclosingElement = function() { return this.enclosingElement; };
Scope.prototype.lookup = function(name) {
  var $0;
  var element = (($0 = this.elements.$index(name)) == null ? null : $0.assert$Element());
  if (element != null) return element;
  return this.parent.lookup(name);
}
Scope.prototype.add = function(element) {
  var $0;
  if (this.elements.containsKey(element.name)) return (($0 = this.elements.$index(element.name)) == null ? null : $0.assert$Element());
  this.elements.$setindex(element.name, element);
  return element;
}
Scope.prototype.add$1 = function($0) {
  return this.add(($0 == null ? null : $0.assert$Element()));
};
Scope.prototype.lookup$1 = function($0) {
  return this.lookup(($0 == null ? null : $0.assert$SourceString()));
};
// ********** Code for TopScope **************
function TopScope(universe) {
  this.universe = universe;
  // Initializers done
  Scope.top$ctor.call(this);
}
$inherits(TopScope, Scope);
TopScope.prototype.lookup = function(name) {
  return this.universe.find(name);
}
TopScope.prototype.add = function(element) {
  $throw("Cannot add an element in the top scope");
}
TopScope.prototype.add$1 = function($0) {
  return this.add(($0 == null ? null : $0.assert$Element()));
};
TopScope.prototype.lookup$1 = function($0) {
  return this.lookup(($0 == null ? null : $0.assert$SourceString()));
};
// ********** Code for leg_Script **************
function leg_Script(file) {
  this.file = file;
  // Initializers done
}
leg_Script.prototype.get$file = function() { return this.file; };
leg_Script.prototype.get$text = function() {
  return $assert_String(this.file.get$text());
}
// ********** Code for TypeCheckerTask **************
function TypeCheckerTask(compiler) {
  this.types = new Types();
  // Initializers done
  CompilerTask.call(this, compiler);
}
$inherits(TypeCheckerTask, CompilerTask);
TypeCheckerTask.prototype.get$name = function() {
  return "Type checker";
}
TypeCheckerTask.prototype.get$types = function() { return this.types; };
TypeCheckerTask.prototype.set$types = function(value) { return this.types = value; };
TypeCheckerTask.prototype.check = function(tree, elements) {
  var $this = this; // closure support
  this.measure((function () {
    var visitor = new TypeCheckerVisitor($this.compiler, elements, $this.types);
    try {
      tree.accept(visitor);
    } catch (e) {
      e = _toDartException(e);
      if (!(e instanceof CancelTypeCheckException)) throw e;
      $this.compiler.reportWarning(e.node, new TypeWarning(const$272/*MessageKind.GENERIC*/, [e.reason]));
    }
  })
  );
}
// ********** Code for SimpleType **************
function SimpleType(name, element) {
  this.name = name;
  this.element = element;
  // Initializers done
}
SimpleType.named$ctor = function(name) {
  this.name = name;
  this.element = new Element(name, null, null);
  // Initializers done
}
SimpleType.named$ctor.prototype = SimpleType.prototype;
SimpleType.prototype.assert$Type = function(){return this};
SimpleType.prototype.get$name = function() { return this.name; };
SimpleType.prototype.get$element = function() { return this.element; };
SimpleType.prototype.toString = function() {
  return this.name.toString();
}
SimpleType.prototype.toString$0 = SimpleType.prototype.toString;
// ********** Code for FunctionType **************
function FunctionType(returnType, parameterTypes) {
  this.returnType = returnType;
  this.parameterTypes = parameterTypes;
  // Initializers done
}
FunctionType.prototype.assert$FunctionType = function(){return this};
FunctionType.prototype.assert$Type = function(){return this};
FunctionType.prototype.get$returnType = function() { return this.returnType; };
FunctionType.prototype.toString = function() {
  var sb = new StringBufferImpl("");
  var first = true;
  sb.add('(');
  this.parameterTypes.printOn(sb, ', ');
  sb.add((') -> ' + this.returnType));
  return sb.toString();
}
FunctionType.prototype.toString$0 = FunctionType.prototype.toString;
// ********** Code for Types **************
function Types() {
  this.voidType = new SimpleType.named$ctor(const$6/*Types.VOID*/);
  this.intType = new SimpleType.named$ctor(const$8/*Types.INT*/);
  this.doubleType = new SimpleType.named$ctor(const$10/*Types.DOUBLE*/);
  this.dynamicType = new SimpleType.named$ctor(const$12/*Types.DYNAMIC*/);
  this.stringType = new SimpleType.named$ctor(const$14/*Types.STRING*/);
  this.boolType = new SimpleType.named$ctor(const$16/*Types.BOOL*/);
  this.objectType = new SimpleType.named$ctor(const$18/*Types.OBJECT*/);
  // Initializers done
}
Types.prototype.assert$Types = function(){return this};
Types.prototype.get$dynamicType = function() { return this.dynamicType; };
Types.prototype.lookup = function(s) {
  if ($notnull_bool($eq(const$6/*Types.VOID*/, s))) {
    return this.voidType;
  }
  else if ($notnull_bool($eq(const$8/*Types.INT*/, s))) {
    return this.intType;
  }
  else if ($notnull_bool($eq(const$10/*Types.DOUBLE*/, s))) {
    return this.doubleType;
  }
  else if ($notnull_bool($eq(const$12/*Types.DYNAMIC*/, s)) || s.get$stringValue() === 'var') {
    return this.dynamicType;
  }
  else if ($notnull_bool($eq(const$14/*Types.STRING*/, s))) {
    return this.stringType;
  }
  else if ($notnull_bool($eq(const$16/*Types.BOOL*/, s))) {
    return this.boolType;
  }
  else if ($notnull_bool($eq(const$18/*Types.OBJECT*/, s))) {
    return this.objectType;
  }
  return null;
}
Types.prototype.isSubtype = function(r, s) {
  return r === s || r === this.dynamicType || s === this.dynamicType || s === this.objectType;
}
Types.prototype.isAssignable = function(r, s) {
  return $notnull_bool(this.isSubtype(r, s)) || $notnull_bool(this.isSubtype(s, r));
}
Types.prototype.lookup$1 = function($0) {
  return this.lookup(($0 == null ? null : $0.assert$SourceString()));
};
// ********** Code for CancelTypeCheckException **************
function CancelTypeCheckException(node, reason) {
  this.node = node;
  this.reason = reason;
  // Initializers done
}
// ********** Code for TypeCheckerVisitor **************
function TypeCheckerVisitor(compiler, elements, types) {
  this.compiler = compiler;
  this.elements = elements;
  this.types = types;
  // Initializers done
}
TypeCheckerVisitor.prototype.assert$Visitor = function(){return this};
TypeCheckerVisitor.prototype.get$types = function() { return this.types; };
TypeCheckerVisitor.prototype.set$types = function(value) { return this.types = value; };
TypeCheckerVisitor.prototype.fail = function(node, reason) {
  var message = 'cannot type-check';
  if (reason != null) {
    message = ('' + message + ': ' + reason);
  }
  $throw(new CancelTypeCheckException(node, message));
}
TypeCheckerVisitor.prototype.reportTypeWarning = function(node, kind, arguments) {
  this.compiler.reportWarning(node, new TypeWarning(kind, arguments));
}
TypeCheckerVisitor.prototype.nonVoidType = function(node) {
  var type = this.type(node);
  if ($eq(type, this.types.voidType)) {
    this.reportTypeWarning(node, const$270/*MessageKind.VOID_EXPRESSION*/, const$21/*const []*/);
  }
  return type;
}
TypeCheckerVisitor.prototype.typeWithDefault = function(node, defaultValue) {
  return node != null ? this.type(node) : defaultValue;
}
TypeCheckerVisitor.prototype.type = function(node) {
  var $0;
  if (node == null) this.fail(null, 'unexpected node: null');
  var result = (($0 = node.accept(this)) == null ? null : $0.assert$Type());
  return result;
}
TypeCheckerVisitor.prototype.get$type = function() {
  return TypeCheckerVisitor.prototype.type.bind(this);
}
TypeCheckerVisitor.prototype.checkAssignable = function(node, s, t) {
  if (!$notnull_bool(this.types.isAssignable(s, t))) {
    this.reportTypeWarning(node, const$258/*MessageKind.NOT_ASSIGNABLE*/, [s, t]);
  }
}
TypeCheckerVisitor.prototype.checkCondition = function(condition) {
  this.checkAssignable(condition, this.types.boolType, this.type(condition));
}
TypeCheckerVisitor.prototype.visitBlock = function(node) {
  this.type(node.statements);
  return this.types.voidType;
}
TypeCheckerVisitor.prototype.visitClassNode = function(node) {
  this.fail(node);
}
TypeCheckerVisitor.prototype.visitDoWhile = function(node) {
  this.type(node.body);
  this.checkCondition(node.condition);
  return this.types.voidType;
}
TypeCheckerVisitor.prototype.visitExpressionStatement = function(node) {
  this.type(node.expression);
  return this.types.voidType;
}
TypeCheckerVisitor.prototype.visitFor = function(node) {
  this.type(node.initializer);
  this.checkCondition(node.get$condition());
  this.type(node.update);
  this.type(node.body);
  return this.types.voidType;
}
TypeCheckerVisitor.prototype.visitFunctionExpression = function(node) {
  var $0;
  var element = this.elements.$index(node);
  var functionType = (($0 = this.computeType((element == null ? null : element.assert$Element()))) == null ? null : $0.assert$FunctionType());
  var returnType = functionType.returnType;
  var previous = this.expectedReturnType;
  this.expectedReturnType = returnType;
  this.type(node.body);
  this.expectedReturnType = previous;
  return functionType;
}
TypeCheckerVisitor.prototype.visitIdentifier = function(node) {
  this.fail(node);
}
TypeCheckerVisitor.prototype.visitIf = function(node) {
  this.type(node.condition);
  this.type(node.thenPart);
  if ($notnull_bool(node.get$hasElsePart())) this.type(node.elsePart);
  return this.types.voidType;
}
TypeCheckerVisitor.prototype.visitSend = function(node) {
  var $0;
  var target = this.elements.$index(node);
  var selector = (($0 = node.selector) == null ? null : $0.assert$Identifier());
  var name = selector.get$source().get$stringValue();
  if (target != null) {
    if (selector.asOperator() != null) {
      this.type(node.receiver);
      if (node.get$arguments().get$head() != null) this.type((($0 = node.get$arguments().get$head()) == null ? null : $0.assert$Node()));
      if (name === '+' || name === '=' || name === '-' || name === '*' || name === '/' || name === '%' || name === '~/' || name === '|' || name === '&' || name === '^' || name === '~' || name === '<<' || name === '>>') {
        return this.types.dynamicType;
      }
      else if (name === '<' || name === '>' || name === '<=' || name === '>=' || name === '==') {
        return this.types.boolType;
      }
      else {
        this.fail(selector, ('unexpected operator ' + name));
      }
    }
    var targetType = this.computeType((target == null ? null : target.assert$Element()));
    if ($notnull_bool(node.get$isPropertyAccess())) {
      return targetType;
    }
    else if ($notnull_bool(node.get$isFunctionObjectInvocation())) {
      this.fail(node);
    }
    else {
      if (!(targetType instanceof FunctionType)) {
        if ((target instanceof ForeignElement)) {
          return this.types.dynamicType;
        }
        this.fail(node, 'can only handle function types');
      }
      var funType = (targetType == null ? null : targetType.assert$FunctionType());
      var formals = funType.parameterTypes;
      var arguments = node.get$arguments();
      while ((!$notnull_bool(formals.isEmpty())) && (!$notnull_bool(arguments.isEmpty()))) {
        var argument = (($0 = arguments.get$head()) == null ? null : $0.assert$Node());
        var argumentType = this.type(argument);
        this.checkAssignable(argument, (($0 = formals.get$head()) == null ? null : $0.assert$Type()), argumentType);
        formals = (($0 = formals.get$tail()) == null ? null : $0.assert$Link_Type());
        arguments = (($0 = arguments.get$tail()) == null ? null : $0.assert$Link_Node());
      }
      if (!$notnull_bool(formals.isEmpty())) {
        this.reportTypeWarning(node, const$264/*MessageKind.MISSING_ARGUMENT*/, const$21/*const []*/);
      }
      if (!$notnull_bool(arguments.isEmpty())) {
        this.reportTypeWarning(node, const$266/*MessageKind.ADDITIONAL_ARGUMENT*/, const$21/*const []*/);
      }
      return funType.returnType;
    }
  }
  else {
    if (name === '||' || name === '&&' || name === '!') {
      var arguments = node.get$arguments();
      var firstArgument = node.receiver;
      this.checkAssignable(firstArgument, this.types.boolType, this.type(firstArgument));
      if (!$notnull_bool(arguments.isEmpty())) {
        var secondArgument = (($0 = arguments.get$head()) == null ? null : $0.assert$Node());
        this.checkAssignable(secondArgument, this.types.boolType, this.type(secondArgument));
      }
      return this.types.boolType;
    }
    this.fail(node, ('unresolved send ' + selector.get$source()));
  }
}
TypeCheckerVisitor.prototype.visitSendSet = function(node) {
  var $0;
  this.compiler.ensure(node.get$arguments() != null);
  var selector = (($0 = node.selector) == null ? null : $0.assert$Identifier());
  var name = node.assignmentOperator.get$source().get$stringValue();
  if (name === '++' || name === '--') {
    this.compiler.ensure((node.selector instanceof Identifier));
    var element = (($0 = this.elements.$index(node.selector)) == null ? null : $0.assert$Element());
    var receiverType = this.computeType(element);
    return $notnull_bool(node.get$isPrefix()) ? this.types.intType : receiverType;
  }
  else {
    this.compiler.ensure(!$notnull_bool(node.get$arguments().isEmpty()));
    var targetType = this.computeType((($0 = this.elements.$index(node)) == null ? null : $0.assert$Element()));
    var value = (($0 = node.get$arguments().get$head()) == null ? null : $0.assert$Node());
    this.checkAssignable(value, targetType, this.type(value));
    return targetType;
  }
}
TypeCheckerVisitor.prototype.visitLiteralInt = function(node) {
  return this.types.intType;
}
TypeCheckerVisitor.prototype.visitLiteralDouble = function(node) {
  return this.types.doubleType;
}
TypeCheckerVisitor.prototype.visitLiteralBool = function(node) {
  return this.types.boolType;
}
TypeCheckerVisitor.prototype.visitLiteralString = function(node) {
  return this.types.stringType;
}
TypeCheckerVisitor.prototype.visitLiteralNull = function(node) {
  return this.types.dynamicType;
}
TypeCheckerVisitor.prototype.visitNodeList = function(node) {
  var $0;
  for (var link = node.get$nodes();
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
    this.type((($0 = link.get$head()) == null ? null : $0.assert$Node()));
  }
  return null;
}
TypeCheckerVisitor.prototype.visitOperator = function(node) {
  return this.types.dynamicType;
}
TypeCheckerVisitor.prototype.visitReturn = function(node) {
  var expression = node.expression;
  var isVoidFunction = (this.expectedReturnType === this.types.voidType);
  if (expression != null) {
    var expressionType = this.type(expression);
    if (isVoidFunction && !$notnull_bool(this.types.isAssignable(expressionType, this.types.voidType))) {
      this.reportTypeWarning(expression, const$260/*MessageKind.RETURN_VALUE_IN_VOID*/, [expressionType]);
    }
    else {
      this.checkAssignable(expression, this.expectedReturnType, expressionType);
    }
  }
  else if (!$notnull_bool(this.types.isAssignable(this.expectedReturnType, this.types.voidType))) {
    this.reportTypeWarning(node, const$262/*MessageKind.RETURN_NOTHING*/, [this.expectedReturnType]);
  }
  return null;
}
TypeCheckerVisitor.prototype.visitThrow = function(node) {
  if (node.expression != null) this.type(node.expression);
  return this.types.voidType;
}
TypeCheckerVisitor.prototype.computeType = function(element) {
  var $0;
  if (element == null) return this.types.dynamicType;
  return (($0 = element.computeType(this.compiler, this.types)) == null ? null : $0.assert$Type());
}
TypeCheckerVisitor.prototype.visitTypeAnnotation = function(node) {
  var $0;
  if (node.typeName == null) return this.types.dynamicType;
  var name = node.typeName.get$source();
  var type = this.computeType((($0 = this.elements.$index(node)) == null ? null : $0.assert$Element()));
  if (type == null) type = this.types.lookup(name);
  if (type == null) {
    return this.types.dynamicType;
  }
  return type;
}
TypeCheckerVisitor.prototype.visitVariableDefinitions = function(node) {
  var $0;
  var type = this.typeWithDefault(node.type, this.types.dynamicType);
  if ($eq(type, this.types.voidType)) {
    this.reportTypeWarning(node.type, const$268/*MessageKind.VOID_VARIABLE*/, const$21/*const []*/);
    type = this.types.dynamicType;
  }
  for (var link = node.definitions.get$nodes();
   !$notnull_bool(link.isEmpty()); link = (($0 = link.get$tail()) == null ? null : $0.assert$Link_Node())) {
    var initialization = (($0 = link.get$head()) == null ? null : $0.assert$Node());
    this.compiler.ensure((initialization instanceof Identifier) || (initialization instanceof Send));
    if ((initialization instanceof Send)) {
      var initializer = this.nonVoidType((($0 = link.get$head()) == null ? null : $0.assert$Node()));
      this.checkAssignable(node, type, initializer);
    }
  }
  return null;
}
TypeCheckerVisitor.prototype.visitWhile = function(node) {
  this.checkCondition(node.condition);
  this.type(node.body);
}
TypeCheckerVisitor.prototype.visitParenthesizedExpression = function(node) {
  return this.type(node.expression);
}
// ********** Code for Universe **************
function Universe() {
  this.elements = $map([]);
  this.generatedCode = $map([]);
  this.scope = new Element(const$4, null, null);
  // Initializers done
}
Universe.prototype.find = function(name) {
  var $0;
  return (($0 = this.elements.$index(name)) == null ? null : $0.assert$Element());
}
Universe.prototype.define = function(element) {
  $assert(this.elements.$index(element.name) == null, "elements[element.name] == null", "universe.dart", 20, 12);
  this.elements.$setindex(element.name, element);
}
Universe.prototype.addGeneratedCode = function(element, code) {
  this.generatedCode.$setindex(element, code);
}
// ********** Code for MessageKind **************
function MessageKind(template) {
  this.template = template;
  // Initializers done
}
MessageKind.prototype.get$template = function() { return this.template; };
MessageKind.prototype.toString = function() {
  return this.template;
}
MessageKind.prototype.toString$0 = MessageKind.prototype.toString;
// ********** Code for Message **************
function Message(kind, arguments) {
  this.kind = kind;
  this.arguments = arguments;
  // Initializers done
}
Message.prototype.get$kind = function() { return this.kind; };
Message.prototype.get$arguments = function() { return this.arguments; };
Message.prototype.toString = function() {
  if (this.message == null) {
    this.message = $assert_String(this.kind.get$template());
    var position = 1;
    var $list = this.arguments;
    for (var $i0 = 0;$i0 < $list.length; $i0++) {
      var argument = $list.$index($i0);
      this.message = this.message.replaceAll(('#{' + (position++) + '}'), argument.toString$0());
    }
  }
  return this.message;
}
Message.prototype.$eq = function(other) {
  if (!(other instanceof Message)) return false;
  return $notnull_bool(($eq(this.kind, other.get$kind()))) && (this.toString() == other.toString$0());
}
Message.prototype.toString$0 = Message.prototype.toString;
// ********** Code for TypeWarning **************
function TypeWarning(kind, arguments) {
  this.message = new Message(kind, arguments);
  // Initializers done
}
TypeWarning.prototype.toString = function() {
  return this.message.toString();
}
TypeWarning.prototype.toString$0 = TypeWarning.prototype.toString;
// ********** Code for ResolutionError **************
function ResolutionError(kind, arguments) {
  this.message = new Message(kind, arguments);
  // Initializers done
}
ResolutionError.prototype.toString = function() {
  return this.message.toString();
}
ResolutionError.prototype.toString$0 = ResolutionError.prototype.toString;
// ********** Code for ResolutionWarning **************
function ResolutionWarning(kind, arguments) {
  this.message = new Message(kind, arguments);
  // Initializers done
}
ResolutionWarning.prototype.toString = function() {
  return this.message.toString();
}
ResolutionWarning.prototype.toString$0 = ResolutionWarning.prototype.toString;
// ********** Code for top level **************
function unreachable() {
  $throw(const$239/*const Exception("Internal Error (Leg): UNREACHABLE")*/);
}
//  ********** Library frog_leg **************
// ********** Code for WorldCompiler **************
function WorldCompiler(world, script) {
  this.world = world;
  // Initializers done
  Compiler.call(this, script);
}
$inherits(WorldCompiler, Compiler);
WorldCompiler.prototype.log = function(message) {
  if ($notnull_bool($globals.options.showInfo)) {
    this.world.info(('[leg] ' + message));
  }
}
WorldCompiler.prototype.run = function() {
  var success = Compiler.prototype.run.call(this);
  if ($notnull_bool(success)) {
    var code = this.getGeneratedCode();
    this.world.legCode = $assert_String(code);
    this.world.jsBytesWritten = $assert_num(code.length);
    var $list = this.tasks;
    for (var $i = 0;$i < $list.length; $i++) {
      var task = $list.$index($i);
      this.log(('' + task.get$name() + ' took ' + task.get$timing() + 'msec'));
    }
  }
  return success;
}
WorldCompiler.prototype.spanFromNode = function(node) {
  var begin = node.getBeginToken();
  var end = node.getEndToken();
  if (begin == null || end == null) {
    this.cancel(('cannot find tokens to produce error message for ' + node + '.'));
  }
  var startOffset = begin.get$charOffset();
  var endOffset = end.get$charOffset() + end.toString$0().length;
  return new SourceSpan(this.script.file, startOffset, endOffset);
}
WorldCompiler.prototype.reportWarning = function(node, message) {
  var $0;
  this.world.warning(('' + message + '.'), (($0 = this.spanFromNode(node)) == null ? null : $0.assert$SourceSpan()));
}
WorldCompiler.prototype.reportError = function(node, message) {
  this.cancel(message.toString$0(), node);
}
WorldCompiler.prototype.readScript = function(filename) {
  var text = $globals.world.files.readAll(filename);
  var sourceFile = new SourceFile(filename, text);
  return new leg_Script(sourceFile);
}
WorldCompiler.prototype.get$legDirectory = function() {
  return join([$globals.options.libDir, '..', 'leg']);
}
WorldCompiler.prototype.cancel = function(reason, node, token, instruction) {
  if (node != null) {
    print(this.spanFromNode(node).toMessageString$1(("cancel leg: " + reason)));
  }
  else if (token != null) {
    var tokenString = token.toString$0();
    var begin = $assert_num(token.get$charOffset());
    var end = begin + tokenString.length;
    print(this.script.file.getLocationMessage$4(("cancel leg: " + reason), begin, end, true));
  }
  Compiler.prototype.cancel.call(this, reason, node, (token == null ? null : token.assert$Token()), (instruction == null ? null : instruction.assert$HInstruction()));
}
// ********** Code for top level **************
function compile(world) {
  var file = world.readFile($globals.options.dartScript);
  var script = new leg_Script(file);
  var compiler = new WorldCompiler(world, script);
  return compiler.run();
}
//  ********** Library lang **************
// ********** Code for CodeWriter **************
function CodeWriter() {
  this._indentation = 0
  this._pendingIndent = false
  this.writeComments = true
  this._buf = new StringBufferImpl("");
  // Initializers done
}
CodeWriter.prototype.assert$CodeWriter = function(){return this};
CodeWriter.prototype.get$text = function() {
  return this._buf.toString();
}
CodeWriter.prototype._indent = function() {
  this._pendingIndent = false;
  for (var i = 0;
   i < this._indentation; i++) {
    this._buf.add('  '/*CodeWriter.INDENTATION*/);
  }
}
CodeWriter.prototype.comment = function(text) {
  if ($notnull_bool(this.writeComments)) {
    this.writeln(text);
  }
}
CodeWriter.prototype.write = function(text) {
  var $0;
  if (text.length == 0) return;
  if ($notnull_bool(this._pendingIndent)) this._indent();
  if (text.indexOf('\n') != -1) {
    var lines = text.split('\n');
    for (var i = 0;
     i < lines.length - 1; i++) {
      this.writeln($assert_String(lines.$index(i)));
    }
    this.write($assert_String(lines.$index(lines.length - 1)));
  }
  else {
    this._buf.add(text);
  }
}
CodeWriter.prototype.writeln = function(text) {
  if (text != null) {
    this.write(text);
  }
  if (!text.endsWith('\n')) this._buf.add('\n'/*CodeWriter.NEWLINE*/);
  this._pendingIndent = true;
}
CodeWriter.prototype.enterBlock = function(text) {
  this.writeln(text);
  this._indentation++;
}
CodeWriter.prototype.exitBlock = function(text) {
  this._indentation--;
  this.writeln(text);
}
CodeWriter.prototype.nextBlock = function(text) {
  this._indentation--;
  this.writeln(text);
  this._indentation++;
}
// ********** Code for CoreJs **************
function CoreJs() {
  this.useStackTraceOf = false
  this.useThrow = false
  this.useGenStub = false
  this.useMap = false
  this.useAssert = false
  this.useNotNullBool = false
  this.useIndex = false
  this.useSetIndex = false
  this.useWrap0 = false
  this.useWrap1 = false
  this.useIsolates = false
  this.useToString = false
  this._generatedTypeNameOf = false
  this._generatedDynamicProto = false
  this._generatedInherits = false
  this._usedOperators = $map([]);
  this.writer = new CodeWriter();
  // Initializers done
}
CoreJs.prototype.useOperator = function(name) {
  if ($notnull_bool($ne(this._usedOperators.$index(name), null))) return;
  var code;
  switch (name) {
    case '\$ne':

      code = "function $ne(x, y) {\n  if (x == null) return y != null;\n  return (typeof(x) == 'number' && typeof(y) == 'number') ||\n         (typeof(x) == 'boolean' && typeof(y) == 'boolean') ||\n         (typeof(x) == 'string' && typeof(y) == 'string')\n    ? x != y : !x.$eq(y);\n}";
      break;

    case '\$eq':

      code = "function $eq(x, y) {\n  if (x == null) return y == null;\n  return (typeof(x) == 'number' && typeof(y) == 'number') ||\n         (typeof(x) == 'boolean' && typeof(y) == 'boolean') ||\n         (typeof(x) == 'string' && typeof(y) == 'string')\n    ? x == y : x.$eq(y);\n}\n// TODO(jimhug): Should this or should it not match equals?\nObject.prototype.$eq = function(other) { return this === other; }";
      break;

    case '\$bit_not':

      code = "function $bit_not(x) {\n  return (typeof(x) == 'number') ? ~x : x.$bit_not();\n}";
      break;

    case '\$negate':

      code = "function $negate(x) {\n  return (typeof(x) == 'number') ? -x : x.$negate();\n}";
      break;

    case '\$add':

      code = "function $add(x, y) {\n  return ((typeof(x) == 'number' && typeof(y) == 'number') ||\n          (typeof(x) == 'string'))\n    ? x + y : x.$add(y);\n}";
      break;

    case '\$truncdiv':

      this.useThrow = true;
      code = "function $truncdiv(x, y) {\n  if (typeof(x) == 'number' && typeof(y) == 'number') {\n    if (y == 0) $throw(new IntegerDivisionByZeroException());\n    var tmp = x / y;\n    return (tmp < 0) ? Math.ceil(tmp) : Math.floor(tmp);\n  } else {\n    return x.$truncdiv(y);\n  }\n}";
      break;

    case '\$mod':

      code = "function $mod(x, y) {\n  if (typeof(x) == 'number' && typeof(y) == 'number') {\n    var result = x % y;\n    if (result == 0) {\n      return 0;  // Make sure we don't return -0.0.\n    } else if (result < 0) {\n      if (y < 0) {\n        return result - y;\n      } else {\n        return result + y;\n      }\n    }\n    return result;\n  } else {\n    return x.$mod(y);\n  }\n}";
      break;

    default:

      var op = TokenKind.rawOperatorFromMethod(name);
      code = ("function " + name + "(x, y) {\n  return (typeof(x) == 'number' && typeof(y) == 'number')\n    ? x " + op + " y : x." + name + "(y);\n}");
      break;

  }
  this._usedOperators.$setindex(name, code);
}
CoreJs.prototype.ensureDynamicProto = function() {
  if ($notnull_bool(this._generatedDynamicProto)) return;
  this._generatedDynamicProto = true;
  this.ensureTypeNameOf();
  this.writer.writeln("function $dynamic(name) {\n  var f = Object.prototype[name];\n  if (f && f.methods) return f.methods;\n\n  var methods = {};\n  if (f) methods.Object = f;\n  function $dynamicBind() {\n    // Find the target method\n    var method;\n    var proto = Object.getPrototypeOf(this);\n    var obj = proto;\n    do {\n      method = methods[obj.$typeNameOf()];\n      if (method) break;\n      obj = Object.getPrototypeOf(obj);\n    } while (obj);\n\n    // Patch the prototype, but don't overwrite an existing stub, like\n    // the one on Object.prototype.\n    if (!proto.hasOwnProperty(name)) proto[name] = method || methods.Object;\n\n    return method.apply(this, Array.prototype.slice.call(arguments));\n  };\n  $dynamicBind.methods = methods;\n  Object.prototype[name] = $dynamicBind;\n  return methods;\n}");
}
CoreJs.prototype.ensureTypeNameOf = function() {
  if ($notnull_bool(this._generatedTypeNameOf)) return;
  this._generatedTypeNameOf = true;
  this.writer.writeln("Object.prototype.$typeNameOf = function() {\n  if ((typeof(window) != 'undefined' && window.constructor.name == 'DOMWindow')\n      || typeof(process) != 'undefined') { // fast-path for Chrome and Node\n    return this.constructor.name;\n  }\n  var str = Object.prototype.toString.call(this);\n  str = str.substring(8, str.length - 1);\n  if (str == 'Window') str = 'DOMWindow';\n  return str;\n}");
}
CoreJs.prototype.ensureInheritsHelper = function() {
  if ($notnull_bool(this._generatedInherits)) return;
  this._generatedInherits = true;
  this.writer.writeln("/** Implements extends for Dart classes on JavaScript prototypes. */\nfunction $inherits(child, parent) {\n  if (child.prototype.__proto__) {\n    child.prototype.__proto__ = parent.prototype;\n  } else {\n    function tmp() {};\n    tmp.prototype = parent.prototype;\n    child.prototype = new tmp();\n    child.prototype.constructor = child;\n  }\n}");
}
CoreJs.prototype.generate = function(w) {
  w.write(this.writer.get$text());
  this.writer = w;
  if ($notnull_bool(this.useGenStub)) {
    this.useThrow = true;
    w.writeln("/**\n * Generates a dynamic call stub for a function.\n * Our goal is to create a stub method like this on-the-fly:\n *   function($0, $1, capture) { return this($0, $1, true, capture); }\n *\n * This stub then replaces the dynamic one on Function, with one that is\n * specialized for that particular function, taking into account its default\n * arguments.\n */\nFunction.prototype.$genStub = function(argsLength, names) {\n  // Fast path: if no named arguments and arg count matches\n  if (this.length == argsLength && !names) {\n    return this;\n  }\n\n  function $throwArgMismatch() {\n    // TODO(jmesserly): better error message\n    $throw(new ClosureArgumentMismatchException());\n  }\n\n  var paramsNamed = this.$optional ? (this.$optional.length / 2) : 0;\n  var paramsBare = this.length - paramsNamed;\n  var argsNamed = names ? names.length : 0;\n  var argsBare = argsLength - argsNamed;\n\n  // Check we got the right number of arguments\n  if (argsBare < paramsBare || argsLength > this.length ||\n      argsNamed > paramsNamed) {\n    return $throwArgMismatch;\n  }\n\n  // First, fill in all of the default values\n  var p = new Array(paramsBare);\n  if (paramsNamed) {\n    p = p.concat(this.$optional.slice(paramsNamed));\n  }\n  // Fill in positional args\n  var a = new Array(argsLength);\n  for (var i = 0; i < argsBare; i++) {\n    p[i] = a[i] = '$' + i;\n  }\n  // Then overwrite with supplied values for optional args\n  var lastParameterIndex;\n  var namesInOrder = true;\n  for (var i = 0; i < argsNamed; i++) {\n    var name = names[i];\n    a[i + argsBare] = name;\n    var j = this.$optional.indexOf(name);\n    if (j < 0 || j >= paramsNamed) {\n      return $throwArgMismatch;\n    } else if (lastParameterIndex && lastParameterIndex > j) {\n      namesInOrder = false;\n    }\n    p[j + paramsBare] = name;\n    lastParameterIndex = j;\n  }\n\n  if (this.length == argsLength && namesInOrder) {\n    // Fast path #2: named arguments, but they're in order.\n    return this;\n  }\n\n  // Note: using Function instead of 'eval' to get a clean scope.\n  // TODO(jmesserly): evaluate the performance of these stubs.\n  var f = 'function(' + a.join(',') + '){return $f(' + p.join(',') + ');}';\n  return new Function('$f', 'return ' + f + '').call(null, this);\n}");
  }
  if ($notnull_bool(this.useStackTraceOf)) {
    w.writeln("function $stackTraceOf(e) {\n  // TODO(jmesserly): we shouldn't be relying on the e.stack property.\n  // Need to mangle it.\n  return  (e && e.stack) ? e.stack : null;\n}");
  }
  if ($notnull_bool(this.useNotNullBool)) {
    this.useThrow = true;
    w.writeln("function $notnull_bool(test) {\n  if (test === true || test === false) return test;\n  $throw(new TypeError(test, 'bool'));\n}");
  }
  if ($notnull_bool(this.useAssert)) {
    this.useThrow = true;
    w.writeln("function $assert(test, text, url, line, column) {\n  if (typeof test == 'function') test = test();\n  if (!test) $throw(new AssertError(text, url, line, column));\n}");
  }
  if ($notnull_bool(this.useThrow)) {
    w.writeln("function $throw(e) {\n  // If e is not a value, we can use V8's captureStackTrace utility method.\n  // TODO(jmesserly): capture the stack trace on other JS engines.\n  if (e && (typeof e == 'object') && Error.captureStackTrace) {\n    // TODO(jmesserly): this will clobber the e.stack property\n    Error.captureStackTrace(e, $throw);\n  }\n  throw e;\n}");
  }
  if ($notnull_bool(this.useMap)) {
    w.writeln("function $map(items) {\n  var ret = new HashMapImplementation();\n  for (var i=0; i < items.length;) {\n    ret.$setindex(items[i++], items[i++]);\n  }\n  return ret;\n}");
  }
  if ($notnull_bool(this.useToString)) {
    w.writeln("function $toString(o) {\n  if (o == null) return 'null';\n  var t = typeof(o);\n  if (t == 'object') { return o.toString(); }\n  else if (t == 'string') { return o; }\n  else if (t == 'bool') { return ''+o; }\n  else if (t == 'number') { return ''+o; }\n  else return o.toString();\n}");
  }
  if ($notnull_bool(this.useIndex)) {
    w.writeln("Object.prototype.$index = function(i) { return this[i]; }\nArray.prototype.$index = function(i) { return this[i]; }\nString.prototype.$index = function(i) { return this[i]; }");
  }
  if ($notnull_bool(this.useSetIndex)) {
    w.writeln("Object.prototype.$setindex = function(i, value) { return this[i] = value; }\nArray.prototype.$setindex = function(i, value) { return this[i] = value; }");
  }
  if ($notnull_bool(this.useIsolates)) {
    if ($notnull_bool(this.useWrap0)) {
      w.writeln("// Wrap a 0-arg dom-callback to bind it with the current isolate:\nfunction $wrap_call$0(fn) { return fn && fn.wrap$call$0(); }\nFunction.prototype.wrap$call$0 = function() {\n  var isolateContext = $globalState.currentContext;\n  var self = this;\n  this.wrap$0 = function() {\n    isolateContext.eval(self);\n    $globalState.topEventLoop.run();\n  };\n  this.wrap$call$0 = function() { return this.wrap$0; };\n  return this.wrap$0;\n}");
    }
    if ($notnull_bool(this.useWrap1)) {
      w.writeln("// Wrap a 1-arg dom-callback to bind it with the current isolate:\nfunction $wrap_call$1(fn) { return fn && fn.wrap$call$1(); }\nFunction.prototype.wrap$call$1 = function() {\n  var isolateContext = $globalState.currentContext;\n  var self = this;\n  this.wrap$1 = function(arg) {\n    isolateContext.eval(function() { self(arg); });\n    $globalState.topEventLoop.run();\n  };\n  this.wrap$call$1 = function() { return this.wrap$1; };\n  return this.wrap$1;\n}");
    }
    w.writeln("var $globalThis = this;\nvar $globals = null;\nvar $globalState = null;");
  }
  else {
    if ($notnull_bool(this.useWrap0)) {
      w.writeln("function $wrap_call$0(fn) { return fn; }");
    }
    if ($notnull_bool(this.useWrap1)) {
      w.writeln("function $wrap_call$1(fn) { return fn; }");
    }
  }
  var $list = orderValuesByKeys(this._usedOperators);
  for (var $i = 0;$i < $list.length; $i++) {
    var opImpl = $list.$index($i);
    w.writeln($assert_String(opImpl));
  }
}
CoreJs.prototype.generate$1 = function($0) {
  return this.generate(($0 == null ? null : $0.assert$CodeWriter()));
};
// ********** Code for lang_Element **************
function lang_Element(name, _enclosingElement) {
  this.name = name;
  this._enclosingElement = _enclosingElement;
  // Initializers done
  this._jsname = this.name;
}
lang_Element.prototype.assert$lang_Element = function(){return this};
lang_Element.prototype.get$name = function() { return this.name; };
lang_Element.prototype.set$name = function(value) { return this.name = value; };
lang_Element.prototype.get$library = function() {
  return null;
}
lang_Element.prototype.get$span = function() {
  return null;
}
lang_Element.prototype.get$isNative = function() {
  return false;
}
lang_Element.prototype.hashCode = function() {
  return this.name.hashCode();
}
lang_Element.prototype.get$jsname = function() {
  return this._jsname;
}
lang_Element.prototype.resolve = function() {

}
lang_Element.prototype.get$typeParameters = function() {
  return null;
}
lang_Element.prototype.get$enclosingElement = function() {
  var $0;
  return (($0 = this._enclosingElement == null ? this.get$library() : this._enclosingElement) == null ? null : $0.assert$lang_Element());
}
lang_Element.prototype.set$enclosingElement = function(e) {
  return this._enclosingElement = e;
}
lang_Element.prototype.resolveType = function(node, typeErrors) {
  var $0;
  if (node == null) return $globals.world.varType;
  if (node.type != null) return node.type;
  if ((node instanceof NameTypeReference)) {
    var typeRef = (node == null ? null : node.assert$NameTypeReference());
    var name;
    if (typeRef.names != null) {
      name = $assert_String(typeRef.names.last().get$name());
    }
    else {
      name = typeRef.name.name;
    }
    if (this.get$typeParameters() != null) {
      var $list = this.get$typeParameters();
      for (var $i = 0;$i < $list.length; $i++) {
        var tp = $list.$index($i);
        if ($notnull_bool($eq(tp.get$name(), name))) {
          typeRef.type = (tp == null ? null : tp.assert$lang_Type());
        }
      }
    }
    if (typeRef.type != null) {
      return typeRef.type;
    }
    return this.get$enclosingElement().resolveType(node, typeErrors);
  }
  else if ((node instanceof GenericTypeReference)) {
    var typeRef = (node == null ? null : node.assert$GenericTypeReference());
    var baseType = this.resolveType(typeRef.baseType, typeErrors);
    if (!$notnull_bool(baseType.get$isGeneric())) {
      $globals.world.error(('' + baseType.get$name() + ' is not generic'), typeRef.span);
      return null;
    }
    if (typeRef.typeArguments.length != baseType.get$typeParameters().length) {
      $globals.world.error('wrong number of type arguments', typeRef.span);
      return null;
    }
    var typeArgs = [];
    for (var i = 0;
     i < typeRef.typeArguments.length; i++) {
      var extendsType = baseType.get$typeParameters().$index(i).get$extendsType();
      var typeArg = this.resolveType((($0 = typeRef.typeArguments.$index(i)) == null ? null : $0.assert$TypeReference()), typeErrors);
      typeArgs.add$1(typeArg);
      if ($notnull_bool($ne(extendsType, null)) && !(typeArg instanceof ParameterType)) {
        typeArg.ensureSubtypeOf$3(extendsType, typeRef.typeArguments.$index(i).get$span(), typeErrors);
      }
    }
    typeRef.type = (($0 = baseType.getOrMakeConcreteType$1(typeArgs)) == null ? null : $0.assert$lang_Type());
  }
  else if ((node instanceof FunctionTypeReference)) {
    var typeRef = (node == null ? null : node.assert$FunctionTypeReference());
    var name = '';
    if (typeRef.func.name != null) {
      name = typeRef.func.name.name;
    }
    typeRef.type = this.get$library().getOrAddFunctionType(this, $assert_String(name), typeRef.func);
  }
  else {
    $globals.world.internalError('unknown type reference', node.span);
  }
  return node.type;
}
lang_Element.prototype.hashCode$0 = lang_Element.prototype.hashCode;
lang_Element.prototype.resolve$0 = lang_Element.prototype.resolve;
// ********** Code for WorldGenerator **************
function WorldGenerator(main, writer) {
  this.hasStatics = false
  this.main = main;
  this.writer = writer;
  this.globals = $map([]);
  this.corejs = new CoreJs();
  // Initializers done
}
WorldGenerator.prototype.run = function() {
  var $0;
  var metaGen = new MethodGenerator(this.main, null);
  var mainTarget = new Value.type$ctor(this.main.declaringType, this.main.get$span());
  var mainCall = this.main.invoke((metaGen == null ? null : metaGen.assert$MethodGenerator()), null, (mainTarget == null ? null : mainTarget.assert$Value()), Arguments.get$EMPTY(), false);
  this.main.declaringType.markUsed();
  if ($notnull_bool($globals.options.compileAll)) {
    this.markLibraryUsed($globals.world.corelib);
    this.markLibraryUsed(this.main.declaringType.get$library());
  }
  else {
    $globals.world.corelib.types.$index('BadNumberFormatException').markUsed$0();
    $globals.world.get$coreimpl().types.$index('NumImplementation').markUsed$0();
    $globals.world.get$coreimpl().types.$index('StringImplementation').markUsed$0();
    this.genMethod((($0 = $globals.world.get$coreimpl().types.$index('StringImplementation').getMember$1('contains')) == null ? null : $0.assert$Member()));
  }
  if ($notnull_bool($globals.world.corelib.types.$index('Isolate').get$isUsed()) || $notnull_bool($globals.world.get$coreimpl().types.$index('ReceivePortImpl').get$isUsed())) {
    if ($notnull_bool(this.corejs.useWrap0) || $notnull_bool(this.corejs.useWrap1)) {
      this.genMethod((($0 = $globals.world.get$coreimpl().types.$index('IsolateContext').getMember$1('eval')) == null ? null : $0.assert$Member()));
      this.genMethod((($0 = $globals.world.get$coreimpl().types.$index('EventLoop').getMember$1('run')) == null ? null : $0.assert$Member()));
    }
    this.corejs.useIsolates = true;
    var isolateMain = (($0 = $globals.world.get$coreimpl().topType.resolveMember('startRootIsolate').members.$index(0)) == null ? null : $0.assert$MethodMember());
    var isolateMainTarget = new Value.type$ctor($globals.world.get$coreimpl().topType, this.main.get$span());
    mainCall = isolateMain.invoke((metaGen == null ? null : metaGen.assert$MethodGenerator()), null, (isolateMainTarget == null ? null : isolateMainTarget.assert$Value()), new Arguments(null, [this.main._get((metaGen == null ? null : metaGen.assert$MethodGenerator()), this.main.definition, null, false)]), false);
  }
  this.writeTypes($globals.world.get$coreimpl());
  this.writeTypes($globals.world.corelib);
  this.writeTypes(this.main.declaringType.get$library());
  if (this._mixins != null) this.writer.write(this._mixins.get$text());
  this.writeGlobals();
  this.writer.writeln(('' + mainCall.get$code() + ';'));
}
WorldGenerator.prototype.markLibraryUsed = function(l) {
  var $this = this; // closure support
  var $0;
  if ($notnull_bool(l.isMarked)) return;
  l.isMarked = true;
  l.imports.forEach((function (i) {
    var $0;
    return $this.markLibraryUsed((($0 = i.get$library()) == null ? null : $0.assert$Library()));
  })
  );
  var $list = l.types.getValues();
  for (var $i = l.types.getValues().iterator$0(); $i.hasNext$0(); ) {
    var type = $i.next$0();
    if (!$notnull_bool(type.get$isClass())) continue;
    type.markUsed$0();
    type.set$isTested(!$notnull_bool(type.get$isTop()) && !($notnull_bool(type.get$isNative()) && $notnull_bool(type.get$members().getValues$0().every$1((function (m) {
      return $notnull_bool(m.get$isStatic()) && !$notnull_bool(m.get$isFactory());
    })
    ))));
    var $list0 = type.get$members().getValues$0();
    for (var $i0 = type.get$members().getValues$0().iterator$0(); $i0.hasNext$0(); ) {
      var member = $i0.next$0();
      if ((member instanceof PropertyMember)) {
        if ($notnull_bool($ne(member.get$getter(), null))) this.genMethod((($0 = member.get$getter()) == null ? null : $0.assert$Member()));
        if ($notnull_bool($ne(member.get$setter(), null))) this.genMethod((($0 = member.get$setter()) == null ? null : $0.assert$Member()));
      }
      if ($notnull_bool(member.get$isMethod())) this.genMethod((member == null ? null : member.assert$Member()));
    }
  }
}
WorldGenerator.prototype.globalForStaticField = function(field, fieldValue, dependencies) {
  var $0;
  this.hasStatics = true;
  var fullname = ("" + field.declaringType.get$jsname() + "." + field.get$jsname());
  if (!this.globals.containsKey(fullname)) {
    this.globals.$setindex(fullname, GlobalValue.GlobalValue$fromStatic$factory(field, fieldValue, dependencies));
  }
  return (($0 = this.globals.$index(fullname)) == null ? null : $0.assert$GlobalValue());
}
WorldGenerator.prototype.globalForConst = function(exp, dependencies) {
  var $0;
  var key = exp.type.get$jsname() + ':' + exp.canonicalCode;
  if (!this.globals.containsKey(key)) {
    this.globals.$setindex(key, GlobalValue.GlobalValue$fromConst$factory(this.globals.get$length(), exp, dependencies));
  }
  $assert($eq(this.globals.$index(key).get$type(), exp.type), "globals[key].type == exp.type", "gen.dart", 130, 12);
  return (($0 = this.globals.$index(key)) == null ? null : $0.assert$GlobalValue());
}
WorldGenerator.prototype.writeTypes = function(lib) {
  var $0;
  if ($notnull_bool(lib.isWritten)) return;
  lib.isWritten = true;
  var $list = lib.imports;
  for (var $i = 0;$i < $list.length; $i++) {
    var import_ = $list.$index($i);
    this.writeTypes((($0 = import_.get$library()) == null ? null : $0.assert$Library()));
  }
  for (var i = 0;
   i < lib.sources.length; i++) {
    lib.sources.$index(i).set$orderInLibrary(i);
  }
  this.writer.comment(('//  ********** Library ' + lib.name + ' **************'));
  if ($notnull_bool(lib.get$isCore())) {
    this.writer.comment('//  ********** Natives dart:core **************');
    this.corejs.generate(this.writer);
  }
  var $list = lib.natives;
  for (var $i = 0;$i < $list.length; $i++) {
    var file = $list.$index($i);
    var filename = basename($assert_String(file.get$filename()));
    this.writer.comment(('//  ********** Natives ' + filename + ' **************'));
    this.writer.writeln($assert_String(file.get$text()));
  }
  lib.topType.markUsed();
  var $list = this._orderValues(lib.types);
  for (var $i = 0;$i < $list.length; $i++) {
    var type = $list.$index($i);
    if (($notnull_bool(type.get$isUsed()) || $notnull_bool(type.get$isHiddenNativeType())) && $notnull_bool(type.get$isClass())) {
      this.writeType((type == null ? null : type.assert$lang_Type()));
      if ($notnull_bool(type.get$isGeneric())) {
        var $list0 = this._orderValues(type._concreteTypes);
        for (var $i0 = 0;$i0 < $list0.length; $i0++) {
          var ct = $list0.$index($i0);
          this.writeType((ct == null ? null : ct.assert$lang_Type()));
        }
      }
    }
    else if ($notnull_bool(type.get$isFunction()) && type.get$varStubs().length > 0) {
      this.writer.comment(('// ********** Code for ' + type.get$jsname() + ' **************'));
      this._writeDynamicStubs((type == null ? null : type.assert$lang_Type()));
    }
    if ($notnull_bool($ne(type.get$typeCheckCode(), null))) {
      this.writer.writeln($assert_String(type.get$typeCheckCode()));
    }
  }
}
WorldGenerator.prototype.genMethod = function(meth, enclosingMethod) {
  if (!$notnull_bool(meth.isGenerated) && !$notnull_bool(meth.get$isAbstract()) && $notnull_bool($ne(meth.get$definition(), null))) {
    new MethodGenerator(meth, enclosingMethod).run();
  }
}
WorldGenerator.prototype._prototypeOf = function(type, name) {
  if ($notnull_bool(type.get$isHiddenNativeType())) {
    this.corejs.ensureDynamicProto();
    return ('\$dynamic("' + name + '").' + type.get$jsname());
  }
  else {
    return ('' + type.get$jsname() + '.prototype.' + name);
  }
}
WorldGenerator.prototype._maybeIsTest = function(onType, checkType) {
  var isSubtype = onType.isSubtypeOf(checkType);
  if ($notnull_bool(checkType.isTested)) {
    this.writer.writeln(this._prototypeOf(onType, ('is\$' + checkType.get$jsname())) + (' = function(){return ' + isSubtype + '};'));
  }
  if ($notnull_bool(checkType.isChecked)) {
    var body = 'return this';
    var checkName = ('assert\$' + checkType.get$jsname());
    if (!$notnull_bool(isSubtype)) {
      body = $assert_String($globals.world.objectType.varStubs.$index(checkName).get$body());
    }
    this.writer.writeln(this._prototypeOf(onType, checkName) + (' = function(){' + body + '};'));
  }
}
WorldGenerator.prototype.writeType = function(type) {
  var $0;
  if (type.name != null && (type instanceof ConcreteType) && $eq(type.get$library(), $globals.world.get$coreimpl()) && type.name.startsWith('ListFactory')) {
    this.writer.writeln(('' + type.get$jsname() + ' = ' + type.get$genericType().get$jsname() + ';'));
    return;
  }
  var typeName = type.get$jsname() != null ? type.get$jsname() : 'top level';
  this.writer.comment(('// ********** Code for ' + typeName + ' **************'));
  if ($notnull_bool(type.get$isNative()) && !$notnull_bool(type.get$isTop())) {
    var nativeName = type.get$definition().get$nativeType().get$name();
    if ($notnull_bool($eq(nativeName, ''))) {
      this.writer.writeln(('function ' + type.get$jsname() + '() {}'));
    }
    else if (type.get$jsname() != nativeName) {
      this.writer.writeln(('' + type.get$jsname() + ' = ' + nativeName + ';'));
    }
  }
  if ($notnull_bool(type.get$isTop())) {
  }
  else if (type.get$constructors().get$length() == 0) {
    if (!$notnull_bool(type.get$isNative())) {
      this.writer.writeln(('function ' + type.get$jsname() + '() {}'));
    }
  }
  else {
    var standardConstructor = (($0 = type.get$constructors().$index('')) == null ? null : $0.assert$Member());
    if (standardConstructor == null || standardConstructor.generator == null) {
      if (!$notnull_bool(type.get$isNative())) {
        this.writer.writeln(('function ' + type.get$jsname() + '() {}'));
      }
    }
    else {
      standardConstructor.generator.writeDefinition(this.writer, null);
    }
    var $list = type.get$constructors().getValues();
    for (var $i = type.get$constructors().getValues().iterator$0(); $i.hasNext$0(); ) {
      var c = $i.next$0();
      if ($notnull_bool($ne(c.get$generator(), null)) && $notnull_bool($ne(c, standardConstructor))) {
        c.get$generator().writeDefinition$2(this.writer);
      }
    }
  }
  if (!$notnull_bool(type.get$isTop())) {
    if ((type instanceof ConcreteType)) {
      var c = (type == null ? null : type.assert$ConcreteType());
      this.corejs.ensureInheritsHelper();
      this.writer.writeln(('\$inherits(' + c.get$jsname() + ', ' + c.genericType.get$jsname() + ');'));
      for (var p = c._parent;
       (p instanceof ConcreteType); p = p._parent) {
        this._ensureInheritMembersHelper();
        this._mixins.writeln(('\$inheritsMembers(' + c.get$jsname() + ', ' + p.get$jsname() + ');'));
      }
    }
    else if (!$notnull_bool(type.get$isNative())) {
      if (type.get$parent() != null && !$notnull_bool(type.get$parent().get$isObject())) {
        this.corejs.ensureInheritsHelper();
        this.writer.writeln(('\$inherits(' + type.get$jsname() + ', ' + type.get$parent().get$jsname() + ');'));
      }
    }
  }
  if (!(type instanceof ConcreteType)) {
    this._maybeIsTest(type, type);
  }
  if (type.get$genericType()._concreteTypes != null) {
    var $list = this._orderValues(type.get$genericType()._concreteTypes);
    for (var $i = 0;$i < $list.length; $i++) {
      var ct = $list.$index($i);
      this._maybeIsTest(type, (ct == null ? null : ct.assert$lang_Type()));
    }
  }
  if (type.get$interfaces() != null) {
    var seen = new HashSetImplementation();
    var worklist = [];
    worklist.addAll(type.get$interfaces());
    seen.addAll(type.get$interfaces());
    while (!worklist.isEmpty()) {
      var interface_ = worklist.removeLast();
      this._maybeIsTest(type, (($0 = interface_.get$genericType()) == null ? null : $0.assert$lang_Type()));
      if (interface_.get$genericType()._concreteTypes != null) {
        var $list = this._orderValues(interface_.get$genericType()._concreteTypes);
        for (var $i = 0;$i < $list.length; $i++) {
          var ct = $list.$index($i);
          this._maybeIsTest(type, (ct == null ? null : ct.assert$lang_Type()));
        }
      }
      var $list = interface_.get$interfaces();
      for (var $i = interface_.get$interfaces().iterator$0(); $i.hasNext$0(); ) {
        var other = $i.next$0();
        if (!seen.contains(other)) {
          worklist.addLast(other);
          seen.add(other);
        }
      }
    }
  }
  type.get$factories().forEach(this.get$_writeMethod());
  var $list = this._orderValues(type.get$members());
  for (var $i = 0;$i < $list.length; $i++) {
    var member = $list.$index($i);
    if ((member instanceof FieldMember)) {
      this._writeField((member == null ? null : member.assert$FieldMember()));
    }
    if ((member instanceof PropertyMember)) {
      this._writeProperty((member == null ? null : member.assert$PropertyMember()));
    }
    if ($notnull_bool(member.get$isMethod())) {
      this._writeMethod((member == null ? null : member.assert$Member()));
    }
  }
  this._writeDynamicStubs(type);
}
WorldGenerator.prototype._ensureInheritMembersHelper = function() {
  if (this._mixins != null) return;
  this._mixins = new CodeWriter();
  this._mixins.comment('// ********** Generic Type Inheritance **************');
  this._mixins.writeln("/** Implements extends for generic types. */\nfunction $inheritsMembers(child, parent) {\n  child = child.prototype;\n  parent = parent.prototype;\n  Object.getOwnPropertyNames(parent).forEach(function(name) {\n    if (typeof(child[name]) == 'undefined') child[name] = parent[name];\n  });\n}");
}
WorldGenerator.prototype._writeDynamicStubs = function(type) {
  var $list = orderValuesByKeys(type.varStubs);
  for (var $i = 0;$i < $list.length; $i++) {
    var stub = $list.$index($i);
    stub.generate$1(this.writer);
  }
}
WorldGenerator.prototype._writeStaticField = function(field) {
  if ($notnull_bool(field.isFinal)) return;
  var fullname = ("" + field.declaringType.get$jsname() + "." + field.get$jsname());
  if (this.globals.containsKey(fullname)) {
    var value = this.globals.$index(fullname);
    if ($notnull_bool(field.declaringType.get$isTop()) && !$notnull_bool(field.isNative)) {
      this.writer.writeln(('\$globals.' + field.get$jsname() + ' = ' + value.get$exp().get$code() + ';'));
    }
    else {
      this.writer.writeln(('\$globals.' + field.declaringType.get$jsname() + '_' + field.get$jsname()) + (' = ' + value.get$exp().get$code() + ';'));
    }
  }
}
WorldGenerator.prototype._writeField = function(field) {
  if ($notnull_bool(field.declaringType.get$isTop()) && !$notnull_bool(field.isNative) && field.value == null) {
    this.writer.writeln(('var ' + field.get$jsname() + ';'));
  }
  if ($notnull_bool(field._providePropertySyntax)) {
    this.writer.writeln(this._prototypeOf(field.declaringType, ('get\$' + field.get$jsname())) + (' = function() { return this.' + field.get$jsname() + '; };'));
    if (!$notnull_bool(field.isFinal)) {
      this.writer.writeln(this._prototypeOf(field.declaringType, ('set\$' + field.get$jsname())) + (' = function(value) { return this.' + field.get$jsname() + ' = value; };'));
    }
  }
}
WorldGenerator.prototype._writeProperty = function(property) {
  if (property.getter != null) this._writeMethod(property.getter);
  if (property.setter != null) this._writeMethod(property.setter);
  if ($notnull_bool(property._provideFieldSyntax)) {
    this.writer.enterBlock('Object.defineProperty(' + ('' + property.declaringType.get$jsname() + '.prototype, "' + property.get$jsname() + '", {'));
    if (property.getter != null) {
      this.writer.write(('get: ' + property.declaringType.get$jsname() + '.prototype.' + property.getter.get$jsname()));
      this.writer.writeln(property.setter == null ? '' : ',');
    }
    if (property.setter != null) {
      this.writer.writeln(('set: ' + property.declaringType.get$jsname() + '.prototype.' + property.setter.get$jsname()));
    }
    this.writer.exitBlock('});');
  }
}
WorldGenerator.prototype._writeMethod = function(method) {
  if (method.generator != null) {
    method.generator.writeDefinition(this.writer, null);
  }
}
WorldGenerator.prototype.get$_writeMethod = function() {
  return WorldGenerator.prototype._writeMethod.bind(this);
}
WorldGenerator.prototype.writeGlobals = function() {
  var $0;
  if (this.globals.get$length() > 0) {
    this.writer.comment('//  ********** Globals **************');
    var list = this.globals.getValues();
    list.sort$1((function (a, b) {
      return a.compareTo$1(b);
    })
    );
    this.writer.enterBlock('function \$static_init(){');
    for (var $i = list.iterator$0(); $i.hasNext$0(); ) {
      var global = $i.next$0();
      if ($notnull_bool($ne(global.get$field(), null))) {
        this._writeStaticField((($0 = global.get$field()) == null ? null : $0.assert$FieldMember()));
      }
    }
    this.writer.exitBlock('}');
    for (var $i = list.iterator$0(); $i.hasNext$0(); ) {
      var global0 = $i.next$0();
      if ($notnull_bool(global0.get$field() == null)) {
        this.writer.writeln(('var ' + global0.get$name() + ' = ' + global0.get$exp().get$code() + ';'));
      }
    }
  }
  if (!$notnull_bool(this.corejs.useIsolates)) {
    if ($notnull_bool(this.hasStatics)) {
      this.writer.writeln('var \$globals = {};');
    }
    if (this.globals.get$length() > 0) {
      this.writer.writeln('\$static_init();');
    }
  }
}
WorldGenerator.prototype._orderValues = function(map) {
  var $0;
  var values = (($0 = map.getValues()) == null ? null : $0.assert$List());
  values.sort(this.get$_compareMembers());
  return values;
}
WorldGenerator.prototype._compareMembers = function(x, y) {
  if ($notnull_bool($ne(x.get$span(), null)) && $notnull_bool($ne(y.get$span(), null))) {
    var spans = $assert_num(x.get$span().compareTo$1(y.get$span()));
    if (spans != 0) return spans;
  }
  if ($notnull_bool(x.get$span() == null)) return 1;
  if ($notnull_bool(y.get$span() == null)) return -1;
  return $assert_num(x.get$name().compareTo$1(y.get$name()));
}
WorldGenerator.prototype.get$_compareMembers = function() {
  return WorldGenerator.prototype._compareMembers.bind(this);
}
WorldGenerator.prototype.useMapFactory = function() {
  var $0;
  this.corejs.useMap = true;
  var factType = $globals.world.get$coreimpl().types.$index('HashMapImplementation');
  var m = factType.resolveMember$1('\$setindex');
  this.genMethod((($0 = m.get$members().$index(0)) == null ? null : $0.assert$Member()));
  var c = factType.getConstructor$1('');
  this.genMethod((c == null ? null : c.assert$Member()));
  return (factType == null ? null : factType.assert$lang_Type());
}
// ********** Code for BlockScope **************
function BlockScope(enclosingMethod, parent, reentrant) {
  this.enclosingMethod = enclosingMethod;
  this.parent = parent;
  this.reentrant = reentrant;
  this._vars = $map([]);
  this._jsNames = new HashSetImplementation();
  // Initializers done
  if ($notnull_bool(this.get$isMethodScope())) {
    this._closedOver = new HashSetImplementation();
  }
  else {
    this.reentrant = $notnull_bool(reentrant) || $notnull_bool(this.parent.reentrant);
  }
}
BlockScope.prototype.assert$BlockScope = function(){return this};
BlockScope.prototype.get$enclosingMethod = function() { return this.enclosingMethod; };
BlockScope.prototype.set$enclosingMethod = function(value) { return this.enclosingMethod = value; };
BlockScope.prototype.get$parent = function() { return this.parent; };
BlockScope.prototype.set$parent = function(value) { return this.parent = value; };
BlockScope.prototype.get$rethrow = function() { return this.rethrow; };
BlockScope.prototype.set$rethrow = function(value) { return this.rethrow = value; };
BlockScope.prototype.get$reentrant = function() { return this.reentrant; };
BlockScope.prototype.set$reentrant = function(value) { return this.reentrant = value; };
BlockScope.prototype.get$isMethodScope = function() {
  return this.parent == null || $ne(this.parent.enclosingMethod, this.enclosingMethod);
}
BlockScope.prototype.get$methodScope = function() {
  var s = this;
  while (!$notnull_bool(s.get$isMethodScope())) s = s.get$parent();
  return (s == null ? null : s.assert$BlockScope());
}
BlockScope.prototype.lookup = function(name) {
  var ret = this._vars.$index(name);
  if ($notnull_bool($ne(ret, null))) return ret;
  for (var s = this.parent;
   $notnull_bool($ne(s, null)); s = s.get$parent()) {
    ret = s._vars.$index(name);
    if ($notnull_bool($ne(ret, null))) {
      if ($notnull_bool($ne(s.get$enclosingMethod(), this.enclosingMethod))) {
        s.get$methodScope()._closedOver.add(ret.get$code());
        if (this.enclosingMethod.captures != null && $notnull_bool(s.get$reentrant())) {
          this.enclosingMethod.captures.add(ret.get$code());
        }
      }
      return ret;
    }
  }
}
BlockScope.prototype._isDefinedInParent = function(name) {
  if ($notnull_bool(this.get$isMethodScope()) && this._closedOver.contains(name)) return true;
  for (var s = this.parent;
   $notnull_bool($ne(s, null)); s = s.get$parent()) {
    if (s._vars.containsKey(name)) return true;
    if (s._jsNames.contains(name)) return true;
    if ($notnull_bool(s.get$isMethodScope()) && s._closedOver.contains(name)) return true;
  }
  var type = this.enclosingMethod.method.declaringType;
  if (type.get$library().lookup(name, null) != null) return true;
  return false;
}
BlockScope.prototype.create = function(name, type, span, isFinal, isParameter) {
  var jsName = $globals.world.toJsIdentifier(name);
  if (this._vars.containsKey(name)) {
    $globals.world.error(('duplicate name "' + name + '"'), span);
  }
  if (!$notnull_bool(isParameter)) {
    var index = 0;
    while ($notnull_bool(this._isDefinedInParent($assert_String(jsName)))) {
      jsName = ('' + name + (index++));
    }
  }
  var ret = new Value(type, jsName, span, false);
  ret.set$isFinal(isFinal);
  this._vars.$setindex(name, ret);
  if (name != jsName) this._jsNames.add(jsName);
  return (ret == null ? null : ret.assert$Value());
}
BlockScope.prototype.declareParameter = function(p) {
  return this.create(p.name, p.type, p.definition.span, false, true);
}
BlockScope.prototype.declare = function(id) {
  var type = this.enclosingMethod.method.resolveType(id.type, false);
  return this.create(id.name.name, (type == null ? null : type.assert$lang_Type()), id.span, false, false);
}
BlockScope.prototype.getRethrow = function() {
  var $0;
  var scope = this;
  while ($notnull_bool(scope.get$rethrow() == null) && $notnull_bool($ne(scope.get$parent(), null))) {
    scope = scope.get$parent();
  }
  return (($0 = scope.get$rethrow()) == null ? null : $0.assert$Value());
}
BlockScope.prototype.lookup$1 = function($0) {
  return this.lookup($assert_String($0));
};
// ********** Code for MethodGenerator **************
function MethodGenerator(method, enclosingMethod) {
  var $0;
  this.method = method;
  this.enclosingMethod = enclosingMethod;
  this.writer = new CodeWriter();
  this.needsThis = false;
  // Initializers done
  if (this.enclosingMethod != null) {
    this._scope = new BlockScope(this, this.enclosingMethod._scope, false);
    this.captures = new HashSetImplementation();
  }
  else {
    this._scope = new BlockScope(this, null, false);
  }
  if (this.enclosingMethod != null && this.method.name != '') {
    var m = (($0 = this.method) == null ? null : $0.assert$MethodMember());
    this._scope.create(m.name, m.get$functionType(), m.definition.span, true, false);
  }
  this._usedTemps = new HashSetImplementation();
  this._freeTemps = [];
}
MethodGenerator.prototype.assert$MethodGenerator = function(){return this};
MethodGenerator.prototype.assert$TreeVisitor = function(){return this};
MethodGenerator.prototype.get$enclosingMethod = function() { return this.enclosingMethod; };
MethodGenerator.prototype.set$enclosingMethod = function(value) { return this.enclosingMethod = value; };
MethodGenerator.prototype.get$needsThis = function() { return this.needsThis; };
MethodGenerator.prototype.set$needsThis = function(value) { return this.needsThis = value; };
MethodGenerator.prototype.get$library = function() {
  return this.method.get$library();
}
MethodGenerator.prototype.findMembers = function(name) {
  return this.get$library()._findMembers(name);
}
MethodGenerator.prototype.get$isClosure = function() {
  return (this.enclosingMethod != null);
}
MethodGenerator.prototype.get$isStatic = function() {
  return this.method.get$isStatic();
}
MethodGenerator.prototype.getTemp = function(value) {
  return $notnull_bool(value.needsTemp) ? this.forceTemp(value) : value;
}
MethodGenerator.prototype.forceTemp = function(value) {
  var name;
  if (this._freeTemps.length > 0) {
    name = $assert_String(this._freeTemps.removeLast());
  }
  else {
    name = '\$' + this._usedTemps.get$length();
  }
  this._usedTemps.add(name);
  return new Value(value.type, name, value.span, false);
}
MethodGenerator.prototype.assignTemp = function(tmp, v) {
  if ($eq(tmp, v)) {
    return v;
  }
  else {
    return new Value(v.type, ('(' + tmp.code + ' = ' + v.code + ')'), v.span, true);
  }
}
MethodGenerator.prototype.freeTemp = function(value) {
  if (this._usedTemps.remove(value.code)) {
    this._freeTemps.add(value.code);
  }
  else {
    $globals.world.internalError(('tried to free unused value or non-temp "' + value.code + '"'));
  }
}
MethodGenerator.prototype.run = function() {
  if ($notnull_bool(this.method.isGenerated)) return;
  this.method.isGenerated = true;
  this.method.generator = this;
  this.writeBody();
  if ($notnull_bool($ne(this.method.get$definition().get$nativeBody(), null))) {
    this.writer = new CodeWriter();
    if ($notnull_bool($eq(this.method.get$definition().get$nativeBody(), ''))) {
      this.method.generator = null;
    }
    else {
      this._paramCode = map(this.method.get$parameters(), (function (p) {
        return p.get$name();
      })
      );
      this.writer.write($assert_String(this.method.get$definition().get$nativeBody()));
    }
  }
}
MethodGenerator.prototype.writeDefinition = function(defWriter, lambda) {
  var $0;
  var paramCode = this._paramCode;
  var names = null;
  if (this.captures != null && this.captures.get$length() > 0) {
    names = ListFactory.ListFactory$from$factory(this.captures);
    names.sort$1((function (x, y) {
      return x.compareTo$1(y);
    })
    );
    paramCode = ListFactory.ListFactory$from$factory((names == null ? null : names.assert$Iterable()));
    paramCode.addAll$1(this._paramCode);
  }
  var _params = ('(' + Strings.join(this._paramCode, ", ") + ')');
  var params = ('(' + Strings.join((paramCode == null ? null : paramCode.assert$List_String()), ", ") + ')');
  if ($notnull_bool(this.method.declaringType.get$isTop()) && !$notnull_bool(this.get$isClosure())) {
    defWriter.enterBlock(('function ' + this.method.get$jsname() + params + ' {'));
  }
  else if ($notnull_bool(this.get$isClosure())) {
    if (this.method.name == '') {
      defWriter.enterBlock(('(function ' + params + ' {'));
    }
    else if ($notnull_bool($ne(names, null))) {
      if (lambda == null) {
        defWriter.enterBlock(('var ' + this.method.get$jsname() + ' = (function' + params + ' {'));
      }
      else {
        defWriter.enterBlock(('(function ' + this.method.get$jsname() + params + ' {'));
      }
    }
    else {
      defWriter.enterBlock(('function ' + this.method.get$jsname() + params + ' {'));
    }
  }
  else if ($notnull_bool(this.method.get$isConstructor())) {
    if (this.method.get$constructorName() == '') {
      defWriter.enterBlock(('function ' + this.method.declaringType.get$jsname() + params + ' {'));
    }
    else {
      defWriter.enterBlock(('' + this.method.declaringType.get$jsname() + '.' + this.method.get$constructorName() + '\$ctor = function' + params + ' {'));
    }
  }
  else if ($notnull_bool(this.method.get$isFactory())) {
    defWriter.enterBlock(('' + this.method.get$generatedFactoryName() + ' = function' + _params + ' {'));
  }
  else if ($notnull_bool(this.method.get$isStatic())) {
    defWriter.enterBlock(('' + this.method.declaringType.get$jsname() + '.' + this.method.get$jsname() + ' = function' + _params + ' {'));
  }
  else {
    defWriter.enterBlock(('' + this.method.declaringType.get$jsname() + '.prototype.') + ('' + this.method.get$jsname() + ' = function' + _params + ' {'));
  }
  if ($notnull_bool(this.needsThis)) {
    defWriter.writeln('var \$this = this; // closure support');
  }
  if (this._usedTemps.get$length() > 0 || this._freeTemps.length > 0) {
    $assert(this._usedTemps.get$length() == 0, "_usedTemps.length == 0", "gen.dart", 812, 14);
    this._freeTemps.addAll(this._usedTemps);
    this._freeTemps.sort((function (x, y) {
      return x.compareTo$1(y);
    })
    );
    defWriter.writeln(('var ' + Strings.join(this._freeTemps, ", ") + ';'));
  }
  defWriter.writeln(this.writer.get$text());
  if ($notnull_bool($ne(names, null))) {
    defWriter.exitBlock(('}).bind(null, ' + Strings.join((names == null ? null : names.assert$List_String()), ", ") + ')'));
  }
  else if ($notnull_bool(this.get$isClosure()) && this.method.name == '') {
    defWriter.exitBlock('})');
  }
  else {
    defWriter.exitBlock('}');
  }
  if ($notnull_bool(this.method.get$isConstructor()) && this.method.get$constructorName() != '') {
    defWriter.writeln(('' + this.method.declaringType.get$jsname() + '.' + this.method.get$constructorName() + '\$ctor.prototype = ') + ('' + this.method.declaringType.get$jsname() + '.prototype;'));
  }
  this._provideOptionalParamInfo(defWriter);
  if ((this.method instanceof MethodMember)) {
    var m = (($0 = this.method) == null ? null : $0.assert$MethodMember());
    if ($notnull_bool(m._providePropertySyntax)) {
      defWriter.enterBlock(('' + m.declaringType.get$jsname() + '.prototype') + ('.get\$' + m.get$jsname() + ' = function() {'));
      defWriter.writeln(('return ' + m.declaringType.get$jsname() + '.prototype.') + ('' + m.get$jsname() + '.bind(this);'));
      defWriter.exitBlock('}');
      if ($notnull_bool(m._provideFieldSyntax)) {
        $globals.world.internalError('bound m accessed with field syntax');
      }
    }
  }
}
MethodGenerator.prototype._provideOptionalParamInfo = function(defWriter) {
  var $0;
  if ((this.method instanceof MethodMember)) {
    var meth = (($0 = this.method) == null ? null : $0.assert$MethodMember());
    if ($notnull_bool(meth._provideOptionalParamInfo)) {
      var optNames = [];
      var optValues = [];
      meth.genParameterValues();
      var $list = meth.parameters;
      for (var $i = 0;$i < $list.length; $i++) {
        var param = $list.$index($i);
        if ($notnull_bool(param.get$isOptional())) {
          optNames.add$1(param.get$name());
          optValues.add$1(MethodGenerator._escapeString($assert_String(param.get$value().get$code())));
        }
      }
      if (optNames.length > 0) {
        var start = '';
        if ($notnull_bool(meth.isStatic)) {
          if (!$notnull_bool(meth.declaringType.get$isTop())) {
            start = meth.declaringType.get$jsname() + '.';
          }
        }
        else {
          start = meth.declaringType.get$jsname() + '.prototype.';
        }
        optNames.addAll$1(optValues);
        var optional = "['" + Strings.join((optNames == null ? null : optNames.assert$List_String()), "', '") + "']";
        defWriter.writeln(('' + start + meth.get$jsname() + '.\$optional = ' + optional));
      }
    }
  }
}
MethodGenerator.prototype.writeBody = function() {
  var $0;
  var initializers = null;
  var initializedFields = null;
  var allMembers = null;
  if ($notnull_bool(this.method.get$isConstructor())) {
    initializers = [];
    initializedFields = new HashSetImplementation();
    allMembers = $globals.world.gen._orderValues(this.method.declaringType.getAllMembers());
    for (var $i = allMembers.iterator$0(); $i.hasNext$0(); ) {
      var f = $i.next$0();
      if ($notnull_bool(f.get$isField()) && !$notnull_bool(f.get$isStatic())) {
        var cv = f.computeValue$0();
        if ($notnull_bool($ne(cv, null))) {
          initializers.add$1(('this.' + f.get$jsname() + ' = ' + cv.get$code()));
          initializedFields.add$1(f.get$name());
        }
      }
    }
  }
  this._paramCode = [];
  var $list = this.method.get$parameters();
  for (var $i = 0;$i < $list.length; $i++) {
    var p = $list.$index($i);
    if ($notnull_bool($ne(initializers, null)) && $notnull_bool(p.get$isInitializer())) {
      var field = this.method.declaringType.getMember($assert_String(p.get$name()));
      if ($notnull_bool(field == null)) {
        $globals.world.error('bad this parameter - no matching field', (($0 = p.get$definition().get$span()) == null ? null : $0.assert$SourceSpan()));
      }
      if (!$notnull_bool(field.get$isField())) {
        $globals.world.error(('"this.' + p.get$name() + '" does not refer to a field'), (($0 = p.get$definition().get$span()) == null ? null : $0.assert$SourceSpan()));
      }
      var paramValue = new Value(field.get$returnType(), p.get$name(), p.get$definition().get$span(), false);
      this._paramCode.add(paramValue.get$code());
      initializers.add$1(('this.' + field.get$jsname() + ' = ' + paramValue.get$code() + ';'));
      initializedFields.add$1(p.get$name());
    }
    else {
      var paramValue = this._scope.declareParameter((p == null ? null : p.assert$Parameter()));
      this._paramCode.add(paramValue.get$code());
    }
  }
  var body = this.method.get$definition().get$body();
  if ($notnull_bool(body == null) && !$notnull_bool(this.method.get$isConstructor()) && !$notnull_bool(this.method.get$isNative())) {
    $globals.world.error(('unexpected empty body for ' + this.method.name), (($0 = this.method.get$definition().get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  var initializerCall = null;
  var declaredInitializers = this.method.get$definition().get$initializers();
  if ($notnull_bool($ne(initializers, null))) {
    for (var $i = initializers.iterator$0(); $i.hasNext$0(); ) {
      var i = $i.next$0();
      this.writer.writeln($assert_String(i));
    }
    if ($notnull_bool($ne(declaredInitializers, null))) {
      for (var $i = declaredInitializers.iterator$0(); $i.hasNext$0(); ) {
        var init = $i.next$0();
        if ((init instanceof CallExpression)) {
          if ($notnull_bool($ne(initializerCall, null))) {
            $globals.world.error('only one initializer redirecting call is allowed', (($0 = init.get$span()) == null ? null : $0.assert$SourceSpan()));
          }
          initializerCall = init;
        }
        else if ((init instanceof BinaryExpression) && TokenKind.kindFromAssign($assert_num(init.get$op().get$kind())) == 0) {
          var left = init.get$x();
          if (!((left instanceof DotExpression) && (left.get$self() instanceof ThisExpression) || (left instanceof VarExpression))) {
            $globals.world.error('invalid left side of initializer', (($0 = left.get$span()) == null ? null : $0.assert$SourceSpan()));
            continue;
          }
          var f = this.method.declaringType.getMember($assert_String(left.get$name().get$name()));
          if ($notnull_bool(f == null)) {
            $globals.world.error('bad initializer - no matching field', (($0 = left.get$span()) == null ? null : $0.assert$SourceSpan()));
            continue;
          }
          else if (!$notnull_bool(f.get$isField())) {
            $globals.world.error(('"' + left.get$name().get$name() + '" does not refer to a field'), (($0 = left.get$span()) == null ? null : $0.assert$SourceSpan()));
            continue;
          }
          initializedFields.add$1(f.get$name());
          this.writer.writeln(('this.' + f.get$jsname() + ' = ' + this.visitValue((($0 = init.get$y()) == null ? null : $0.assert$lang_Expression())).get$code() + ';'));
        }
        else {
          $globals.world.error('invalid initializer', (($0 = init.get$span()) == null ? null : $0.assert$SourceSpan()));
        }
      }
    }
    this.writer.comment('// Initializers done');
  }
  if ($notnull_bool(this.method.get$isConstructor()) && $notnull_bool(initializerCall == null) && !$notnull_bool(this.method.get$isNative())) {
    var parentType = this.method.declaringType.get$parent();
    if ($notnull_bool($ne(parentType, null)) && !$notnull_bool(parentType.get$isObject())) {
      initializerCall = new CallExpression(new SuperExpression(this.method.get$span()), [], this.method.get$span());
    }
  }
  if ($notnull_bool($ne(initializerCall, null))) {
    var target = this._writeInitializerCall((initializerCall == null ? null : initializerCall.assert$CallExpression()));
    if (!$notnull_bool(target.get$isSuper())) {
      if (initializers.length > 0) {
        var $list = this.method.get$parameters();
        for (var $i = 0;$i < $list.length; $i++) {
          var p = $list.$index($i);
          if ($notnull_bool(p.get$isInitializer())) {
            $globals.world.error('no initialization allowed on redirecting constructors', (($0 = p.get$definition().get$span()) == null ? null : $0.assert$SourceSpan()));
            break;
          }
        }
      }
      if ($notnull_bool($ne(declaredInitializers, null)) && declaredInitializers.length > 1) {
        var init = $notnull_bool($eq(declaredInitializers.$index(0), initializerCall)) ? declaredInitializers.$index(1) : declaredInitializers.$index(0);
        $globals.world.error('no initialization allowed on redirecting constructors', (($0 = init.get$span()) == null ? null : $0.assert$SourceSpan()));
      }
      initializedFields = null;
    }
  }
  if ($notnull_bool($ne(initializedFields, null))) {
    for (var $i = allMembers.iterator$0(); $i.hasNext$0(); ) {
      var member = $i.next$0();
      if ($notnull_bool(member.get$isField()) && $notnull_bool(member.get$isFinal()) && !$notnull_bool(member.get$isStatic()) && !$notnull_bool(this.method.get$isNative()) && !$notnull_bool(initializedFields.contains$1(member.get$name()))) {
        $globals.world.error(('Field "' + member.get$name() + '" is final and was not initialized'), (($0 = this.method.get$definition().get$span()) == null ? null : $0.assert$SourceSpan()));
      }
    }
  }
  this.visitStatementsInBlock((body == null ? null : body.assert$lang_Statement()));
}
MethodGenerator.prototype._writeInitializerCall = function(node) {
  var contructorName = '';
  var targetExp = node.target;
  if ((targetExp instanceof DotExpression)) {
    var dot = (targetExp == null ? null : targetExp.assert$DotExpression());
    targetExp = dot.self;
    contructorName = dot.name.name;
  }
  var target = null;
  if ((targetExp instanceof SuperExpression)) {
    target = this._makeSuperValue((targetExp == null ? null : targetExp.assert$lang_Node()));
  }
  else if ((targetExp instanceof ThisExpression)) {
    target = this._makeThisValue((targetExp == null ? null : targetExp.assert$lang_Node()));
  }
  else {
    $globals.world.error('bad call in initializers', node.span);
  }
  var m = target.get$type().getConstructor$1(contructorName);
  this.method.set$initDelegate(m);
  var other = m;
  while ($notnull_bool($ne(other, null))) {
    if ($notnull_bool($eq(other, this.method))) {
      $globals.world.error('initialization cycle', node.span);
      break;
    }
    other = other.get$initDelegate();
  }
  $globals.world.gen.genMethod((m == null ? null : m.assert$Member()));
  var value = m.invoke$4(this, node, target, this._makeArgs(node.arguments));
  if ($notnull_bool($ne(target.get$type(), $globals.world.objectType))) {
    this.writer.writeln(('' + value.get$code() + ';'));
  }
  return (target == null ? null : target.assert$Value());
}
MethodGenerator.prototype._makeArgs = function(arguments) {
  var $0;
  var args = [];
  var seenLabel = false;
  for (var $i = 0;$i < arguments.length; $i++) {
    var arg = arguments.$index($i);
    if ($notnull_bool($ne(arg.get$label(), null))) {
      seenLabel = true;
    }
    else if ($notnull_bool(seenLabel)) {
      $globals.world.error('bare argument can not follow named arguments', (($0 = arg.get$span()) == null ? null : $0.assert$SourceSpan()));
    }
    args.add$1(this.visitValue((($0 = arg.get$value()) == null ? null : $0.assert$lang_Expression())));
  }
  return new Arguments(arguments, args);
}
MethodGenerator.prototype._invokeNative = function(name, arguments) {
  var $0;
  var args = Arguments.get$EMPTY();
  if (arguments.length > 0) {
    args = new Arguments(null, arguments);
  }
  var method = $globals.world.corelib.topType.members.$index(name);
  return (($0 = method.invoke$4(this, method.get$definition(), new Value($globals.world.corelib.topType, null, null, true), args)) == null ? null : $0.assert$Value());
}
MethodGenerator._escapeString = function(text) {
  return text.replaceAll('\\', '\\\\').replaceAll('"', '\\"').replaceAll('\n', '\\n').replaceAll('\r', '\\r');
}
MethodGenerator.prototype.visitStatementsInBlock = function(body) {
  if ((body instanceof BlockStatement)) {
    var block = (body == null ? null : body.assert$BlockStatement());
    var $list = block.body;
    for (var $i = 0;$i < $list.length; $i++) {
      var stmt = $list.$index($i);
      stmt.visit$1(this);
    }
  }
  else {
    if (body != null) body.visit(this);
  }
  return false;
}
MethodGenerator.prototype._pushBlock = function(reentrant) {
  this._scope = new BlockScope(this, this._scope, reentrant);
}
MethodGenerator.prototype._popBlock = function() {
  this._scope = this._scope.parent;
}
MethodGenerator.prototype._makeLambdaMethod = function(name, func) {
  var meth = new MethodMember(name, this.method.declaringType, func);
  meth.set$isLambda(true);
  meth.set$enclosingElement(this.method);
  meth.resolve$0();
  $globals.world.gen.genMethod((meth == null ? null : meth.assert$Member()), this);
  return (meth == null ? null : meth.assert$MethodMember());
}
MethodGenerator.prototype.visitBool = function(node) {
  return this.visitValue(node).convertTo$3(this, $globals.world.nonNullBool, node);
}
MethodGenerator.prototype.visitValue = function(node) {
  if (node == null) return null;
  var value = node.visit(this);
  value.checkFirstClass$1(node.span);
  return value;
}
MethodGenerator.prototype.visitTypedValue = function(node, expectedType) {
  return this.visitValue(node).convertTo$3(this, expectedType, node);
}
MethodGenerator.prototype.visitVoid = function(node) {
  if ((node instanceof PostfixExpression)) {
    var value = this.visitPostfixExpression((node == null ? null : node.assert$PostfixExpression()), true);
    value.checkFirstClass$1(node.span);
    return value;
  }
  return this.visitValue(node);
}
MethodGenerator.prototype.visitDietStatement = function(node) {
  var $0;
  var parser = new lang_Parser(node.span.file, false, false, false, node.span.start);
  this.visitStatementsInBlock((($0 = parser.block$0()) == null ? null : $0.assert$lang_Statement()));
  return false;
}
MethodGenerator.prototype.visitVariableDefinition = function(node) {
  var $0;
  var isFinal = false;
  if (node.modifiers != null && $notnull_bool($eq(node.modifiers.$index(0).get$kind(), 97/*TokenKind.FINAL*/))) {
    isFinal = true;
  }
  this.writer.write('var ');
  var type = this.method.resolveType(node.type, false);
  for (var i = 0;
   i < node.names.length; i++) {
    var thisType = type;
    if (i > 0) {
      this.writer.write(', ');
    }
    var name = node.names.$index(i).get$name();
    var value = this.visitValue((($0 = node.values.$index(i)) == null ? null : $0.assert$lang_Expression()));
    if ($notnull_bool(isFinal)) {
      if ($notnull_bool(value == null)) {
        $globals.world.error('no value specified for final variable', node.span);
      }
      else {
        if ($notnull_bool(thisType.get$isVar())) thisType = value.get$type();
      }
    }
    var val = this._scope.create($assert_String(name), (thisType == null ? null : thisType.assert$lang_Type()), (($0 = node.names.$index(i).get$span()) == null ? null : $0.assert$SourceSpan()), $assert_bool(isFinal), false);
    if ($notnull_bool(value == null)) {
      if ($notnull_bool(this._scope.reentrant)) {
        this.writer.write(('' + val.get$code() + ' = null'));
      }
      else {
        this.writer.write(('' + val.get$code()));
      }
    }
    else {
      value = value.convertTo$3(this, type, node.values.$index(i));
      this.writer.write(('' + val.get$code() + ' = ' + value.get$code()));
    }
  }
  this.writer.writeln(';');
  return false;
}
MethodGenerator.prototype.visitFunctionDefinition = function(node) {
  var $0;
  var name = $globals.world.toJsIdentifier(node.name.name);
  var meth = this._makeLambdaMethod($assert_String(name), node);
  var funcValue = this._scope.create($assert_String(name), (($0 = meth.get$functionType()) == null ? null : $0.assert$lang_Type()), (($0 = this.method.get$definition().get$span()) == null ? null : $0.assert$SourceSpan()), true, false);
  meth.get$generator().writeDefinition$2(this.writer);
  return false;
}
MethodGenerator.prototype.visitReturnStatement = function(node) {
  if (node.value == null) {
    this.writer.writeln('return;');
  }
  else {
    if ($notnull_bool(this.method.get$isConstructor())) {
      $globals.world.error('return of value not allowed from constructor', node.span);
    }
    var value = this.visitTypedValue(node.value, this.method.get$returnType());
    this.writer.writeln(('return ' + value.get$code() + ';'));
  }
  return true;
}
MethodGenerator.prototype.visitThrowStatement = function(node) {
  if (node.value != null) {
    var value = this.visitValue(node.value);
    value.invoke$4(this, 'toString', node, Arguments.get$EMPTY());
    this.writer.writeln(('\$throw(' + value.get$code() + ');'));
    $globals.world.gen.corejs.useThrow = true;
  }
  else {
    var rethrow = this._scope.getRethrow();
    if ($notnull_bool(rethrow == null)) {
      $globals.world.error('rethrow outside of catch', node.span);
    }
    else {
      this.writer.writeln(('throw ' + rethrow.get$code() + ';'));
    }
  }
  return true;
}
MethodGenerator.prototype.visitAssertStatement = function(node) {
  var $0;
  var test = this.visitValue(node.test);
  if ($notnull_bool($globals.options.enableAsserts)) {
    var err = $globals.world.corelib.types.$index('AssertError');
    $globals.world.gen.genMethod((($0 = err.getConstructor$1('_internal')) == null ? null : $0.assert$Member()));
    $globals.world.gen.genMethod((($0 = err.get$members().$index('toString')) == null ? null : $0.assert$Member()));
    var span = node.test.span;
    var line = span.get$file().getLine$1(span.get$start());
    var column = span.get$file().getColumn$2(line, span.get$start());
    this.writer.writeln(('\$assert(' + test.get$code() + ', "' + MethodGenerator._escapeString($assert_String(span.get$text())) + '",') + (' "' + basename($assert_String(span.get$file().get$filename())) + '", ' + (line + 1) + ', ' + (column + 1) + ');'));
    $globals.world.gen.corejs.useAssert = true;
  }
  return false;
}
MethodGenerator.prototype.visitBreakStatement = function(node) {
  if (node.label == null) {
    this.writer.writeln('break;');
  }
  else {
    this.writer.writeln(('break ' + node.label.name + ';'));
  }
  return true;
}
MethodGenerator.prototype.visitContinueStatement = function(node) {
  if (node.label == null) {
    this.writer.writeln('continue;');
  }
  else {
    this.writer.writeln(('continue ' + node.label.name + ';'));
  }
  return true;
}
MethodGenerator.prototype.visitIfStatement = function(node) {
  var test = this.visitBool(node.test);
  this.writer.write(('if (' + test.get$code() + ') '));
  var exit1 = node.trueBranch.visit(this);
  if (node.falseBranch != null) {
    this.writer.write('else ');
    if ($notnull_bool(node.falseBranch.visit(this)) && $notnull_bool(exit1)) {
      return true;
    }
  }
  return false;
}
MethodGenerator.prototype.visitWhileStatement = function(node) {
  var test = this.visitBool(node.test);
  this.writer.write(('while (' + test.get$code() + ') '));
  this._pushBlock(true);
  node.body.visit(this);
  this._popBlock();
  return false;
}
MethodGenerator.prototype.visitDoStatement = function(node) {
  this.writer.write('do ');
  this._pushBlock(true);
  node.body.visit(this);
  this._popBlock();
  var test = this.visitBool(node.test);
  this.writer.writeln(('while (' + test.get$code() + ')'));
  return false;
}
MethodGenerator.prototype.visitForStatement = function(node) {
  this._pushBlock(false);
  this.writer.write('for (');
  if (node.init != null) node.init.visit(this);
  else this.writer.write(';');
  if (node.test != null) {
    var test = this.visitBool(node.test);
    this.writer.write((' ' + test.get$code() + '; '));
  }
  else {
    this.writer.write('; ');
  }
  var needsComma = false;
  var $list = node.step;
  for (var $i = 0;$i < $list.length; $i++) {
    var s = $list.$index($i);
    if ($notnull_bool(needsComma)) this.writer.write(', ');
    var sv = this.visitVoid((s == null ? null : s.assert$lang_Expression()));
    this.writer.write($assert_String(sv.get$code()));
    needsComma = true;
  }
  this.writer.write(') ');
  this._pushBlock(true);
  node.body.visit(this);
  this._popBlock();
  this._popBlock();
  return false;
}
MethodGenerator.prototype._isFinal = function(typeRef) {
  if ((typeRef instanceof GenericTypeReference)) {
    typeRef = typeRef.get$baseType();
  }
  return $notnull_bool($ne(typeRef, null)) && $notnull_bool(typeRef.get$isFinal());
}
MethodGenerator.prototype.visitForInStatement = function(node) {
  var $0;
  var itemType = this.method.resolveType(node.item.type, false);
  var itemName = node.item.name.name;
  var list = node.list.visit(this);
  this._pushBlock(true);
  var isFinal = this._isFinal(node.item.type);
  var item = this._scope.create($assert_String(itemName), (itemType == null ? null : itemType.assert$lang_Type()), node.item.name.span, isFinal, false);
  var listVar = (list == null ? null : list.assert$Value());
  if ($notnull_bool(list.get$needsTemp())) {
    listVar = this._scope.create('\$list', (($0 = list.get$type()) == null ? null : $0.assert$lang_Type()), null, false, false);
    this.writer.writeln(('var ' + listVar.code + ' = ' + list.get$code() + ';'));
  }
  if ($notnull_bool(list.get$type().get$isList())) {
    var tmpi = this._scope.create('\$i', $globals.world.numType, null, false, false);
    this.writer.enterBlock(('for (var ' + tmpi.get$code() + ' = 0;') + ('' + tmpi.get$code() + ' < ' + listVar.code + '.length; ' + tmpi.get$code() + '++) {'));
    var value = listVar.invoke(this, '\$index', node.list, new Arguments(null, [tmpi]), false);
    this.writer.writeln(('var ' + item.get$code() + ' = ' + value.get$code() + ';'));
  }
  else {
    this._pushBlock(false);
    var iterator = list.invoke$4(this, 'iterator', node.list, Arguments.get$EMPTY());
    var tmpi = this._scope.create('\$i', (($0 = iterator.get$type()) == null ? null : $0.assert$lang_Type()), null, false, false);
    var hasNext = tmpi.invoke$4(this, 'hasNext', node.list, Arguments.get$EMPTY());
    var next = tmpi.invoke$4(this, 'next', node.list, Arguments.get$EMPTY());
    this.writer.enterBlock(('for (var ' + tmpi.get$code() + ' = ' + iterator.get$code() + '; ' + hasNext.get$code() + '; ) {'));
    this.writer.writeln(('var ' + item.get$code() + ' = ' + next.get$code() + ';'));
  }
  this.visitStatementsInBlock(node.body);
  this.writer.exitBlock('}');
  this._popBlock();
  return false;
}
MethodGenerator.prototype._genToDartException = function(ex, node) {
  var result = this._invokeNative("_toDartException", [ex]);
  this.writer.writeln(('' + ex.code + ' = ' + result.get$code() + ';'));
}
MethodGenerator.prototype.visitTryStatement = function(node) {
  var $0;
  this.writer.enterBlock('try {');
  this._pushBlock(false);
  this.visitStatementsInBlock(node.body);
  this._popBlock();
  if (node.catches.length == 1) {
    var catch_ = node.catches.$index(0);
    this._pushBlock(false);
    var ex = this._scope.declare((($0 = catch_.get$exception()) == null ? null : $0.assert$DeclaredIdentifier()));
    this._scope.rethrow = (ex == null ? null : ex.assert$Value());
    this.writer.nextBlock(('} catch (' + ex.get$code() + ') {'));
    if ($notnull_bool($ne(catch_.get$trace(), null))) {
      var trace = this._scope.declare((($0 = catch_.get$trace()) == null ? null : $0.assert$DeclaredIdentifier()));
      this.writer.writeln(('var ' + trace.get$code() + ' = \$stackTraceOf(' + ex.get$code() + ');'));
      $globals.world.gen.corejs.useStackTraceOf = true;
    }
    this._genToDartException((ex == null ? null : ex.assert$Value()), node);
    if (!$notnull_bool(ex.get$type().get$isVarOrObject())) {
      var test = ex.instanceOf$3$isTrue$forceCheck(this, ex.get$type(), catch_.get$exception().get$span(), false, true);
      this.writer.writeln(('if (' + test.get$code() + ') throw ' + ex.get$code() + ';'));
    }
    this.visitStatementsInBlock((($0 = node.catches.$index(0).get$body()) == null ? null : $0.assert$lang_Statement()));
    this._popBlock();
  }
  else if (node.catches.length > 0) {
    this._pushBlock(false);
    var ex = this._scope.create('\$ex', $globals.world.varType, null, false, false);
    this._scope.rethrow = (ex == null ? null : ex.assert$Value());
    this.writer.nextBlock(('} catch (' + ex.get$code() + ') {'));
    var trace = null;
    if (node.catches.some((function (c) {
      return $ne(c.get$trace(), null);
    })
    )) {
      trace = this._scope.create('\$trace', $globals.world.varType, null, false, false);
      this.writer.writeln(('var ' + trace.get$code() + ' = \$stackTraceOf(' + ex.get$code() + ');'));
      $globals.world.gen.corejs.useStackTraceOf = true;
    }
    this._genToDartException((ex == null ? null : ex.assert$Value()), node);
    var needsRethrow = true;
    for (var i = 0;
     i < node.catches.length; i++) {
      var catch_ = node.catches.$index(i);
      this._pushBlock(false);
      var tmp = this._scope.declare((($0 = catch_.get$exception()) == null ? null : $0.assert$DeclaredIdentifier()));
      if (!$notnull_bool(tmp.get$type().get$isVarOrObject())) {
        var test = ex.instanceOf$3$isTrue$forceCheck(this, tmp.get$type(), catch_.get$exception().get$span(), true, true);
        if (i == 0) {
          this.writer.enterBlock(('if (' + test.get$code() + ') {'));
        }
        else {
          this.writer.nextBlock(('} else if (' + test.get$code() + ') {'));
        }
      }
      else if (i > 0) {
        this.writer.nextBlock('} else {');
      }
      this.writer.writeln(('var ' + tmp.get$code() + ' = ' + ex.get$code() + ';'));
      if ($notnull_bool($ne(catch_.get$trace(), null))) {
        var tmptrace = this._scope.declare((($0 = catch_.get$trace()) == null ? null : $0.assert$DeclaredIdentifier()));
        this.writer.writeln(('var ' + tmptrace.get$code() + ' = ' + trace.get$code() + ';'));
      }
      this.visitStatementsInBlock((($0 = catch_.get$body()) == null ? null : $0.assert$lang_Statement()));
      this._popBlock();
      if ($notnull_bool(tmp.get$type().get$isVarOrObject())) {
        if (i + 1 < node.catches.length) {
          $globals.world.warning('Unreachable catch clause', (($0 = node.catches.$index(i + 1)) == null ? null : $0.assert$SourceSpan()));
        }
        if (i > 0) {
          this.writer.exitBlock('}');
        }
        needsRethrow = false;
        break;
      }
    }
    if ($notnull_bool(needsRethrow)) {
      this.writer.nextBlock('} else {');
      this.writer.writeln(('throw ' + ex.get$code() + ';'));
      this.writer.exitBlock('}');
    }
    this._popBlock();
  }
  if (node.finallyBlock != null) {
    this.writer.nextBlock('} finally {');
    this._pushBlock(false);
    this.visitStatementsInBlock(node.finallyBlock);
    this._popBlock();
  }
  this.writer.exitBlock('}');
  return false;
}
MethodGenerator.prototype.visitSwitchStatement = function(node) {
  var $0;
  var test = this.visitValue(node.test);
  this.writer.enterBlock(('switch (' + test.get$code() + ') {'));
  var $list = node.cases;
  for (var $i = 0;$i < $list.length; $i++) {
    var case_ = $list.$index($i);
    if ($notnull_bool($ne(case_.get$label(), null))) {
      $globals.world.error('unimplemented: labeled case statement', (($0 = case_.get$span()) == null ? null : $0.assert$SourceSpan()));
    }
    this._pushBlock(false);
    for (var i = 0;
     i < $assert_num(case_.get$cases().length); i++) {
      var expr = case_.get$cases().$index(i);
      if ($notnull_bool(expr == null)) {
        if (i < case_.get$cases().length - 1) {
          $globals.world.error('default clause must be the last case', (($0 = case_.get$span()) == null ? null : $0.assert$SourceSpan()));
        }
        this.writer.writeln('default:');
      }
      else {
        var value = this.visitValue((expr == null ? null : expr.assert$lang_Expression()));
        this.writer.writeln(('case ' + value.get$code() + ':'));
      }
    }
    this.writer.enterBlock('');
    var caseExits = this._visitAllStatements(case_.get$statements(), false);
    if ($notnull_bool($ne(case_, node.cases.$index(node.cases.length - 1))) && !$notnull_bool(caseExits)) {
      var span = case_.get$statements().$index(case_.get$statements().length - 1).get$span();
      this.writer.writeln('\$throw(new FallThroughError());');
      $globals.world.gen.corejs.useThrow = true;
    }
    this.writer.exitBlock('');
    this._popBlock();
  }
  this.writer.exitBlock('}');
  return false;
}
MethodGenerator.prototype._visitAllStatements = function(statementList, exits) {
  var $0;
  for (var i = 0;
   i < $assert_num(statementList.length); i++) {
    var stmt = statementList.$index(i);
    exits = stmt.visit$1(this);
    if ($notnull_bool($ne(stmt, statementList.$index(statementList.length - 1))) && $notnull_bool(exits)) {
      $globals.world.warning('unreachable code', (($0 = statementList.$index(i + 1).get$span()) == null ? null : $0.assert$SourceSpan()));
    }
  }
  return $assert_bool(exits);
}
MethodGenerator.prototype.visitBlockStatement = function(node) {
  this._pushBlock(false);
  this.writer.enterBlock('{');
  var exits = this._visitAllStatements(node.body, false);
  this.writer.exitBlock('}');
  this._popBlock();
  return $assert_bool(exits);
}
MethodGenerator.prototype.visitLabeledStatement = function(node) {
  this.writer.writeln(('' + node.name.name + ':'));
  node.body.visit(this);
  return false;
}
MethodGenerator.prototype.visitExpressionStatement = function(node) {
  if ((node.body instanceof VarExpression) || (node.body instanceof ThisExpression)) {
    $globals.world.warning('variable used as statement', node.span);
  }
  var value = this.visitVoid(node.body);
  this.writer.writeln(('' + value.get$code() + ';'));
  return false;
}
MethodGenerator.prototype.visitEmptyStatement = function(node) {
  this.writer.writeln(';');
  return false;
}
MethodGenerator.prototype._checkNonStatic = function(node) {
  if ($notnull_bool(this.get$isStatic())) {
    $globals.world.warning('not allowed in static method', node.span);
  }
}
MethodGenerator.prototype._makeSuperValue = function(node) {
  var parentType = this.method.declaringType.get$parent();
  this._checkNonStatic(node);
  if ($notnull_bool(parentType == null)) {
    $globals.world.error('no super class', node.span);
  }
  var ret = new Value(parentType, 'this', node.span, false);
  ret.set$isSuper(true);
  return ret;
}
MethodGenerator.prototype._getOutermostMethod = function() {
  var result = this;
  while ($notnull_bool($ne(result.get$enclosingMethod(), null))) {
    result = result.get$enclosingMethod();
  }
  return result;
}
MethodGenerator.prototype._makeThisCode = function() {
  if (this.enclosingMethod != null) {
    this._getOutermostMethod().set$needsThis(true);
    return '\$this';
  }
  else {
    return 'this';
  }
}
MethodGenerator.prototype._makeThisValue = function(node) {
  if (this.enclosingMethod != null) {
    var outermostMethod = this._getOutermostMethod();
    outermostMethod._checkNonStatic(node);
    outermostMethod.set$needsThis(true);
    return new Value(outermostMethod.method.get$declaringType(), '\$this', node != null ? node.span : null, false);
  }
  else {
    this._checkNonStatic(node);
    return new Value(this.method.declaringType, 'this', node != null ? node.span : null, false);
  }
}
MethodGenerator.prototype.visitLambdaExpression = function(node) {
  var name = '';
  if (node.func.name != null) {
    name = $globals.world.toJsIdentifier(node.func.name.name);
  }
  var meth = this._makeLambdaMethod($assert_String(name), node.func);
  var w = new CodeWriter();
  meth.get$generator().writeDefinition$2(w, node);
  return new Value(meth.get$functionType(), w.get$text(), node.span, true);
}
MethodGenerator.prototype.visitCallExpression = function(node) {
  var $0;
  var target;
  var position = node.target;
  var name = '\$call';
  if ((node.target instanceof DotExpression)) {
    var dot = (($0 = node.target) == null ? null : $0.assert$DotExpression());
    target = dot.self.visit(this);
    name = dot.name.name;
    position = dot.name;
  }
  else if ((node.target instanceof VarExpression)) {
    var varExpr = (($0 = node.target) == null ? null : $0.assert$VarExpression());
    name = varExpr.name.name;
    target = this._scope.lookup($assert_String(name));
    if ($notnull_bool($ne(target, null))) {
      return target.invoke$4(this, '\$call', node, this._makeArgs(node.arguments));
    }
    target = this._makeThisOrType(varExpr.span);
    return target.invoke$4(this, name, node, this._makeArgs(node.arguments));
  }
  else {
    target = node.target.visit(this);
  }
  return target.invoke$4(this, name, position, this._makeArgs(node.arguments));
}
MethodGenerator.prototype.visitIndexExpression = function(node) {
  var target = this.visitValue(node.target);
  var index = this.visitValue(node.index);
  return target.invoke$4(this, '\$index', node, new Arguments(null, [index]));
}
MethodGenerator.prototype.visitBinaryExpression = function(node) {
  var kind = node.op.kind;
  if (kind == 35/*TokenKind.AND*/ || kind == 34/*TokenKind.OR*/) {
    var x = this.visitTypedValue(node.x, $globals.world.nonNullBool);
    var y = this.visitTypedValue(node.y, $globals.world.nonNullBool);
    var code = ('' + x.get$code() + ' ' + node.op + ' ' + y.get$code());
    if ($notnull_bool(x.get$isConst()) && $notnull_bool(y.get$isConst())) {
      var value = (kind == 35/*TokenKind.AND*/) ? $notnull_bool(x.get$actualValue()) && $notnull_bool(y.get$actualValue()) : $notnull_bool(x.get$actualValue()) || $notnull_bool(y.get$actualValue());
      return EvaluatedValue.EvaluatedValue$factory($globals.world.nonNullBool, value, ('' + value), node.span);
    }
    return new Value($globals.world.nonNullBool, code, node.span, true);
  }
  else if (kind == 50/*TokenKind.EQ_STRICT*/ || kind == 51/*TokenKind.NE_STRICT*/) {
    var x = this.visitValue(node.x);
    var y = this.visitValue(node.y);
    if ($notnull_bool(x.get$isConst()) && $notnull_bool(y.get$isConst())) {
      var xVal = x.get$actualValue();
      var yVal = y.get$actualValue();
      if ($notnull_bool(x.get$type().get$isString()) && $notnull_bool(y.get$type().get$isString()) && $notnull_bool($ne(xVal.$index(0), yVal.$index(0)))) {
        if ($notnull_bool($eq(xVal.$index(0), '"'))) {
          xVal = xVal.substring$2(1, xVal.length - 1);
          yVal = toDoubleQuote($assert_String(yVal.substring$2(1, yVal.length - 1)));
        }
        else {
          xVal = toDoubleQuote($assert_String(xVal.substring$2(1, xVal.length - 1)));
          yVal = yVal.substring$2(1, yVal.length - 1);
        }
      }
      var value = kind == 50/*TokenKind.EQ_STRICT*/ ? $eq(xVal, yVal) : $ne(xVal, yVal);
      return EvaluatedValue.EvaluatedValue$factory($globals.world.nonNullBool, value, ("" + value), node.span);
    }
    if ($notnull_bool($eq(x.get$code(), 'null')) || $notnull_bool($eq(y.get$code(), 'null'))) {
      var op = node.op.toString().substring(0, 2);
      return new Value($globals.world.nonNullBool, ('' + x.get$code() + ' ' + op + ' ' + y.get$code()), node.span, true);
    }
    else {
      return new Value($globals.world.nonNullBool, ('' + x.get$code() + ' ' + node.op + ' ' + y.get$code()), node.span, true);
    }
  }
  var assignKind = TokenKind.kindFromAssign(node.op.kind);
  if (assignKind == -1) {
    var x = this.visitValue(node.x);
    var y = this.visitValue(node.y);
    var name = TokenKind.binaryMethodName(node.op.kind);
    if (node.op.kind == 49/*TokenKind.NE*/) {
      name = '\$ne';
    }
    if ($notnull_bool(name == null)) {
      $globals.world.internalError(('unimplemented binary op ' + node.op), node.span);
      return;
    }
    return x.invoke$4(this, name, node, new Arguments(null, [y]));
  }
  else {
    return this._visitAssign(assignKind, node.x, node.y, node, to$call$1(null));
  }
}
MethodGenerator.prototype._visitAssign = function(kind, xn, yn, position, captureOriginal) {
  if (captureOriginal == null) {
    captureOriginal = (function (x) {
      return x;
    })
    ;
  }
  if ((xn instanceof VarExpression)) {
    return this._visitVarAssign(kind, (xn == null ? null : xn.assert$VarExpression()), yn, position, captureOriginal);
  }
  else if ((xn instanceof IndexExpression)) {
    return this._visitIndexAssign(kind, (xn == null ? null : xn.assert$IndexExpression()), yn, position, captureOriginal);
  }
  else if ((xn instanceof DotExpression)) {
    return this._visitDotAssign(kind, (xn == null ? null : xn.assert$DotExpression()), yn, position, captureOriginal);
  }
  else {
    $globals.world.error('illegal lhs', position.span);
  }
}
MethodGenerator.prototype._visitVarAssign = function(kind, xn, yn, position, captureOriginal) {
  var name = xn.name.name;
  var x = this._scope.lookup(name);
  var y = this.visitValue(yn);
  if ($notnull_bool(x == null)) {
    var members = this.method.declaringType.resolveMember(name);
    x = this._makeThisOrType(position.span);
    if ($notnull_bool($ne(members, null))) {
      if (kind == 0) {
        return x.set_$4(this, name, position, y);
      }
      else if (!$notnull_bool(members.get$treatAsField()) || $notnull_bool(members.get$containsMethods())) {
        var right = x.get_$3(this, name, position);
        right = captureOriginal((right == null ? null : right.assert$Value()));
        y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
        return x.set_$4(this, name, position, y);
      }
      else {
        x = x.get_$3(this, name, position);
      }
    }
    else {
      var member = this.get$library().lookup(name, xn.name.span);
      if (member == null) {
        $globals.world.warning(('can not resolve ' + name), xn.span);
        return this._makeMissingValue(name);
      }
      members = new MemberSet(member, false);
      if (!$notnull_bool(members.get$treatAsField()) || $notnull_bool(members.get$containsMethods())) {
        if (kind != 0) {
          var right = members._get$3(this, position, x);
          right = captureOriginal((right == null ? null : right.assert$Value()));
          y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
        }
        return members._set$4(this, position, x, y);
      }
      else {
        x = members._get$3(this, position, x);
      }
    }
  }
  if ($notnull_bool(x.get$isFinal())) {
    $globals.world.error(('final variable "' + x.get$code() + '" is not assignable'), position.span);
  }
  y = y.convertTo$3(this, x.get$type(), yn);
  if (kind == 0) {
    x = captureOriginal((x == null ? null : x.assert$Value()));
    return new Value(y.get$type(), ('' + x.get$code() + ' = ' + y.get$code()), position.span, true);
  }
  else if ($notnull_bool(x.get$type().get$isNum()) && $notnull_bool(y.get$type().get$isNum()) && (kind != 46/*TokenKind.TRUNCDIV*/)) {
    x = captureOriginal((x == null ? null : x.assert$Value()));
    var op = TokenKind.kindToString(kind);
    return new Value(y.get$type(), ('' + x.get$code() + ' ' + op + '= ' + y.get$code()), position.span, true);
  }
  else {
    var right = x;
    right = captureOriginal((right == null ? null : right.assert$Value()));
    y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
    return new Value(y.get$type(), ('' + x.get$code() + ' = ' + y.get$code()), position.span, true);
  }
}
MethodGenerator.prototype._visitIndexAssign = function(kind, xn, yn, position, captureOriginal) {
  var target = this.visitValue(xn.target);
  var index = this.visitValue(xn.index);
  var y = this.visitValue(yn);
  var tmptarget = target;
  var tmpindex = index;
  if (kind != 0) {
    tmptarget = this.getTemp((target == null ? null : target.assert$Value()));
    tmpindex = this.getTemp((index == null ? null : index.assert$Value()));
    index = this.assignTemp((tmpindex == null ? null : tmpindex.assert$Value()), (index == null ? null : index.assert$Value()));
    var right = tmptarget.invoke$4(this, '\$index', position, new Arguments(null, [tmpindex]));
    right = captureOriginal((right == null ? null : right.assert$Value()));
    y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
  }
  var ret = this.assignTemp((tmptarget == null ? null : tmptarget.assert$Value()), (target == null ? null : target.assert$Value())).invoke(this, '\$setindex', position, new Arguments(null, [index, y]), false);
  if ($notnull_bool($ne(tmptarget, target))) this.freeTemp((tmptarget == null ? null : tmptarget.assert$Value()));
  if ($notnull_bool($ne(tmpindex, index))) this.freeTemp((tmpindex == null ? null : tmpindex.assert$Value()));
  return ret;
}
MethodGenerator.prototype._visitDotAssign = function(kind, xn, yn, position, captureOriginal) {
  var target = xn.self.visit(this);
  var y = this.visitValue(yn);
  var tmptarget = target;
  if (kind != 0) {
    tmptarget = this.getTemp((target == null ? null : target.assert$Value()));
    var right = tmptarget.get_$3(this, xn.name.name, xn.name);
    right = captureOriginal((right == null ? null : right.assert$Value()));
    y = right.invoke$4(this, TokenKind.binaryMethodName(kind), position, new Arguments(null, [y]));
  }
  var ret = this.assignTemp((tmptarget == null ? null : tmptarget.assert$Value()), (target == null ? null : target.assert$Value())).set_(this, xn.name.name, xn.name, (y == null ? null : y.assert$Value()), false);
  if ($notnull_bool($ne(tmptarget, target))) this.freeTemp((tmptarget == null ? null : tmptarget.assert$Value()));
  return ret;
}
MethodGenerator.prototype.visitUnaryExpression = function(node) {
  var $0;
  var value = this.visitValue(node.self);
  switch (node.op.kind) {
    case 16/*TokenKind.INCR*/:
    case 17/*TokenKind.DECR*/:

      if ($notnull_bool(value.get$type().get$isNum())) {
        return new Value(value.get$type(), ('' + node.op + value.get$code()), node.span, true);
      }
      else {
        var kind = (16/*TokenKind.INCR*/ == node.op.kind ? 42/*TokenKind.ADD*/ : 43/*TokenKind.SUB*/);
        var operand = new LiteralExpression(1, new TypeReference(node.span, $globals.world.numType), '1', node.span);
        return this._visitAssign($assert_num(kind), node.self, (operand == null ? null : operand.assert$lang_Expression()), node, to$call$1(null));
      }

    case 19/*TokenKind.NOT*/:

      if ($notnull_bool(value.get$type().get$isBool()) && $notnull_bool(value.get$isConst())) {
        var newVal = !$notnull_bool(value.get$actualValue());
        return EvaluatedValue.EvaluatedValue$factory((($0 = value.get$type()) == null ? null : $0.assert$lang_Type()), newVal, ('' + newVal), node.span);
      }
      else {
        var newVal = value.convertTo$3(this, $globals.world.nonNullBool, node);
        return new Value(newVal.get$type(), ('!' + newVal.get$code()), node.span, true);
      }

    case 42/*TokenKind.ADD*/:

      return value.convertTo$3(this, $globals.world.numType, node);

    case 43/*TokenKind.SUB*/:
    case 18/*TokenKind.BIT_NOT*/:

      if (node.op.kind == 18/*TokenKind.BIT_NOT*/) {
        return value.invoke$4(this, '\$bit_not', node, Arguments.get$EMPTY());
      }
      else if (node.op.kind == 43/*TokenKind.SUB*/) {
        return value.invoke$4(this, '\$negate', node, Arguments.get$EMPTY());
      }
      else {
        $globals.world.internalError(('unimplemented: unary ' + node.op), node.span);
      }
      $throw(new FallThroughError());

    default:

      $globals.world.internalError(('unimplemented: ' + node.op), node.span);

  }
}
MethodGenerator.prototype.visitPostfixExpression = function(node, isVoid) {
  var $this = this; // closure support
  var value = this.visitValue(node.body);
  if ($notnull_bool(value.get$type().get$isNum())) {
    return new Value(value.get$type(), ('' + value.get$code() + node.op), node.span, true);
  }
  var kind = (16/*TokenKind.INCR*/ == node.op.kind) ? 42/*TokenKind.ADD*/ : 43/*TokenKind.SUB*/;
  var operand = new LiteralExpression(1, new TypeReference(node.span, $globals.world.numType), '1', node.span);
  var tmpleft = null, left = null;
  var ret = this._visitAssign($assert_num(kind), node.body, (operand == null ? null : operand.assert$lang_Expression()), node, (function (l) {
    if ($notnull_bool(isVoid)) {
      return l;
    }
    else {
      left = l;
      tmpleft = $this.forceTemp((l == null ? null : l.assert$Value()));
      return $this.assignTemp((tmpleft == null ? null : tmpleft.assert$Value()), (left == null ? null : left.assert$Value()));
    }
  })
  );
  if ($notnull_bool($ne(tmpleft, null))) {
    ret = new Value(ret.get$type(), ("(" + ret.get$code() + ", " + tmpleft.get$code() + ")"), node.span, true);
  }
  if ($notnull_bool($ne(tmpleft, left))) {
    this.freeTemp((tmpleft == null ? null : tmpleft.assert$Value()));
  }
  return ret;
}
MethodGenerator.prototype.visitNewExpression = function(node) {
  var $0;
  var typeRef = node.type;
  var constructorName = '';
  if (node.name != null) {
    constructorName = node.name.name;
  }
  if ($notnull_bool($eq(constructorName, '')) && !(typeRef instanceof GenericTypeReference) && $notnull_bool($ne(typeRef.get$names(), null))) {
    var names = ListFactory.ListFactory$from$factory((($0 = typeRef.get$names()) == null ? null : $0.assert$Iterable()));
    constructorName = names.removeLast$0().get$name();
    if ($notnull_bool($eq(names.length, 0))) names = null;
    typeRef = new NameTypeReference(typeRef.get$isFinal(), typeRef.get$name(), names, (($0 = typeRef.get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  var type = this.method.resolveType((typeRef == null ? null : typeRef.assert$TypeReference()), true);
  if ($notnull_bool(type.get$isTop())) {
    type = type.get$library().findTypeByName$1(constructorName);
    constructorName = '';
  }
  var m = type.getConstructor$1(constructorName);
  if ($notnull_bool(m == null)) {
    var name = type.get$jsname();
    if ($notnull_bool(type.get$isVar())) {
      name = typeRef.get$name().get$name();
    }
    $globals.world.error(('no matching constructor for ' + name), node.span);
    return this._makeMissingValue($assert_String(name));
  }
  if ($notnull_bool(node.isConst)) {
    if (!$notnull_bool(m.get$isConst())) {
      $globals.world.error('can\'t use const on a non-const constructor', node.span);
    }
    var $list = node.arguments;
    for (var $i = 0;$i < $list.length; $i++) {
      var arg = $list.$index($i);
      if (!$notnull_bool(this.visitValue((($0 = arg.get$value()) == null ? null : $0.assert$lang_Expression())).get$isConst())) {
        $globals.world.error('const constructor expects const arguments', (($0 = arg.get$span()) == null ? null : $0.assert$SourceSpan()));
      }
    }
  }
  var target = new Value.type$ctor(type, typeRef.get$span());
  return m.invoke$4(this, node, target, this._makeArgs(node.arguments));
}
MethodGenerator.prototype.visitListExpression = function(node) {
  var $0;
  var argsCode = [];
  var argValues = [];
  var $list = node.values;
  for (var $i = 0;$i < $list.length; $i++) {
    var item = $list.$index($i);
    var arg = this.visitValue((item == null ? null : item.assert$lang_Expression()));
    argValues.add$1(arg);
    if ($notnull_bool(node.isConst)) {
      if (!$notnull_bool(arg.get$isConst())) {
        $globals.world.error('const list can only contain const values', (($0 = item.get$span()) == null ? null : $0.assert$SourceSpan()));
        argsCode.add$1(arg.get$code());
      }
      else {
        argsCode.add$1(arg.get$canonicalCode());
      }
    }
    else {
      argsCode.add$1(arg.get$code());
    }
  }
  $globals.world.get$coreimpl().types.$index('ListFactory').markUsed$0();
  var code = ('[' + Strings.join((argsCode == null ? null : argsCode.assert$List_String()), ", ") + ']');
  var value = new Value($globals.world.listType, code, node.span, true);
  if ($notnull_bool(node.isConst)) {
    var immutableList = $globals.world.get$coreimpl().types.$index('ImmutableList');
    var immutableListCtor = immutableList.getConstructor$1('from');
    var result = immutableListCtor.invoke$4(this, node, new Value.type$ctor(value.get$type(), node.span), new Arguments(null, [value]));
    value = $globals.world.gen.globalForConst(ConstListValue.ConstListValue$factory((immutableList == null ? null : immutableList.assert$lang_Type()), (argValues == null ? null : argValues.assert$List_EvaluatedValue()), ('const ' + code), $assert_String(result.get$code()), node.span), (argValues == null ? null : argValues.assert$List_Value()));
  }
  return value;
}
MethodGenerator.prototype.visitMapExpression = function(node) {
  var $0;
  var mapImplType = $globals.world.gen.useMapFactory();
  var argValues = [];
  var argsCode = [];
  for (var i = 0;
   i < node.items.length; i += 2) {
    var key = this.visitTypedValue((($0 = node.items.$index(i)) == null ? null : $0.assert$lang_Expression()), $globals.world.stringType);
    var valueItem = node.items.$index(i + 1);
    var value = this.visitValue((valueItem == null ? null : valueItem.assert$lang_Expression()));
    argValues.add$1(key);
    argValues.add$1(value);
    if ($notnull_bool(node.isConst)) {
      if (!$notnull_bool(key.get$isConst()) || !$notnull_bool(value.get$isConst())) {
        $globals.world.error('const map can only contain const values', (($0 = valueItem.get$span()) == null ? null : $0.assert$SourceSpan()));
        argsCode.add$1(key.get$code());
        argsCode.add$1(value.get$code());
      }
      else {
        argsCode.add$1(key.get$canonicalCode());
        argsCode.add$1(value.get$canonicalCode());
      }
    }
    else {
      argsCode.add$1(key.get$code());
      argsCode.add$1(value.get$code());
    }
  }
  var argList = ('[' + Strings.join((argsCode == null ? null : argsCode.assert$List_String()), ", ") + ']');
  var code = ('\$map(' + argList + ')');
  if ($notnull_bool(node.isConst)) {
    var immutableMap = $globals.world.get$coreimpl().types.$index('ImmutableMap');
    var immutableMapCtor = immutableMap.getConstructor$1('');
    var argsValue = new Value($globals.world.listType, argList, node.span, true);
    var result = immutableMapCtor.invoke$4(this, node, new Value.type$ctor(immutableMap, node.span), new Arguments(null, [argsValue]));
    var value = ConstMapValue.ConstMapValue$factory((immutableMap == null ? null : immutableMap.assert$lang_Type()), (argValues == null ? null : argValues.assert$List_EvaluatedValue()), code, $assert_String(result.get$code()), node.span);
    return $globals.world.gen.globalForConst(value, (argValues == null ? null : argValues.assert$List_Value()));
  }
  return new Value(mapImplType, code, node.span, true);
}
MethodGenerator.prototype.visitConditionalExpression = function(node) {
  var $0;
  var test = this.visitBool(node.test);
  var trueBranch = this.visitValue(node.trueBranch);
  var falseBranch = this.visitValue(node.falseBranch);
  var code = ('' + test.get$code() + ' ? ' + trueBranch.get$code() + ' : ' + falseBranch.get$code());
  return new Value(lang_Type.union((($0 = trueBranch.get$type()) == null ? null : $0.assert$lang_Type()), (($0 = falseBranch.get$type()) == null ? null : $0.assert$lang_Type())), code, node.span, true);
}
MethodGenerator.prototype.visitIsExpression = function(node) {
  var value = this.visitValue(node.x);
  var type = this.method.resolveType(node.type, false);
  return value.instanceOf$4(this, type, node.span, node.isTrue);
}
MethodGenerator.prototype.visitParenExpression = function(node) {
  var $0;
  var body = this.visitValue(node.body);
  if ($notnull_bool(body.get$isConst())) {
    return EvaluatedValue.EvaluatedValue$factory((($0 = body.get$type()) == null ? null : $0.assert$lang_Type()), body.get$actualValue(), ('(' + body.get$canonicalCode() + ')'), node.span);
  }
  return new Value(body.get$type(), ('(' + body.get$code() + ')'), node.span, true);
}
MethodGenerator.prototype.visitDotExpression = function(node) {
  var target = node.self.visit(this);
  return target.get_$3(this, node.name.name, node.name);
}
MethodGenerator.prototype.visitVarExpression = function(node) {
  var name = node.name.name;
  var ret = this._scope.lookup(name);
  if ($notnull_bool($ne(ret, null))) return ret;
  return this._makeThisOrType(node.span).get_$3(this, name, node);
}
MethodGenerator.prototype._makeMissingValue = function(name) {
  return new Value($globals.world.varType, ('' + name + '()/*NotFound*/'), null, true);
}
MethodGenerator.prototype._makeThisOrType = function(span) {
  var $0;
  return new BareValue(this, (($0 = this._getOutermostMethod()) == null ? null : $0.assert$MethodGenerator()), span);
}
MethodGenerator.prototype.visitThisExpression = function(node) {
  return this._makeThisValue(node);
}
MethodGenerator.prototype.visitSuperExpression = function(node) {
  return this._makeSuperValue(node);
}
MethodGenerator.prototype.visitNullExpression = function(node) {
  return EvaluatedValue.EvaluatedValue$factory($globals.world.varType, null, 'null', null);
}
MethodGenerator.prototype._isUnaryIncrement = function(item) {
  if ((item instanceof UnaryExpression)) {
    var u = (item == null ? null : item.assert$UnaryExpression());
    return u.op.kind == 16/*TokenKind.INCR*/ || u.op.kind == 17/*TokenKind.DECR*/;
  }
  else {
    return false;
  }
}
MethodGenerator.prototype.visitLiteralExpression = function(node) {
  var $0;
  var type = node.type.type;
  $assert($ne(type, null), "type != null", "gen.dart", 2264, 12);
  if (!!(($0 = node.value) && $0.is$List())) {
    var items = [];
    var $list = node.value;
    for (var $i = node.value.iterator$0(); $i.hasNext$0(); ) {
      var item = $i.next$0();
      var val = this.visitValue((item == null ? null : item.assert$lang_Expression()));
      val.invoke$4(this, 'toString', item, Arguments.get$EMPTY());
      var code = val.get$code();
      if ((item instanceof BinaryExpression) || (item instanceof ConditionalExpression) || (item instanceof PostfixExpression) || $notnull_bool(this._isUnaryIncrement((item == null ? null : item.assert$lang_Expression())))) {
        code = ('(' + code + ')');
      }
      if ($notnull_bool($eq(items.length, 0)) || ($notnull_bool($ne(code, "''")) && $notnull_bool($ne(code, '""')))) {
        items.add$1(code);
      }
    }
    return new Value(type, ('(' + Strings.join((items == null ? null : items.assert$List_String()), " + ") + ')'), node.span, true);
  }
  var text = node.text;
  if ($notnull_bool(type.get$isString())) {
    if ($notnull_bool(text.startsWith$1('@'))) {
      text = MethodGenerator._escapeString(parseStringLiteral($assert_String(text)));
      text = ('"' + text + '"');
    }
    else if ($notnull_bool(isMultilineString($assert_String(text)))) {
      text = parseStringLiteral($assert_String(text));
      text = text.replaceAll$2('\n', '\\n');
      text = toDoubleQuote($assert_String(text));
      text = ('"' + text + '"');
    }
    if (text !== node.text) {
      node.value = text;
      node.text = $assert_String(text);
    }
  }
  return EvaluatedValue.EvaluatedValue$factory((type == null ? null : type.assert$lang_Type()), node.value, node.text, null);
}
MethodGenerator.prototype.visitPostfixExpression$1 = function($0) {
  return this.visitPostfixExpression(($0 == null ? null : $0.assert$PostfixExpression()), false);
};
MethodGenerator.prototype.writeDefinition$2 = function($0, $1) {
  return this.writeDefinition(($0 == null ? null : $0.assert$CodeWriter()), ($1 == null ? null : $1.assert$LambdaExpression()));
};
// ********** Code for Arguments **************
function Arguments(nodes, values) {
  this.nodes = nodes;
  this.values = values;
  // Initializers done
}
Arguments.prototype.assert$Arguments = function(){return this};
Arguments.Arguments$bare$factory = function(arity) {
  var values = [];
  for (var i = 0;
   i < arity; i++) {
    values.add$1(new Value($globals.world.varType, ('\$' + i), null, false));
  }
  return new Arguments(null, values);
}
Arguments.get$EMPTY = function() {
  if ($globals.Arguments__empty == null) {
    $globals.Arguments__empty = new Arguments(null, []);
  }
  return $globals.Arguments__empty;
}
Arguments.prototype.get$values = function() { return this.values; };
Arguments.prototype.set$values = function(value) { return this.values = value; };
Arguments.prototype.get$nodes = function() { return this.nodes; };
Arguments.prototype.set$nodes = function(value) { return this.nodes = value; };
Arguments.prototype.get$nameCount = function() {
  return this.get$length() - this.get$bareCount();
}
Arguments.prototype.get$hasNames = function() {
  return this.get$bareCount() < this.get$length();
}
Arguments.prototype.get$length = function() {
  return this.values.length;
}
Object.defineProperty(Arguments.prototype, "length", {
  get: Arguments.prototype.get$length
});
Arguments.prototype.getName = function(i) {
  return $assert_String(this.nodes.$index(i).get$label().get$name());
}
Arguments.prototype.getIndexOfName = function(name) {
  for (var i = this.get$bareCount();
   i < this.get$length(); i++) {
    if (this.getName(i) == name) {
      return i;
    }
  }
  return -1;
}
Arguments.prototype.getValue = function(name) {
  var $0;
  var i = this.getIndexOfName(name);
  return (($0 = i >= 0 ? this.values.$index(i) : null) == null ? null : $0.assert$Value());
}
Arguments.prototype.get$bareCount = function() {
  if (this._bareCount == null) {
    this._bareCount = this.get$length();
    if (this.nodes != null) {
      for (var i = 0;
       i < this.nodes.length; i++) {
        if ($notnull_bool($ne(this.nodes.$index(i).get$label(), null))) {
          this._bareCount = i;
          break;
        }
      }
    }
  }
  return this._bareCount;
}
Arguments.prototype.getCode = function() {
  var argsCode = [];
  for (var i = 0;
   i < this.get$length(); i++) {
    argsCode.add$1(this.values.$index(i).get$code());
  }
  Arguments.removeTrailingNulls((argsCode == null ? null : argsCode.assert$List_Value()));
  return Strings.join((argsCode == null ? null : argsCode.assert$List_String()), ", ");
}
Arguments.removeTrailingNulls = function(argsCode) {
  while (argsCode.length > 0 && $notnull_bool($eq(argsCode.last(), 'null'))) {
    argsCode.removeLast();
  }
}
Arguments.prototype.getNames = function() {
  var names = [];
  for (var i = this.get$bareCount();
   i < this.get$length(); i++) {
    names.add$1(this.getName(i));
  }
  return (names == null ? null : names.assert$List_String());
}
Arguments.prototype.toCallStubArgs = function() {
  var result = [];
  for (var i = 0;
   i < this.get$bareCount(); i++) {
    result.add$1(new Value($globals.world.varType, ('\$' + i), null, false));
  }
  for (var i = this.get$bareCount();
   i < this.get$length(); i++) {
    var name = this.getName(i);
    if ($notnull_bool(name == null)) name = ('\$' + i);
    result.add$1(new Value($globals.world.varType, name, null, false));
  }
  return new Arguments(this.nodes, result);
}
// ********** Code for LibraryImport **************
function LibraryImport(library, prefix) {
  this.library = library;
  this.prefix = prefix;
  // Initializers done
}
LibraryImport.prototype.get$prefix = function() { return this.prefix; };
LibraryImport.prototype.set$prefix = function(value) { return this.prefix = value; };
LibraryImport.prototype.get$library = function() { return this.library; };
LibraryImport.prototype.set$library = function(value) { return this.library = value; };
// ********** Code for Library **************
function Library(baseSource) {
  this.isWritten = false
  this.isMarked = false
  this.baseSource = baseSource;
  // Initializers done
  lang_Element.call(this, null, null);
  this.sourceDir = dirname(this.baseSource.filename);
  this.topType = new DefinedType(null, this, null, true);
  this.types = $map(['', this.topType]);
  this.imports = [];
  this.natives = [];
  this.sources = [];
  this._privateMembers = $map([]);
}
$inherits(Library, lang_Element);
Library.prototype.assert$Library = function(){return this};
Library.prototype.get$baseSource = function() { return this.baseSource; };
Library.prototype.get$types = function() { return this.types; };
Library.prototype.set$types = function(value) { return this.types = value; };
Library.prototype.get$topType = function() { return this.topType; };
Library.prototype.set$topType = function(value) { return this.topType = value; };
Library.prototype.get$enclosingElement = function() {
  return null;
}
Library.prototype.get$library = function() {
  return this;
}
Library.prototype.get$isNative = function() {
  return this.topType.isNative;
}
Library.prototype.get$isCore = function() {
  return $eq(this, $globals.world.corelib);
}
Library.prototype.get$isCoreImpl = function() {
  return $eq(this, $globals.world.get$coreimpl());
}
Library.prototype.get$span = function() {
  return new SourceSpan(this.baseSource, 0, 0);
}
Library.prototype.makeFullPath = function(filename) {
  if (filename.startsWith('dart:')) return filename;
  if (filename.startsWith('/')) return filename;
  if (filename.startsWith('file:///')) return filename;
  if (filename.startsWith('http://')) return filename;
  return joinPaths(this.sourceDir, filename);
}
Library.prototype.addImport = function(fullname, prefix) {
  var newLib = $globals.world.getOrAddLibrary(fullname);
  this.imports.add(new LibraryImport(newLib, prefix));
  return newLib;
}
Library.prototype.addNative = function(fullname) {
  this.natives.add($globals.world.reader.readFile(fullname));
}
Library.prototype._findMembers = function(name) {
  var $0;
  if (name.startsWith('_')) {
    return (($0 = this._privateMembers.$index(name)) == null ? null : $0.assert$MemberSet());
  }
  else {
    return (($0 = $globals.world._members.$index(name)) == null ? null : $0.assert$MemberSet());
  }
}
Library.prototype._addMember = function(member) {
  if ($notnull_bool(member.get$isPrivate())) {
    if ($notnull_bool(member.get$isStatic())) {
      if ($notnull_bool(member.declaringType.get$isTop())) {
        $globals.world._addTopName(member);
      }
      return;
    }
    var mset = this._privateMembers.$index(member.name);
    if ($notnull_bool(mset == null)) {
      var $list = $globals.world.libraries.getValues();
      for (var $i = $globals.world.libraries.getValues().iterator$0(); $i.hasNext$0(); ) {
        var lib = $i.next$0();
        if (lib._privateMembers.containsKey(member.get$jsname())) {
          member._jsname = ('_' + this.get$jsname() + member.get$jsname());
          break;
        }
      }
      mset = new MemberSet(member, false);
      this._privateMembers.$setindex(member.name, mset);
    }
    else {
      mset.get$members().add$1(member);
    }
  }
  else {
    $globals.world._addMember(member);
  }
}
Library.prototype.getOrAddFunctionType = function(enclosingElement, name, func) {
  var def = new FunctionTypeDefinition(func, null, func.span);
  var type = new DefinedType(name, this, def, false);
  type.addMethod('\$call', func);
  var m = type.members.$index('\$call');
  m.set$enclosingElement(enclosingElement);
  m.resolve$0();
  type.interfaces = [$globals.world.functionType];
  return type;
}
Library.prototype.addType = function(name, definition, isClass) {
  var $0;
  if (this.types.containsKey(name)) {
    var existingType = this.types.$index(name);
    if ($notnull_bool(this.get$isCore()) && $notnull_bool(existingType.get$definition() == null)) {
      existingType.setDefinition$1(definition);
    }
    else {
      $globals.world.warning(('duplicate definition of ' + name), definition.span, (($0 = existingType.get$span()) == null ? null : $0.assert$SourceSpan()));
    }
  }
  else {
    this.types.$setindex(name, new DefinedType(name, this, (definition == null ? null : definition.assert$Definition()), isClass));
  }
  return (($0 = this.types.$index(name)) == null ? null : $0.assert$DefinedType());
}
Library.prototype.findType = function(type) {
  var result = this.findTypeByName(type.name.name);
  if (result == null) return null;
  if (type.names != null) {
    if (type.names.length > 1) {
      return null;
    }
    if (!$notnull_bool(result.get$isTop())) {
      return null;
    }
    return result.get$library().findTypeByName($assert_String(type.names.$index(0).get$name()));
  }
  return result;
}
Library.prototype.findTypeByName = function(name) {
  var $0;
  var ret = this.types.$index(name);
  var $list = this.imports;
  for (var $i = 0;$i < $list.length; $i++) {
    var imported = $list.$index($i);
    var newRet = null;
    if ($notnull_bool(imported.get$prefix() == null)) {
      newRet = imported.get$library().get$types().$index(name);
    }
    else if ($notnull_bool($eq(imported.get$prefix(), name))) {
      newRet = imported.get$library().get$topType();
    }
    if ($notnull_bool($ne(newRet, null))) {
      if ($notnull_bool($ne(ret, null)) && $notnull_bool($ne(ret, newRet))) {
        $globals.world.error(('conflicting types for "' + name + '"'), (($0 = ret.get$span()) == null ? null : $0.assert$SourceSpan()), (($0 = newRet.get$span()) == null ? null : $0.assert$SourceSpan()));
      }
      else {
        ret = newRet;
      }
    }
  }
  return (ret == null ? null : ret.assert$lang_Type());
}
Library.prototype.resolveType = function(node, typeErrors) {
  if (node == null) return $globals.world.varType;
  if (node.type != null) return node.type;
  node.type = this.findType((node == null ? null : node.assert$NameTypeReference()));
  if (node.type == null) {
    var message = ('cannot find type ' + Library._getDottedName((node == null ? null : node.assert$NameTypeReference())));
    if ($notnull_bool(typeErrors)) {
      $globals.world.error($assert_String(message), node.span);
      node.type = $globals.world.objectType;
    }
    else {
      $globals.world.warning($assert_String(message), node.span);
      node.type = $globals.world.varType;
    }
  }
  return node.type;
}
Library._getDottedName = function(type) {
  if (type.names != null) {
    var names = map(type.names, (function (n) {
      return n.get$name();
    })
    );
    return type.name.name + '.' + Strings.join((names == null ? null : names.assert$List_String()), '.');
  }
  else {
    return type.name.name;
  }
}
Library.prototype.lookup = function(name, span) {
  var $0;
  var retType = this.findTypeByName(name);
  var ret = null;
  if ($notnull_bool($ne(retType, null))) {
    ret = retType.get$typeMember();
  }
  var newRet = this.topType.getMember(name);
  if ($notnull_bool($ne(newRet, null))) {
    if ($notnull_bool($ne(ret, null)) && $notnull_bool($ne(ret, newRet))) {
      $globals.world.error(('conflicting members for "' + name + '"'), span, (($0 = ret.get$span()) == null ? null : $0.assert$SourceSpan()), (($0 = newRet.get$span()) == null ? null : $0.assert$SourceSpan()));
    }
    else {
      ret = newRet;
    }
  }
  var $list = this.imports;
  for (var $i = 0;$i < $list.length; $i++) {
    var imported = $list.$index($i);
    if ($notnull_bool(imported.get$prefix() == null)) {
      newRet = imported.get$library().get$topType().getMember$1(name);
      if ($notnull_bool($ne(newRet, null))) {
        if ($notnull_bool($ne(ret, null)) && $notnull_bool($ne(ret, newRet))) {
          $globals.world.error(('conflicting members for "' + name + '"'), span, (($0 = ret.get$span()) == null ? null : $0.assert$SourceSpan()), (($0 = newRet.get$span()) == null ? null : $0.assert$SourceSpan()));
        }
        else {
          ret = newRet;
        }
      }
    }
  }
  return (ret == null ? null : ret.assert$Member());
}
Library.prototype.resolve = function() {
  if (this.name == null) {
    this.name = this.baseSource.filename;
    var index = this.name.lastIndexOf('/', this.name.length);
    if (index >= 0) {
      this.name = this.name.substring($assert_num(index + 1));
    }
    index = this.name.indexOf('.');
    if (index > 0) {
      this.name = this.name.substring(0, $assert_num(index));
    }
  }
  this._jsname = this.name.replaceAll('.', '_').replaceAll(':', '_').replaceAll(' ', '_');
  var $list = this.types.getValues();
  for (var $i = this.types.getValues().iterator$0(); $i.hasNext$0(); ) {
    var type = $i.next$0();
    type.resolve$0();
  }
}
Library.prototype.visitSources = function() {
  var visitor = new _LibraryVisitor(this);
  visitor.addSource$1(this.baseSource);
}
Library.prototype.toString = function() {
  return this.baseSource.filename;
}
Library.prototype.findTypeByName$1 = function($0) {
  return this.findTypeByName($assert_String($0));
};
Library.prototype.resolve$0 = Library.prototype.resolve;
Library.prototype.toString$0 = Library.prototype.toString;
Library.prototype.visitSources$0 = Library.prototype.visitSources;
// ********** Code for _LibraryVisitor **************
function _LibraryVisitor(library) {
  this.seenImport = false
  this.seenSource = false
  this.seenResource = false
  this.isTop = true
  this.library = library;
  // Initializers done
  this.currentType = this.library.topType;
  this.sources = [];
}
_LibraryVisitor.prototype.assert$TreeVisitor = function(){return this};
_LibraryVisitor.prototype.get$library = function() { return this.library; };
_LibraryVisitor.prototype.get$isTop = function() { return this.isTop; };
_LibraryVisitor.prototype.set$isTop = function(value) { return this.isTop = value; };
_LibraryVisitor.prototype.addSourceFromName = function(name, span) {
  var filename = this.library.makeFullPath(name);
  if ($notnull_bool($eq(filename, this.library.baseSource.filename))) {
    $globals.world.error('library can not source itself', span);
    return;
  }
  else if (this.sources.some((function (s) {
    return $eq(s.get$filename(), filename);
  })
  )) {
    $globals.world.error(('file "' + filename + '" has already been sourced'), span);
    return;
  }
  var source = $globals.world.readFile(this.library.makeFullPath(name));
  this.sources.add(source);
}
_LibraryVisitor.prototype.addSource = function(source) {
  var $this = this; // closure support
  if (this.library.sources.some((function (s) {
    return $eq(s.get$filename(), source.filename);
  })
  )) {
    $globals.world.error(('duplicate source file "' + source.filename + '"'));
    return;
  }
  this.library.sources.add(source);
  var parser = new lang_Parser(source, $globals.options.dietParse, false, false, 0);
  var unit = parser.compilationUnit();
  unit.forEach((function (def) {
    return def.visit$1($this);
  })
  );
  $assert(this.sources.length == 0 || $notnull_bool(this.isTop), "sources.length == 0 || isTop", "library.dart", 330, 12);
  this.isTop = false;
  var newSources = this.sources;
  this.sources = [];
  for (var $i = newSources.iterator$0(); $i.hasNext$0(); ) {
    var source0 = $i.next$0();
    this.addSource((source0 == null ? null : source0.assert$SourceFile()));
  }
}
_LibraryVisitor.prototype.visitDirectiveDefinition = function(node) {
  if (!$notnull_bool(this.isTop)) {
    $globals.world.error('directives not allowed in sourced file', node.span);
    return;
  }
  var name;
  switch (node.name.name) {
    case "library":

      name = this.getSingleStringArg(node);
      if (this.library.name == null) {
        this.library.name = $assert_String(name);
        if ($notnull_bool($eq(name, 'node')) || $notnull_bool($eq(name, 'dom'))) {
          this.library.topType.isNative = true;
        }
        if ($notnull_bool(this.seenImport) || $notnull_bool(this.seenSource) || $notnull_bool(this.seenResource)) {
          $globals.world.error('#library must be first directive in file', node.span);
        }
      }
      else {
        $globals.world.error('already specified library name', node.span);
      }
      break;

    case "import":

      this.seenImport = true;
      name = this.getFirstStringArg(node);
      var prefix = this.tryGetNamedStringArg(node, 'prefix');
      if (node.arguments.length > 2 || node.arguments.length == 2 && $notnull_bool(prefix == null)) {
        $globals.world.error('expected at most one "name" argument and one optional "prefix"' + (' but found ' + node.arguments.length), node.span);
      }
      else if ($notnull_bool($ne(prefix, null)) && prefix.indexOf$1('.') >= 0) {
        $globals.world.error('library prefix canot contain "."', node.span);
      }
      else if ($notnull_bool(this.seenSource) || $notnull_bool(this.seenResource)) {
        $globals.world.error('#imports must come before any #source or #resource', node.span);
      }
      if ($notnull_bool($eq(prefix, ''))) prefix = null;
      var filename = this.library.makeFullPath($assert_String(name));
      if (this.library.imports.some((function (li) {
        return $eq(li.get$library().get$baseSource(), filename);
      })
      )) {
        $globals.world.error(('duplicate import of "' + name + '"'), node.span);
        return;
      }
      var newLib = this.library.addImport($assert_String(filename), $assert_String(prefix));
      break;

    case "source":

      this.seenSource = true;
      name = this.getSingleStringArg(node);
      this.addSourceFromName($assert_String(name), node.span);
      if ($notnull_bool(this.seenResource)) {
        $globals.world.error('#sources must come before any #resource', node.span);
      }
      break;

    case "native":

      name = this.getSingleStringArg(node);
      this.library.addNative(this.library.makeFullPath($assert_String(name)));
      break;

    case "resource":

      this.seenResource = true;
      this.getFirstStringArg(node);
      break;

    default:

      $globals.world.error(('unknown directive: ' + node.name.name), node.span);

  }
}
_LibraryVisitor.prototype.getSingleStringArg = function(node) {
  if (node.arguments.length != 1) {
    $globals.world.error(('expected exactly one argument but found ' + node.arguments.length), node.span);
  }
  return this.getFirstStringArg(node);
}
_LibraryVisitor.prototype.getFirstStringArg = function(node) {
  if (node.arguments.length < 1) {
    $globals.world.error(('expected at least one argument but found ' + node.arguments.length), node.span);
  }
  var arg = node.arguments.$index(0);
  if ($notnull_bool($ne(arg.get$label(), null))) {
    $globals.world.error('label not allowed for directive', node.span);
  }
  return this._parseStringArgument((arg == null ? null : arg.assert$ArgumentNode()));
}
_LibraryVisitor.prototype.tryGetNamedStringArg = function(node, argName) {
  var args = node.arguments.filter((function (a) {
    return $notnull_bool($ne(a.get$label(), null)) && $notnull_bool($eq(a.get$label().get$name(), argName));
  })
  );
  if ($notnull_bool($eq(args.length, 0))) {
    return null;
  }
  if (args.length > 1) {
    $globals.world.error(('expected at most one "' + argName + '" argument but found ') + node.arguments.length, node.span);
  }
  for (var $i = args.iterator$0(); $i.hasNext$0(); ) {
    var arg = $i.next$0();
    return this._parseStringArgument((arg == null ? null : arg.assert$ArgumentNode()));
  }
}
_LibraryVisitor.prototype._parseStringArgument = function(arg) {
  var $0;
  var expr = arg.value;
  if (!(expr instanceof LiteralExpression) || !$notnull_bool(expr.get$type().get$type().get$isString())) {
    $globals.world.error('expected string', (($0 = expr.get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  return parseStringLiteral($assert_String(expr.get$value()));
}
_LibraryVisitor.prototype.visitTypeDefinition = function(node) {
  var oldType = this.currentType;
  this.currentType = this.library.addType(node.name.name, node, node.isClass);
  var $list = node.body;
  for (var $i = 0;$i < $list.length; $i++) {
    var member = $list.$index($i);
    member.visit$1(this);
  }
  this.currentType = (oldType == null ? null : oldType.assert$DefinedType());
}
_LibraryVisitor.prototype.visitVariableDefinition = function(node) {
  this.currentType.addField(node);
}
_LibraryVisitor.prototype.visitFunctionDefinition = function(node) {
  this.currentType.addMethod(node.name.name, node);
}
_LibraryVisitor.prototype.visitFunctionTypeDefinition = function(node) {
  var type = this.library.addType(node.func.name.name, node, false);
  type.addMethod$2('\$call', node.func);
}
_LibraryVisitor.prototype.addSource$1 = function($0) {
  return this.addSource(($0 == null ? null : $0.assert$SourceFile()));
};
// ********** Code for Parameter **************
function Parameter(definition, method) {
  this.isInitializer = false
  this.definition = definition;
  this.method = method;
  // Initializers done
}
Parameter.prototype.assert$Parameter = function(){return this};
Parameter.prototype.get$definition = function() { return this.definition; };
Parameter.prototype.set$definition = function(value) { return this.definition = value; };
Parameter.prototype.get$name = function() { return this.name; };
Parameter.prototype.set$name = function(value) { return this.name = value; };
Parameter.prototype.get$type = function() { return this.type; };
Parameter.prototype.set$type = function(value) { return this.type = value; };
Parameter.prototype.get$isInitializer = function() { return this.isInitializer; };
Parameter.prototype.set$isInitializer = function(value) { return this.isInitializer = value; };
Parameter.prototype.get$value = function() { return this.value; };
Parameter.prototype.set$value = function(value) { return this.value = value; };
Parameter.prototype.resolve = function() {
  this.name = this.definition.name.name;
  if (this.name.startsWith('this.')) {
    this.name = this.name.substring(5);
    this.isInitializer = true;
  }
  this.type = this.method.resolveType(this.definition.type, false);
  if ($notnull_bool(this.method.get$isStatic()) && this.method.get$typeParameters() == null && $notnull_bool(this.type.get$hasTypeParams())) {
    $globals.world.error('using type parameter in static context', this.definition.span);
  }
  if (this.definition.value != null) {
    if ((this.definition.value instanceof NullExpression) && this.definition.value.span.start == this.definition.span.start) {
      return;
    }
    if (this.method.name == '\$call') {
      if ($notnull_bool(this.method.get$definition().get$body() == null)) {
        $globals.world.error('default value not allowed on function type', this.definition.span);
      }
    }
    else if ($notnull_bool(this.method.get$isAbstract())) {
      $globals.world.error('default value not allowed on abstract methods', this.definition.span);
    }
  }
  else if ($notnull_bool(this.isInitializer) && !$notnull_bool(this.method.get$isConstructor())) {
    $globals.world.error('initializer parameters only allowed on constructors', this.definition.span);
  }
}
Parameter.prototype.genValue = function(method, context) {
  var $0;
  if (this.definition.value == null || this.value != null) return;
  if (context == null) {
    context = new MethodGenerator(method, null);
  }
  this.value = (($0 = this.definition.value.visit(context)) == null ? null : $0.assert$Value());
  this.value = this.value.convertTo(context, this.type, this.definition.value, false);
}
Parameter.prototype.copyWithNewType = function(newMethod, newType) {
  var $0;
  var ret = new Parameter(this.definition, newMethod);
  ret.set$type(newType);
  ret.set$name(this.name);
  ret.set$isInitializer(this.isInitializer);
  return (ret == null ? null : ret.assert$Parameter());
}
Parameter.prototype.get$isOptional = function() {
  return this.definition != null && this.definition.value != null;
}
Parameter.prototype.copyWithNewType$2 = function($0, $1) {
  return this.copyWithNewType(($0 == null ? null : $0.assert$Member()), ($1 == null ? null : $1.assert$lang_Type()));
};
Parameter.prototype.genValue$2 = function($0, $1) {
  return this.genValue(($0 == null ? null : $0.assert$MethodMember()), ($1 == null ? null : $1.assert$MethodGenerator()));
};
Parameter.prototype.resolve$0 = Parameter.prototype.resolve;
// ********** Code for Member **************
function Member(name, declaringType) {
  this.isGenerated = false;
  this.declaringType = declaringType;
  // Initializers done
  lang_Element.call(this, name, declaringType);
}
$inherits(Member, lang_Element);
Member.prototype.assert$Member = function(){return this};
Member.prototype.get$declaringType = function() { return this.declaringType; };
Member.prototype.get$generator = function() { return this.generator; };
Member.prototype.set$generator = function(value) { return this.generator = value; };
Member.prototype.get$library = function() {
  return this.declaringType.get$library();
}
Member.prototype.get$isPrivate = function() {
  return this.name.startsWith('_');
}
Member.prototype.get$isConstructor = function() {
  return false;
}
Member.prototype.get$isField = function() {
  return false;
}
Member.prototype.get$isMethod = function() {
  return false;
}
Member.prototype.get$isProperty = function() {
  return false;
}
Member.prototype.get$isAbstract = function() {
  return false;
}
Member.prototype.get$isFinal = function() {
  return false;
}
Member.prototype.get$isConst = function() {
  return false;
}
Member.prototype.get$isFactory = function() {
  return false;
}
Member.prototype.get$isOperator = function() {
  return this.name.startsWith('\$');
}
Member.prototype.get$isCallMethod = function() {
  return this.name == '\$call';
}
Member.prototype.get$prefersPropertySyntax = function() {
  return true;
}
Member.prototype.get$requiresFieldSyntax = function() {
  return false;
}
Member.prototype.get$isNative = function() {
  return false;
}
Member.prototype.get$constructorName = function() {
  $globals.world.internalError('can not be a constructor', this.get$span());
}
Member.prototype.provideFieldSyntax = function() {

}
Member.prototype.providePropertySyntax = function() {

}
Member.prototype.get$initDelegate = function() {
  $globals.world.internalError('cannot have initializers', this.get$span());
}
Member.prototype.set$initDelegate = function(ctor) {
  $globals.world.internalError('cannot have initializers', this.get$span());
}
Member.prototype.computeValue = function() {
  $globals.world.internalError('cannot have value', this.get$span());
}
Member.prototype.get$inferredResult = function() {
  var t = this.get$returnType();
  if ($notnull_bool(t.get$isBool()) && ($notnull_bool(this.get$library().get$isCore()) || $notnull_bool(this.get$library().get$isCoreImpl()))) {
    return $globals.world.nonNullBool;
  }
  return (t == null ? null : t.assert$lang_Type());
}
Member.prototype.get$definition = function() {
  return null;
}
Member.prototype.get$parameters = function() {
  return [];
}
Member.prototype.canInvoke = function(context, args) {
  return $notnull_bool(this.get$canGet()) && $notnull_bool(new Value(this.get$returnType(), null, null, true).canInvoke(context, '\$call', args));
}
Member.prototype.invoke = function(context, node, target, args, isDynamic) {
  var $0;
  var newTarget = this._get(context, node, target, isDynamic);
  return (($0 = newTarget.invoke$5(context, '\$call', node, args, isDynamic)) == null ? null : $0.assert$Value());
}
Member.prototype.override = function(other) {
  if ($notnull_bool(this.get$isStatic())) {
    $globals.world.error('static members can not hide parent members', this.get$span(), other.get$span());
    return false;
  }
  else if ($notnull_bool(other.get$isStatic())) {
    $globals.world.error('can not override static member', this.get$span(), other.get$span());
    return false;
  }
  return true;
}
Member.prototype.get$generatedFactoryName = function() {
  $assert(this.get$isFactory(), "this.isFactory", "member.dart", 187, 12);
  var prefix = ('' + this.declaringType.get$jsname() + '.' + this.get$constructorName() + '\$');
  if (this.name == '') {
    return ('' + prefix + 'factory');
  }
  else {
    return ('' + prefix + this.name + '\$factory');
  }
}
Member.prototype.hashCode = function() {
  return (this.declaringType.hashCode() << 4) ^ this.name.hashCode();
}
Member.prototype._get$3 = function($0, $1, $2) {
  return this._get(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()));
};
Member.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Value()));
};
Member.prototype.canInvoke$2 = function($0, $1) {
  return this.canInvoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$Arguments()));
};
Member.prototype.computeValue$0 = Member.prototype.computeValue;
Member.prototype.hashCode$0 = Member.prototype.hashCode;
Member.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), false);
};
Member.prototype.invoke$4$isDynamic = function($0, $1, $2, $3, isDynamic) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool(isDynamic));
};
Member.prototype.invoke$5 = function($0, $1, $2, $3, $4) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool($4));
};
Member.prototype.provideFieldSyntax$0 = Member.prototype.provideFieldSyntax;
Member.prototype.providePropertySyntax$0 = Member.prototype.providePropertySyntax;
// ********** Code for TypeMember **************
function TypeMember(type) {
  this.type = type;
  // Initializers done
  Member.call(this, type.name, type.library.topType);
}
$inherits(TypeMember, Member);
TypeMember.prototype.assert$TypeMember = function(){return this};
TypeMember.prototype.get$type = function() { return this.type; };
TypeMember.prototype.get$span = function() {
  return this.type.definition.span;
}
TypeMember.prototype.get$isStatic = function() {
  return true;
}
TypeMember.prototype.get$returnType = function() {
  return $globals.world.varType;
}
TypeMember.prototype.canInvoke = function(context, args) {
  return false;
}
TypeMember.prototype.get$canGet = function() {
  return true;
}
TypeMember.prototype.get$canSet = function() {
  return false;
}
TypeMember.prototype._get = function(context, node, target, isDynamic) {
  return new Value.type$ctor(this.type, node.span);
}
TypeMember.prototype._set = function(context, node, target, value, isDynamic) {
  $globals.world.error('cannot set type', node.span);
}
TypeMember.prototype.invoke = function(context, node, target, args, isDynamic) {
  $globals.world.error('cannot invoke type', node.span);
}
TypeMember.prototype._get$3 = function($0, $1, $2) {
  return this._get(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), false);
};
TypeMember.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Value()), false);
};
TypeMember.prototype.canInvoke$2 = function($0, $1) {
  return this.canInvoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$Arguments()));
};
TypeMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), false);
};
TypeMember.prototype.invoke$4$isDynamic = function($0, $1, $2, $3, isDynamic) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool(isDynamic));
};
TypeMember.prototype.invoke$5 = function($0, $1, $2, $3, $4) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool($4));
};
// ********** Code for FieldMember **************
function FieldMember(name, declaringType, definition, value) {
  this._providePropertySyntax = false
  this._computing = false
  this.definition = definition;
  this.value = value;
  this.isNative = false;
  // Initializers done
  Member.call(this, name, declaringType);
}
$inherits(FieldMember, Member);
FieldMember.prototype.assert$FieldMember = function(){return this};
FieldMember.prototype.get$definition = function() { return this.definition; };
FieldMember.prototype.get$value = function() { return this.value; };
FieldMember.prototype.get$type = function() { return this.type; };
FieldMember.prototype.set$type = function(value) { return this.type = value; };
FieldMember.prototype.get$isStatic = function() { return this.isStatic; };
FieldMember.prototype.set$isStatic = function(value) { return this.isStatic = value; };
FieldMember.prototype.get$isFinal = function() { return this.isFinal; };
FieldMember.prototype.set$isFinal = function(value) { return this.isFinal = value; };
FieldMember.prototype.get$isNative = function() { return this.isNative; };
FieldMember.prototype.set$isNative = function(value) { return this.isNative = value; };
FieldMember.prototype.override = function(other) {
  if (!$notnull_bool(Member.prototype.override.call(this, other))) return false;
  if ($notnull_bool(other.get$isProperty())) {
    return true;
  }
  else {
    $globals.world.error('field can not override anything but property', this.get$span(), other.get$span());
    return false;
  }
}
FieldMember.prototype.get$prefersPropertySyntax = function() {
  return false;
}
FieldMember.prototype.get$requiresFieldSyntax = function() {
  return this.isNative;
}
FieldMember.prototype.provideFieldSyntax = function() {

}
FieldMember.prototype.providePropertySyntax = function() {
  this._providePropertySyntax = true;
}
FieldMember.prototype.get$span = function() {
  var $0;
  return (($0 = this.definition == null ? null : this.definition.span) == null ? null : $0.assert$SourceSpan());
}
FieldMember.prototype.get$returnType = function() {
  return this.type;
}
FieldMember.prototype.get$canGet = function() {
  return true;
}
FieldMember.prototype.get$canSet = function() {
  return !$notnull_bool(this.isFinal);
}
FieldMember.prototype.get$isField = function() {
  return true;
}
FieldMember.prototype.resolve = function() {
  var $0;
  this.isStatic = this.declaringType.get$isTop();
  this.isFinal = false;
  if (this.definition.modifiers != null) {
    var $list = this.definition.modifiers;
    for (var $i = 0;$i < $list.length; $i++) {
      var mod = $list.$index($i);
      if ($notnull_bool($eq(mod.get$kind(), 86/*TokenKind.STATIC*/))) {
        if ($notnull_bool(this.isStatic)) {
          $globals.world.error('duplicate static modifier', (($0 = mod.get$span()) == null ? null : $0.assert$SourceSpan()));
        }
        this.isStatic = true;
      }
      else if ($notnull_bool($eq(mod.get$kind(), 97/*TokenKind.FINAL*/))) {
        if ($notnull_bool(this.isFinal)) {
          $globals.world.error('duplicate final modifier', (($0 = mod.get$span()) == null ? null : $0.assert$SourceSpan()));
        }
        this.isFinal = true;
      }
      else {
        $globals.world.error(('' + mod + ' modifier not allowed on field'), (($0 = mod.get$span()) == null ? null : $0.assert$SourceSpan()));
      }
    }
  }
  this.type = this.resolveType(this.definition.type, false);
  if ($notnull_bool(this.isStatic) && $notnull_bool(this.type.get$hasTypeParams())) {
    $globals.world.error('using type parameter in static context', this.definition.type.span);
  }
  if ($notnull_bool(this.isStatic) && $notnull_bool(this.isFinal) && this.value == null) {
    $globals.world.error('static final field is missing initializer', this.get$span());
  }
  this.get$library()._addMember(this);
}
FieldMember.prototype.computeValue = function() {
  var $0;
  if (this.value == null) return null;
  if (this._computedValue == null) {
    if ($notnull_bool(this._computing)) {
      $globals.world.error('circular reference', this.value.span);
      return null;
    }
    this._computing = true;
    var finalMethod = new MethodMember('final_context', this.declaringType, null);
    finalMethod.set$isStatic(true);
    var finalGen = new MethodGenerator(finalMethod, null);
    this._computedValue = (($0 = this.value.visit((finalGen == null ? null : finalGen.assert$TreeVisitor()))) == null ? null : $0.assert$Value());
    if (!$notnull_bool(this._computedValue.get$isConst())) {
      if ($notnull_bool(this.isStatic)) {
        $globals.world.error('non constant static field must be initialized in functions', this.value.span);
      }
      else {
        $globals.world.error('non constant field must be initialized in constructor', this.value.span);
      }
    }
    if ($notnull_bool(this.isStatic)) {
      this._computedValue = $globals.world.gen.globalForStaticField(this, this._computedValue, [this._computedValue]);
    }
    this._computing = false;
  }
  return this._computedValue;
}
FieldMember.prototype._get = function(context, node, target, isDynamic) {
  var $0;
  if (!$notnull_bool(isDynamic)) {
    this.declaringType.markUsed();
  }
  if ($notnull_bool(this.isStatic)) {
    var cv = this.computeValue();
    if ($notnull_bool(this.isFinal)) {
      return (cv == null ? null : cv.assert$Value());
    }
    $globals.world.gen.hasStatics = true;
    if ($notnull_bool(this.declaringType.get$isTop())) {
      if ($eq(this.declaringType.get$library(), $globals.world.get$dom())) {
        return new Value(this.type, ('' + this.get$jsname()), node.span, true);
      }
      else {
        return new Value(this.type, ('\$globals.' + this.get$jsname()), node.span, true);
      }
    }
    else if ($notnull_bool(this.declaringType.get$isNative())) {
      if ($notnull_bool(this.declaringType.get$isHiddenNativeType())) {
        $globals.world.error('static field of hidden native type is inaccessible', node.span);
      }
      return new Value(this.type, ('' + this.declaringType.get$jsname() + '.' + this.get$jsname()), node.span, true);
    }
    else {
      return new Value(this.type, ('\$globals.' + this.declaringType.get$jsname() + '_' + this.get$jsname()), node.span, true);
    }
  }
  else if ($notnull_bool(target.get$isConst()) && $notnull_bool(this.isFinal)) {
    var constTarget = (target instanceof GlobalValue) ? target.get$dynamic().get$exp() : target;
    if ((constTarget instanceof ConstObjectValue)) {
      return (($0 = constTarget.get$fields().$index(this.name)) == null ? null : $0.assert$Value());
    }
    else if ($notnull_bool($eq(constTarget.get$type(), $globals.world.stringType)) && this.name == 'length') {
      return new Value(this.type, ('' + constTarget.get$actualValue().length), node.span, true);
    }
  }
  return new Value(this.type, ('' + target.code + '.' + this.get$jsname()), node.span, true);
}
FieldMember.prototype._set = function(context, node, target, value, isDynamic) {
  var lhs = this._get(context, node, target, isDynamic);
  value = value.convertTo(context, this.type, node, isDynamic);
  return new Value(this.type, ('' + lhs.get$code() + ' = ' + value.code), node.span, true);
}
FieldMember.prototype._get$3 = function($0, $1, $2) {
  return this._get(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), false);
};
FieldMember.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Value()), false);
};
FieldMember.prototype.computeValue$0 = FieldMember.prototype.computeValue;
FieldMember.prototype.provideFieldSyntax$0 = FieldMember.prototype.provideFieldSyntax;
FieldMember.prototype.providePropertySyntax$0 = FieldMember.prototype.providePropertySyntax;
FieldMember.prototype.resolve$0 = FieldMember.prototype.resolve;
// ********** Code for PropertyMember **************
function PropertyMember(name, declaringType) {
  this._provideFieldSyntax = false
  // Initializers done
  Member.call(this, name, declaringType);
}
$inherits(PropertyMember, Member);
PropertyMember.prototype.assert$PropertyMember = function(){return this};
PropertyMember.prototype.get$getter = function() { return this.getter; };
PropertyMember.prototype.set$getter = function(value) { return this.getter = value; };
PropertyMember.prototype.get$setter = function() { return this.setter; };
PropertyMember.prototype.set$setter = function(value) { return this.setter = value; };
PropertyMember.prototype.get$span = function() {
  var $0;
  return (($0 = this.getter != null ? this.getter.get$span() : null) == null ? null : $0.assert$SourceSpan());
}
PropertyMember.prototype.get$canGet = function() {
  return this.getter != null;
}
PropertyMember.prototype.get$canSet = function() {
  return this.setter != null;
}
PropertyMember.prototype.get$prefersPropertySyntax = function() {
  return true;
}
PropertyMember.prototype.get$requiresFieldSyntax = function() {
  return false;
}
PropertyMember.prototype.provideFieldSyntax = function() {
  this._provideFieldSyntax = true;
}
PropertyMember.prototype.providePropertySyntax = function() {

}
PropertyMember.prototype.get$isStatic = function() {
  return this.getter == null ? this.setter.isStatic : this.getter.isStatic;
}
PropertyMember.prototype.get$isProperty = function() {
  return true;
}
PropertyMember.prototype.get$returnType = function() {
  return this.getter == null ? this.setter.returnType : this.getter.returnType;
}
PropertyMember.prototype.override = function(other) {
  if (!$notnull_bool(Member.prototype.override.call(this, other))) return false;
  if ($notnull_bool(other.get$isProperty()) || $notnull_bool(other.get$isField())) {
    if ($notnull_bool(other.get$isProperty())) this.addFromParent(other);
    else this._overriddenField = other;
    return true;
  }
  else {
    $globals.world.error('property can only override field or property', this.get$span(), other.get$span());
    return false;
  }
}
PropertyMember.prototype._get = function(context, node, target, isDynamic) {
  if (this.getter == null) {
    if (this._overriddenField != null) {
      return this._overriddenField._get(context, node, target, isDynamic);
    }
    return target.invokeNoSuchMethod(context, ('get:' + this.name), node);
  }
  return this.getter.invoke(context, node, target, Arguments.get$EMPTY(), false);
}
PropertyMember.prototype._set = function(context, node, target, value, isDynamic) {
  if (this.setter == null) {
    if (this._overriddenField != null) {
      return this._overriddenField._set(context, node, target, value, isDynamic);
    }
    return target.invokeNoSuchMethod(context, ('set:' + this.name), node, new Arguments(null, [value]));
  }
  return this.setter.invoke(context, node, target, new Arguments(null, [value]), isDynamic);
}
PropertyMember.prototype.addFromParent = function(parentMember) {
  var $0;
  var parent;
  if ((parentMember instanceof ConcreteMember)) {
    var c = (parentMember == null ? null : parentMember.assert$ConcreteMember());
    parent = (($0 = c.baseMember) == null ? null : $0.assert$PropertyMember());
  }
  else {
    parent = (parentMember == null ? null : parentMember.assert$PropertyMember());
  }
  if (this.getter == null) this.getter = parent.getter;
  if (this.setter == null) this.setter = parent.setter;
}
PropertyMember.prototype.resolve = function() {
  if (this.getter != null) this.getter.resolve();
  if (this.setter != null) this.setter.resolve();
  this.get$library()._addMember(this);
}
PropertyMember.prototype._get$3 = function($0, $1, $2) {
  return this._get(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), false);
};
PropertyMember.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Value()), false);
};
PropertyMember.prototype.provideFieldSyntax$0 = PropertyMember.prototype.provideFieldSyntax;
PropertyMember.prototype.providePropertySyntax$0 = PropertyMember.prototype.providePropertySyntax;
PropertyMember.prototype.resolve$0 = PropertyMember.prototype.resolve;
// ********** Code for ConcreteMember **************
function ConcreteMember(name, declaringType, baseMember) {
  this.baseMember = baseMember;
  // Initializers done
  Member.call(this, name, declaringType);
  this.parameters = [];
  this.returnType = this.baseMember.get$returnType().resolveTypeParams(declaringType);
  var $list = this.baseMember.get$parameters();
  for (var $i = 0;$i < $list.length; $i++) {
    var p = $list.$index($i);
    var newType = p.get$type().resolveTypeParams$1(declaringType);
    if ($notnull_bool($ne(newType, p.get$type()))) {
      this.parameters.add(p.copyWithNewType$2(this, newType));
    }
    else {
      this.parameters.add(p);
    }
  }
}
$inherits(ConcreteMember, Member);
ConcreteMember.prototype.assert$ConcreteMember = function(){return this};
ConcreteMember.prototype.get$returnType = function() { return this.returnType; };
ConcreteMember.prototype.set$returnType = function(value) { return this.returnType = value; };
ConcreteMember.prototype.get$parameters = function() { return this.parameters; };
ConcreteMember.prototype.set$parameters = function(value) { return this.parameters = value; };
ConcreteMember.prototype.get$span = function() {
  return this.baseMember.get$span();
}
ConcreteMember.prototype.get$isStatic = function() {
  return this.baseMember.get$isStatic();
}
ConcreteMember.prototype.get$isAbstract = function() {
  return this.baseMember.get$isAbstract();
}
ConcreteMember.prototype.get$isConst = function() {
  return this.baseMember.get$isConst();
}
ConcreteMember.prototype.get$isFactory = function() {
  return this.baseMember.get$isFactory();
}
ConcreteMember.prototype.get$isFinal = function() {
  return this.baseMember.get$isFinal();
}
ConcreteMember.prototype.get$isNative = function() {
  return this.baseMember.get$isNative();
}
ConcreteMember.prototype.get$jsname = function() {
  return this.baseMember.get$jsname();
}
ConcreteMember.prototype.get$canGet = function() {
  return this.baseMember.get$canGet();
}
ConcreteMember.prototype.get$canSet = function() {
  return this.baseMember.get$canSet();
}
ConcreteMember.prototype.canInvoke = function(context, args) {
  return this.baseMember.canInvoke(context, args);
}
ConcreteMember.prototype.get$isField = function() {
  return this.baseMember.get$isField();
}
ConcreteMember.prototype.get$isMethod = function() {
  return this.baseMember.get$isMethod();
}
ConcreteMember.prototype.get$isProperty = function() {
  return this.baseMember.get$isProperty();
}
ConcreteMember.prototype.get$prefersPropertySyntax = function() {
  return this.baseMember.get$prefersPropertySyntax();
}
ConcreteMember.prototype.get$requiresFieldSyntax = function() {
  return this.baseMember.get$requiresFieldSyntax();
}
ConcreteMember.prototype.provideFieldSyntax = function() {
  return this.baseMember.provideFieldSyntax();
}
ConcreteMember.prototype.providePropertySyntax = function() {
  return this.baseMember.providePropertySyntax();
}
ConcreteMember.prototype.get$isConstructor = function() {
  return this.name == this.declaringType.name;
}
ConcreteMember.prototype.get$constructorName = function() {
  return this.baseMember.get$constructorName();
}
ConcreteMember.prototype.get$definition = function() {
  var $0;
  return (($0 = this.baseMember.get$definition()) == null ? null : $0.assert$Definition());
}
ConcreteMember.prototype.get$initDelegate = function() {
  return this.baseMember.get$initDelegate();
}
ConcreteMember.prototype.set$initDelegate = function(ctor) {
  this.baseMember.set$initDelegate(ctor);
}
ConcreteMember.prototype.resolveType = function(node, isRequired) {
  var $0;
  var type = this.baseMember.resolveType(node, isRequired);
  return (($0 = type.resolveTypeParams$1(this.declaringType)) == null ? null : $0.assert$lang_Type());
}
ConcreteMember.prototype.computeValue = function() {
  return this.baseMember.computeValue();
}
ConcreteMember.prototype.override = function(other) {
  return this.baseMember.override(other);
}
ConcreteMember.prototype._get = function(context, node, target, isDynamic) {
  var ret = this.baseMember._get(context, node, target, isDynamic);
  return new Value(this.get$inferredResult(), ret.code, node.span, true);
}
ConcreteMember.prototype._set = function(context, node, target, value, isDynamic) {
  var ret = this.baseMember._set(context, node, target, value, isDynamic);
  return new Value(this.returnType, ret.code, node.span, true);
}
ConcreteMember.prototype.invoke = function(context, node, target, args, isDynamic) {
  var ret = this.baseMember.invoke(context, node, target, args, isDynamic);
  var code = ret.code;
  if ($notnull_bool(this.get$isConstructor())) {
    code = code.replaceFirst$2(this.declaringType.get$genericType().get$jsname(), this.declaringType.get$jsname());
  }
  if ((this.baseMember instanceof MethodMember)) {
    this.declaringType.genMethod(this);
  }
  return new Value(this.get$inferredResult(), code, node.span, true);
}
ConcreteMember.prototype._get$3 = function($0, $1, $2) {
  return this._get(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), false);
};
ConcreteMember.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Value()), false);
};
ConcreteMember.prototype.canInvoke$2 = function($0, $1) {
  return this.canInvoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$Arguments()));
};
ConcreteMember.prototype.computeValue$0 = ConcreteMember.prototype.computeValue;
ConcreteMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), false);
};
ConcreteMember.prototype.invoke$4$isDynamic = function($0, $1, $2, $3, isDynamic) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool(isDynamic));
};
ConcreteMember.prototype.invoke$5 = function($0, $1, $2, $3, $4) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool($4));
};
ConcreteMember.prototype.provideFieldSyntax$0 = ConcreteMember.prototype.provideFieldSyntax;
ConcreteMember.prototype.providePropertySyntax$0 = ConcreteMember.prototype.providePropertySyntax;
// ********** Code for MethodMember **************
function MethodMember(name, declaringType, definition) {
  this.isStatic = false
  this.isAbstract = false
  this.isConst = false
  this.isFactory = false
  this.isLambda = false
  this._providePropertySyntax = false
  this._provideFieldSyntax = false
  this._provideOptionalParamInfo = false
  this.definition = definition;
  // Initializers done
  Member.call(this, name, declaringType);
}
$inherits(MethodMember, Member);
MethodMember.prototype.assert$MethodMember = function(){return this};
MethodMember.prototype.get$definition = function() { return this.definition; };
MethodMember.prototype.set$definition = function(value) { return this.definition = value; };
MethodMember.prototype.get$returnType = function() { return this.returnType; };
MethodMember.prototype.set$returnType = function(value) { return this.returnType = value; };
MethodMember.prototype.get$parameters = function() { return this.parameters; };
MethodMember.prototype.set$parameters = function(value) { return this.parameters = value; };
MethodMember.prototype.get$typeParameters = function() { return this.typeParameters; };
MethodMember.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
MethodMember.prototype.get$isStatic = function() { return this.isStatic; };
MethodMember.prototype.set$isStatic = function(value) { return this.isStatic = value; };
MethodMember.prototype.get$isAbstract = function() { return this.isAbstract; };
MethodMember.prototype.set$isAbstract = function(value) { return this.isAbstract = value; };
MethodMember.prototype.get$isConst = function() { return this.isConst; };
MethodMember.prototype.set$isConst = function(value) { return this.isConst = value; };
MethodMember.prototype.get$isFactory = function() { return this.isFactory; };
MethodMember.prototype.set$isFactory = function(value) { return this.isFactory = value; };
MethodMember.prototype.get$isLambda = function() { return this.isLambda; };
MethodMember.prototype.set$isLambda = function(value) { return this.isLambda = value; };
MethodMember.prototype.get$initDelegate = function() { return this.initDelegate; };
MethodMember.prototype.set$initDelegate = function(value) { return this.initDelegate = value; };
MethodMember.prototype.get$isConstructor = function() {
  return this.name == this.declaringType.name;
}
MethodMember.prototype.get$isMethod = function() {
  return !$notnull_bool(this.get$isConstructor());
}
MethodMember.prototype.get$isNative = function() {
  return this.definition.nativeBody != null;
}
MethodMember.prototype.get$canGet = function() {
  return false;
}
MethodMember.prototype.get$canSet = function() {
  return false;
}
MethodMember.prototype.get$span = function() {
  var $0;
  return (($0 = this.definition == null ? null : this.definition.span) == null ? null : $0.assert$SourceSpan());
}
MethodMember.prototype.get$constructorName = function() {
  var returnType = this.definition.returnType;
  if ($notnull_bool(returnType == null)) return '';
  if ((returnType instanceof GenericTypeReference)) {
    return '';
  }
  if ($notnull_bool($ne(returnType.get$names(), null))) {
    return $assert_String(returnType.get$names().$index(0).get$name());
  }
  else if ($notnull_bool($ne(returnType.get$name(), null))) {
    return $assert_String(returnType.get$name().get$name());
  }
  $globals.world.internalError('no valid constructor name', this.definition.span);
}
MethodMember.prototype.get$functionType = function() {
  if (this._functionType == null) {
    this._functionType = this.get$library().getOrAddFunctionType(this.declaringType, this.name, this.definition);
    if (this.parameters == null) {
      this.resolve();
    }
  }
  return this._functionType;
}
MethodMember.prototype.override = function(other) {
  if (!$notnull_bool(Member.prototype.override.call(this, other))) return false;
  if ($notnull_bool(other.get$isMethod())) {
    return true;
  }
  else {
    $globals.world.error('method can only override methods', this.get$span(), other.get$span());
    return false;
  }
}
MethodMember.prototype.canInvoke = function(context, args) {
  var bareCount = args.get$bareCount();
  if (bareCount > this.parameters.length) return false;
  if (bareCount == this.parameters.length) {
    if (bareCount != args.get$length()) return false;
  }
  else {
    if (!$notnull_bool(this.parameters.$index(bareCount).get$isOptional())) return false;
    for (var i = bareCount;
     i < args.get$length(); i++) {
      if (this.indexOfParameter(args.getName(i)) < 0) {
        return false;
      }
    }
  }
  return true;
}
MethodMember.prototype.indexOfParameter = function(name) {
  for (var i = 0;
   i < this.parameters.length; i++) {
    var p = this.parameters.$index(i);
    if ($notnull_bool(p.get$isOptional()) && $notnull_bool($eq(p.get$name(), name))) {
      return i;
    }
  }
  return -1;
}
MethodMember.prototype.get$prefersPropertySyntax = function() {
  return true;
}
MethodMember.prototype.get$requiresFieldSyntax = function() {
  return false;
}
MethodMember.prototype.provideFieldSyntax = function() {
  this._provideFieldSyntax = true;
}
MethodMember.prototype.providePropertySyntax = function() {
  this._providePropertySyntax = true;
}
MethodMember.prototype._set = function(context, node, target, value, isDynamic) {
  $globals.world.error('cannot set method', node.span);
}
MethodMember.prototype._get = function(context, node, target, isDynamic) {
  this.declaringType.genMethod(this);
  this._provideOptionalParamInfo = true;
  if ($notnull_bool(this.isStatic)) {
    this.declaringType.markUsed();
    var type = $notnull_bool(this.declaringType.get$isTop()) ? '' : ('' + this.declaringType.get$jsname() + '.');
    return new Value(this.get$functionType(), ('' + type + this.get$jsname()), node.span, true);
  }
  this._providePropertySyntax = true;
  return new Value(this.get$functionType(), ('' + target.code + '.get\$' + this.get$jsname() + '()'), node.span, true);
}
MethodMember.prototype.namesInOrder = function(args) {
  if (!$notnull_bool(args.get$hasNames())) return true;
  var lastParameter = null;
  for (var i = args.get$bareCount();
   i < this.parameters.length; i++) {
    var p = args.getIndexOfName($assert_String(this.parameters.$index(i).get$name()));
    if (p >= 0 && $notnull_bool(args.values.$index(p).get$needsTemp())) {
      if (lastParameter != null && lastParameter > $assert_num(p)) {
        return false;
      }
      lastParameter = $assert_num(p);
    }
  }
  return true;
}
MethodMember.prototype.needsArgumentConversion = function(args) {
  var bareCount = args.get$bareCount();
  for (var i = 0;
   i < bareCount; i++) {
    var arg = args.values.$index(i);
    if ($notnull_bool(arg.needsConversion$1(this.parameters.$index(i).get$type()))) {
      return true;
    }
  }
  if (bareCount < this.parameters.length) {
    this.genParameterValues();
    for (var i = bareCount;
     i < this.parameters.length; i++) {
      var arg = args.getValue($assert_String(this.parameters.$index(i).get$name()));
      if ($notnull_bool($ne(arg, null)) && $notnull_bool(arg.needsConversion$1(this.parameters.$index(i).get$type()))) {
        return true;
      }
    }
  }
  return false;
}
MethodMember._argCountMsg = function(actual, expected, atLeast) {
  return 'wrong number of arguments, expected ' + ('' + ($notnull_bool(atLeast) ? "at least " : "") + expected + ' but found ' + actual);
}
MethodMember.prototype._argError = function(context, node, target, args, msg) {
  if ($notnull_bool(this.isStatic) || $notnull_bool(this.get$isConstructor())) {
    $globals.world.error(msg, node.span);
  }
  else {
    $globals.world.warning(msg, node.span);
  }
  return target.invokeNoSuchMethod(context, this.name, node, args);
}
MethodMember.prototype.genParameterValues = function() {
  var $list = this.parameters;
  for (var $i = 0;$i < $list.length; $i++) {
    var p = $list.$index($i);
    p.genValue$2(this, this.generator);
  }
}
MethodMember.prototype.invoke = function(context, node, target, args, isDynamic) {
  var $0;
  if (this.parameters == null) {
    $globals.world.info(('surprised to need to resolve: ' + this.declaringType.name + '.' + this.name));
    this.resolve();
  }
  this.declaringType.genMethod(this);
  if ($notnull_bool(this.isStatic) || $notnull_bool(this.isFactory)) {
    this.declaringType.markUsed();
  }
  if ($notnull_bool(this.get$isNative()) && this.returnType != null) this.returnType.markUsed();
  if (!$notnull_bool(this.namesInOrder(args))) {
    return context.findMembers(this.name).invokeOnVar(context, node, target, args);
  }
  var argsCode = [];
  if (!$notnull_bool(target.isType) && ($notnull_bool(this.get$isConstructor()) || $notnull_bool(target.isSuper))) {
    argsCode.add$1('this');
  }
  var bareCount = args.get$bareCount();
  for (var i = 0;
   i < bareCount; i++) {
    var arg = args.values.$index(i);
    if (i >= this.parameters.length) {
      var msg = MethodMember._argCountMsg(args.get$length(), this.parameters.length, false);
      return this._argError(context, node, target, args, $assert_String(msg));
    }
    arg = arg.convertTo$4(context, this.parameters.$index(i).get$type(), node, isDynamic);
    if ($notnull_bool(this.isConst) && $notnull_bool(arg.get$isConst())) {
      argsCode.add$1(arg.get$canonicalCode());
    }
    else {
      argsCode.add$1(arg.get$code());
    }
  }
  if (bareCount < this.parameters.length) {
    this.genParameterValues();
    var namedArgsUsed = 0;
    for (var i = bareCount;
     i < this.parameters.length; i++) {
      var arg = args.getValue($assert_String(this.parameters.$index(i).get$name()));
      if ($notnull_bool(arg == null)) {
        arg = this.parameters.$index(i).get$value();
      }
      else {
        arg = arg.convertTo$4(context, this.parameters.$index(i).get$type(), node, isDynamic);
        namedArgsUsed++;
      }
      if ($notnull_bool(arg == null) || !$notnull_bool(this.parameters.$index(i).get$isOptional())) {
        var msg = MethodMember._argCountMsg(Math.min(i, args.get$length()), i + 1, true);
        return this._argError(context, node, target, args, $assert_String(msg));
      }
      else {
        argsCode.add$1($notnull_bool(this.isConst) && $notnull_bool(arg.get$isConst()) ? arg.get$canonicalCode() : arg.get$code());
      }
    }
    if (namedArgsUsed < args.get$nameCount()) {
      var seen = new HashSetImplementation();
      for (var i = bareCount;
       i < args.get$length(); i++) {
        var name = args.getName(i);
        if ($notnull_bool(seen.contains$1(name))) {
          return this._argError(context, node, target, args, ('duplicate argument "' + name + '"'));
        }
        seen.add$1(name);
        var p = this.indexOfParameter($assert_String(name));
        if (p < 0) {
          return this._argError(context, node, target, args, ('method does not have optional parameter "' + name + '"'));
        }
        else if (p < bareCount) {
          return this._argError(context, node, target, args, ('argument "' + name + '" passed as positional and named'));
        }
      }
      $globals.world.internalError(('wrong named arguments calling ' + this.name), node.span);
    }
    Arguments.removeTrailingNulls((argsCode == null ? null : argsCode.assert$List_Value()));
  }
  var argsString = Strings.join((argsCode == null ? null : argsCode.assert$List_String()), ', ');
  if ($notnull_bool(this.get$isConstructor())) {
    return this._invokeConstructor(context, node, target, args, argsString);
  }
  if ($notnull_bool(target.isSuper)) {
    return new Value(this.get$inferredResult(), ('' + this.declaringType.get$jsname() + '.prototype.' + this.get$jsname() + '.call(' + argsString + ')'), node.span, true);
  }
  if ($notnull_bool(this.get$isOperator())) {
    return this._invokeBuiltin(context, node, target, args, argsCode, isDynamic);
  }
  if ($notnull_bool(this.isFactory)) {
    $assert(target.isType, "target.isType", "member.dart", 946, 14);
    return new Value(target.type, ('' + this.get$generatedFactoryName() + '(' + argsString + ')'), node.span, true);
  }
  if ($notnull_bool(this.isStatic)) {
    if ($notnull_bool(this.declaringType.get$isTop())) {
      return new Value(this.get$inferredResult(), ('' + this.get$jsname() + '(' + argsString + ')'), node != null ? node.span : node, true);
    }
    return new Value(this.get$inferredResult(), ('' + this.declaringType.get$jsname() + '.' + this.get$jsname() + '(' + argsString + ')'), node.span, true);
  }
  var code = ('' + target.code + '.' + this.get$jsname() + '(' + argsString + ')');
  if ($notnull_bool(target.get$isConst())) {
    if ((target instanceof GlobalValue)) {
      target = (($0 = target.get$dynamic().get$exp()) == null ? null : $0.assert$Value());
    }
    if (this.name == 'get\$length') {
      if ((target instanceof ConstListValue) || (target instanceof ConstMapValue)) {
        code = ('' + target.get$dynamic().get$values().length);
      }
    }
    else if (this.name == 'isEmpty') {
      if ((target instanceof ConstListValue) || (target instanceof ConstMapValue)) {
        code = ('' + target.get$dynamic().get$values().isEmpty$0());
      }
    }
  }
  if (this.name == 'get\$typeName' && $eq(this.declaringType.get$library(), $globals.world.get$dom())) {
    $globals.world.gen.corejs.ensureTypeNameOf();
  }
  return new Value(this.get$inferredResult(), code, node.span, true);
}
MethodMember.prototype._invokeConstructor = function(context, node, target, args, argsString) {
  this.declaringType.markUsed();
  if (!$notnull_bool(target.isType)) {
    var code = (this.get$constructorName() != '') ? ('' + this.declaringType.get$jsname() + '.' + this.get$constructorName() + '\$ctor.call(' + argsString + ')') : ('' + this.declaringType.get$jsname() + '.call(' + argsString + ')');
    return new Value(target.type, code, node.span, true);
  }
  else {
    var code = (this.get$constructorName() != '') ? ('new ' + this.declaringType.get$jsname() + '.' + this.get$constructorName() + '\$ctor(' + argsString + ')') : ('new ' + this.declaringType.get$jsname() + '(' + argsString + ')');
    if ($notnull_bool(this.isConst) && (node instanceof lang_NewExpression) && $notnull_bool(node.get$dynamic().get$isConst())) {
      return this._invokeConstConstructor(node, $assert_String(code), target, args);
    }
    else {
      return new Value(target.type, code, node.span, true);
    }
  }
}
MethodMember.prototype._invokeConstConstructor = function(node, code, target, args) {
  var $0;
  var fields = new HashMapImplementation();
  for (var i = 0;
   i < this.parameters.length; i++) {
    var param = this.parameters.$index(i);
    if ($notnull_bool(param.get$isInitializer())) {
      var value = null;
      if (i < args.get$length()) {
        value = args.values.$index(i);
      }
      else {
        value = args.getValue($assert_String(param.get$name()));
        if ($notnull_bool(value == null)) {
          value = param.get$value();
        }
      }
      fields.$setindex(param.get$name(), value);
    }
  }
  if (this.definition.initializers != null) {
    this.generator._pushBlock(false);
    for (var j = 0;
     j < this.definition.formals.length; j++) {
      var name = this.definition.formals.$index(j).get$name().get$name();
      var value = null;
      if (j < args.get$length()) {
        value = args.values.$index(j);
      }
      else {
        value = args.getValue($assert_String(this.parameters.$index(j).get$name()));
        if ($notnull_bool(value == null)) {
          value = this.parameters.$index(j).get$value();
        }
      }
      this.generator._scope._vars.$setindex(name, value);
    }
    var $list = this.definition.initializers;
    for (var $i = 0;$i < $list.length; $i++) {
      var init = $list.$index($i);
      if ((init instanceof CallExpression)) {
        var delegateArgs = this.generator._makeArgs((($0 = init.get$arguments()) == null ? null : $0.assert$List_ArgumentNode()));
        var value = this.initDelegate.invoke(this.generator, node, target, (delegateArgs == null ? null : delegateArgs.assert$Arguments()), false);
        if ((init.get$target() instanceof ThisExpression)) {
          return (value == null ? null : value.assert$Value());
        }
        else {
          if ((value instanceof GlobalValue)) {
            value = value.get$exp();
          }
          var $list0 = value.get$fields().getKeys$0();
          for (var $i0 = value.get$fields().getKeys$0().iterator$0(); $i0.hasNext$0(); ) {
            var fname = $i0.next$0();
            fields.$setindex(fname, value.get$fields().$index(fname));
          }
        }
      }
      else {
        var assign = (init == null ? null : init.assert$BinaryExpression());
        var x = assign.x;
        var fname = x.get$name().get$name();
        var val = this.generator.visitValue(assign.y);
        fields.$setindex(fname, val);
      }
    }
    this.generator._popBlock();
  }
  var $list = this.declaringType.get$members().getValues();
  for (var $i = this.declaringType.get$members().getValues().iterator$0(); $i.hasNext$0(); ) {
    var f = $i.next$0();
    if ((f instanceof FieldMember) && !$notnull_bool(f.get$isStatic()) && $notnull_bool($ne(f.get$value(), null)) && !fields.containsKey(f.get$name())) {
      fields.$setindex(f.get$name(), f.computeValue$0());
    }
  }
  return $globals.world.gen.globalForConst(ConstObjectValue.ConstObjectValue$factory(target.type, fields, code, node.span), args.values);
}
MethodMember.prototype._invokeBuiltin = function(context, node, target, args, argsCode, isDynamic) {
  var $0;
  var allConst = $notnull_bool(target.get$isConst()) && args.values.every((function (arg) {
    return arg.get$isConst();
  })
  );
  if ($notnull_bool(this.declaringType.get$isNum())) {
    if (!$notnull_bool(allConst)) {
      var code;
      if (this.name == '\$negate') {
        code = ('-' + target.code);
      }
      else if (this.name == '\$bit_not') {
        code = ('~' + target.code);
      }
      else if (this.name == '\$truncdiv' || this.name == '\$mod') {
        $globals.world.gen.corejs.useOperator(this.name);
        code = ('' + this.name + '(' + target.code + ', ' + argsCode.$index(0) + ')');
      }
      else {
        var op = TokenKind.rawOperatorFromMethod(this.name);
        code = ('' + target.code + ' ' + op + ' ' + argsCode.$index(0));
      }
      return new Value(this.get$inferredResult(), code, node.span, true);
    }
    else {
      var value;
      var val0, val1, ival0, ival1;
      val0 = $assert_num(target.get$dynamic().get$actualValue());
      ival0 = val0.toInt();
      if (args.values.length > 0) {
        val1 = $assert_num(args.values.$index(0).get$dynamic().get$actualValue());
        ival1 = val1.toInt();
      }
      switch (this.name) {
        case '\$negate':

          value = -val0;
          break;

        case '\$add':

          value = val0 + val1;
          break;

        case '\$sub':

          value = val0 - val1;
          break;

        case '\$mul':

          value = val0 * val1;
          break;

        case '\$div':

          value = val0 / val1;
          break;

        case '\$truncdiv':

          value = $truncdiv(val0, val1);
          break;

        case '\$mod':

          value = $mod(val0, val1);
          break;

        case '\$eq':

          value = val0 == val1;
          break;

        case '\$lt':

          value = val0 < val1;
          break;

        case '\$gt':

          value = val0 > val1;
          break;

        case '\$lte':

          value = val0 <= val1;
          break;

        case '\$gte':

          value = val0 >= val1;
          break;

        case '\$ne':

          value = val0 != val1;
          break;

        case '\$bit_not':

          value = (~ival0).toDouble();
          break;

        case '\$bit_or':

          value = (ival0 | ival1).toDouble();
          break;

        case '\$bit_xor':

          value = (ival0 ^ ival1).toDouble();
          break;

        case '\$bit_and':

          value = (ival0 & ival1).toDouble();
          break;

        case '\$shl':

          value = (ival0 << ival1).toDouble();
          break;

        case '\$sar':

          value = (ival0 >> ival1).toDouble();
          break;

        case '\$shr':

          value = (ival0 >>> ival1).toDouble();
          break;

      }
      return EvaluatedValue.EvaluatedValue$factory(this.get$inferredResult(), value, ("" + value), node.span);
    }
  }
  else if ($notnull_bool(this.declaringType.get$isString())) {
    if (this.name == '\$index') {
      return new Value(this.declaringType, ('' + target.code + '[' + argsCode.$index(0) + ']'), node.span, true);
    }
    else if (this.name == '\$add') {
      if ($notnull_bool(allConst)) {
        var value = this._normConcat(target, (($0 = args.values.$index(0)) == null ? null : $0.assert$Value()));
        return EvaluatedValue.EvaluatedValue$factory($globals.world.stringType, value, value, node.span);
      }
      return new Value(this.declaringType, ('' + target.code + ' + ' + argsCode.$index(0)), node.span, true);
    }
  }
  else if ($notnull_bool(this.declaringType.get$isNative())) {
    if (this.name == '\$index') {
      return new Value(this.returnType, ('' + target.code + '[' + argsCode.$index(0) + ']'), node.span, true);
    }
    else if (this.name == '\$setindex') {
      return new Value(this.returnType, ('' + target.code + '[' + argsCode.$index(0) + '] = ' + argsCode.$index(1)), node.span, true);
    }
  }
  if (this.name == '\$eq' || this.name == '\$ne') {
    var op = this.name == '\$eq' ? '==' : '!=';
    if (this.name == '\$ne') {
      target.invoke(context, '\$eq', node, args, isDynamic);
    }
    if ($notnull_bool(allConst)) {
      var val0 = target.get$dynamic().get$actualValue();
      var val1 = args.values.$index(0).get$dynamic().get$actualValue();
      var newVal = this.name == '\$eq' ? $eq(val0, val1) : $ne(val0, val1);
      return EvaluatedValue.EvaluatedValue$factory($globals.world.nonNullBool, newVal, ("" + newVal), node.span);
    }
    if ($notnull_bool($eq(argsCode.$index(0), 'null'))) {
      return new Value(this.get$inferredResult(), ('' + target.code + ' ' + op + ' null'), node.span, true);
    }
    else if ($notnull_bool(target.type.get$isNum()) || $notnull_bool(target.type.get$isString())) {
      return new Value(this.get$inferredResult(), ('' + target.code + ' ' + op + ' ' + argsCode.$index(0)), node.span, true);
    }
    $globals.world.gen.corejs.useOperator(this.name);
    return new Value(this.get$inferredResult(), ('' + this.name + '(' + target.code + ', ' + argsCode.$index(0) + ')'), node.span, true);
  }
  if ($notnull_bool(this.get$isCallMethod())) {
    this.declaringType.markUsed();
    return new Value(this.get$inferredResult(), ('' + target.code + '(' + Strings.join((argsCode == null ? null : argsCode.assert$List_String()), ", ") + ')'), node.span, true);
  }
  if (this.name == '\$index') {
    $globals.world.gen.corejs.useIndex = true;
  }
  else if (this.name == '\$setindex') {
    $globals.world.gen.corejs.useSetIndex = true;
  }
  var argsString = Strings.join((argsCode == null ? null : argsCode.assert$List_String()), ', ');
  return new Value(this.get$inferredResult(), ('' + target.code + '.' + this.get$jsname() + '(' + argsString + ')'), node.span, true);
}
MethodMember.prototype._normConcat = function(a, b) {
  $assert(b.type.get$isString(), "b.type.isString", "member.dart", 1250, 12);
  var val0 = a.get$dynamic().get$actualValue();
  var quote0 = val0.$index(0);
  val0 = val0.substring$2(1, val0.length - 1);
  var val1 = b.get$dynamic().get$actualValue();
  var quote1 = null;
  if ($notnull_bool(b.type.get$isString())) {
    quote1 = val1.$index(0);
    val1 = val1.substring$2(1, val1.length - 1);
  }
  var value;
  if ($notnull_bool($eq(quote0, quote1)) || $notnull_bool(quote1 == null)) {
    value = ('' + quote0 + val0 + val1 + quote0);
  }
  else if ($notnull_bool($eq(quote0, '"'))) {
    $assert($eq(quote1, "'"), "quote1 == \"'\"", "member.dart", 1268, 14);
    value = ('' + quote0 + val0 + toDoubleQuote($assert_String(val1)) + quote0);
  }
  else {
    $assert($eq(quote1, '"'), "quote1 == '\"'", "member.dart", 1271, 14);
    value = ('' + quote1 + toDoubleQuote($assert_String(val0)) + val1 + quote1);
  }
  return $assert_String(value);
}
MethodMember.prototype.resolve = function() {
  var $0;
  this.isStatic = this.declaringType.get$isTop();
  this.isConst = false;
  this.isFactory = false;
  this.isAbstract = !$notnull_bool(this.declaringType.get$isClass());
  if (this.definition.modifiers != null) {
    var $list = this.definition.modifiers;
    for (var $i = 0;$i < $list.length; $i++) {
      var mod = $list.$index($i);
      if ($notnull_bool($eq(mod.get$kind(), 86/*TokenKind.STATIC*/))) {
        if ($notnull_bool(this.isStatic)) {
          $globals.world.error('duplicate static modifier', (($0 = mod.get$span()) == null ? null : $0.assert$SourceSpan()));
        }
        this.isStatic = true;
      }
      else if ($notnull_bool(this.get$isConstructor()) && $notnull_bool($eq(mod.get$kind(), 91/*TokenKind.CONST*/))) {
        if ($notnull_bool(this.isConst)) {
          $globals.world.error('duplicate const modifier', (($0 = mod.get$span()) == null ? null : $0.assert$SourceSpan()));
        }
        this.isConst = true;
      }
      else if ($notnull_bool($eq(mod.get$kind(), 75/*TokenKind.FACTORY*/))) {
        if ($notnull_bool(this.isFactory)) {
          $globals.world.error('duplicate factory modifier', (($0 = mod.get$span()) == null ? null : $0.assert$SourceSpan()));
        }
        this.isFactory = true;
      }
      else if ($notnull_bool($eq(mod.get$kind(), 71/*TokenKind.ABSTRACT*/))) {
        if ($notnull_bool(this.isAbstract)) {
          if ($notnull_bool(this.declaringType.get$isClass())) {
            $globals.world.error('duplicate abstract modifier', (($0 = mod.get$span()) == null ? null : $0.assert$SourceSpan()));
          }
          else {
            $globals.world.error('abstract modifier not allowed on interface members', (($0 = mod.get$span()) == null ? null : $0.assert$SourceSpan()));
          }
        }
        this.isAbstract = true;
      }
      else {
        $globals.world.error(('' + mod + ' modifier not allowed on method'), (($0 = mod.get$span()) == null ? null : $0.assert$SourceSpan()));
      }
    }
  }
  if ($notnull_bool(this.isFactory)) {
    this.isStatic = true;
  }
  if (this.definition.typeParameters != null) {
    if (!$notnull_bool(this.isFactory)) {
      $globals.world.error('Only factories are allowed to have explicit type parameters', (($0 = this.definition.typeParameters.$index(0).get$span()) == null ? null : $0.assert$SourceSpan()));
    }
    else {
      this.typeParameters = this.definition.typeParameters;
      var $list = this.definition.typeParameters;
      for (var $i = 0;$i < $list.length; $i++) {
        var tp = $list.$index($i);
        tp.set$enclosingElement(this);
        tp.resolve$0();
      }
    }
  }
  if ($notnull_bool(this.get$isOperator()) && $notnull_bool(this.isStatic) && !$notnull_bool(this.get$isCallMethod())) {
    $globals.world.error(('operator method may not be static "' + this.name + '"'), this.get$span());
  }
  if ($notnull_bool(this.isAbstract)) {
    if (this.definition.body != null && !(this.declaringType.get$definition() instanceof FunctionTypeDefinition)) {
      $globals.world.error('abstract method can not have a body', this.get$span());
    }
    if ($notnull_bool(this.isStatic) && !(this.declaringType.get$definition() instanceof FunctionTypeDefinition)) {
      $globals.world.error('static method can not be abstract', this.get$span());
    }
  }
  else {
    if (this.definition.body == null && !$notnull_bool(this.get$isConstructor()) && !$notnull_bool(this.get$isNative())) {
      $globals.world.error('method needs a body', this.get$span());
    }
  }
  if ($notnull_bool(this.get$isConstructor()) && !$notnull_bool(this.isFactory)) {
    this.returnType = this.declaringType;
  }
  else {
    this.returnType = this.resolveType(this.definition.returnType, false);
  }
  this.parameters = [];
  var $list = this.definition.formals;
  for (var $i = 0;$i < $list.length; $i++) {
    var formal = $list.$index($i);
    var param = new Parameter(formal, this);
    param.resolve$0();
    this.parameters.add(param);
  }
  if (!$notnull_bool(this.isLambda)) {
    this.get$library()._addMember(this);
  }
}
MethodMember.prototype._get$3 = function($0, $1, $2) {
  return this._get(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), false);
};
MethodMember.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Value()), false);
};
MethodMember.prototype.canInvoke$2 = function($0, $1) {
  return this.canInvoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$Arguments()));
};
MethodMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), false);
};
MethodMember.prototype.invoke$4$isDynamic = function($0, $1, $2, $3, isDynamic) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool(isDynamic));
};
MethodMember.prototype.invoke$5 = function($0, $1, $2, $3, $4) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool($4));
};
MethodMember.prototype.namesInOrder$1 = function($0) {
  return this.namesInOrder(($0 == null ? null : $0.assert$Arguments()));
};
MethodMember.prototype.provideFieldSyntax$0 = MethodMember.prototype.provideFieldSyntax;
MethodMember.prototype.providePropertySyntax$0 = MethodMember.prototype.providePropertySyntax;
MethodMember.prototype.resolve$0 = MethodMember.prototype.resolve;
// ********** Code for MemberSet **************
function MemberSet(member, isVar) {
  this.name = member.name;
  this.members = [member];
  this.jsname = member.get$jsname();
  this.isVar = isVar;
  // Initializers done
}
MemberSet.prototype.assert$MemberSet = function(){return this};
MemberSet.prototype.get$name = function() { return this.name; };
MemberSet.prototype.get$members = function() { return this.members; };
MemberSet.prototype.get$jsname = function() { return this.jsname; };
MemberSet.prototype.get$isVar = function() { return this.isVar; };
MemberSet.prototype.toString = function() {
  return ('' + this.name + ':' + this.members.length);
}
MemberSet.prototype.get$containsMethods = function() {
  return this.members.some((function (m) {
    return (m instanceof MethodMember);
  })
  );
}
MemberSet.prototype.add = function(member) {
  return this.members.add(member);
}
MemberSet.prototype.get$isStatic = function() {
  return this.members.length == 1 && $notnull_bool(this.members.$index(0).get$isStatic());
}
MemberSet.prototype.get$isOperator = function() {
  return $assert_bool(this.members.$index(0).get$isOperator());
}
MemberSet.prototype.canInvoke = function(context, args) {
  return this.members.some((function (m) {
    return m.canInvoke$2(context, args);
  })
  );
}
MemberSet.prototype._makeError = function(node, target, action) {
  if (!$notnull_bool(target.type.get$isVar())) {
    $globals.world.warning(('could not find applicable ' + action + ' for "' + this.name + '"'), node.span);
  }
  return new Value($globals.world.varType, ('' + target.code + '.' + this.jsname + '() /*no applicable ' + action + '*/'), node.span, true);
}
MemberSet.prototype.get$treatAsField = function() {
  if (this._treatAsField == null) {
    this._treatAsField = !$notnull_bool(this.isVar);
    var $list = this.members;
    for (var $i = 0;$i < $list.length; $i++) {
      var member = $list.$index($i);
      if ($notnull_bool(member.get$requiresFieldSyntax())) {
        this._treatAsField = true;
        break;
      }
      if ($notnull_bool(member.get$prefersPropertySyntax())) {
        this._treatAsField = false;
      }
    }
    var $list = this.members;
    for (var $i = 0;$i < $list.length; $i++) {
      var member = $list.$index($i);
      if ($notnull_bool(this._treatAsField)) {
        member.provideFieldSyntax$0();
      }
      else {
        member.providePropertySyntax$0();
      }
    }
  }
  return this._treatAsField;
}
MemberSet.prototype._get = function(context, node, target, isDynamic) {
  var returnValue;
  var targets = this.members.filter((function (m) {
    return m.get$canGet();
  })
  );
  if ($notnull_bool(this.isVar)) {
    targets.forEach$1((function (m) {
      return m._get(context, node, target, true);
    })
    );
    returnValue = new Value(this._foldTypes((targets == null ? null : targets.assert$List_Member())), null, node.span, true);
  }
  else {
    if (this.members.length == 1) {
      return this.members.$index(0)._get(context, node, target, isDynamic);
    }
    else if ($notnull_bool($eq(targets.length, 1))) {
      return targets.$index(0)._get(context, node, target, isDynamic);
    }
    for (var $i = targets.iterator$0(); $i.hasNext$0(); ) {
      var member = $i.next$0();
      var value = member._get(context, node, target, true);
      returnValue = this._tryUnion(returnValue, value, node);
    }
    if (returnValue == null) {
      return this._makeError(node, target, 'getter');
    }
  }
  if (returnValue.code == null) {
    if ($notnull_bool(this.get$treatAsField())) {
      return new Value(returnValue.type, ('' + target.code + '.' + this.jsname), node.span, true);
    }
    else {
      return new Value(returnValue.type, ('' + target.code + '.get\$' + this.jsname + '()'), node.span, true);
    }
  }
  return returnValue;
}
MemberSet.prototype._set = function(context, node, target, value, isDynamic) {
  var returnValue;
  var targets = this.members.filter((function (m) {
    return m.get$canSet();
  })
  );
  if ($notnull_bool(this.isVar)) {
    targets.forEach$1((function (m) {
      return m._set(context, node, target, value, true);
    })
    );
    returnValue = new Value(this._foldTypes((targets == null ? null : targets.assert$List_Member())), null, node.span, true);
  }
  else {
    if (this.members.length == 1) {
      return this.members.$index(0)._set(context, node, target, value, isDynamic);
    }
    else if ($notnull_bool($eq(targets.length, 1))) {
      return targets.$index(0)._set(context, node, target, value, isDynamic);
    }
    for (var $i = targets.iterator$0(); $i.hasNext$0(); ) {
      var member = $i.next$0();
      var res = member._set(context, node, target, value, true);
      returnValue = this._tryUnion(returnValue, res, node);
    }
    if (returnValue == null) {
      return this._makeError(node, target, 'setter');
    }
  }
  if (returnValue.code == null) {
    if ($notnull_bool(this.get$treatAsField())) {
      return new Value(returnValue.type, ('' + target.code + '.' + this.jsname + ' = ' + value.code), node.span, true);
    }
    else {
      return new Value(returnValue.type, ('' + target.code + '.set\$' + this.jsname + '(' + value.code + ')'), node.span, true);
    }
  }
  return returnValue;
}
MemberSet.prototype.invoke = function(context, node, target, args, isDynamic) {
  var $0;
  if ($notnull_bool(this.isVar) && !$notnull_bool(this.get$isOperator())) {
    return this.invokeOnVar(context, node, target, args);
  }
  if (this.members.length == 1) {
    return (($0 = this.members.$index(0).invoke$5(context, node, target, args, isDynamic)) == null ? null : $0.assert$Value());
  }
  var targets = this.members.filter((function (m) {
    return m.canInvoke$2(context, args);
  })
  );
  if ($notnull_bool($eq(targets.length, 1))) {
    return (($0 = targets.$index(0).invoke$5(context, node, target, args, isDynamic)) == null ? null : $0.assert$Value());
  }
  var returnValue = null;
  for (var $i = targets.iterator$0(); $i.hasNext$0(); ) {
    var member = $i.next$0();
    var res = member.invoke$4$isDynamic(context, node, target, args, true);
    returnValue = this._tryUnion(returnValue, (res == null ? null : res.assert$Value()), node);
  }
  if (returnValue == null) {
    return this._makeError(node, target, 'method');
  }
  if (returnValue.code == null) {
    if (this.name == '\$call') {
      return target._varCall(context, args);
    }
    else if ($notnull_bool(this.get$isOperator())) {
      return target.invokeSpecial(this.name, args, returnValue.type);
    }
    else {
      return this.invokeOnVar(context, node, target, args);
    }
  }
  return returnValue;
}
MemberSet.prototype.invokeOnVar = function(context, node, target, args) {
  var $0;
  var member = this.getVarMember(context, node, args);
  return (($0 = member.invoke$4(context, node, target, args)) == null ? null : $0.assert$Value());
}
MemberSet.prototype._tryUnion = function(x, y, node) {
  if (x == null) return y;
  var type = lang_Type.union(x.type, y.type);
  if (x.code == y.code) {
    if ($notnull_bool($eq(type, x.type))) {
      return x;
    }
    else if ($notnull_bool(x.get$isConst()) || $notnull_bool(y.get$isConst())) {
      $globals.world.internalError("unexpected: union of const values ");
    }
    else {
      var ret = new Value(type, x.code, node.span, true);
      ret.set$isSuper($notnull_bool(x.isSuper) && $notnull_bool(y.isSuper));
      ret.set$needsTemp($notnull_bool(x.needsTemp) || $notnull_bool(y.needsTemp));
      ret.set$isType($notnull_bool(x.isType) && $notnull_bool(y.isType));
      return (ret == null ? null : ret.assert$Value());
    }
  }
  else {
    return new Value(type, null, node.span, true);
  }
}
MemberSet.prototype.getVarMember = function(context, node, args) {
  if ($globals.world.objectType.varStubs == null) {
    $globals.world.objectType.varStubs = $map([]);
  }
  var stubName = _getCallStubName(this.name, args);
  var stub = $globals.world.objectType.varStubs.$index(stubName);
  if ($notnull_bool(stub == null)) {
    var mset = context.findMembers(this.name).members;
    var targets = mset.filter((function (m) {
      return m.canInvoke$2(context, args);
    })
    );
    stub = new VarMethodSet($assert_String(stubName), targets, args, this._foldTypes((targets == null ? null : targets.assert$List_Member())));
    $globals.world.objectType.varStubs.$setindex(stubName, stub);
  }
  return (stub == null ? null : stub.assert$VarMember());
}
MemberSet.prototype._foldTypes = function(targets) {
  var $0;
  return (($0 = reduce(map(targets, (function (t) {
    return t.get$returnType();
  })
  ), lang_Type.union, $globals.world.varType)) == null ? null : $0.assert$lang_Type());
}
MemberSet.prototype._get$3 = function($0, $1, $2) {
  return this._get(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), false);
};
MemberSet.prototype._set$4 = function($0, $1, $2, $3) {
  return this._set(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Value()), false);
};
MemberSet.prototype.add$1 = function($0) {
  return this.add(($0 == null ? null : $0.assert$Member()));
};
MemberSet.prototype.canInvoke$2 = function($0, $1) {
  return this.canInvoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$Arguments()));
};
MemberSet.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), false);
};
MemberSet.prototype.invoke$4$isDynamic = function($0, $1, $2, $3, isDynamic) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool(isDynamic));
};
MemberSet.prototype.invoke$5 = function($0, $1, $2, $3, $4) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool($4));
};
MemberSet.prototype.toString$0 = MemberSet.prototype.toString;
// ********** Code for FactoryMap **************
function FactoryMap() {
  this.factories = $map([]);
  // Initializers done
}
FactoryMap.prototype.getFactoriesFor = function(typeName) {
  var ret = this.factories.$index(typeName);
  if ($notnull_bool(ret == null)) {
    ret = $map([]);
    this.factories.$setindex(typeName, ret);
  }
  return (ret == null ? null : ret.assert$Map_String$Member());
}
FactoryMap.prototype.addFactory = function(typeName, name, member) {
  this.getFactoriesFor(typeName).$setindex(name, member);
}
FactoryMap.prototype.getFactory = function(typeName, name) {
  var $0;
  return (($0 = this.getFactoriesFor(typeName).$index(name)) == null ? null : $0.assert$Member());
}
FactoryMap.prototype.forEach = function(f) {
  this.factories.forEach((function (_, constructors) {
    constructors.forEach((function (_, member) {
      f(member);
    })
    );
  })
  );
}
FactoryMap.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$1($0));
};
FactoryMap.prototype.getFactory$2 = function($0, $1) {
  return this.getFactory($assert_String($0), $assert_String($1));
};
// ********** Code for lang_Token **************
function lang_Token(kind, source, start, end) {
  this.kind = kind;
  this.source = source;
  this.start = start;
  this.end = end;
  // Initializers done
}
lang_Token.prototype.assert$lang_Token = function(){return this};
lang_Token.prototype.get$kind = function() { return this.kind; };
lang_Token.prototype.get$source = function() { return this.source; };
lang_Token.prototype.get$end = function() { return this.end; };
lang_Token.prototype.get$start = function() { return this.start; };
lang_Token.prototype.get$text = function() {
  return this.source.get$text().substring(this.start, this.end);
}
lang_Token.prototype.toString = function() {
  var kindText = TokenKind.kindToString(this.kind);
  var actualText = this.get$text();
  if ($notnull_bool($ne(kindText, actualText))) {
    if (actualText.length > 10) {
      actualText = $add(actualText.substring$2(0, 8), '...');
    }
    return ('' + kindText + '(' + actualText + ')');
  }
  else {
    return $assert_String(kindText);
  }
}
lang_Token.prototype.get$span = function() {
  return new SourceSpan(this.source, this.start, this.end);
}
lang_Token.prototype.toString$0 = lang_Token.prototype.toString;
// ********** Code for SourceFile **************
function SourceFile(filename, _text) {
  this.filename = filename;
  this._text = _text;
  // Initializers done
}
SourceFile.prototype.assert$SourceFile = function(){return this};
SourceFile.prototype.assert$Comparable = function(){return this};
SourceFile.prototype.get$filename = function() { return this.filename; };
SourceFile.prototype.get$orderInLibrary = function() { return this.orderInLibrary; };
SourceFile.prototype.set$orderInLibrary = function(value) { return this.orderInLibrary = value; };
SourceFile.prototype.get$text = function() {
  return this._text;
}
SourceFile.prototype.get$lineStarts = function() {
  if (this._lineStarts == null) {
    var starts = [0];
    var index = 0;
    while (index < this.get$text().length) {
      index = this.get$text().indexOf('\n', $assert_num(index)) + 1;
      if (index <= 0) break;
      starts.add$1(index);
    }
    starts.add$1(this.get$text().length + 1);
    this._lineStarts = (starts == null ? null : starts.assert$List_int());
  }
  return this._lineStarts;
}
SourceFile.prototype.getLine = function(position) {
  var starts = this.get$lineStarts();
  for (var i = 0;
   i < $assert_num(starts.length); i++) {
    if (starts.$index(i) > position) return i - 1;
  }
  $globals.world.internalError('bad position');
}
SourceFile.prototype.getColumn = function(line, position) {
  return position - $assert_num(this.get$lineStarts().$index(line));
}
SourceFile.prototype.getLocationMessage = function(message, start, end, includeText) {
  var line = this.getLine(start);
  var column = this.getColumn($assert_num(line), start);
  var buf = new StringBufferImpl(('' + this.filename + ':' + (line + 1) + ':' + (column + 1) + ': ' + message));
  if ($notnull_bool(includeText)) {
    buf.add$1('\n');
    var textLine;
    if ((line + 2) < this._lineStarts.length) {
      textLine = this.get$text().substring($assert_num(this._lineStarts.$index(line)), $assert_num(this._lineStarts.$index(line + 1)));
    }
    else {
      textLine = this.get$text().substring($assert_num(this._lineStarts.$index(line))) + '\n';
    }
    buf.add$1(textLine);
    var i = 0;
    for (; i < $assert_num(column); i++) {
      buf.add$1(' ');
    }
    var toColumn = Math.min($assert_num(column + (end - start)), $assert_num(textLine.length));
    for (; i < toColumn; i++) {
      buf.add$1('^');
    }
  }
  return buf.toString$0();
}
SourceFile.prototype.compareTo = function(other) {
  if (this.orderInLibrary != null && other.orderInLibrary != null) {
    return this.orderInLibrary - other.orderInLibrary;
  }
  else {
    return this.filename.compareTo(other.filename);
  }
}
SourceFile.prototype.compareTo$1 = function($0) {
  return this.compareTo(($0 == null ? null : $0.assert$SourceFile()));
};
SourceFile.prototype.getColumn$2 = function($0, $1) {
  return this.getColumn($assert_num($0), $assert_num($1));
};
SourceFile.prototype.getLine$1 = function($0) {
  return this.getLine($assert_num($0));
};
SourceFile.prototype.getLocationMessage$4 = function($0, $1, $2, $3) {
  return this.getLocationMessage($assert_String($0), $assert_num($1), $assert_num($2), $assert_bool($3));
};
// ********** Code for SourceSpan **************
function SourceSpan(file, start, end) {
  this.file = file;
  this.start = start;
  this.end = end;
  // Initializers done
}
SourceSpan.prototype.assert$SourceSpan = function(){return this};
SourceSpan.prototype.assert$Comparable = function(){return this};
SourceSpan.prototype.get$file = function() { return this.file; };
SourceSpan.prototype.get$start = function() { return this.start; };
SourceSpan.prototype.get$end = function() { return this.end; };
SourceSpan.prototype.get$text = function() {
  return this.file.get$text().substring(this.start, this.end);
}
SourceSpan.prototype.toMessageString = function(message) {
  return this.file.getLocationMessage(message, this.start, this.end, true);
}
SourceSpan.prototype.get$locationText = function() {
  var line = this.file.getLine(this.start);
  var column = this.file.getColumn($assert_num(line), this.start);
  return ('' + this.file.filename + ':' + (line + 1) + ':' + (column + 1));
}
SourceSpan.prototype.compareTo = function(other) {
  if ($eq(this.file, other.file)) {
    var d = this.start - other.start;
    return d == 0 ? (this.end - other.end) : d;
  }
  return this.file.compareTo(other.file);
}
SourceSpan.prototype.compareTo$1 = function($0) {
  return this.compareTo(($0 == null ? null : $0.assert$SourceSpan()));
};
SourceSpan.prototype.toMessageString$1 = function($0) {
  return this.toMessageString($assert_String($0));
};
// ********** Code for InterpStack **************
function InterpStack(previous, quote, isMultiline) {
  this.previous = previous;
  this.quote = quote;
  this.isMultiline = isMultiline;
  this.depth = -1;
  // Initializers done
}
InterpStack.prototype.assert$InterpStack = function(){return this};
InterpStack.prototype.get$previous = function() { return this.previous; };
InterpStack.prototype.set$previous = function(value) { return this.previous = value; };
InterpStack.prototype.get$quote = function() { return this.quote; };
InterpStack.prototype.get$isMultiline = function() { return this.isMultiline; };
InterpStack.prototype.get$depth = function() { return this.depth; };
InterpStack.prototype.set$depth = function(value) { return this.depth = value; };
InterpStack.prototype.pop = function() {
  return this.previous;
}
InterpStack.push = function(stack, quote, isMultiline) {
  var newStack = new InterpStack(stack, quote, isMultiline);
  if (stack != null) newStack.set$previous(stack);
  return (newStack == null ? null : newStack.assert$InterpStack());
}
InterpStack.prototype.next$0 = function() {
  return this.next();
};
// ********** Code for TokenizerBase **************
function TokenizerBase(_source, _skipWhitespace, index) {
  this._source = _source;
  this._skipWhitespace = _skipWhitespace;
  this._lang_index = index;
  // Initializers done
  TokenizerHelpers.call(this);
  this._text = this._source.get$text();
}
$inherits(TokenizerBase, TokenizerHelpers);
TokenizerBase.prototype._nextChar = function() {
  if (this._lang_index < this._text.length) {
    return this._text.charCodeAt(this._lang_index++);
  }
  else {
    return 0;
  }
}
TokenizerBase.prototype._peekChar = function() {
  if (this._lang_index < this._text.length) {
    return this._text.charCodeAt(this._lang_index);
  }
  else {
    return 0;
  }
}
TokenizerBase.prototype._maybeEatChar = function(ch) {
  if (this._lang_index < this._text.length) {
    if (this._text.charCodeAt(this._lang_index) == ch) {
      this._lang_index++;
      return true;
    }
    else {
      return false;
    }
  }
  else {
    return false;
  }
}
TokenizerBase.prototype._finishToken = function(kind) {
  return new lang_Token(kind, this._source, this._startIndex, this._lang_index);
}
TokenizerBase.prototype._errorToken = function() {
  return this._finishToken(65/*TokenKind.ERROR*/);
}
TokenizerBase.prototype.finishWhitespace = function() {
  this._lang_index--;
  while (this._lang_index < this._text.length) {
    var ch = this._text.charCodeAt(this._lang_index++);
    if (ch == 32 || ch == 9 || ch == 13) {
    }
    else if (ch == 10) {
      if (!$notnull_bool(this._skipWhitespace)) {
        return this._finishToken(63/*TokenKind.WHITESPACE*/);
      }
    }
    else {
      this._lang_index--;
      if ($notnull_bool(this._skipWhitespace)) {
        return this.next();
      }
      else {
        return this._finishToken(63/*TokenKind.WHITESPACE*/);
      }
    }
  }
  return this._finishToken(1/*TokenKind.END_OF_FILE*/);
}
TokenizerBase.prototype.finishHashBang = function() {
  while (true) {
    var ch = this._nextChar();
    if (ch == 0 || ch == 10 || ch == 13) {
      return this._finishToken(13/*TokenKind.HASHBANG*/);
    }
  }
}
TokenizerBase.prototype.finishSingleLineComment = function() {
  while (true) {
    var ch = this._nextChar();
    if (ch == 0 || ch == 10 || ch == 13) {
      if ($notnull_bool(this._skipWhitespace)) {
        return this.next();
      }
      else {
        return this._finishToken(64/*TokenKind.COMMENT*/);
      }
    }
  }
}
TokenizerBase.prototype.finishMultiLineComment = function() {
  while (true) {
    var ch = this._nextChar();
    if (ch == 0) {
      return this._finishToken(67/*TokenKind.INCOMPLETE_COMMENT*/);
    }
    else if (ch == 42) {
      if ($notnull_bool(this._maybeEatChar(47))) {
        if ($notnull_bool(this._skipWhitespace)) {
          return this.next();
        }
        else {
          return this._finishToken(64/*TokenKind.COMMENT*/);
        }
      }
    }
  }
  return this._errorToken();
}
TokenizerBase.prototype.eatDigits = function() {
  while (this._lang_index < this._text.length) {
    if ($notnull_bool(TokenizerHelpers.isDigit(this._text.charCodeAt(this._lang_index)))) {
      this._lang_index++;
    }
    else {
      return;
    }
  }
}
TokenizerBase.prototype.eatHexDigits = function() {
  while (this._lang_index < this._text.length) {
    if ($notnull_bool(TokenizerHelpers.isHexDigit(this._text.charCodeAt(this._lang_index)))) {
      this._lang_index++;
    }
    else {
      return;
    }
  }
}
TokenizerBase.prototype.maybeEatHexDigit = function() {
  if (this._lang_index < this._text.length && $notnull_bool(TokenizerHelpers.isHexDigit(this._text.charCodeAt(this._lang_index)))) {
    this._lang_index++;
    return true;
  }
  return false;
}
TokenizerBase.prototype.finishHex = function() {
  this.eatHexDigits();
  return this._finishToken(61/*TokenKind.HEX_INTEGER*/);
}
TokenizerBase.prototype.finishNumber = function() {
  this.eatDigits();
  if (this._peekChar() == 46) {
    this._nextChar();
    if ($notnull_bool(TokenizerHelpers.isDigit(this._peekChar()))) {
      this.eatDigits();
      return this.finishNumberExtra(62/*TokenKind.DOUBLE*/);
    }
    else {
      this._lang_index--;
    }
  }
  return this.finishNumberExtra(60/*TokenKind.INTEGER*/);
}
TokenizerBase.prototype.finishNumberExtra = function(kind) {
  if ($notnull_bool(this._maybeEatChar(101)) || $notnull_bool(this._maybeEatChar(69))) {
    kind = 62/*TokenKind.DOUBLE*/;
    this._maybeEatChar(45);
    this._maybeEatChar(43);
    this.eatDigits();
  }
  if (this._peekChar() != 0 && $notnull_bool(TokenizerHelpers.isIdentifierStart(this._peekChar()))) {
    this._nextChar();
    return this._errorToken();
  }
  return this._finishToken(kind);
}
TokenizerBase.prototype.finishMultilineString = function(quote) {
  while (true) {
    var ch = this._nextChar();
    if (ch == 0) {
      var kind = quote == 34 ? 68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/ : 69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/;
      return this._finishToken(kind);
    }
    else if (ch == quote) {
      if ($notnull_bool(this._maybeEatChar(quote))) {
        if ($notnull_bool(this._maybeEatChar(quote))) {
          return this._finishToken(58/*TokenKind.STRING*/);
        }
      }
    }
    else if (ch == 36) {
      this._interpStack = InterpStack.push(this._interpStack, quote, true);
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
    else if (ch == 92) {
      if (!$notnull_bool(this.eatEscapeSequence())) {
        return this._errorToken();
      }
    }
  }
}
TokenizerBase.prototype._finishOpenBrace = function() {
  var $0;
  if (this._interpStack != null) {
    if (this._interpStack.depth == -1) {
      this._interpStack.depth = 1;
    }
    else {
      $assert(this._interpStack.depth >= 0, "_interpStack.depth >= 0", "tokenizer.dart", 278, 16);
      ($0 = this._interpStack).depth = $0.depth + 1;
    }
  }
  return this._finishToken(6/*TokenKind.LBRACE*/);
}
TokenizerBase.prototype._finishCloseBrace = function() {
  var $0;
  if (this._interpStack != null) {
    ($0 = this._interpStack).depth = $0.depth - 1;
    $assert(this._interpStack.depth >= 0, "_interpStack.depth >= 0", "tokenizer.dart", 288, 14);
  }
  return this._finishToken(7/*TokenKind.RBRACE*/);
}
TokenizerBase.prototype.finishString = function(quote) {
  if ($notnull_bool(this._maybeEatChar(quote))) {
    if ($notnull_bool(this._maybeEatChar(quote))) {
      return this.finishMultilineString(quote);
    }
    else {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
  }
  return this.finishStringBody(quote);
}
TokenizerBase.prototype.finishRawString = function(quote) {
  if ($notnull_bool(this._maybeEatChar(quote))) {
    if ($notnull_bool(this._maybeEatChar(quote))) {
      return this.finishMultilineRawString(quote);
    }
    else {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
  }
  while (true) {
    var ch = this._nextChar();
    if (ch == quote) {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
    else if (ch == 0) {
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
  }
}
TokenizerBase.prototype.finishMultilineRawString = function(quote) {
  while (true) {
    var ch = this._nextChar();
    if (ch == 0) {
      var kind = quote == 34 ? 68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/ : 69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/;
      return this._finishToken(kind);
    }
    else if (ch == quote && $notnull_bool(this._maybeEatChar(quote)) && $notnull_bool(this._maybeEatChar(quote))) {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
  }
}
TokenizerBase.prototype.finishStringBody = function(quote) {
  while (true) {
    var ch = this._nextChar();
    if (ch == quote) {
      return this._finishToken(58/*TokenKind.STRING*/);
    }
    else if (ch == 36) {
      this._interpStack = InterpStack.push(this._interpStack, quote, false);
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
    else if (ch == 0) {
      return this._finishToken(66/*TokenKind.INCOMPLETE_STRING*/);
    }
    else if (ch == 92) {
      if (!$notnull_bool(this.eatEscapeSequence())) {
        return this._errorToken();
      }
    }
  }
}
TokenizerBase.prototype.eatEscapeSequence = function() {
  var hex;
  switch (this._nextChar()) {
    case 120:

      return $notnull_bool(this.maybeEatHexDigit()) && $notnull_bool(this.maybeEatHexDigit());

    case 117:

      if ($notnull_bool(this._maybeEatChar(123))) {
        var start = this._lang_index;
        this.eatHexDigits();
        var chars = this._lang_index - start;
        if (chars > 0 && chars <= 6 && $notnull_bool(this._maybeEatChar(125))) {
          hex = this._text.substring(start, start + chars);
          break;
        }
        else {
          return false;
        }
      }
      else {
        if ($notnull_bool(this.maybeEatHexDigit()) && $notnull_bool(this.maybeEatHexDigit()) && $notnull_bool(this.maybeEatHexDigit()) && $notnull_bool(this.maybeEatHexDigit())) {
          hex = this._text.substring(this._lang_index - 4, this._lang_index);
          break;
        }
        else {
          return false;
        }
      }

    default:

      return true;

  }
  var n = lang_Parser.parseHex(hex);
  return n < 0xD800 || n > 0xDFFF && n <= 0x10FFFF;
}
TokenizerBase.prototype.finishDot = function() {
  if ($notnull_bool(TokenizerHelpers.isDigit(this._peekChar()))) {
    this.eatDigits();
    return this.finishNumberExtra(62/*TokenKind.DOUBLE*/);
  }
  else {
    return this._finishToken(14/*TokenKind.DOT*/);
  }
}
TokenizerBase.prototype.finishIdentifier = function(ch) {
  if (this._interpStack != null && this._interpStack.depth == -1) {
    this._interpStack.depth = 0;
    if (ch == 36) {
      return this._errorToken();
    }
    while (this._lang_index < this._text.length) {
      if (!$notnull_bool(TokenizerHelpers.isInterpIdentifierPart(this._text.charCodeAt(this._lang_index++)))) {
        this._lang_index--;
        break;
      }
    }
  }
  else {
    while (this._lang_index < this._text.length) {
      if (!$notnull_bool(TokenizerHelpers.isIdentifierPart(this._text.charCodeAt(this._lang_index++)))) {
        this._lang_index--;
        break;
      }
    }
  }
  var kind = this.getIdentifierKind();
  if (kind == 70/*TokenKind.IDENTIFIER*/) {
    return this._finishToken(70/*TokenKind.IDENTIFIER*/);
  }
  else {
    return this._finishToken(kind);
  }
}
TokenizerBase.prototype.next$0 = TokenizerBase.prototype.next;
// ********** Code for Tokenizer **************
function Tokenizer(source, skipWhitespace, index) {
  // Initializers done
  TokenizerBase.call(this, source, skipWhitespace, index);
}
$inherits(Tokenizer, TokenizerBase);
Tokenizer.prototype.next = function() {
  this._startIndex = this._lang_index;
  if (this._interpStack != null && this._interpStack.depth == 0) {
    var istack = this._interpStack;
    this._interpStack = this._interpStack.pop();
    if ($notnull_bool(istack.get$isMultiline())) {
      return this.finishMultilineString($assert_num(istack.get$quote()));
    }
    else {
      return this.finishStringBody($assert_num(istack.get$quote()));
    }
  }
  var ch;
  ch = this._nextChar();
  switch (ch) {
    case 0:

      return this._finishToken(1/*TokenKind.END_OF_FILE*/);

    case 32:
    case 9:
    case 10:
    case 13:

      return this.finishWhitespace();

    case 33:

      if ($notnull_bool(this._maybeEatChar(61))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(51/*TokenKind.NE_STRICT*/);
        }
        else {
          return this._finishToken(49/*TokenKind.NE*/);
        }
      }
      else {
        return this._finishToken(19/*TokenKind.NOT*/);
      }

    case 34:

      return this.finishString(34);

    case 35:

      if ($notnull_bool(this._maybeEatChar(33))) {
        return this.finishHashBang();
      }
      else {
        return this._finishToken(12/*TokenKind.HASH*/);
      }

    case 36:

      if ($notnull_bool(this._maybeEatChar(34))) {
        return this.finishString(34);
      }
      else if ($notnull_bool(this._maybeEatChar(39))) {
        return this.finishString(39);
      }
      else {
        return this.finishIdentifier(36);
      }

    case 37:

      if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(32/*TokenKind.ASSIGN_MOD*/);
      }
      else {
        return this._finishToken(47/*TokenKind.MOD*/);
      }

    case 38:

      if ($notnull_bool(this._maybeEatChar(38))) {
        return this._finishToken(35/*TokenKind.AND*/);
      }
      else if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(23/*TokenKind.ASSIGN_AND*/);
      }
      else {
        return this._finishToken(38/*TokenKind.BIT_AND*/);
      }

    case 39:

      return this.finishString(39);

    case 40:

      return this._finishToken(2/*TokenKind.LPAREN*/);

    case 41:

      return this._finishToken(3/*TokenKind.RPAREN*/);

    case 42:

      if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(29/*TokenKind.ASSIGN_MUL*/);
      }
      else {
        return this._finishToken(44/*TokenKind.MUL*/);
      }

    case 43:

      if ($notnull_bool(this._maybeEatChar(43))) {
        return this._finishToken(16/*TokenKind.INCR*/);
      }
      else if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(27/*TokenKind.ASSIGN_ADD*/);
      }
      else {
        return this._finishToken(42/*TokenKind.ADD*/);
      }

    case 44:

      return this._finishToken(11/*TokenKind.COMMA*/);

    case 45:

      if ($notnull_bool(this._maybeEatChar(45))) {
        return this._finishToken(17/*TokenKind.DECR*/);
      }
      else if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(28/*TokenKind.ASSIGN_SUB*/);
      }
      else {
        return this._finishToken(43/*TokenKind.SUB*/);
      }

    case 46:

      if ($notnull_bool(this._maybeEatChar(46))) {
        if ($notnull_bool(this._maybeEatChar(46))) {
          return this._finishToken(15/*TokenKind.ELLIPSIS*/);
        }
        else {
          return this._errorToken();
        }
      }
      else {
        return this.finishDot();
      }

    case 47:

      if ($notnull_bool(this._maybeEatChar(42))) {
        return this.finishMultiLineComment();
      }
      else if ($notnull_bool(this._maybeEatChar(47))) {
        return this.finishSingleLineComment();
      }
      else if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(30/*TokenKind.ASSIGN_DIV*/);
      }
      else {
        return this._finishToken(45/*TokenKind.DIV*/);
      }

    case 48:

      if ($notnull_bool(this._maybeEatChar(88))) {
        return this.finishHex();
      }
      else if ($notnull_bool(this._maybeEatChar(120))) {
        return this.finishHex();
      }
      else {
        return this.finishNumber();
      }

    case 58:

      return this._finishToken(8/*TokenKind.COLON*/);

    case 59:

      return this._finishToken(10/*TokenKind.SEMICOLON*/);

    case 60:

      if ($notnull_bool(this._maybeEatChar(60))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(24/*TokenKind.ASSIGN_SHL*/);
        }
        else {
          return this._finishToken(39/*TokenKind.SHL*/);
        }
      }
      else if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(54/*TokenKind.LTE*/);
      }
      else {
        return this._finishToken(52/*TokenKind.LT*/);
      }

    case 61:

      if ($notnull_bool(this._maybeEatChar(61))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(50/*TokenKind.EQ_STRICT*/);
        }
        else {
          return this._finishToken(48/*TokenKind.EQ*/);
        }
      }
      else if ($notnull_bool(this._maybeEatChar(62))) {
        return this._finishToken(9/*TokenKind.ARROW*/);
      }
      else {
        return this._finishToken(20/*TokenKind.ASSIGN*/);
      }

    case 62:

      if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(55/*TokenKind.GTE*/);
      }
      else if ($notnull_bool(this._maybeEatChar(62))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(25/*TokenKind.ASSIGN_SAR*/);
        }
        else if ($notnull_bool(this._maybeEatChar(62))) {
          if ($notnull_bool(this._maybeEatChar(61))) {
            return this._finishToken(26/*TokenKind.ASSIGN_SHR*/);
          }
          else {
            return this._finishToken(41/*TokenKind.SHR*/);
          }
        }
        else {
          return this._finishToken(40/*TokenKind.SAR*/);
        }
      }
      else {
        return this._finishToken(53/*TokenKind.GT*/);
      }

    case 63:

      return this._finishToken(33/*TokenKind.CONDITIONAL*/);

    case 64:

      if ($notnull_bool(this._maybeEatChar(34))) {
        return this.finishRawString(34);
      }
      else if ($notnull_bool(this._maybeEatChar(39))) {
        return this.finishRawString(39);
      }
      else {
        return this._errorToken();
      }

    case 91:

      if ($notnull_bool(this._maybeEatChar(93))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(57/*TokenKind.SETINDEX*/);
        }
        else {
          return this._finishToken(56/*TokenKind.INDEX*/);
        }
      }
      else {
        return this._finishToken(4/*TokenKind.LBRACK*/);
      }

    case 93:

      return this._finishToken(5/*TokenKind.RBRACK*/);

    case 94:

      if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(22/*TokenKind.ASSIGN_XOR*/);
      }
      else {
        return this._finishToken(37/*TokenKind.BIT_XOR*/);
      }

    case 123:

      return this._finishOpenBrace();

    case 124:

      if ($notnull_bool(this._maybeEatChar(61))) {
        return this._finishToken(21/*TokenKind.ASSIGN_OR*/);
      }
      else if ($notnull_bool(this._maybeEatChar(124))) {
        return this._finishToken(34/*TokenKind.OR*/);
      }
      else {
        return this._finishToken(36/*TokenKind.BIT_OR*/);
      }

    case 125:

      return this._finishCloseBrace();

    case 126:

      if ($notnull_bool(this._maybeEatChar(47))) {
        if ($notnull_bool(this._maybeEatChar(61))) {
          return this._finishToken(31/*TokenKind.ASSIGN_TRUNCDIV*/);
        }
        else {
          return this._finishToken(46/*TokenKind.TRUNCDIV*/);
        }
      }
      else {
        return this._finishToken(18/*TokenKind.BIT_NOT*/);
      }

    default:

      if ($notnull_bool(TokenizerHelpers.isIdentifierStart(ch))) {
        return this.finishIdentifier(ch);
      }
      else if ($notnull_bool(TokenizerHelpers.isDigit(ch))) {
        return this.finishNumber();
      }
      else {
        return this._errorToken();
      }

  }
}
Tokenizer.prototype.getIdentifierKind = function() {
  var i0 = this._startIndex;
  switch (this._lang_index - i0) {
    case 2:

      if (this._text.charCodeAt(i0) == 100) {
        if (this._text.charCodeAt(i0 + 1) == 111) return 94/*TokenKind.DO*/;
      }
      else if (this._text.charCodeAt(i0) == 105) {
        if (this._text.charCodeAt(i0 + 1) == 102) {
          return 100/*TokenKind.IF*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 110) {
          return 101/*TokenKind.IN*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 115) {
          return 102/*TokenKind.IS*/;
        }
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 3:

      if (this._text.charCodeAt(i0) == 102) {
        if (this._text.charCodeAt(i0 + 1) == 111 && this._text.charCodeAt(i0 + 2) == 114) return 99/*TokenKind.FOR*/;
      }
      else if (this._text.charCodeAt(i0) == 103) {
        if (this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 116) return 76/*TokenKind.GET*/;
      }
      else if (this._text.charCodeAt(i0) == 110) {
        if (this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 119) return 103/*TokenKind.NEW*/;
      }
      else if (this._text.charCodeAt(i0) == 115) {
        if (this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 116) return 84/*TokenKind.SET*/;
      }
      else if (this._text.charCodeAt(i0) == 116) {
        if (this._text.charCodeAt(i0 + 1) == 114 && this._text.charCodeAt(i0 + 2) == 121) return 111/*TokenKind.TRY*/;
      }
      else if (this._text.charCodeAt(i0) == 118) {
        if (this._text.charCodeAt(i0 + 1) == 97 && this._text.charCodeAt(i0 + 2) == 114) return 112/*TokenKind.VAR*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 4:

      if (this._text.charCodeAt(i0) == 99) {
        if (this._text.charCodeAt(i0 + 1) == 97 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 101) return 89/*TokenKind.CASE*/;
      }
      else if (this._text.charCodeAt(i0) == 101) {
        if (this._text.charCodeAt(i0 + 1) == 108 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 101) return 95/*TokenKind.ELSE*/;
      }
      else if (this._text.charCodeAt(i0) == 110) {
        if (this._text.charCodeAt(i0 + 1) == 117 && this._text.charCodeAt(i0 + 2) == 108 && this._text.charCodeAt(i0 + 3) == 108) return 104/*TokenKind.NULL*/;
      }
      else if (this._text.charCodeAt(i0) == 116) {
        if (this._text.charCodeAt(i0 + 1) == 104) {
          if (this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 115) return 108/*TokenKind.THIS*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 114) {
          if (this._text.charCodeAt(i0 + 2) == 117 && this._text.charCodeAt(i0 + 3) == 101) return 110/*TokenKind.TRUE*/;
        }
      }
      else if (this._text.charCodeAt(i0) == 118) {
        if (this._text.charCodeAt(i0 + 1) == 111 && this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 100) return 113/*TokenKind.VOID*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 5:

      if (this._text.charCodeAt(i0) == 98) {
        if (this._text.charCodeAt(i0 + 1) == 114 && this._text.charCodeAt(i0 + 2) == 101 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 107) return 88/*TokenKind.BREAK*/;
      }
      else if (this._text.charCodeAt(i0) == 99) {
        if (this._text.charCodeAt(i0 + 1) == 97) {
          if (this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 99 && this._text.charCodeAt(i0 + 4) == 104) return 90/*TokenKind.CATCH*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 108) {
          if (this._text.charCodeAt(i0 + 2) == 97 && this._text.charCodeAt(i0 + 3) == 115 && this._text.charCodeAt(i0 + 4) == 115) return 73/*TokenKind.CLASS*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 111) {
          if (this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 115 && this._text.charCodeAt(i0 + 4) == 116) return 91/*TokenKind.CONST*/;
        }
      }
      else if (this._text.charCodeAt(i0) == 102) {
        if (this._text.charCodeAt(i0 + 1) == 97) {
          if (this._text.charCodeAt(i0 + 2) == 108 && this._text.charCodeAt(i0 + 3) == 115 && this._text.charCodeAt(i0 + 4) == 101) return 96/*TokenKind.FALSE*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 105) {
          if (this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 108) return 97/*TokenKind.FINAL*/;
        }
      }
      else if (this._text.charCodeAt(i0) == 115) {
        if (this._text.charCodeAt(i0 + 1) == 117 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 114) return 106/*TokenKind.SUPER*/;
      }
      else if (this._text.charCodeAt(i0) == 116) {
        if (this._text.charCodeAt(i0 + 1) == 104 && this._text.charCodeAt(i0 + 2) == 114 && this._text.charCodeAt(i0 + 3) == 111 && this._text.charCodeAt(i0 + 4) == 119) return 109/*TokenKind.THROW*/;
      }
      else if (this._text.charCodeAt(i0) == 119) {
        if (this._text.charCodeAt(i0 + 1) == 104 && this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 108 && this._text.charCodeAt(i0 + 4) == 101) return 114/*TokenKind.WHILE*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 6:

      if (this._text.charCodeAt(i0) == 97) {
        if (this._text.charCodeAt(i0 + 1) == 115 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 116) return 72/*TokenKind.ASSERT*/;
      }
      else if (this._text.charCodeAt(i0) == 105) {
        if (this._text.charCodeAt(i0 + 1) == 109 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 111 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 116) return 78/*TokenKind.IMPORT*/;
      }
      else if (this._text.charCodeAt(i0) == 110) {
        if (this._text.charCodeAt(i0 + 1) == 97) {
          if (this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 105 && this._text.charCodeAt(i0 + 4) == 118 && this._text.charCodeAt(i0 + 5) == 101) return 81/*TokenKind.NATIVE*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 101) {
          if (this._text.charCodeAt(i0 + 2) == 103 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 116 && this._text.charCodeAt(i0 + 5) == 101) return 82/*TokenKind.NEGATE*/;
        }
      }
      else if (this._text.charCodeAt(i0) == 114) {
        if (this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 117 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 110) return 105/*TokenKind.RETURN*/;
      }
      else if (this._text.charCodeAt(i0) == 115) {
        if (this._text.charCodeAt(i0 + 1) == 111) {
          if (this._text.charCodeAt(i0 + 2) == 117 && this._text.charCodeAt(i0 + 3) == 114 && this._text.charCodeAt(i0 + 4) == 99 && this._text.charCodeAt(i0 + 5) == 101) return 85/*TokenKind.SOURCE*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 116) {
          if (this._text.charCodeAt(i0 + 2) == 97 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 105 && this._text.charCodeAt(i0 + 5) == 99) return 86/*TokenKind.STATIC*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 119) {
          if (this._text.charCodeAt(i0 + 2) == 105 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 99 && this._text.charCodeAt(i0 + 5) == 104) return 107/*TokenKind.SWITCH*/;
        }
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 7:

      if (this._text.charCodeAt(i0) == 100) {
        if (this._text.charCodeAt(i0 + 1) == 101 && this._text.charCodeAt(i0 + 2) == 102 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 117 && this._text.charCodeAt(i0 + 5) == 108 && this._text.charCodeAt(i0 + 6) == 116) return 93/*TokenKind.DEFAULT*/;
      }
      else if (this._text.charCodeAt(i0) == 101) {
        if (this._text.charCodeAt(i0 + 1) == 120 && this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 110 && this._text.charCodeAt(i0 + 5) == 100 && this._text.charCodeAt(i0 + 6) == 115) return 74/*TokenKind.EXTENDS*/;
      }
      else if (this._text.charCodeAt(i0) == 102) {
        if (this._text.charCodeAt(i0 + 1) == 97) {
          if (this._text.charCodeAt(i0 + 2) == 99 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 111 && this._text.charCodeAt(i0 + 5) == 114 && this._text.charCodeAt(i0 + 6) == 121) return 75/*TokenKind.FACTORY*/;
        }
        else if (this._text.charCodeAt(i0 + 1) == 105) {
          if (this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 97 && this._text.charCodeAt(i0 + 4) == 108 && this._text.charCodeAt(i0 + 5) == 108 && this._text.charCodeAt(i0 + 6) == 121) return 98/*TokenKind.FINALLY*/;
        }
      }
      else if (this._text.charCodeAt(i0) == 108) {
        if (this._text.charCodeAt(i0 + 1) == 105 && this._text.charCodeAt(i0 + 2) == 98 && this._text.charCodeAt(i0 + 3) == 114 && this._text.charCodeAt(i0 + 4) == 97 && this._text.charCodeAt(i0 + 5) == 114 && this._text.charCodeAt(i0 + 6) == 121) return 80/*TokenKind.LIBRARY*/;
      }
      else if (this._text.charCodeAt(i0) == 116) {
        if (this._text.charCodeAt(i0 + 1) == 121 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 100 && this._text.charCodeAt(i0 + 5) == 101 && this._text.charCodeAt(i0 + 6) == 102) return 87/*TokenKind.TYPEDEF*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 8:

      if (this._text.charCodeAt(i0) == 97) {
        if (this._text.charCodeAt(i0 + 1) == 98 && this._text.charCodeAt(i0 + 2) == 115 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 97 && this._text.charCodeAt(i0 + 6) == 99 && this._text.charCodeAt(i0 + 7) == 116) return 71/*TokenKind.ABSTRACT*/;
      }
      else if (this._text.charCodeAt(i0) == 99) {
        if (this._text.charCodeAt(i0 + 1) == 111 && this._text.charCodeAt(i0 + 2) == 110 && this._text.charCodeAt(i0 + 3) == 116 && this._text.charCodeAt(i0 + 4) == 105 && this._text.charCodeAt(i0 + 5) == 110 && this._text.charCodeAt(i0 + 6) == 117 && this._text.charCodeAt(i0 + 7) == 101) return 92/*TokenKind.CONTINUE*/;
      }
      else if (this._text.charCodeAt(i0) == 111) {
        if (this._text.charCodeAt(i0 + 1) == 112 && this._text.charCodeAt(i0 + 2) == 101 && this._text.charCodeAt(i0 + 3) == 114 && this._text.charCodeAt(i0 + 4) == 97 && this._text.charCodeAt(i0 + 5) == 116 && this._text.charCodeAt(i0 + 6) == 111 && this._text.charCodeAt(i0 + 7) == 114) return 83/*TokenKind.OPERATOR*/;
      }
      return 70/*TokenKind.IDENTIFIER*/;

    case 9:

      if (this._text.charCodeAt(i0) == 105 && this._text.charCodeAt(i0 + 1) == 110 && this._text.charCodeAt(i0 + 2) == 116 && this._text.charCodeAt(i0 + 3) == 101 && this._text.charCodeAt(i0 + 4) == 114 && this._text.charCodeAt(i0 + 5) == 102 && this._text.charCodeAt(i0 + 6) == 97 && this._text.charCodeAt(i0 + 7) == 99 && this._text.charCodeAt(i0 + 8) == 101) return 79/*TokenKind.INTERFACE*/;
      return 70/*TokenKind.IDENTIFIER*/;

    case 10:

      if (this._text.charCodeAt(i0) == 105 && this._text.charCodeAt(i0 + 1) == 109 && this._text.charCodeAt(i0 + 2) == 112 && this._text.charCodeAt(i0 + 3) == 108 && this._text.charCodeAt(i0 + 4) == 101 && this._text.charCodeAt(i0 + 5) == 109 && this._text.charCodeAt(i0 + 6) == 101 && this._text.charCodeAt(i0 + 7) == 110 && this._text.charCodeAt(i0 + 8) == 116 && this._text.charCodeAt(i0 + 9) == 115) return 77/*TokenKind.IMPLEMENTS*/;
      return 70/*TokenKind.IDENTIFIER*/;

    default:

      return 70/*TokenKind.IDENTIFIER*/;

  }
}
Tokenizer.prototype.next$0 = Tokenizer.prototype.next;
// ********** Code for TokenizerHelpers **************
function TokenizerHelpers() {
  // Initializers done
}
TokenizerHelpers.isIdentifierStart = function(c) {
  return ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || c == 95);
}
TokenizerHelpers.isDigit = function(c) {
  return (c >= 48 && c <= 57);
}
TokenizerHelpers.isHexDigit = function(c) {
  return ($notnull_bool(TokenizerHelpers.isDigit(c)) || (c >= 97 && c <= 102) || (c >= 65 && c <= 70));
}
TokenizerHelpers.isIdentifierPart = function(c) {
  return ($notnull_bool(TokenizerHelpers.isIdentifierStart(c)) || $notnull_bool(TokenizerHelpers.isDigit(c)) || c == 36);
}
TokenizerHelpers.isInterpIdentifierPart = function(c) {
  return ($notnull_bool(TokenizerHelpers.isIdentifierStart(c)) || $notnull_bool(TokenizerHelpers.isDigit(c)));
}
// ********** Code for TokenKind **************
function TokenKind() {}
TokenKind.kindToString = function(kind) {
  switch (kind) {
    case 1/*TokenKind.END_OF_FILE*/:

      return "end of file";

    case 2/*TokenKind.LPAREN*/:

      return "(";

    case 3/*TokenKind.RPAREN*/:

      return ")";

    case 4/*TokenKind.LBRACK*/:

      return "[";

    case 5/*TokenKind.RBRACK*/:

      return "]";

    case 6/*TokenKind.LBRACE*/:

      return "{";

    case 7/*TokenKind.RBRACE*/:

      return "}";

    case 8/*TokenKind.COLON*/:

      return ":";

    case 9/*TokenKind.ARROW*/:

      return "=>";

    case 10/*TokenKind.SEMICOLON*/:

      return ";";

    case 11/*TokenKind.COMMA*/:

      return ",";

    case 12/*TokenKind.HASH*/:

      return "#";

    case 13/*TokenKind.HASHBANG*/:

      return "#!";

    case 14/*TokenKind.DOT*/:

      return ".";

    case 15/*TokenKind.ELLIPSIS*/:

      return "...";

    case 16/*TokenKind.INCR*/:

      return "++";

    case 17/*TokenKind.DECR*/:

      return "--";

    case 18/*TokenKind.BIT_NOT*/:

      return "~";

    case 19/*TokenKind.NOT*/:

      return "!";

    case 20/*TokenKind.ASSIGN*/:

      return "=";

    case 21/*TokenKind.ASSIGN_OR*/:

      return "|=";

    case 22/*TokenKind.ASSIGN_XOR*/:

      return "^=";

    case 23/*TokenKind.ASSIGN_AND*/:

      return "&=";

    case 24/*TokenKind.ASSIGN_SHL*/:

      return "<<=";

    case 25/*TokenKind.ASSIGN_SAR*/:

      return ">>=";

    case 26/*TokenKind.ASSIGN_SHR*/:

      return ">>>=";

    case 27/*TokenKind.ASSIGN_ADD*/:

      return "+=";

    case 28/*TokenKind.ASSIGN_SUB*/:

      return "-=";

    case 29/*TokenKind.ASSIGN_MUL*/:

      return "*=";

    case 30/*TokenKind.ASSIGN_DIV*/:

      return "/=";

    case 31/*TokenKind.ASSIGN_TRUNCDIV*/:

      return "~/=";

    case 32/*TokenKind.ASSIGN_MOD*/:

      return "%=";

    case 33/*TokenKind.CONDITIONAL*/:

      return "?";

    case 34/*TokenKind.OR*/:

      return "||";

    case 35/*TokenKind.AND*/:

      return "&&";

    case 36/*TokenKind.BIT_OR*/:

      return "|";

    case 37/*TokenKind.BIT_XOR*/:

      return "^";

    case 38/*TokenKind.BIT_AND*/:

      return "&";

    case 39/*TokenKind.SHL*/:

      return "<<";

    case 40/*TokenKind.SAR*/:

      return ">>";

    case 41/*TokenKind.SHR*/:

      return ">>>";

    case 42/*TokenKind.ADD*/:

      return "+";

    case 43/*TokenKind.SUB*/:

      return "-";

    case 44/*TokenKind.MUL*/:

      return "*";

    case 45/*TokenKind.DIV*/:

      return "/";

    case 46/*TokenKind.TRUNCDIV*/:

      return "~/";

    case 47/*TokenKind.MOD*/:

      return "%";

    case 48/*TokenKind.EQ*/:

      return "==";

    case 49/*TokenKind.NE*/:

      return "!=";

    case 50/*TokenKind.EQ_STRICT*/:

      return "===";

    case 51/*TokenKind.NE_STRICT*/:

      return "!==";

    case 52/*TokenKind.LT*/:

      return "<";

    case 53/*TokenKind.GT*/:

      return ">";

    case 54/*TokenKind.LTE*/:

      return "<=";

    case 55/*TokenKind.GTE*/:

      return ">=";

    case 56/*TokenKind.INDEX*/:

      return "[]";

    case 57/*TokenKind.SETINDEX*/:

      return "[]=";

    case 58/*TokenKind.STRING*/:

      return "string";

    case 59/*TokenKind.STRING_PART*/:

      return "string part";

    case 60/*TokenKind.INTEGER*/:

      return "integer";

    case 61/*TokenKind.HEX_INTEGER*/:

      return "hex integer";

    case 62/*TokenKind.DOUBLE*/:

      return "double";

    case 63/*TokenKind.WHITESPACE*/:

      return "whitespace";

    case 64/*TokenKind.COMMENT*/:

      return "comment";

    case 65/*TokenKind.ERROR*/:

      return "error";

    case 66/*TokenKind.INCOMPLETE_STRING*/:

      return "incomplete string";

    case 67/*TokenKind.INCOMPLETE_COMMENT*/:

      return "incomplete comment";

    case 68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/:

      return "incomplete multiline string dq";

    case 69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/:

      return "incomplete multiline string sq";

    case 70/*TokenKind.IDENTIFIER*/:

      return "identifier";

    case 71/*TokenKind.ABSTRACT*/:

      return "pseudo-keyword 'abstract'";

    case 72/*TokenKind.ASSERT*/:

      return "pseudo-keyword 'assert'";

    case 73/*TokenKind.CLASS*/:

      return "pseudo-keyword 'class'";

    case 74/*TokenKind.EXTENDS*/:

      return "pseudo-keyword 'extends'";

    case 75/*TokenKind.FACTORY*/:

      return "pseudo-keyword 'factory'";

    case 76/*TokenKind.GET*/:

      return "pseudo-keyword 'get'";

    case 77/*TokenKind.IMPLEMENTS*/:

      return "pseudo-keyword 'implements'";

    case 78/*TokenKind.IMPORT*/:

      return "pseudo-keyword 'import'";

    case 79/*TokenKind.INTERFACE*/:

      return "pseudo-keyword 'interface'";

    case 80/*TokenKind.LIBRARY*/:

      return "pseudo-keyword 'library'";

    case 81/*TokenKind.NATIVE*/:

      return "pseudo-keyword 'native'";

    case 82/*TokenKind.NEGATE*/:

      return "pseudo-keyword 'negate'";

    case 83/*TokenKind.OPERATOR*/:

      return "pseudo-keyword 'operator'";

    case 84/*TokenKind.SET*/:

      return "pseudo-keyword 'set'";

    case 85/*TokenKind.SOURCE*/:

      return "pseudo-keyword 'source'";

    case 86/*TokenKind.STATIC*/:

      return "pseudo-keyword 'static'";

    case 87/*TokenKind.TYPEDEF*/:

      return "pseudo-keyword 'typedef'";

    case 88/*TokenKind.BREAK*/:

      return "keyword 'break'";

    case 89/*TokenKind.CASE*/:

      return "keyword 'case'";

    case 90/*TokenKind.CATCH*/:

      return "keyword 'catch'";

    case 91/*TokenKind.CONST*/:

      return "keyword 'const'";

    case 92/*TokenKind.CONTINUE*/:

      return "keyword 'continue'";

    case 93/*TokenKind.DEFAULT*/:

      return "keyword 'default'";

    case 94/*TokenKind.DO*/:

      return "keyword 'do'";

    case 95/*TokenKind.ELSE*/:

      return "keyword 'else'";

    case 96/*TokenKind.FALSE*/:

      return "keyword 'false'";

    case 97/*TokenKind.FINAL*/:

      return "keyword 'final'";

    case 98/*TokenKind.FINALLY*/:

      return "keyword 'finally'";

    case 99/*TokenKind.FOR*/:

      return "keyword 'for'";

    case 100/*TokenKind.IF*/:

      return "keyword 'if'";

    case 101/*TokenKind.IN*/:

      return "keyword 'in'";

    case 102/*TokenKind.IS*/:

      return "keyword 'is'";

    case 103/*TokenKind.NEW*/:

      return "keyword 'new'";

    case 104/*TokenKind.NULL*/:

      return "keyword 'null'";

    case 105/*TokenKind.RETURN*/:

      return "keyword 'return'";

    case 106/*TokenKind.SUPER*/:

      return "keyword 'super'";

    case 107/*TokenKind.SWITCH*/:

      return "keyword 'switch'";

    case 108/*TokenKind.THIS*/:

      return "keyword 'this'";

    case 109/*TokenKind.THROW*/:

      return "keyword 'throw'";

    case 110/*TokenKind.TRUE*/:

      return "keyword 'true'";

    case 111/*TokenKind.TRY*/:

      return "keyword 'try'";

    case 112/*TokenKind.VAR*/:

      return "keyword 'var'";

    case 113/*TokenKind.VOID*/:

      return "keyword 'void'";

    case 114/*TokenKind.WHILE*/:

      return "keyword 'while'";

    default:

      return "TokenKind(" + kind.toString() + ")";

  }
}
TokenKind.isIdentifier = function(kind) {
  return kind >= 70/*TokenKind.IDENTIFIER*/ && kind < 88/*TokenKind.BREAK*/;
}
TokenKind.infixPrecedence = function(kind) {
  switch (kind) {
    case 20/*TokenKind.ASSIGN*/:

      return 2;

    case 21/*TokenKind.ASSIGN_OR*/:

      return 2;

    case 22/*TokenKind.ASSIGN_XOR*/:

      return 2;

    case 23/*TokenKind.ASSIGN_AND*/:

      return 2;

    case 24/*TokenKind.ASSIGN_SHL*/:

      return 2;

    case 25/*TokenKind.ASSIGN_SAR*/:

      return 2;

    case 26/*TokenKind.ASSIGN_SHR*/:

      return 2;

    case 27/*TokenKind.ASSIGN_ADD*/:

      return 2;

    case 28/*TokenKind.ASSIGN_SUB*/:

      return 2;

    case 29/*TokenKind.ASSIGN_MUL*/:

      return 2;

    case 30/*TokenKind.ASSIGN_DIV*/:

      return 2;

    case 31/*TokenKind.ASSIGN_TRUNCDIV*/:

      return 2;

    case 32/*TokenKind.ASSIGN_MOD*/:

      return 2;

    case 33/*TokenKind.CONDITIONAL*/:

      return 3;

    case 34/*TokenKind.OR*/:

      return 4;

    case 35/*TokenKind.AND*/:

      return 5;

    case 36/*TokenKind.BIT_OR*/:

      return 6;

    case 37/*TokenKind.BIT_XOR*/:

      return 7;

    case 38/*TokenKind.BIT_AND*/:

      return 8;

    case 39/*TokenKind.SHL*/:

      return 11;

    case 40/*TokenKind.SAR*/:

      return 11;

    case 41/*TokenKind.SHR*/:

      return 11;

    case 42/*TokenKind.ADD*/:

      return 12;

    case 43/*TokenKind.SUB*/:

      return 12;

    case 44/*TokenKind.MUL*/:

      return 13;

    case 45/*TokenKind.DIV*/:

      return 13;

    case 46/*TokenKind.TRUNCDIV*/:

      return 13;

    case 47/*TokenKind.MOD*/:

      return 13;

    case 48/*TokenKind.EQ*/:

      return 9;

    case 49/*TokenKind.NE*/:

      return 9;

    case 50/*TokenKind.EQ_STRICT*/:

      return 9;

    case 51/*TokenKind.NE_STRICT*/:

      return 9;

    case 52/*TokenKind.LT*/:

      return 10;

    case 53/*TokenKind.GT*/:

      return 10;

    case 54/*TokenKind.LTE*/:

      return 10;

    case 55/*TokenKind.GTE*/:

      return 10;

    case 102/*TokenKind.IS*/:

      return 10;

    default:

      return -1;

  }
}
TokenKind.rawOperatorFromMethod = function(name) {
  switch (name) {
    case '\$bit_not':

      return '~';

    case '\$bit_or':

      return '|';

    case '\$bit_xor':

      return '^';

    case '\$bit_and':

      return '&';

    case '\$shl':

      return '<<';

    case '\$sar':

      return '>>';

    case '\$shr':

      return '>>>';

    case '\$add':

      return '+';

    case '\$sub':

      return '-';

    case '\$mul':

      return '*';

    case '\$div':

      return '/';

    case '\$truncdiv':

      return '~/';

    case '\$mod':

      return '%';

    case '\$eq':

      return '==';

    case '\$lt':

      return '<';

    case '\$gt':

      return '>';

    case '\$lte':

      return '<=';

    case '\$gte':

      return '>=';

    case '\$index':

      return '[]';

    case '\$setindex':

      return '[]=';

    case '\$ne':

      return '!=';

  }
}
TokenKind.binaryMethodName = function(kind) {
  switch (kind) {
    case 18/*TokenKind.BIT_NOT*/:

      return '\$bit_not';

    case 36/*TokenKind.BIT_OR*/:

      return '\$bit_or';

    case 37/*TokenKind.BIT_XOR*/:

      return '\$bit_xor';

    case 38/*TokenKind.BIT_AND*/:

      return '\$bit_and';

    case 39/*TokenKind.SHL*/:

      return '\$shl';

    case 40/*TokenKind.SAR*/:

      return '\$sar';

    case 41/*TokenKind.SHR*/:

      return '\$shr';

    case 42/*TokenKind.ADD*/:

      return '\$add';

    case 43/*TokenKind.SUB*/:

      return '\$sub';

    case 44/*TokenKind.MUL*/:

      return '\$mul';

    case 45/*TokenKind.DIV*/:

      return '\$div';

    case 46/*TokenKind.TRUNCDIV*/:

      return '\$truncdiv';

    case 47/*TokenKind.MOD*/:

      return '\$mod';

    case 48/*TokenKind.EQ*/:

      return '\$eq';

    case 52/*TokenKind.LT*/:

      return '\$lt';

    case 53/*TokenKind.GT*/:

      return '\$gt';

    case 54/*TokenKind.LTE*/:

      return '\$lte';

    case 55/*TokenKind.GTE*/:

      return '\$gte';

    case 56/*TokenKind.INDEX*/:

      return '\$index';

    case 57/*TokenKind.SETINDEX*/:

      return '\$setindex';

  }
}
TokenKind.kindFromAssign = function(kind) {
  if (kind == 20/*TokenKind.ASSIGN*/) return 0;
  if (kind > 20/*TokenKind.ASSIGN*/ && kind <= 32/*TokenKind.ASSIGN_MOD*/) {
    return kind + (15)/*(ADD - ASSIGN_ADD)*/;
  }
  return -1;
}
// ********** Code for lang_Parser **************
function lang_Parser(source, diet, throwOnIncomplete, optionalSemicolons, startOffset) {
  var $0;
  this._afterParensIndex = 0
  this.source = source;
  this.diet = diet;
  this.throwOnIncomplete = throwOnIncomplete;
  this.optionalSemicolons = optionalSemicolons;
  // Initializers done
  this.tokenizer = new Tokenizer(this.source, true, startOffset);
  this._peekToken = (($0 = this.tokenizer.next()) == null ? null : $0.assert$lang_Token());
  this._previousToken = null;
  this._inInitializers = false;
  this._afterParens = [];
}
lang_Parser.prototype.get$source = function() { return this.source; };
lang_Parser.prototype.isPrematureEndOfFile = function() {
  if ($notnull_bool(this.throwOnIncomplete) && $notnull_bool(this._maybeEat(1/*TokenKind.END_OF_FILE*/)) || $notnull_bool(this._maybeEat(68/*TokenKind.INCOMPLETE_MULTILINE_STRING_DQ*/)) || $notnull_bool(this._maybeEat(69/*TokenKind.INCOMPLETE_MULTILINE_STRING_SQ*/))) {
    $throw(new IncompleteSourceException(this._previousToken));
  }
  else if ($notnull_bool(this._maybeEat(1/*TokenKind.END_OF_FILE*/))) {
    this._lang_error('unexpected end of file', this._peekToken.get$span());
    return true;
  }
  else {
    return false;
  }
}
lang_Parser.prototype._peek = function() {
  return this._peekToken.kind;
}
lang_Parser.prototype._lang_next = function() {
  var $0;
  this._previousToken = this._peekToken;
  this._peekToken = (($0 = this.tokenizer.next()) == null ? null : $0.assert$lang_Token());
  return this._previousToken;
}
lang_Parser.prototype._peekKind = function(kind) {
  return this._peekToken.kind == kind;
}
lang_Parser.prototype._peekIdentifier = function() {
  return TokenKind.isIdentifier(this._peekToken.kind);
}
lang_Parser.prototype._maybeEat = function(kind) {
  var $0;
  if (this._peekToken.kind == kind) {
    this._previousToken = this._peekToken;
    this._peekToken = (($0 = this.tokenizer.next()) == null ? null : $0.assert$lang_Token());
    return true;
  }
  else {
    return false;
  }
}
lang_Parser.prototype._eat = function(kind) {
  if (!$notnull_bool(this._maybeEat(kind))) {
    this._errorExpected(TokenKind.kindToString(kind));
  }
}
lang_Parser.prototype._eatSemicolon = function() {
  if ($notnull_bool(this.optionalSemicolons) && $notnull_bool(this._peekKind(1/*TokenKind.END_OF_FILE*/))) return;
  this._eat(10/*TokenKind.SEMICOLON*/);
}
lang_Parser.prototype._errorExpected = function(expected) {
  var $0;
  if ($notnull_bool(this.throwOnIncomplete)) this.isPrematureEndOfFile();
  var tok = this._lang_next();
  var message = ('expected ' + expected + ', but found ' + tok);
  this._lang_error($assert_String(message), (($0 = tok.get$span()) == null ? null : $0.assert$SourceSpan()));
}
lang_Parser.prototype._lang_error = function(message, location) {
  if (location == null) {
    location = this._peekToken.get$span();
  }
  $globals.world.fatal(message, location);
}
lang_Parser.prototype._skipBlock = function() {
  var $0;
  var depth = 1;
  this._eat(6/*TokenKind.LBRACE*/);
  while (true) {
    var tok = this._lang_next();
    if ($notnull_bool($eq(tok.get$kind(), 6/*TokenKind.LBRACE*/))) {
      depth += 1;
    }
    else if ($notnull_bool($eq(tok.get$kind(), 7/*TokenKind.RBRACE*/))) {
      depth -= 1;
      if (depth == 0) return;
    }
    else if ($notnull_bool($eq(tok.get$kind(), 1/*TokenKind.END_OF_FILE*/))) {
      this._lang_error('unexpected end of file during diet parse', (($0 = tok.get$span()) == null ? null : $0.assert$SourceSpan()));
      return;
    }
  }
}
lang_Parser.prototype._makeSpan = function(start) {
  return new SourceSpan(this.source, start, this._previousToken.end);
}
lang_Parser.prototype.compilationUnit = function() {
  var ret = [];
  this._maybeEat(13/*TokenKind.HASHBANG*/);
  while ($notnull_bool(this._peekKind(12/*TokenKind.HASH*/))) {
    ret.add$1(this.directive());
  }
  while (!$notnull_bool(this._maybeEat(1/*TokenKind.END_OF_FILE*/))) {
    ret.add$1(this.topLevelDefinition());
  }
  return (ret == null ? null : ret.assert$List_Definition());
}
lang_Parser.prototype.directive = function() {
  var start = this._peekToken.start;
  this._eat(12/*TokenKind.HASH*/);
  var name = this.identifier();
  var args = this.arguments();
  this._eatSemicolon();
  return new DirectiveDefinition(name, args, this._makeSpan(start));
}
lang_Parser.prototype.topLevelDefinition = function() {
  switch (this._peek()) {
    case 73/*TokenKind.CLASS*/:

      return this.classDefinition(73/*TokenKind.CLASS*/);

    case 79/*TokenKind.INTERFACE*/:

      return this.classDefinition(79/*TokenKind.INTERFACE*/);

    case 87/*TokenKind.TYPEDEF*/:

      return this.functionTypeAlias();

    default:

      return this.declaration(true);

  }
}
lang_Parser.prototype.classDefinition = function(kind) {
  var start = this._peekToken.start;
  this._eat(kind);
  var name = this.identifier();
  var typeParams = null;
  if ($notnull_bool(this._peekKind(52/*TokenKind.LT*/))) {
    typeParams = this.typeParameters();
  }
  var _extends = null;
  if ($notnull_bool(this._maybeEat(74/*TokenKind.EXTENDS*/))) {
    _extends = this.typeList();
  }
  var _implements = null;
  if ($notnull_bool(this._maybeEat(77/*TokenKind.IMPLEMENTS*/))) {
    _implements = this.typeList();
  }
  var _native = null;
  if ($notnull_bool(this._maybeEat(81/*TokenKind.NATIVE*/))) {
    _native = this.maybeStringLiteral();
    if (_native != null) _native = new NativeType($assert_String(_native));
  }
  var _factory = null;
  if ($notnull_bool(this._maybeEat(75/*TokenKind.FACTORY*/))) {
    _factory = this.type(0);
  }
  var body = [];
  if ($notnull_bool(this._maybeEat(6/*TokenKind.LBRACE*/))) {
    while (!$notnull_bool(this._maybeEat(7/*TokenKind.RBRACE*/))) {
      if ($notnull_bool(this.isPrematureEndOfFile())) break;
      body.add$1(this.declaration(true));
    }
  }
  else {
    this._errorExpected('block starting with "{" or ";"');
  }
  return new TypeDefinition(kind == 73/*TokenKind.CLASS*/, name, typeParams, _extends, _implements, _native, _factory, body, this._makeSpan(start));
}
lang_Parser.prototype.functionTypeAlias = function() {
  var start = this._peekToken.start;
  this._eat(87/*TokenKind.TYPEDEF*/);
  var di = this.declaredIdentifier(false);
  var typeParams = null;
  if ($notnull_bool(this._peekKind(52/*TokenKind.LT*/))) {
    typeParams = this.typeParameters();
  }
  var formals = this.formalParameterList();
  this._eatSemicolon();
  var func = new FunctionDefinition(null, di.get$type(), di.get$name(), formals, null, null, null, null, this._makeSpan(start));
  return new FunctionTypeDefinition(func, typeParams, this._makeSpan(start));
}
lang_Parser.prototype.initializers = function() {
  this._inInitializers = true;
  var ret = [];
  do {
    ret.add$1(this.expression());
  }
  while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/)))
  this._inInitializers = false;
  return ret;
}
lang_Parser.prototype.get$initializers = function() {
  return lang_Parser.prototype.initializers.bind(this);
}
lang_Parser.prototype.functionBody = function(inExpression) {
  var start = this._peekToken.start;
  if ($notnull_bool(this._maybeEat(9/*TokenKind.ARROW*/))) {
    var expr = this.expression();
    if (!$notnull_bool(inExpression)) {
      this._eatSemicolon();
    }
    return new ReturnStatement(expr, this._makeSpan(start));
  }
  else if ($notnull_bool(this._peekKind(6/*TokenKind.LBRACE*/))) {
    if ($notnull_bool(this.diet)) {
      this._skipBlock();
      return new DietStatement(this._makeSpan(start));
    }
    else {
      return this.block();
    }
  }
  else if (!$notnull_bool(inExpression)) {
    if ($notnull_bool(this._maybeEat(10/*TokenKind.SEMICOLON*/))) {
      return null;
    }
  }
  this._lang_error('Expected function body (neither { nor => found)');
}
lang_Parser.prototype.finishField = function(start, modifiers, typeParams, type, name, value) {
  if (typeParams != null) {
    $globals.world.internalError('trying to create a generic field', this._makeSpan($assert_num(start)));
  }
  var names = [name];
  var values = [value];
  while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
    names.add$1(this.identifier());
    if ($notnull_bool(this._maybeEat(20/*TokenKind.ASSIGN*/))) {
      values.add$1(this.expression());
    }
    else {
      values.add$1();
    }
  }
  this._eatSemicolon();
  return new VariableDefinition(modifiers, type, names, values, this._makeSpan($assert_num(start)));
}
lang_Parser.prototype.finishDefinition = function(start, modifiers, di, typeParams) {
  var $0;
  switch (this._peek()) {
    case 2/*TokenKind.LPAREN*/:

      var formals = this.formalParameterList();
      var inits = null, native_ = null;
      if ($notnull_bool(this._maybeEat(8/*TokenKind.COLON*/))) {
        inits = this.initializers();
      }
      if ($notnull_bool(this._maybeEat(81/*TokenKind.NATIVE*/))) {
        native_ = this.maybeStringLiteral();
        if ($notnull_bool(native_ == null)) native_ = '';
      }
      var body = this.functionBody(false);
      if ($notnull_bool(di.get$name() == null)) {
        di.set$name(di.get$type().get$name());
      }
      return new FunctionDefinition(modifiers, di.get$type(), di.get$name(), formals, typeParams, inits, native_, body, this._makeSpan(start));

    case 20/*TokenKind.ASSIGN*/:

      this._eat(20/*TokenKind.ASSIGN*/);
      var value = this.expression();
      return this.finishField(start, modifiers, typeParams, di.get$type(), di.get$name(), value);

    case 11/*TokenKind.COMMA*/:
    case 10/*TokenKind.SEMICOLON*/:

      return this.finishField(start, modifiers, typeParams, di.get$type(), di.get$name(), null);

    default:

      this._errorExpected('declaration');
      return null;

  }
}
lang_Parser.prototype.declaration = function(includeOperators) {
  var start = this._peekToken.start;
  if ($notnull_bool(this._peekKind(75/*TokenKind.FACTORY*/))) {
    return this.factoryConstructorDeclaration();
  }
  var modifiers = this._readModifiers();
  return this.finishDefinition(start, (modifiers == null ? null : modifiers.assert$List_Token()), this.declaredIdentifier(includeOperators), null);
}
lang_Parser.prototype.factoryConstructorDeclaration = function() {
  var $0;
  var start = this._peekToken.start;
  var factoryToken = this._lang_next();
  var names = [this.identifier()];
  while ($notnull_bool(this._maybeEat(14/*TokenKind.DOT*/))) {
    names.add$1(this.identifier());
  }
  var typeParams = null;
  if ($notnull_bool(this._peekKind(52/*TokenKind.LT*/))) {
    typeParams = this.typeParameters();
  }
  var name = null;
  var type = null;
  if ($notnull_bool(this._maybeEat(14/*TokenKind.DOT*/))) {
    name = this.identifier();
  }
  else if ($notnull_bool(typeParams == null)) {
    if (names.length > 1) {
      name = names.removeLast$0();
    }
    else {
      name = new lang_Identifier('', (($0 = names.$index(0).get$span()) == null ? null : $0.assert$SourceSpan()));
    }
  }
  else {
    name = new lang_Identifier('', (($0 = names.$index(0).get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  if (names.length > 1) {
    this._lang_error('unsupported qualified name for factory', (($0 = names.$index(0).get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  type = new NameTypeReference(false, names.$index(0), null, (($0 = names.$index(0).get$span()) == null ? null : $0.assert$SourceSpan()));
  var di = new DeclaredIdentifier(type, name, this._makeSpan(start));
  return this.finishDefinition(start, [factoryToken], di, (typeParams == null ? null : typeParams.assert$List_ParameterType()));
}
lang_Parser.prototype.statement = function() {
  var $0;
  switch (this._peek()) {
    case 88/*TokenKind.BREAK*/:

      return (($0 = this.breakStatement()) == null ? null : $0.assert$lang_Statement());

    case 92/*TokenKind.CONTINUE*/:

      return (($0 = this.continueStatement()) == null ? null : $0.assert$lang_Statement());

    case 105/*TokenKind.RETURN*/:

      return (($0 = this.returnStatement()) == null ? null : $0.assert$lang_Statement());

    case 109/*TokenKind.THROW*/:

      return (($0 = this.throwStatement()) == null ? null : $0.assert$lang_Statement());

    case 72/*TokenKind.ASSERT*/:

      return (($0 = this.assertStatement()) == null ? null : $0.assert$lang_Statement());

    case 114/*TokenKind.WHILE*/:

      return this.whileStatement();

    case 94/*TokenKind.DO*/:

      return this.doStatement();

    case 99/*TokenKind.FOR*/:

      return (($0 = this.forStatement()) == null ? null : $0.assert$lang_Statement());

    case 100/*TokenKind.IF*/:

      return this.ifStatement();

    case 107/*TokenKind.SWITCH*/:

      return (($0 = this.switchStatement()) == null ? null : $0.assert$lang_Statement());

    case 111/*TokenKind.TRY*/:

      return (($0 = this.tryStatement()) == null ? null : $0.assert$lang_Statement());

    case 6/*TokenKind.LBRACE*/:

      return this.block();

    case 10/*TokenKind.SEMICOLON*/:

      return this.emptyStatement();

    case 97/*TokenKind.FINAL*/:

      return (($0 = this.declaration(false)) == null ? null : $0.assert$lang_Statement());

    case 112/*TokenKind.VAR*/:

      return (($0 = this.declaration(false)) == null ? null : $0.assert$lang_Statement());

    default:

      return (($0 = this.finishExpressionAsStatement(this.expression())) == null ? null : $0.assert$lang_Statement());

  }
}
lang_Parser.prototype.finishExpressionAsStatement = function(expr) {
  var $0;
  var start = $assert_num(expr.get$span().get$start());
  if ($notnull_bool(this._maybeEat(8/*TokenKind.COLON*/))) {
    var label = this._makeLabel(expr);
    return new LabeledStatement(label, this.statement(), this._makeSpan(start));
  }
  if ((expr instanceof LambdaExpression)) {
    if (!(expr.get$func().get$body() instanceof BlockStatement)) {
      this._eatSemicolon();
      expr.get$func().set$span(this._makeSpan(start));
    }
    return expr.get$func();
  }
  else if ((expr instanceof DeclaredIdentifier)) {
    var value = null;
    if ($notnull_bool(this._maybeEat(20/*TokenKind.ASSIGN*/))) {
      value = this.expression();
    }
    return this.finishField(start, null, null, expr.get$type(), expr.get$name(), value);
  }
  else if ($notnull_bool(this._isBin(expr, 20/*TokenKind.ASSIGN*/)) && ((expr.get$x() instanceof DeclaredIdentifier))) {
    var di = (($0 = expr.get$x()) == null ? null : $0.assert$DeclaredIdentifier());
    return this.finishField(start, null, null, di.type, di.name, expr.get$y());
  }
  else if ($notnull_bool(this._isBin(expr, 52/*TokenKind.LT*/)) && $notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
    var baseType = this._makeType(expr.get$x());
    var typeArgs = [this._makeType(expr.get$y())];
    var gt = this._finishTypeArguments((baseType == null ? null : baseType.assert$TypeReference()), 0, typeArgs);
    var name = this.identifier();
    var value = null;
    if ($notnull_bool(this._maybeEat(20/*TokenKind.ASSIGN*/))) {
      value = this.expression();
    }
    return this.finishField(expr.get$span().get$start(), null, null, gt, name, value);
  }
  else {
    this._eatSemicolon();
    return new lang_ExpressionStatement(expr, this._makeSpan($assert_num(expr.get$span().get$start())));
  }
}
lang_Parser.prototype.testCondition = function() {
  this._eatLeftParen();
  var ret = this.expression();
  this._eat(3/*TokenKind.RPAREN*/);
  return (ret == null ? null : ret.assert$lang_Expression());
}
lang_Parser.prototype.block = function() {
  var start = this._peekToken.start;
  this._eat(6/*TokenKind.LBRACE*/);
  var stmts = [];
  while (!$notnull_bool(this._maybeEat(7/*TokenKind.RBRACE*/))) {
    if ($notnull_bool(this.isPrematureEndOfFile())) break;
    stmts.add$1(this.statement());
  }
  return new BlockStatement(stmts, this._makeSpan(start));
}
lang_Parser.prototype.emptyStatement = function() {
  var start = this._peekToken.start;
  this._eat(10/*TokenKind.SEMICOLON*/);
  return new EmptyStatement(this._makeSpan(start));
}
lang_Parser.prototype.ifStatement = function() {
  var start = this._peekToken.start;
  this._eat(100/*TokenKind.IF*/);
  var test = this.testCondition();
  var trueBranch = this.statement();
  var falseBranch = null;
  if ($notnull_bool(this._maybeEat(95/*TokenKind.ELSE*/))) {
    falseBranch = this.statement();
  }
  return new IfStatement(test, trueBranch, falseBranch, this._makeSpan(start));
}
lang_Parser.prototype.whileStatement = function() {
  var start = this._peekToken.start;
  this._eat(114/*TokenKind.WHILE*/);
  var test = this.testCondition();
  var body = this.statement();
  return new WhileStatement(test, body, this._makeSpan(start));
}
lang_Parser.prototype.doStatement = function() {
  var start = this._peekToken.start;
  this._eat(94/*TokenKind.DO*/);
  var body = this.statement();
  this._eat(114/*TokenKind.WHILE*/);
  var test = this.testCondition();
  this._eatSemicolon();
  return new DoStatement(body, test, this._makeSpan(start));
}
lang_Parser.prototype.forStatement = function() {
  var start = this._peekToken.start;
  this._eat(99/*TokenKind.FOR*/);
  this._eatLeftParen();
  var init = this.forInitializerStatement(start);
  if ((init instanceof ForInStatement)) {
    return init;
  }
  var test = null;
  if (!$notnull_bool(this._maybeEat(10/*TokenKind.SEMICOLON*/))) {
    test = this.expression();
    this._eatSemicolon();
  }
  var step = [];
  if (!$notnull_bool(this._maybeEat(3/*TokenKind.RPAREN*/))) {
    step.add$1(this.expression());
    while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
      step.add$1(this.expression());
    }
    this._eat(3/*TokenKind.RPAREN*/);
  }
  var body = this.statement();
  return new ForStatement(init, test, step, body, this._makeSpan(start));
}
lang_Parser.prototype.forInitializerStatement = function(start) {
  var $0;
  if ($notnull_bool(this._maybeEat(10/*TokenKind.SEMICOLON*/))) {
    return null;
  }
  else {
    var init = this.expression();
    if ($notnull_bool(this._peekKind(11/*TokenKind.COMMA*/)) && $notnull_bool(this._isBin(init, 52/*TokenKind.LT*/))) {
      this._eat(11/*TokenKind.COMMA*/);
      var baseType = this._makeType(init.get$x());
      var typeArgs = [this._makeType(init.get$y())];
      var gt = this._finishTypeArguments((baseType == null ? null : baseType.assert$TypeReference()), 0, typeArgs);
      var name = this.identifier();
      init = new DeclaredIdentifier(gt, name, this._makeSpan($assert_num(init.get$span().get$start())));
    }
    if ($notnull_bool(this._maybeEat(101/*TokenKind.IN*/))) {
      return this._finishForIn(start, (($0 = this._makeDeclaredIdentifier(init)) == null ? null : $0.assert$DeclaredIdentifier()));
    }
    else {
      return this.finishExpressionAsStatement(init);
    }
  }
}
lang_Parser.prototype._finishForIn = function(start, di) {
  var expr = this.expression();
  this._eat(3/*TokenKind.RPAREN*/);
  var body = this.statement();
  return new ForInStatement(di, expr, body, this._makeSpan(start));
}
lang_Parser.prototype.tryStatement = function() {
  var start = this._peekToken.start;
  this._eat(111/*TokenKind.TRY*/);
  var body = this.block();
  var catches = [];
  while ($notnull_bool(this._peekKind(90/*TokenKind.CATCH*/))) {
    catches.add$1(this.catchNode());
  }
  var finallyBlock = null;
  if ($notnull_bool(this._maybeEat(98/*TokenKind.FINALLY*/))) {
    finallyBlock = this.block();
  }
  return new TryStatement(body, catches, finallyBlock, this._makeSpan(start));
}
lang_Parser.prototype.catchNode = function() {
  var start = this._peekToken.start;
  this._eat(90/*TokenKind.CATCH*/);
  this._eatLeftParen();
  var exc = this.declaredIdentifier(false);
  var trace = null;
  if ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
    trace = this.declaredIdentifier(false);
  }
  this._eat(3/*TokenKind.RPAREN*/);
  var body = this.block();
  return new CatchNode(exc, trace, body, this._makeSpan(start));
}
lang_Parser.prototype.switchStatement = function() {
  var start = this._peekToken.start;
  this._eat(107/*TokenKind.SWITCH*/);
  var test = this.testCondition();
  var cases = [];
  this._eat(6/*TokenKind.LBRACE*/);
  while (!$notnull_bool(this._maybeEat(7/*TokenKind.RBRACE*/))) {
    cases.add$1(this.caseNode());
  }
  return new SwitchStatement(test, cases, this._makeSpan(start));
}
lang_Parser.prototype._peekCaseEnd = function() {
  var kind = this._peek();
  return $notnull_bool($eq(kind, 7/*TokenKind.RBRACE*/)) || $notnull_bool($eq(kind, 89/*TokenKind.CASE*/)) || $notnull_bool($eq(kind, 93/*TokenKind.DEFAULT*/));
}
lang_Parser.prototype.caseNode = function() {
  var start = this._peekToken.start;
  var label = null;
  if ($notnull_bool(this._peekIdentifier())) {
    label = this.identifier();
    this._eat(8/*TokenKind.COLON*/);
  }
  var cases = [];
  while (true) {
    if ($notnull_bool(this._maybeEat(89/*TokenKind.CASE*/))) {
      cases.add$1(this.expression());
      this._eat(8/*TokenKind.COLON*/);
    }
    else if ($notnull_bool(this._maybeEat(93/*TokenKind.DEFAULT*/))) {
      cases.add$1();
      this._eat(8/*TokenKind.COLON*/);
    }
    else {
      break;
    }
  }
  if ($notnull_bool($eq(cases.length, 0))) {
    this._lang_error('case or default');
  }
  var stmts = [];
  while (!$notnull_bool(this._peekCaseEnd())) {
    if ($notnull_bool(this.isPrematureEndOfFile())) break;
    stmts.add$1(this.statement());
  }
  return new CaseNode(label, cases, stmts, this._makeSpan(start));
}
lang_Parser.prototype.returnStatement = function() {
  var start = this._peekToken.start;
  this._eat(105/*TokenKind.RETURN*/);
  var expr;
  if ($notnull_bool(this._maybeEat(10/*TokenKind.SEMICOLON*/))) {
    expr = null;
  }
  else {
    expr = this.expression();
    this._eatSemicolon();
  }
  return new ReturnStatement(expr, this._makeSpan(start));
}
lang_Parser.prototype.throwStatement = function() {
  var start = this._peekToken.start;
  this._eat(109/*TokenKind.THROW*/);
  var expr;
  if ($notnull_bool(this._maybeEat(10/*TokenKind.SEMICOLON*/))) {
    expr = null;
  }
  else {
    expr = this.expression();
    this._eatSemicolon();
  }
  return new ThrowStatement(expr, this._makeSpan(start));
}
lang_Parser.prototype.assertStatement = function() {
  var start = this._peekToken.start;
  this._eat(72/*TokenKind.ASSERT*/);
  this._eatLeftParen();
  var expr = this.expression();
  this._eat(3/*TokenKind.RPAREN*/);
  this._eatSemicolon();
  return new AssertStatement(expr, this._makeSpan(start));
}
lang_Parser.prototype.breakStatement = function() {
  var start = this._peekToken.start;
  this._eat(88/*TokenKind.BREAK*/);
  var name = null;
  if ($notnull_bool(this._peekIdentifier())) {
    name = this.identifier();
  }
  this._eatSemicolon();
  return new BreakStatement(name, this._makeSpan(start));
}
lang_Parser.prototype.continueStatement = function() {
  var start = this._peekToken.start;
  this._eat(92/*TokenKind.CONTINUE*/);
  var name = null;
  if ($notnull_bool(this._peekIdentifier())) {
    name = this.identifier();
  }
  this._eatSemicolon();
  return new ContinueStatement(name, this._makeSpan(start));
}
lang_Parser.prototype.expression = function() {
  return this.infixExpression(0);
}
lang_Parser.prototype._makeType = function(expr) {
  var $0;
  if ((expr instanceof VarExpression)) {
    return new NameTypeReference(false, expr.get$name(), null, (($0 = expr.get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  else if ((expr instanceof DotExpression)) {
    var type = this._makeType(expr.get$self());
    if (type.get$names() == null) {
      type.set$names([expr.get$name()]);
    }
    else {
      type.get$names().add$1(expr.get$name());
    }
    type.set$span(expr.get$span());
    return type;
  }
  else {
    this._lang_error('expected type reference');
    return null;
  }
}
lang_Parser.prototype.infixExpression = function(precedence) {
  var $0;
  return this.finishInfixExpression((($0 = this.unaryExpression()) == null ? null : $0.assert$lang_Expression()), precedence);
}
lang_Parser.prototype._finishDeclaredId = function(type) {
  var name = this.identifier();
  return this.finishPostfixExpression(new DeclaredIdentifier(type, name, this._makeSpan($assert_num(type.get$span().get$start()))));
}
lang_Parser.prototype._fixAsType = function(x) {
  $assert(this._isBin(x, 52/*TokenKind.LT*/), "_isBin(x, TokenKind.LT)", "parser.dart", 799, 12);
  if ($notnull_bool(this._maybeEat(53/*TokenKind.GT*/))) {
    var base = this._makeType(x.x);
    var typeParam = this._makeType(x.y);
    var type = new GenericTypeReference(base, [typeParam], 0, this._makeSpan(x.span.start));
    return this._finishDeclaredId(type);
  }
  else {
    $assert(this._peekKind(52/*TokenKind.LT*/), "_peekKind(TokenKind.LT)", "parser.dart", 810, 14);
    var base = this._makeType(x.x);
    var paramBase = this._makeType(x.y);
    var firstParam = this.addTypeArguments((paramBase == null ? null : paramBase.assert$TypeReference()), 1);
    var type;
    if (firstParam.get$depth() <= 0) {
      type = new GenericTypeReference(base, [firstParam], 0, this._makeSpan(x.span.start));
    }
    else if ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
      type = this._finishTypeArguments((base == null ? null : base.assert$TypeReference()), 0, [firstParam]);
    }
    else {
      this._eat(53/*TokenKind.GT*/);
      type = new GenericTypeReference(base, [firstParam], 0, this._makeSpan(x.span.start));
    }
    return this._finishDeclaredId(type);
  }
}
lang_Parser.prototype.finishInfixExpression = function(x, precedence) {
  while (true) {
    var kind = this._peek();
    var prec = TokenKind.infixPrecedence(this._peek());
    if (prec >= precedence) {
      if (kind == 52/*TokenKind.LT*/ || kind == 53/*TokenKind.GT*/) {
        if ($notnull_bool(this._isBin(x, 52/*TokenKind.LT*/))) {
          return this._fixAsType((x == null ? null : x.assert$BinaryExpression()));
        }
      }
      var op = this._lang_next();
      if ($notnull_bool($eq(op.get$kind(), 102/*TokenKind.IS*/))) {
        var isTrue = !$notnull_bool(this._maybeEat(19/*TokenKind.NOT*/));
        var typeRef = this.type(0);
        x = new IsExpression(isTrue, x, typeRef, this._makeSpan(x.span.start));
        continue;
      }
      var y = this.infixExpression($assert_num($notnull_bool($eq(prec, 2)) ? prec : prec + 1));
      if ($notnull_bool($eq(op.get$kind(), 33/*TokenKind.CONDITIONAL*/))) {
        this._eat(8/*TokenKind.COLON*/);
        var z = this.infixExpression($assert_num(prec));
        x = new ConditionalExpression(x, y, z, this._makeSpan(x.span.start));
      }
      else {
        x = new BinaryExpression(op, x, y, this._makeSpan(x.span.start));
      }
    }
    else {
      break;
    }
  }
  return x;
}
lang_Parser.prototype._isPrefixUnaryOperator = function(kind) {
  switch (kind) {
    case 42/*TokenKind.ADD*/:
    case 43/*TokenKind.SUB*/:
    case 19/*TokenKind.NOT*/:
    case 18/*TokenKind.BIT_NOT*/:
    case 16/*TokenKind.INCR*/:
    case 17/*TokenKind.DECR*/:

      return true;

    default:

      return false;

  }
}
lang_Parser.prototype.unaryExpression = function() {
  var start = this._peekToken.start;
  if ($notnull_bool(this._isPrefixUnaryOperator(this._peek()))) {
    var tok = this._lang_next();
    var expr = this.unaryExpression();
    return new UnaryExpression(tok, expr, this._makeSpan(start));
  }
  return this.finishPostfixExpression(this.primary());
}
lang_Parser.prototype.argument = function() {
  var start = this._peekToken.start;
  var expr;
  var label = null;
  if ($notnull_bool(this._maybeEat(15/*TokenKind.ELLIPSIS*/))) {
    label = new lang_Identifier('...', this._makeSpan(start));
  }
  expr = this.expression();
  if (label == null && $notnull_bool(this._maybeEat(8/*TokenKind.COLON*/))) {
    label = this._makeLabel(expr);
    expr = this.expression();
  }
  return new ArgumentNode(label, expr, this._makeSpan(start));
}
lang_Parser.prototype.arguments = function() {
  var args = [];
  this._eatLeftParen();
  if (!$notnull_bool(this._maybeEat(3/*TokenKind.RPAREN*/))) {
    do {
      args.add$1(this.argument());
    }
    while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/)))
    this._eat(3/*TokenKind.RPAREN*/);
  }
  return args;
}
lang_Parser.prototype.get$arguments = function() {
  return lang_Parser.prototype.arguments.bind(this);
}
lang_Parser.prototype.finishPostfixExpression = function(expr) {
  switch (this._peek()) {
    case 2/*TokenKind.LPAREN*/:

      return this.finishCallOrLambdaExpression(expr);

    case 4/*TokenKind.LBRACK*/:

      this._eat(4/*TokenKind.LBRACK*/);
      var index = this.expression();
      this._eat(5/*TokenKind.RBRACK*/);
      return this.finishPostfixExpression(new IndexExpression(expr, index, this._makeSpan($assert_num(expr.get$span().get$start()))));

    case 14/*TokenKind.DOT*/:

      this._eat(14/*TokenKind.DOT*/);
      var name = this.identifier();
      var ret = new DotExpression(expr, name, this._makeSpan($assert_num(expr.get$span().get$start())));
      return this.finishPostfixExpression(ret);

    case 16/*TokenKind.INCR*/:
    case 17/*TokenKind.DECR*/:

      var tok = this._lang_next();
      return new PostfixExpression(expr, tok, this._makeSpan($assert_num(expr.get$span().get$start())));

    case 9/*TokenKind.ARROW*/:
    case 6/*TokenKind.LBRACE*/:

      return expr;

    default:

      if ($notnull_bool(this._peekIdentifier())) {
        return this.finishPostfixExpression(new DeclaredIdentifier(this._makeType(expr), this.identifier(), this._makeSpan($assert_num(expr.get$span().get$start()))));
      }
      else {
        return expr;
      }

  }
}
lang_Parser.prototype.finishCallOrLambdaExpression = function(expr) {
  var $0;
  if ($notnull_bool(this._atClosureParameters())) {
    var formals = this.formalParameterList();
    var body = this.functionBody(true);
    return this._makeFunction(expr, formals, body);
  }
  else {
    if ((expr instanceof DeclaredIdentifier)) {
      this._lang_error('illegal target for call, did you mean to declare a function?', (($0 = expr.get$span()) == null ? null : $0.assert$SourceSpan()));
    }
    var args = this.arguments();
    return this.finishPostfixExpression(new CallExpression(expr, args, this._makeSpan($assert_num(expr.get$span().get$start()))));
  }
}
lang_Parser.prototype._isBin = function(expr, kind) {
  return (expr instanceof BinaryExpression) && $notnull_bool($eq(expr.get$op().get$kind(), kind));
}
lang_Parser.prototype._boolTypeRef = function(span) {
  return new TypeReference(span, $globals.world.nonNullBool);
}
lang_Parser.prototype._intTypeRef = function(span) {
  return new TypeReference(span, $globals.world.intType);
}
lang_Parser.prototype._doubleTypeRef = function(span) {
  return new TypeReference(span, $globals.world.doubleType);
}
lang_Parser.prototype._stringTypeRef = function(span) {
  return new TypeReference(span, $globals.world.stringType);
}
lang_Parser.prototype.primary = function() {
  var start = this._peekToken.start;
  switch (this._peek()) {
    case 108/*TokenKind.THIS*/:

      this._eat(108/*TokenKind.THIS*/);
      return new ThisExpression(this._makeSpan(start));

    case 106/*TokenKind.SUPER*/:

      this._eat(106/*TokenKind.SUPER*/);
      return new SuperExpression(this._makeSpan(start));

    case 91/*TokenKind.CONST*/:

      this._eat(91/*TokenKind.CONST*/);
      if ($notnull_bool(this._peekKind(4/*TokenKind.LBRACK*/)) || $notnull_bool(this._peekKind(56/*TokenKind.INDEX*/))) {
        return this.finishListLiteral(start, true, null);
      }
      else if ($notnull_bool(this._peekKind(6/*TokenKind.LBRACE*/))) {
        return this.finishMapLiteral(start, true, null);
      }
      else if ($notnull_bool(this._peekKind(52/*TokenKind.LT*/))) {
        return this.finishTypedLiteral(start, true);
      }
      else {
        return this.finishNewExpression(start, true);
      }

    case 103/*TokenKind.NEW*/:

      this._eat(103/*TokenKind.NEW*/);
      return this.finishNewExpression(start, false);

    case 2/*TokenKind.LPAREN*/:

      return this._parenOrLambda();

    case 4/*TokenKind.LBRACK*/:
    case 56/*TokenKind.INDEX*/:

      return this.finishListLiteral(start, false, null);

    case 6/*TokenKind.LBRACE*/:

      return this.finishMapLiteral(start, false, null);

    case 104/*TokenKind.NULL*/:

      this._eat(104/*TokenKind.NULL*/);
      return new NullExpression(this._makeSpan(start));

    case 110/*TokenKind.TRUE*/:

      this._eat(110/*TokenKind.TRUE*/);
      return new LiteralExpression(true, this._boolTypeRef(this._makeSpan(start)), 'true', this._makeSpan(start));

    case 96/*TokenKind.FALSE*/:

      this._eat(96/*TokenKind.FALSE*/);
      return new LiteralExpression(false, this._boolTypeRef(this._makeSpan(start)), 'false', this._makeSpan(start));

    case 61/*TokenKind.HEX_INTEGER*/:

      var t = this._lang_next();
      return new LiteralExpression(lang_Parser.parseHex($assert_String(t.get$text().substring$1(2))), this._intTypeRef(this._makeSpan(start)), t.get$text(), this._makeSpan(start));

    case 60/*TokenKind.INTEGER*/:

      var t = this._lang_next();
      return new LiteralExpression(Math.parseInt($assert_String(t.get$text())), this._intTypeRef(this._makeSpan(start)), t.get$text(), this._makeSpan(start));

    case 62/*TokenKind.DOUBLE*/:

      var t = this._lang_next();
      return new LiteralExpression(Math.parseDouble($assert_String(t.get$text())), this._doubleTypeRef(this._makeSpan(start)), t.get$text(), this._makeSpan(start));

    case 58/*TokenKind.STRING*/:

      return this.stringLiteralExpr();

    case 66/*TokenKind.INCOMPLETE_STRING*/:

      return this.stringInterpolation();

    case 52/*TokenKind.LT*/:

      return this.finishTypedLiteral(start, false);

    case 113/*TokenKind.VOID*/:
    case 112/*TokenKind.VAR*/:
    case 97/*TokenKind.FINAL*/:

      return this.declaredIdentifier(false);

    default:

      if (!$notnull_bool(this._peekIdentifier())) {
        this._errorExpected('expression');
      }
      return new VarExpression(this.identifier(), this._makeSpan(start));

  }
}
lang_Parser.prototype.stringInterpolation = function() {
  var $0;
  var start = this._peekToken.start;
  var lits = [];
  var startQuote = null, endQuote = null;
  while ($notnull_bool(this._peekKind(66/*TokenKind.INCOMPLETE_STRING*/))) {
    var token = this._lang_next();
    var text = token.get$text();
    if ($notnull_bool(startQuote == null)) {
      if ($notnull_bool(isMultilineString($assert_String(text)))) {
        endQuote = text.substring$2(0, 3);
        startQuote = $add(endQuote, '\n');
      }
      else {
        startQuote = endQuote = text.$index(0);
      }
      text = $add(text.substring$2(0, text.length - 1), endQuote);
    }
    else {
      text = $add($add(startQuote, text.substring$2(0, text.length - 1)), endQuote);
    }
    lits.add$1(this.makeStringLiteral($assert_String(text), (($0 = token.get$span()) == null ? null : $0.assert$SourceSpan())));
    if ($notnull_bool(this._maybeEat(6/*TokenKind.LBRACE*/))) {
      lits.add$1(this.expression());
      this._eat(7/*TokenKind.RBRACE*/);
    }
    else if ($notnull_bool(this._maybeEat(108/*TokenKind.THIS*/))) {
      lits.add$1(new ThisExpression(this._previousToken.get$span()));
    }
    else {
      var id = this.identifier();
      lits.add$1(new VarExpression(id, (($0 = id.get$span()) == null ? null : $0.assert$SourceSpan())));
    }
  }
  var tok = this._lang_next();
  if ($notnull_bool($ne(tok.get$kind(), 58/*TokenKind.STRING*/))) {
    this._errorExpected('interpolated string');
  }
  var text = $add(startQuote, tok.get$text());
  lits.add$1(this.makeStringLiteral($assert_String(text), (($0 = tok.get$span()) == null ? null : $0.assert$SourceSpan())));
  var span = this._makeSpan(start);
  return new LiteralExpression(lits, this._stringTypeRef((span == null ? null : span.assert$SourceSpan())), '\$\$\$', (span == null ? null : span.assert$SourceSpan()));
}
lang_Parser.prototype.makeStringLiteral = function(text, span) {
  return new LiteralExpression(text, this._stringTypeRef(span), text, span);
}
lang_Parser.prototype.stringLiteralExpr = function() {
  var $0;
  var token = this._lang_next();
  return this.makeStringLiteral($assert_String(token.get$text()), (($0 = token.get$span()) == null ? null : $0.assert$SourceSpan()));
}
lang_Parser.prototype.maybeStringLiteral = function() {
  var kind = this._peek();
  if ($notnull_bool($eq(kind, 58/*TokenKind.STRING*/))) {
    return parseStringLiteral(this._lang_next().get$text());
  }
  else if ($notnull_bool($eq(kind, 59/*TokenKind.STRING_PART*/))) {
    this._lang_next();
    this._errorExpected('string literal, but found interpolated string start');
  }
  else if ($notnull_bool($eq(kind, 66/*TokenKind.INCOMPLETE_STRING*/))) {
    this._lang_next();
    this._errorExpected('string literal, but found incomplete string');
  }
  return null;
}
lang_Parser.prototype._parenOrLambda = function() {
  var $0;
  var start = this._peekToken.start;
  if ($notnull_bool(this._atClosureParameters())) {
    var formals = this.formalParameterList();
    var body = this.functionBody(true);
    var func = new FunctionDefinition(null, null, null, formals, null, null, null, body, this._makeSpan(start));
    return new LambdaExpression(func, (($0 = func.get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  else {
    var saved = this._inInitializers;
    this._inInitializers = false;
    var args = this.arguments();
    this._inInitializers = $assert_bool(saved);
    if ($notnull_bool($eq(args.length, 1))) {
      return new ParenExpression(args.$index(0).get$value(), this._makeSpan(start));
    }
    else {
      this._lang_error('unexpected comma expression');
      return args.$index(0).get$value();
    }
  }
}
lang_Parser.prototype._atClosureParameters = function() {
  if ($notnull_bool(this._inInitializers)) return false;
  var after = this._peekAfterCloseParen();
  return after.kind == 9/*TokenKind.ARROW*/ || after.kind == 6/*TokenKind.LBRACE*/;
}
lang_Parser.prototype._eatLeftParen = function() {
  this._eat(2/*TokenKind.LPAREN*/);
  this._afterParensIndex++;
}
lang_Parser.prototype._peekAfterCloseParen = function() {
  var $0;
  if (this._afterParensIndex < this._afterParens.length) {
    return (($0 = this._afterParens.$index(this._afterParensIndex)) == null ? null : $0.assert$lang_Token());
  }
  this._afterParensIndex = 0;
  this._afterParens.clear();
  var tokens = [this._lang_next()];
  this._lookaheadAfterParens((tokens == null ? null : tokens.assert$List_Token()));
  var after = this._peekToken;
  tokens.add$1(after);
  this.tokenizer = new DivertedTokenSource(tokens, this, this.tokenizer);
  this._lang_next();
  return (after == null ? null : after.assert$lang_Token());
}
lang_Parser.prototype._lookaheadAfterParens = function(tokens) {
  var saved = this._afterParens.length;
  this._afterParens.add(null);
  while (true) {
    var token = this._lang_next();
    tokens.add(token);
    var kind = token.kind;
    if (kind == 3/*TokenKind.RPAREN*/ || kind == 1/*TokenKind.END_OF_FILE*/) {
      this._afterParens.$setindex(saved, this._peekToken);
      return;
    }
    else if (kind == 2/*TokenKind.LPAREN*/) {
      this._lookaheadAfterParens(tokens);
    }
  }
}
lang_Parser.prototype._typeAsIdentifier = function(type) {
  return type.get$name();
}
lang_Parser.prototype._specialIdentifier = function(includeOperators) {
  var start = this._peekToken.start;
  var name;
  switch (this._peek()) {
    case 15/*TokenKind.ELLIPSIS*/:

      this._eat(15/*TokenKind.ELLIPSIS*/);
      this._lang_error('rest no longer supported', this._previousToken.get$span());
      name = $assert_String(this.identifier().get$name());
      break;

    case 108/*TokenKind.THIS*/:

      this._eat(108/*TokenKind.THIS*/);
      this._eat(14/*TokenKind.DOT*/);
      name = ('this.' + this.identifier().get$name());
      break;

    case 76/*TokenKind.GET*/:

      if (!$notnull_bool(includeOperators)) return null;
      this._eat(76/*TokenKind.GET*/);
      if ($notnull_bool(this._peekIdentifier())) {
        name = ('get\$' + this.identifier().get$name());
      }
      else {
        name = 'get';
      }
      break;

    case 84/*TokenKind.SET*/:

      if (!$notnull_bool(includeOperators)) return null;
      this._eat(84/*TokenKind.SET*/);
      if ($notnull_bool(this._peekIdentifier())) {
        name = ('set\$' + this.identifier().get$name());
      }
      else {
        name = 'set';
      }
      break;

    case 83/*TokenKind.OPERATOR*/:

      if (!$notnull_bool(includeOperators)) return null;
      this._eat(83/*TokenKind.OPERATOR*/);
      var kind = this._peek();
      if ($notnull_bool($eq(kind, 82/*TokenKind.NEGATE*/))) {
        name = '\$negate';
        this._lang_next();
      }
      else {
        name = TokenKind.binaryMethodName($assert_num(kind));
        if (name == null) {
          name = 'operator';
        }
        else {
          this._lang_next();
        }
      }
      break;

    default:

      return null;

  }
  return new lang_Identifier(name, this._makeSpan(start));
}
lang_Parser.prototype.declaredIdentifier = function(includeOperators) {
  var start = this._peekToken.start;
  var myType = null;
  var name = this._specialIdentifier(includeOperators);
  if (name == null) {
    myType = this.type(0);
    name = this._specialIdentifier(includeOperators);
    if (name == null) {
      if ($notnull_bool(this._peekIdentifier())) {
        name = this.identifier();
      }
      else if ((myType instanceof NameTypeReference) && $notnull_bool(myType.get$names() == null)) {
        name = this._typeAsIdentifier(myType);
        myType = null;
      }
      else {
      }
    }
  }
  return new DeclaredIdentifier(myType, name, this._makeSpan(start));
}
lang_Parser._hexDigit = function(c) {
  if (c >= 48 && c <= 57) {
    return c - 48;
  }
  else if (c >= 97 && c <= 102) {
    return c - 87;
  }
  else if (c >= 65 && c <= 70) {
    return c - 55;
  }
  else {
    return -1;
  }
}
lang_Parser.parseHex = function(hex) {
  var result = 0;
  for (var i = 0;
   i < hex.length; i++) {
    var digit = lang_Parser._hexDigit(hex.charCodeAt(i));
    $assert($ne(digit, -1), "digit != -1", "parser.dart", 1339, 14);
    result = (result * 16) + $assert_num(digit);
  }
  return $assert_num(result);
}
lang_Parser.prototype.finishNewExpression = function(start, isConst) {
  var type = this.type(0);
  var name = null;
  if ($notnull_bool(this._maybeEat(14/*TokenKind.DOT*/))) {
    name = this.identifier();
  }
  var args = this.arguments();
  return new lang_NewExpression(isConst, type, name, args, this._makeSpan(start));
}
lang_Parser.prototype.finishListLiteral = function(start, isConst, type) {
  if ($notnull_bool(this._maybeEat(56/*TokenKind.INDEX*/))) {
    return new ListExpression(isConst, type, [], this._makeSpan(start));
  }
  var values = [];
  this._eat(4/*TokenKind.LBRACK*/);
  while (!$notnull_bool(this._maybeEat(5/*TokenKind.RBRACK*/))) {
    if ($notnull_bool(this.isPrematureEndOfFile())) break;
    values.add$1(this.expression());
    if (!$notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
      this._eat(5/*TokenKind.RBRACK*/);
      break;
    }
  }
  return new ListExpression(isConst, type, values, this._makeSpan(start));
}
lang_Parser.prototype.finishMapLiteral = function(start, isConst, type) {
  var items = [];
  this._eat(6/*TokenKind.LBRACE*/);
  while (!$notnull_bool(this._maybeEat(7/*TokenKind.RBRACE*/))) {
    if ($notnull_bool(this.isPrematureEndOfFile())) break;
    items.add$1(this.expression());
    this._eat(8/*TokenKind.COLON*/);
    items.add$1(this.expression());
    if (!$notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
      this._eat(7/*TokenKind.RBRACE*/);
      break;
    }
  }
  return new MapExpression(isConst, type, items, this._makeSpan(start));
}
lang_Parser.prototype.finishTypedLiteral = function(start, isConst) {
  var span = this._makeSpan(start);
  var typeToBeNamedLater = new NameTypeReference(false, null, null, (span == null ? null : span.assert$SourceSpan()));
  var genericType = this.addTypeArguments((typeToBeNamedLater == null ? null : typeToBeNamedLater.assert$TypeReference()), 0);
  if ($notnull_bool(this._peekKind(4/*TokenKind.LBRACK*/)) || $notnull_bool(this._peekKind(56/*TokenKind.INDEX*/))) {
    return this.finishListLiteral(start, isConst, (genericType == null ? null : genericType.assert$TypeReference()));
  }
  else if ($notnull_bool(this._peekKind(6/*TokenKind.LBRACE*/))) {
    return this.finishMapLiteral(start, isConst, (genericType == null ? null : genericType.assert$TypeReference()));
  }
  else {
    this._errorExpected('array or map literal');
  }
}
lang_Parser.prototype._readModifiers = function() {
  var modifiers = null;
  while (true) {
    switch (this._peek()) {
      case 86/*TokenKind.STATIC*/:
      case 97/*TokenKind.FINAL*/:
      case 91/*TokenKind.CONST*/:
      case 71/*TokenKind.ABSTRACT*/:
      case 75/*TokenKind.FACTORY*/:

        if (modifiers == null) modifiers = [];
        modifiers.add$1(this._lang_next());
        break;

      default:

        return modifiers;

    }
  }
  return null;
}
lang_Parser.prototype.typeParameter = function() {
  var start = this._peekToken.start;
  var name = this.identifier();
  var myType = null;
  if ($notnull_bool(this._maybeEat(74/*TokenKind.EXTENDS*/))) {
    myType = this.type(1);
  }
  var tp = new TypeParameter(name, myType, this._makeSpan(start));
  return new ParameterType($assert_String(name.get$name()), tp);
}
lang_Parser.prototype.get$typeParameter = function() {
  return lang_Parser.prototype.typeParameter.bind(this);
}
lang_Parser.prototype.typeParameters = function() {
  this._eat(52/*TokenKind.LT*/);
  var closed = false;
  var ret = [];
  do {
    var tp = this.typeParameter();
    ret.add$1(tp);
    if ((tp.get$typeParameter().get$extendsType() instanceof GenericTypeReference) && $notnull_bool($eq(tp.get$typeParameter().get$extendsType().get$depth(), 0))) {
      closed = true;
      break;
    }
  }
  while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/)))
  if (!$notnull_bool(closed)) {
    this._eat(53/*TokenKind.GT*/);
  }
  return (ret == null ? null : ret.assert$List_ParameterType());
}
lang_Parser.prototype.get$typeParameters = function() {
  return lang_Parser.prototype.typeParameters.bind(this);
}
lang_Parser.prototype._eatClosingAngle = function(depth) {
  if ($notnull_bool(this._maybeEat(53/*TokenKind.GT*/))) {
    return depth;
  }
  else if (depth > 0 && $notnull_bool(this._maybeEat(40/*TokenKind.SAR*/))) {
    return depth - 1;
  }
  else if (depth > 1 && $notnull_bool(this._maybeEat(41/*TokenKind.SHR*/))) {
    return depth - 2;
  }
  else {
    this._errorExpected('>');
    return depth;
  }
}
lang_Parser.prototype.addTypeArguments = function(baseType, depth) {
  this._eat(52/*TokenKind.LT*/);
  return this._finishTypeArguments(baseType, depth, []);
}
lang_Parser.prototype._finishTypeArguments = function(baseType, depth, types) {
  var delta = -1;
  do {
    var myType = this.type(depth + 1);
    types.add$1(myType);
    if ((myType instanceof GenericTypeReference) && myType.get$depth() <= depth) {
      delta = depth - $assert_num(myType.get$depth());
      break;
    }
  }
  while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/)))
  if (delta >= 0) {
    depth -= $assert_num(delta);
  }
  else {
    depth = this._eatClosingAngle(depth);
  }
  var span = this._makeSpan(baseType.span.start);
  return new GenericTypeReference(baseType, types, depth, (span == null ? null : span.assert$SourceSpan()));
}
lang_Parser.prototype.typeList = function() {
  var types = [];
  do {
    types.add$1(this.type(0));
  }
  while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/)))
  return types;
}
lang_Parser.prototype.type = function(depth) {
  var start = this._peekToken.start;
  var name;
  var names = null;
  var typeArgs = null;
  var isFinal = false;
  switch (this._peek()) {
    case 113/*TokenKind.VOID*/:

      return new TypeReference(this._lang_next().get$span(), $globals.world.voidType);

    case 112/*TokenKind.VAR*/:

      return new TypeReference(this._lang_next().get$span(), $globals.world.varType);

    case 97/*TokenKind.FINAL*/:

      this._eat(97/*TokenKind.FINAL*/);
      isFinal = true;
      name = this.identifier();
      break;

    default:

      name = this.identifier();
      break;

  }
  while ($notnull_bool(this._maybeEat(14/*TokenKind.DOT*/))) {
    if (names == null) names = [];
    names.add$1(this.identifier());
  }
  var typeRef = new NameTypeReference(isFinal, name, names, this._makeSpan(start));
  if ($notnull_bool(this._peekKind(52/*TokenKind.LT*/))) {
    return this.addTypeArguments((typeRef == null ? null : typeRef.assert$TypeReference()), depth);
  }
  else {
    return typeRef;
  }
}
lang_Parser.prototype.get$type = function() {
  return lang_Parser.prototype.type.bind(this);
}
lang_Parser.prototype.formalParameter = function(inOptionalBlock) {
  var $0;
  var start = this._peekToken.start;
  var isThis = false;
  var isRest = false;
  var di = this.declaredIdentifier(false);
  var type = di.get$type();
  var name = di.get$name();
  var value = null;
  if ($notnull_bool(this._maybeEat(20/*TokenKind.ASSIGN*/))) {
    if (!$notnull_bool(inOptionalBlock)) {
      this._lang_error('default values only allowed inside [optional] section');
    }
    value = this.expression();
  }
  else if ($notnull_bool(this._peekKind(2/*TokenKind.LPAREN*/))) {
    var formals = this.formalParameterList();
    var func = new FunctionDefinition(null, type, name, formals, null, null, null, null, this._makeSpan(start));
    type = new FunctionTypeReference(false, func, (($0 = func.get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  if ($notnull_bool(inOptionalBlock) && $notnull_bool(value == null)) {
    value = new NullExpression(this._makeSpan(start));
  }
  return new FormalNode(isThis, isRest, type, name, value, this._makeSpan(start));
}
lang_Parser.prototype.formalParameterList = function() {
  this._eatLeftParen();
  var formals = [];
  var inOptionalBlock = false;
  if (!$notnull_bool(this._maybeEat(3/*TokenKind.RPAREN*/))) {
    if ($notnull_bool(this._maybeEat(4/*TokenKind.LBRACK*/))) {
      inOptionalBlock = true;
    }
    formals.add$1(this.formalParameter($assert_bool(inOptionalBlock)));
    while ($notnull_bool(this._maybeEat(11/*TokenKind.COMMA*/))) {
      if ($notnull_bool(this._maybeEat(4/*TokenKind.LBRACK*/))) {
        if ($notnull_bool(inOptionalBlock)) {
          this._lang_error('already inside an optional block', this._previousToken.get$span());
        }
        inOptionalBlock = true;
      }
      formals.add$1(this.formalParameter($assert_bool(inOptionalBlock)));
    }
    if ($notnull_bool(inOptionalBlock)) {
      this._eat(5/*TokenKind.RBRACK*/);
    }
    this._eat(3/*TokenKind.RPAREN*/);
  }
  return formals;
}
lang_Parser.prototype.identifier = function() {
  var $0;
  var tok = this._lang_next();
  if (!$notnull_bool(TokenKind.isIdentifier($assert_num(tok.get$kind())))) {
    this._lang_error(('expected identifier, but found ' + tok), (($0 = tok.get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  return new lang_Identifier(tok.get$text(), this._makeSpan($assert_num(tok.get$start())));
}
lang_Parser.prototype._makeFunction = function(expr, formals, body) {
  var $0;
  var name, type;
  if ((expr instanceof VarExpression)) {
    name = expr.get$name();
    type = null;
  }
  else if ((expr instanceof DeclaredIdentifier)) {
    name = expr.get$name();
    type = expr.get$type();
  }
  else {
    this._lang_error('bad function body', (($0 = expr.get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  var span = new SourceSpan(expr.get$span().get$file(), expr.get$span().get$start(), body.get$span().get$end());
  var func = new FunctionDefinition(null, type, name, formals, null, null, null, body, (span == null ? null : span.assert$SourceSpan()));
  return new LambdaExpression(func, (($0 = func.get$span()) == null ? null : $0.assert$SourceSpan()));
}
lang_Parser.prototype._makeDeclaredIdentifier = function(e) {
  var $0;
  if ((e instanceof VarExpression)) {
    return new DeclaredIdentifier(null, e.get$name(), (($0 = e.get$span()) == null ? null : $0.assert$SourceSpan()));
  }
  else if ((e instanceof DeclaredIdentifier)) {
    return e;
  }
  else {
    this._lang_error('expected declared identifier');
    return new DeclaredIdentifier(null, null, (($0 = e.get$span()) == null ? null : $0.assert$SourceSpan()));
  }
}
lang_Parser.prototype._makeLabel = function(expr) {
  if ((expr instanceof VarExpression)) {
    return expr.get$name();
  }
  else {
    this._errorExpected('label');
    return null;
  }
}
lang_Parser.prototype.block$0 = lang_Parser.prototype.block;
// ********** Code for IncompleteSourceException **************
function IncompleteSourceException(token) {
  this.token = token;
  // Initializers done
}
IncompleteSourceException.prototype.toString = function() {
  if (this.token.get$span() == null) return ('Unexpected ' + this.token);
  return $assert_String(this.token.get$span().toMessageString(('Unexpected ' + this.token)));
}
IncompleteSourceException.prototype.toString$0 = IncompleteSourceException.prototype.toString;
// ********** Code for DivertedTokenSource **************
function DivertedTokenSource(tokens, parser, previousTokenizer) {
  this._lang_pos = 0
  this.tokens = tokens;
  this.parser = parser;
  this.previousTokenizer = previousTokenizer;
  // Initializers done
}
DivertedTokenSource.prototype.next = function() {
  var token = this.tokens.$index(this._lang_pos);
  ++this._lang_pos;
  if (this._lang_pos == this.tokens.length) {
    this.parser.tokenizer = this.previousTokenizer;
  }
  return token;
}
DivertedTokenSource.prototype.next$0 = DivertedTokenSource.prototype.next;
// ********** Code for lang_Node **************
function lang_Node(span) {
  this.span = span;
  // Initializers done
}
lang_Node.prototype.assert$lang_Node = function(){return this};
lang_Node.prototype.get$span = function() { return this.span; };
lang_Node.prototype.set$span = function(value) { return this.span = value; };
lang_Node.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for Definition **************
function Definition(span) {
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(Definition, lang_Statement);
Definition.prototype.assert$Definition = function(){return this};
Definition.prototype.get$typeParameters = function() {
  return null;
}
Definition.prototype.get$nativeType = function() {
  return null;
}
// ********** Code for lang_Statement **************
function lang_Statement(span) {
  // Initializers done
  lang_Node.call(this, span);
}
$inherits(lang_Statement, lang_Node);
lang_Statement.prototype.assert$lang_Statement = function(){return this};
// ********** Code for lang_Expression **************
function lang_Expression(span) {
  // Initializers done
  lang_Node.call(this, span);
}
$inherits(lang_Expression, lang_Node);
lang_Expression.prototype.assert$lang_Expression = function(){return this};
// ********** Code for TypeReference **************
function TypeReference(span, type) {
  this.type = type;
  // Initializers done
  lang_Node.call(this, span);
}
$inherits(TypeReference, lang_Node);
TypeReference.prototype.assert$TypeReference = function(){return this};
TypeReference.prototype.get$type = function() { return this.type; };
TypeReference.prototype.set$type = function(value) { return this.type = value; };
TypeReference.prototype.visit = function(visitor) {
  return visitor.visitTypeReference(this);
}
TypeReference.prototype.get$isFinal = function() {
  return false;
}
TypeReference.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for DirectiveDefinition **************
function DirectiveDefinition(name, arguments, span) {
  this.name = name;
  this.arguments = arguments;
  // Initializers done
  Definition.call(this, span);
}
$inherits(DirectiveDefinition, Definition);
DirectiveDefinition.prototype.get$name = function() { return this.name; };
DirectiveDefinition.prototype.set$name = function(value) { return this.name = value; };
DirectiveDefinition.prototype.get$arguments = function() { return this.arguments; };
DirectiveDefinition.prototype.set$arguments = function(value) { return this.arguments = value; };
DirectiveDefinition.prototype.visit = function(visitor) {
  return visitor.visitDirectiveDefinition(this);
}
DirectiveDefinition.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for TypeDefinition **************
function TypeDefinition(isClass, name, typeParameters, extendsTypes, implementsTypes, nativeType, factoryType, body, span) {
  this.isClass = isClass;
  this.name = name;
  this.typeParameters = typeParameters;
  this.extendsTypes = extendsTypes;
  this.implementsTypes = implementsTypes;
  this.nativeType = nativeType;
  this.factoryType = factoryType;
  this.body = body;
  // Initializers done
  Definition.call(this, span);
}
$inherits(TypeDefinition, Definition);
TypeDefinition.prototype.assert$TypeDefinition = function(){return this};
TypeDefinition.prototype.get$isClass = function() { return this.isClass; };
TypeDefinition.prototype.set$isClass = function(value) { return this.isClass = value; };
TypeDefinition.prototype.get$name = function() { return this.name; };
TypeDefinition.prototype.set$name = function(value) { return this.name = value; };
TypeDefinition.prototype.get$typeParameters = function() { return this.typeParameters; };
TypeDefinition.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
TypeDefinition.prototype.get$nativeType = function() { return this.nativeType; };
TypeDefinition.prototype.set$nativeType = function(value) { return this.nativeType = value; };
TypeDefinition.prototype.get$body = function() { return this.body; };
TypeDefinition.prototype.set$body = function(value) { return this.body = value; };
TypeDefinition.prototype.visit = function(visitor) {
  return visitor.visitTypeDefinition(this);
}
TypeDefinition.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for FunctionTypeDefinition **************
function FunctionTypeDefinition(func, typeParameters, span) {
  this.func = func;
  this.typeParameters = typeParameters;
  // Initializers done
  Definition.call(this, span);
}
$inherits(FunctionTypeDefinition, Definition);
FunctionTypeDefinition.prototype.get$func = function() { return this.func; };
FunctionTypeDefinition.prototype.set$func = function(value) { return this.func = value; };
FunctionTypeDefinition.prototype.get$typeParameters = function() { return this.typeParameters; };
FunctionTypeDefinition.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
FunctionTypeDefinition.prototype.visit = function(visitor) {
  return visitor.visitFunctionTypeDefinition(this);
}
FunctionTypeDefinition.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for VariableDefinition **************
function VariableDefinition(modifiers, type, names, values, span) {
  this.modifiers = modifiers;
  this.type = type;
  this.names = names;
  this.values = values;
  // Initializers done
  Definition.call(this, span);
}
$inherits(VariableDefinition, Definition);
VariableDefinition.prototype.get$type = function() { return this.type; };
VariableDefinition.prototype.set$type = function(value) { return this.type = value; };
VariableDefinition.prototype.get$names = function() { return this.names; };
VariableDefinition.prototype.set$names = function(value) { return this.names = value; };
VariableDefinition.prototype.get$values = function() { return this.values; };
VariableDefinition.prototype.set$values = function(value) { return this.values = value; };
VariableDefinition.prototype.visit = function(visitor) {
  return visitor.visitVariableDefinition(this);
}
VariableDefinition.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for FunctionDefinition **************
function FunctionDefinition(modifiers, returnType, name, formals, typeParameters, initializers, nativeBody, body, span) {
  this.modifiers = modifiers;
  this.returnType = returnType;
  this.name = name;
  this.formals = formals;
  this.typeParameters = typeParameters;
  this.initializers = initializers;
  this.nativeBody = nativeBody;
  this.body = body;
  // Initializers done
  Definition.call(this, span);
}
$inherits(FunctionDefinition, Definition);
FunctionDefinition.prototype.assert$FunctionDefinition = function(){return this};
FunctionDefinition.prototype.get$returnType = function() { return this.returnType; };
FunctionDefinition.prototype.set$returnType = function(value) { return this.returnType = value; };
FunctionDefinition.prototype.get$name = function() { return this.name; };
FunctionDefinition.prototype.set$name = function(value) { return this.name = value; };
FunctionDefinition.prototype.get$typeParameters = function() { return this.typeParameters; };
FunctionDefinition.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
FunctionDefinition.prototype.get$initializers = function() { return this.initializers; };
FunctionDefinition.prototype.set$initializers = function(value) { return this.initializers = value; };
FunctionDefinition.prototype.get$nativeBody = function() { return this.nativeBody; };
FunctionDefinition.prototype.set$nativeBody = function(value) { return this.nativeBody = value; };
FunctionDefinition.prototype.get$body = function() { return this.body; };
FunctionDefinition.prototype.set$body = function(value) { return this.body = value; };
FunctionDefinition.prototype.visit = function(visitor) {
  return visitor.visitFunctionDefinition(this);
}
FunctionDefinition.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for ReturnStatement **************
function ReturnStatement(value, span) {
  this.value = value;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(ReturnStatement, lang_Statement);
ReturnStatement.prototype.get$value = function() { return this.value; };
ReturnStatement.prototype.set$value = function(value) { return this.value = value; };
ReturnStatement.prototype.visit = function(visitor) {
  return visitor.visitReturnStatement(this);
}
ReturnStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for ThrowStatement **************
function ThrowStatement(value, span) {
  this.value = value;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(ThrowStatement, lang_Statement);
ThrowStatement.prototype.get$value = function() { return this.value; };
ThrowStatement.prototype.set$value = function(value) { return this.value = value; };
ThrowStatement.prototype.visit = function(visitor) {
  return visitor.visitThrowStatement(this);
}
ThrowStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for AssertStatement **************
function AssertStatement(test, span) {
  this.test = test;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(AssertStatement, lang_Statement);
AssertStatement.prototype.visit = function(visitor) {
  return visitor.visitAssertStatement(this);
}
AssertStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for BreakStatement **************
function BreakStatement(label, span) {
  this.label = label;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(BreakStatement, lang_Statement);
BreakStatement.prototype.get$label = function() { return this.label; };
BreakStatement.prototype.set$label = function(value) { return this.label = value; };
BreakStatement.prototype.visit = function(visitor) {
  return visitor.visitBreakStatement(this);
}
BreakStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for ContinueStatement **************
function ContinueStatement(label, span) {
  this.label = label;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(ContinueStatement, lang_Statement);
ContinueStatement.prototype.get$label = function() { return this.label; };
ContinueStatement.prototype.set$label = function(value) { return this.label = value; };
ContinueStatement.prototype.visit = function(visitor) {
  return visitor.visitContinueStatement(this);
}
ContinueStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for IfStatement **************
function IfStatement(test, trueBranch, falseBranch, span) {
  this.test = test;
  this.trueBranch = trueBranch;
  this.falseBranch = falseBranch;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(IfStatement, lang_Statement);
IfStatement.prototype.visit = function(visitor) {
  return visitor.visitIfStatement(this);
}
IfStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for WhileStatement **************
function WhileStatement(test, body, span) {
  this.test = test;
  this.body = body;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(WhileStatement, lang_Statement);
WhileStatement.prototype.get$body = function() { return this.body; };
WhileStatement.prototype.set$body = function(value) { return this.body = value; };
WhileStatement.prototype.visit = function(visitor) {
  return visitor.visitWhileStatement(this);
}
WhileStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for DoStatement **************
function DoStatement(body, test, span) {
  this.body = body;
  this.test = test;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(DoStatement, lang_Statement);
DoStatement.prototype.get$body = function() { return this.body; };
DoStatement.prototype.set$body = function(value) { return this.body = value; };
DoStatement.prototype.visit = function(visitor) {
  return visitor.visitDoStatement(this);
}
DoStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for ForStatement **************
function ForStatement(init, test, step, body, span) {
  this.init = init;
  this.test = test;
  this.step = step;
  this.body = body;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(ForStatement, lang_Statement);
ForStatement.prototype.get$body = function() { return this.body; };
ForStatement.prototype.set$body = function(value) { return this.body = value; };
ForStatement.prototype.visit = function(visitor) {
  return visitor.visitForStatement(this);
}
ForStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for ForInStatement **************
function ForInStatement(item, list, body, span) {
  this.item = item;
  this.list = list;
  this.body = body;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(ForInStatement, lang_Statement);
ForInStatement.prototype.get$body = function() { return this.body; };
ForInStatement.prototype.set$body = function(value) { return this.body = value; };
ForInStatement.prototype.visit = function(visitor) {
  return visitor.visitForInStatement(this);
}
ForInStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for TryStatement **************
function TryStatement(body, catches, finallyBlock, span) {
  this.body = body;
  this.catches = catches;
  this.finallyBlock = finallyBlock;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(TryStatement, lang_Statement);
TryStatement.prototype.get$body = function() { return this.body; };
TryStatement.prototype.set$body = function(value) { return this.body = value; };
TryStatement.prototype.visit = function(visitor) {
  return visitor.visitTryStatement(this);
}
TryStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for SwitchStatement **************
function SwitchStatement(test, cases, span) {
  this.test = test;
  this.cases = cases;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(SwitchStatement, lang_Statement);
SwitchStatement.prototype.get$cases = function() { return this.cases; };
SwitchStatement.prototype.set$cases = function(value) { return this.cases = value; };
SwitchStatement.prototype.visit = function(visitor) {
  return visitor.visitSwitchStatement(this);
}
SwitchStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for BlockStatement **************
function BlockStatement(body, span) {
  this.body = body;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(BlockStatement, lang_Statement);
BlockStatement.prototype.assert$BlockStatement = function(){return this};
BlockStatement.prototype.get$body = function() { return this.body; };
BlockStatement.prototype.set$body = function(value) { return this.body = value; };
BlockStatement.prototype.visit = function(visitor) {
  return visitor.visitBlockStatement(this);
}
BlockStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for LabeledStatement **************
function LabeledStatement(name, body, span) {
  this.name = name;
  this.body = body;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(LabeledStatement, lang_Statement);
LabeledStatement.prototype.get$name = function() { return this.name; };
LabeledStatement.prototype.set$name = function(value) { return this.name = value; };
LabeledStatement.prototype.get$body = function() { return this.body; };
LabeledStatement.prototype.set$body = function(value) { return this.body = value; };
LabeledStatement.prototype.visit = function(visitor) {
  return visitor.visitLabeledStatement(this);
}
LabeledStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for lang_ExpressionStatement **************
function lang_ExpressionStatement(body, span) {
  this.body = body;
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(lang_ExpressionStatement, lang_Statement);
lang_ExpressionStatement.prototype.get$body = function() { return this.body; };
lang_ExpressionStatement.prototype.set$body = function(value) { return this.body = value; };
lang_ExpressionStatement.prototype.visit = function(visitor) {
  return visitor.visitExpressionStatement(this);
}
lang_ExpressionStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for EmptyStatement **************
function EmptyStatement(span) {
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(EmptyStatement, lang_Statement);
EmptyStatement.prototype.visit = function(visitor) {
  return visitor.visitEmptyStatement(this);
}
EmptyStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for DietStatement **************
function DietStatement(span) {
  // Initializers done
  lang_Statement.call(this, span);
}
$inherits(DietStatement, lang_Statement);
DietStatement.prototype.visit = function(visitor) {
  return visitor.visitDietStatement(this);
}
DietStatement.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for LambdaExpression **************
function LambdaExpression(func, span) {
  this.func = func;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(LambdaExpression, lang_Expression);
LambdaExpression.prototype.assert$LambdaExpression = function(){return this};
LambdaExpression.prototype.get$func = function() { return this.func; };
LambdaExpression.prototype.set$func = function(value) { return this.func = value; };
LambdaExpression.prototype.visit = function(visitor) {
  return visitor.visitLambdaExpression(this);
}
LambdaExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for CallExpression **************
function CallExpression(target, arguments, span) {
  this.target = target;
  this.arguments = arguments;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(CallExpression, lang_Expression);
CallExpression.prototype.assert$CallExpression = function(){return this};
CallExpression.prototype.get$target = function() { return this.target; };
CallExpression.prototype.set$target = function(value) { return this.target = value; };
CallExpression.prototype.get$arguments = function() { return this.arguments; };
CallExpression.prototype.set$arguments = function(value) { return this.arguments = value; };
CallExpression.prototype.visit = function(visitor) {
  return visitor.visitCallExpression(this);
}
CallExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for IndexExpression **************
function IndexExpression(target, index, span) {
  this.target = target;
  this.index = index;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(IndexExpression, lang_Expression);
IndexExpression.prototype.assert$IndexExpression = function(){return this};
IndexExpression.prototype.get$target = function() { return this.target; };
IndexExpression.prototype.set$target = function(value) { return this.target = value; };
IndexExpression.prototype.visit = function(visitor) {
  return visitor.visitIndexExpression(this);
}
IndexExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for BinaryExpression **************
function BinaryExpression(op, x, y, span) {
  this.op = op;
  this.x = x;
  this.y = y;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(BinaryExpression, lang_Expression);
BinaryExpression.prototype.assert$BinaryExpression = function(){return this};
BinaryExpression.prototype.get$op = function() { return this.op; };
BinaryExpression.prototype.set$op = function(value) { return this.op = value; };
BinaryExpression.prototype.get$x = function() { return this.x; };
BinaryExpression.prototype.set$x = function(value) { return this.x = value; };
BinaryExpression.prototype.get$y = function() { return this.y; };
BinaryExpression.prototype.set$y = function(value) { return this.y = value; };
BinaryExpression.prototype.visit = function(visitor) {
  return visitor.visitBinaryExpression(this);
}
BinaryExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for UnaryExpression **************
function UnaryExpression(op, self, span) {
  this.op = op;
  this.self = self;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(UnaryExpression, lang_Expression);
UnaryExpression.prototype.assert$UnaryExpression = function(){return this};
UnaryExpression.prototype.get$op = function() { return this.op; };
UnaryExpression.prototype.set$op = function(value) { return this.op = value; };
UnaryExpression.prototype.get$self = function() { return this.self; };
UnaryExpression.prototype.set$self = function(value) { return this.self = value; };
UnaryExpression.prototype.visit = function(visitor) {
  return visitor.visitUnaryExpression(this);
}
UnaryExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for PostfixExpression **************
function PostfixExpression(body, op, span) {
  this.body = body;
  this.op = op;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(PostfixExpression, lang_Expression);
PostfixExpression.prototype.assert$PostfixExpression = function(){return this};
PostfixExpression.prototype.get$body = function() { return this.body; };
PostfixExpression.prototype.set$body = function(value) { return this.body = value; };
PostfixExpression.prototype.get$op = function() { return this.op; };
PostfixExpression.prototype.set$op = function(value) { return this.op = value; };
PostfixExpression.prototype.visit = function(visitor) {
  return visitor.visitPostfixExpression$1(this);
}
PostfixExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for lang_NewExpression **************
function lang_NewExpression(isConst, type, name, arguments, span) {
  this.isConst = isConst;
  this.type = type;
  this.name = name;
  this.arguments = arguments;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(lang_NewExpression, lang_Expression);
lang_NewExpression.prototype.get$isConst = function() { return this.isConst; };
lang_NewExpression.prototype.set$isConst = function(value) { return this.isConst = value; };
lang_NewExpression.prototype.get$type = function() { return this.type; };
lang_NewExpression.prototype.set$type = function(value) { return this.type = value; };
lang_NewExpression.prototype.get$name = function() { return this.name; };
lang_NewExpression.prototype.set$name = function(value) { return this.name = value; };
lang_NewExpression.prototype.get$arguments = function() { return this.arguments; };
lang_NewExpression.prototype.set$arguments = function(value) { return this.arguments = value; };
lang_NewExpression.prototype.visit = function(visitor) {
  return visitor.visitNewExpression(this);
}
lang_NewExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for ListExpression **************
function ListExpression(isConst, type, values, span) {
  this.isConst = isConst;
  this.type = type;
  this.values = values;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(ListExpression, lang_Expression);
ListExpression.prototype.get$isConst = function() { return this.isConst; };
ListExpression.prototype.set$isConst = function(value) { return this.isConst = value; };
ListExpression.prototype.get$type = function() { return this.type; };
ListExpression.prototype.set$type = function(value) { return this.type = value; };
ListExpression.prototype.get$values = function() { return this.values; };
ListExpression.prototype.set$values = function(value) { return this.values = value; };
ListExpression.prototype.visit = function(visitor) {
  return visitor.visitListExpression(this);
}
ListExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for MapExpression **************
function MapExpression(isConst, type, items, span) {
  this.isConst = isConst;
  this.type = type;
  this.items = items;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(MapExpression, lang_Expression);
MapExpression.prototype.get$isConst = function() { return this.isConst; };
MapExpression.prototype.set$isConst = function(value) { return this.isConst = value; };
MapExpression.prototype.get$type = function() { return this.type; };
MapExpression.prototype.set$type = function(value) { return this.type = value; };
MapExpression.prototype.visit = function(visitor) {
  return visitor.visitMapExpression(this);
}
MapExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for ConditionalExpression **************
function ConditionalExpression(test, trueBranch, falseBranch, span) {
  this.test = test;
  this.trueBranch = trueBranch;
  this.falseBranch = falseBranch;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(ConditionalExpression, lang_Expression);
ConditionalExpression.prototype.visit = function(visitor) {
  return visitor.visitConditionalExpression(this);
}
ConditionalExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for IsExpression **************
function IsExpression(isTrue, x, type, span) {
  this.isTrue = isTrue;
  this.x = x;
  this.type = type;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(IsExpression, lang_Expression);
IsExpression.prototype.get$x = function() { return this.x; };
IsExpression.prototype.set$x = function(value) { return this.x = value; };
IsExpression.prototype.get$type = function() { return this.type; };
IsExpression.prototype.set$type = function(value) { return this.type = value; };
IsExpression.prototype.visit = function(visitor) {
  return visitor.visitIsExpression(this);
}
IsExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for ParenExpression **************
function ParenExpression(body, span) {
  this.body = body;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(ParenExpression, lang_Expression);
ParenExpression.prototype.get$body = function() { return this.body; };
ParenExpression.prototype.set$body = function(value) { return this.body = value; };
ParenExpression.prototype.visit = function(visitor) {
  return visitor.visitParenExpression(this);
}
ParenExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for DotExpression **************
function DotExpression(self, name, span) {
  this.self = self;
  this.name = name;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(DotExpression, lang_Expression);
DotExpression.prototype.assert$DotExpression = function(){return this};
DotExpression.prototype.get$self = function() { return this.self; };
DotExpression.prototype.set$self = function(value) { return this.self = value; };
DotExpression.prototype.get$name = function() { return this.name; };
DotExpression.prototype.set$name = function(value) { return this.name = value; };
DotExpression.prototype.visit = function(visitor) {
  return visitor.visitDotExpression(this);
}
DotExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for VarExpression **************
function VarExpression(name, span) {
  this.name = name;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(VarExpression, lang_Expression);
VarExpression.prototype.assert$VarExpression = function(){return this};
VarExpression.prototype.get$name = function() { return this.name; };
VarExpression.prototype.set$name = function(value) { return this.name = value; };
VarExpression.prototype.visit = function(visitor) {
  return visitor.visitVarExpression(this);
}
VarExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for ThisExpression **************
function ThisExpression(span) {
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(ThisExpression, lang_Expression);
ThisExpression.prototype.visit = function(visitor) {
  return visitor.visitThisExpression(this);
}
ThisExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for SuperExpression **************
function SuperExpression(span) {
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(SuperExpression, lang_Expression);
SuperExpression.prototype.visit = function(visitor) {
  return visitor.visitSuperExpression(this);
}
SuperExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for NullExpression **************
function NullExpression(span) {
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(NullExpression, lang_Expression);
NullExpression.prototype.visit = function(visitor) {
  return visitor.visitNullExpression(this);
}
NullExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for LiteralExpression **************
function LiteralExpression(value, type, text, span) {
  this.value = value;
  this.type = type;
  this.text = text;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(LiteralExpression, lang_Expression);
LiteralExpression.prototype.get$value = function() { return this.value; };
LiteralExpression.prototype.set$value = function(value) { return this.value = value; };
LiteralExpression.prototype.get$type = function() { return this.type; };
LiteralExpression.prototype.set$type = function(value) { return this.type = value; };
LiteralExpression.prototype.get$text = function() { return this.text; };
LiteralExpression.prototype.set$text = function(value) { return this.text = value; };
LiteralExpression.prototype.visit = function(visitor) {
  return visitor.visitLiteralExpression(this);
}
LiteralExpression.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for NameTypeReference **************
function NameTypeReference(isFinal, name, names, span) {
  this.isFinal = isFinal;
  this.name = name;
  this.names = names;
  // Initializers done
  TypeReference.call(this, span);
}
$inherits(NameTypeReference, TypeReference);
NameTypeReference.prototype.assert$NameTypeReference = function(){return this};
NameTypeReference.prototype.get$isFinal = function() { return this.isFinal; };
NameTypeReference.prototype.set$isFinal = function(value) { return this.isFinal = value; };
NameTypeReference.prototype.get$name = function() { return this.name; };
NameTypeReference.prototype.set$name = function(value) { return this.name = value; };
NameTypeReference.prototype.get$names = function() { return this.names; };
NameTypeReference.prototype.set$names = function(value) { return this.names = value; };
NameTypeReference.prototype.visit = function(visitor) {
  return visitor.visitNameTypeReference(this);
}
NameTypeReference.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for GenericTypeReference **************
function GenericTypeReference(baseType, typeArguments, depth, span) {
  this.baseType = baseType;
  this.typeArguments = typeArguments;
  this.depth = depth;
  // Initializers done
  TypeReference.call(this, span);
}
$inherits(GenericTypeReference, TypeReference);
GenericTypeReference.prototype.assert$GenericTypeReference = function(){return this};
GenericTypeReference.prototype.get$baseType = function() { return this.baseType; };
GenericTypeReference.prototype.set$baseType = function(value) { return this.baseType = value; };
GenericTypeReference.prototype.get$depth = function() { return this.depth; };
GenericTypeReference.prototype.set$depth = function(value) { return this.depth = value; };
GenericTypeReference.prototype.visit = function(visitor) {
  return visitor.visitGenericTypeReference(this);
}
GenericTypeReference.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for FunctionTypeReference **************
function FunctionTypeReference(isFinal, func, span) {
  this.isFinal = isFinal;
  this.func = func;
  // Initializers done
  TypeReference.call(this, span);
}
$inherits(FunctionTypeReference, TypeReference);
FunctionTypeReference.prototype.assert$FunctionTypeReference = function(){return this};
FunctionTypeReference.prototype.get$isFinal = function() { return this.isFinal; };
FunctionTypeReference.prototype.set$isFinal = function(value) { return this.isFinal = value; };
FunctionTypeReference.prototype.get$func = function() { return this.func; };
FunctionTypeReference.prototype.set$func = function(value) { return this.func = value; };
FunctionTypeReference.prototype.visit = function(visitor) {
  return visitor.visitFunctionTypeReference(this);
}
FunctionTypeReference.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for ArgumentNode **************
function ArgumentNode(label, value, span) {
  this.label = label;
  this.value = value;
  // Initializers done
  lang_Node.call(this, span);
}
$inherits(ArgumentNode, lang_Node);
ArgumentNode.prototype.assert$ArgumentNode = function(){return this};
ArgumentNode.prototype.get$label = function() { return this.label; };
ArgumentNode.prototype.set$label = function(value) { return this.label = value; };
ArgumentNode.prototype.get$value = function() { return this.value; };
ArgumentNode.prototype.set$value = function(value) { return this.value = value; };
ArgumentNode.prototype.visit = function(visitor) {
  return visitor.visitArgumentNode(this);
}
ArgumentNode.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for FormalNode **************
function FormalNode(isThis, isRest, type, name, value, span) {
  this.isThis = isThis;
  this.isRest = isRest;
  this.type = type;
  this.name = name;
  this.value = value;
  // Initializers done
  lang_Node.call(this, span);
}
$inherits(FormalNode, lang_Node);
FormalNode.prototype.get$type = function() { return this.type; };
FormalNode.prototype.set$type = function(value) { return this.type = value; };
FormalNode.prototype.get$name = function() { return this.name; };
FormalNode.prototype.set$name = function(value) { return this.name = value; };
FormalNode.prototype.get$value = function() { return this.value; };
FormalNode.prototype.set$value = function(value) { return this.value = value; };
FormalNode.prototype.visit = function(visitor) {
  return visitor.visitFormalNode(this);
}
FormalNode.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for CatchNode **************
function CatchNode(exception, trace, body, span) {
  this.exception = exception;
  this.trace = trace;
  this.body = body;
  // Initializers done
  lang_Node.call(this, span);
}
$inherits(CatchNode, lang_Node);
CatchNode.prototype.get$exception = function() { return this.exception; };
CatchNode.prototype.set$exception = function(value) { return this.exception = value; };
CatchNode.prototype.get$trace = function() { return this.trace; };
CatchNode.prototype.set$trace = function(value) { return this.trace = value; };
CatchNode.prototype.get$body = function() { return this.body; };
CatchNode.prototype.set$body = function(value) { return this.body = value; };
CatchNode.prototype.visit = function(visitor) {
  return visitor.visitCatchNode(this);
}
CatchNode.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for CaseNode **************
function CaseNode(label, cases, statements, span) {
  this.label = label;
  this.cases = cases;
  this.statements = statements;
  // Initializers done
  lang_Node.call(this, span);
}
$inherits(CaseNode, lang_Node);
CaseNode.prototype.get$label = function() { return this.label; };
CaseNode.prototype.set$label = function(value) { return this.label = value; };
CaseNode.prototype.get$cases = function() { return this.cases; };
CaseNode.prototype.set$cases = function(value) { return this.cases = value; };
CaseNode.prototype.get$statements = function() { return this.statements; };
CaseNode.prototype.set$statements = function(value) { return this.statements = value; };
CaseNode.prototype.visit = function(visitor) {
  return visitor.visitCaseNode(this);
}
CaseNode.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for TypeParameter **************
function TypeParameter(name, extendsType, span) {
  this.name = name;
  this.extendsType = extendsType;
  // Initializers done
  lang_Node.call(this, span);
}
$inherits(TypeParameter, lang_Node);
TypeParameter.prototype.get$name = function() { return this.name; };
TypeParameter.prototype.set$name = function(value) { return this.name = value; };
TypeParameter.prototype.get$extendsType = function() { return this.extendsType; };
TypeParameter.prototype.set$extendsType = function(value) { return this.extendsType = value; };
TypeParameter.prototype.visit = function(visitor) {
  return visitor.visitTypeParameter(this);
}
TypeParameter.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for lang_Identifier **************
function lang_Identifier(name, span) {
  this.name = name;
  // Initializers done
  lang_Node.call(this, span);
}
$inherits(lang_Identifier, lang_Node);
lang_Identifier.prototype.assert$lang_Identifier = function(){return this};
lang_Identifier.prototype.get$name = function() { return this.name; };
lang_Identifier.prototype.set$name = function(value) { return this.name = value; };
lang_Identifier.prototype.visit = function(visitor) {
  return visitor.visitIdentifier(this);
}
lang_Identifier.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for DeclaredIdentifier **************
function DeclaredIdentifier(type, name, span) {
  this.type = type;
  this.name = name;
  // Initializers done
  lang_Expression.call(this, span);
}
$inherits(DeclaredIdentifier, lang_Expression);
DeclaredIdentifier.prototype.assert$DeclaredIdentifier = function(){return this};
DeclaredIdentifier.prototype.get$type = function() { return this.type; };
DeclaredIdentifier.prototype.set$type = function(value) { return this.type = value; };
DeclaredIdentifier.prototype.get$name = function() { return this.name; };
DeclaredIdentifier.prototype.set$name = function(value) { return this.name = value; };
DeclaredIdentifier.prototype.visit = function(visitor) {
  return visitor.visitDeclaredIdentifier(this);
}
DeclaredIdentifier.prototype.visit$1 = function($0) {
  return this.visit(($0 == null ? null : $0.assert$TreeVisitor()));
};
// ********** Code for lang_Type **************
function lang_Type(name) {
  this.isTested = false
  this.isChecked = false
  this._resolvedMembers = $map([]);
  this.varStubs = $map([]);
  // Initializers done
  lang_Element.call(this, name, null);
}
$inherits(lang_Type, lang_Element);
lang_Type.prototype.assert$lang_Type = function(){return this};
lang_Type.prototype.get$isTested = function() { return this.isTested; };
lang_Type.prototype.set$isTested = function(value) { return this.isTested = value; };
lang_Type.prototype.get$typeCheckCode = function() { return this.typeCheckCode; };
lang_Type.prototype.set$typeCheckCode = function(value) { return this.typeCheckCode = value; };
lang_Type.prototype.get$varStubs = function() { return this.varStubs; };
lang_Type.prototype.set$varStubs = function(value) { return this.varStubs = value; };
lang_Type.prototype.markUsed = function() {

}
lang_Type.prototype.get$typeMember = function() {
  var $0;
  if (this._typeMember == null) {
    this._typeMember = new TypeMember((this == null ? null : this.assert$DefinedType()));
  }
  return (($0 = this._typeMember) == null ? null : $0.assert$TypeMember());
}
lang_Type.prototype.getMember = function(name) {
  return null;
}
lang_Type.prototype.get$subtypes = function() {
  return null;
}
lang_Type.prototype.get$isVar = function() {
  return false;
}
lang_Type.prototype.get$isTop = function() {
  return false;
}
lang_Type.prototype.get$isObject = function() {
  return false;
}
lang_Type.prototype.get$isString = function() {
  return false;
}
lang_Type.prototype.get$isBool = function() {
  return false;
}
lang_Type.prototype.get$isFunction = function() {
  return false;
}
lang_Type.prototype.get$isList = function() {
  return false;
}
lang_Type.prototype.get$isNum = function() {
  return false;
}
lang_Type.prototype.get$isVoid = function() {
  return false;
}
lang_Type.prototype.get$isNullable = function() {
  return true;
}
lang_Type.prototype.get$isVarOrFunction = function() {
  return $notnull_bool(this.get$isVar()) || $notnull_bool(this.get$isFunction());
}
lang_Type.prototype.get$isVarOrObject = function() {
  return $notnull_bool(this.get$isVar()) || $notnull_bool(this.get$isObject());
}
lang_Type.prototype.getCallMethod = function() {
  return null;
}
lang_Type.prototype.get$isClosed = function() {
  return $notnull_bool(this.get$isString()) || $notnull_bool(this.get$isBool()) || $notnull_bool(this.get$isNum()) || $notnull_bool(this.get$isFunction()) || $notnull_bool(this.get$isVar());
}
lang_Type.prototype.get$isUsed = function() {
  return false;
}
lang_Type.prototype.get$isGeneric = function() {
  return false;
}
lang_Type.prototype.get$isHiddenNativeType = function() {
  return false;
}
lang_Type.prototype.get$hasTypeParams = function() {
  return false;
}
lang_Type.prototype.get$typeofName = function() {
  return null;
}
lang_Type.prototype.get$members = function() {
  return null;
}
lang_Type.prototype.get$definition = function() {
  return null;
}
lang_Type.prototype.get$factories = function() {
  return null;
}
lang_Type.prototype.get$typeArgsInOrder = function() {
  return null;
}
lang_Type.prototype.get$genericType = function() {
  return (this == null ? null : this.assert$DefinedType());
}
lang_Type.prototype.get$interfaces = function() {
  return null;
}
lang_Type.prototype.get$parent = function() {
  return null;
}
lang_Type.prototype.getAllMembers = function() {
  return $map([]);
}
lang_Type.prototype.get$hasNativeSubtypes = function() {
  if (this._hasNativeSubtypes == null) {
    this._hasNativeSubtypes = this.get$subtypes().some((function (t) {
      return t.get$isNative();
    })
    );
  }
  return this._hasNativeSubtypes;
}
lang_Type.prototype._checkOverride = function(member) {
  var parentMember = this._getMemberInParents(member.name);
  if ($notnull_bool($ne(parentMember, null))) {
    if (!$notnull_bool(member.get$isPrivate()) || $eq(member.get$library(), parentMember.get$library())) {
      member.override((parentMember == null ? null : parentMember.assert$Member()));
    }
  }
}
lang_Type.prototype._createNotEqualMember = function() {
  var $0;
  var eq = (($0 = this.get$members().$index('\$eq')) == null ? null : $0.assert$MethodMember());
  if (eq == null) {
    $globals.world.internalError('INTERNAL: object does not define ==', this.get$definition().span);
  }
  var ne = new MethodMember('\$ne', this, eq.definition);
  ne.isGenerated = true;
  ne.returnType = eq.returnType;
  ne.parameters = eq.parameters;
  ne.isStatic = eq.isStatic;
  ne.isAbstract = eq.isAbstract;
  return ne;
}
lang_Type.prototype._getMemberInParents = function(memberName) {
  if ($notnull_bool(this.get$isClass())) {
    if (this.get$parent() != null) {
      return this.get$parent().getMember(memberName);
    }
    else if ($notnull_bool(this.get$isObject())) {
      if (memberName == '\$ne') {
        var ret = this._createNotEqualMember();
        this.get$members().$setindex(memberName, ret);
        return (ret == null ? null : ret.assert$Member());
      }
      return null;
    }
  }
  else {
    if (this.get$interfaces() != null && this.get$interfaces().length > 0) {
      var $list = this.get$interfaces();
      for (var $i = 0;$i < $list.length; $i++) {
        var i = $list.$index($i);
        var ret = i.getMember$1(memberName);
        if ($notnull_bool($ne(ret, null))) {
          return (ret == null ? null : ret.assert$Member());
        }
      }
      return null;
    }
    else {
      return $globals.world.objectType.getMember(memberName);
    }
  }
}
lang_Type.prototype.resolveMember = function(memberName) {
  var $0;
  var ret = (($0 = this._resolvedMembers.$index(memberName)) == null ? null : $0.assert$MemberSet());
  if (ret != null) return ret;
  var member = this.getMember(memberName);
  if (member == null) {
    return null;
  }
  ret = new MemberSet(member, false);
  this._resolvedMembers.$setindex(memberName, ret);
  if ($notnull_bool(member.get$isStatic())) {
    return ret;
  }
  else {
    var $list = this.get$subtypes();
    for (var $i = this.get$subtypes().iterator(); $i.hasNext$0(); ) {
      var t = $i.next$0();
      if (!$notnull_bool(this.get$isClass()) && $notnull_bool(t.get$isClass())) {
        var m = t.getMember$1(memberName);
        if ($notnull_bool($ne(m, null)) && ret.members.indexOf(m) == -1) {
          ret.add((m == null ? null : m.assert$Member()));
        }
      }
      else {
        var m = t.get$members().$index(memberName);
        if ($notnull_bool($ne(m, null))) ret.add((m == null ? null : m.assert$Member()));
      }
    }
    return ret;
  }
}
lang_Type.prototype.ensureSubtypeOf = function(other, span, typeErrors) {
  if (!$notnull_bool(this.isSubtypeOf(other))) {
    var msg = ('type ' + this.name + ' is not a subtype of ' + other.name);
    if ($notnull_bool(typeErrors)) {
      $globals.world.error($assert_String(msg), span);
    }
    else {
      $globals.world.warning($assert_String(msg), span);
    }
  }
}
lang_Type.prototype.needsVarCall = function(args) {
  if ($notnull_bool(this.get$isVarOrFunction())) {
    return true;
  }
  var call = this.getCallMethod();
  if ($notnull_bool($ne(call, null))) {
    if (args.get$length() != call.get$parameters().length || !$notnull_bool(call.namesInOrder$1(args))) {
      return true;
    }
  }
  return false;
}
lang_Type.union = function(x, y) {
  if ($eq(x, y)) return x;
  if ($notnull_bool(x.get$isNum()) && $notnull_bool(y.get$isNum())) return $globals.world.numType;
  if ($notnull_bool(x.get$isString()) && $notnull_bool(y.get$isString())) return $globals.world.stringType;
  return $globals.world.varType;
}
lang_Type.prototype.isAssignable = function(other) {
  return $notnull_bool(this.isSubtypeOf(other)) || $notnull_bool(other.isSubtypeOf(this));
}
lang_Type.prototype._isDirectSupertypeOf = function(other) {
  var $this = this; // closure support
  if ($notnull_bool(other.get$isClass())) {
    return $eq(other.get$parent(), this) || $notnull_bool(this.get$isObject()) && other.get$parent() == null;
  }
  else {
    if (other.get$interfaces() == null || other.get$interfaces().isEmpty()) {
      return this.get$isObject();
    }
    else {
      return other.get$interfaces().some((function (i) {
        return $eq(i, $this);
      })
      );
    }
  }
}
lang_Type.prototype.isSubtypeOf = function(other) {
  if ((other instanceof ParameterType)) {
    return true;
  }
  if ($eq(this, other)) return true;
  if ($notnull_bool(this.get$isVar())) return true;
  if ($notnull_bool(other.get$isVar())) return true;
  if ($notnull_bool(other._isDirectSupertypeOf(this))) return true;
  var call = this.getCallMethod();
  var otherCall = other.getCallMethod();
  if ($notnull_bool($ne(call, null)) && $notnull_bool($ne(otherCall, null))) {
    return lang_Type._isFunctionSubtypeOf((call == null ? null : call.assert$MethodMember()), (otherCall == null ? null : otherCall.assert$MethodMember()));
  }
  if ($eq(this.get$genericType(), other.get$genericType()) && $notnull_bool($ne(this.get$typeArgsInOrder(), null)) && $notnull_bool($ne(other.get$typeArgsInOrder(), null)) && $notnull_bool($eq(this.get$typeArgsInOrder().length, other.get$typeArgsInOrder().length))) {
    var t = this.get$typeArgsInOrder().iterator$0();
    var s = other.get$typeArgsInOrder().iterator$0();
    while ($notnull_bool(t.hasNext$0())) {
      if (!$notnull_bool(t.next$0().isSubtypeOf$1(s.next$0()))) return false;
    }
    return true;
  }
  if (this.get$parent() != null && $notnull_bool(this.get$parent().isSubtypeOf(other))) {
    return true;
  }
  if (this.get$interfaces() != null && this.get$interfaces().some((function (i) {
    return i.isSubtypeOf$1(other);
  })
  )) {
    return true;
  }
  return false;
}
lang_Type._isFunctionSubtypeOf = function(t, s) {
  var $0;
  if (!$notnull_bool(s.returnType.get$isVoid()) && !$notnull_bool(s.returnType.isAssignable(t.returnType))) {
    return false;
  }
  var tp = t.parameters;
  var sp = s.parameters;
  if (tp.length < $assert_num(sp.length)) return false;
  for (var i = 0;
   i < $assert_num(sp.length); i++) {
    if ($notnull_bool($ne(tp.$index(i).get$isOptional(), sp.$index(i).get$isOptional()))) return false;
    if ($notnull_bool(tp.$index(i).get$isOptional()) && $notnull_bool($ne(tp.$index(i).get$name(), sp.$index(i).get$name()))) return false;
    if (!$notnull_bool(tp.$index(i).get$type().isAssignable$1(sp.$index(i).get$type()))) return false;
  }
  if (tp.length > $assert_num(sp.length) && !$notnull_bool(tp.$index(sp.length).get$isOptional())) return false;
  return true;
}
lang_Type.prototype.addDirectSubtype$1 = function($0) {
  return this.addDirectSubtype(($0 == null ? null : $0.assert$lang_Type()));
};
lang_Type.prototype.ensureSubtypeOf$3 = function($0, $1, $2) {
  return this.ensureSubtypeOf(($0 == null ? null : $0.assert$lang_Type()), ($1 == null ? null : $1.assert$SourceSpan()), $assert_bool($2));
};
lang_Type.prototype.getConstructor$1 = function($0) {
  return this.getConstructor($assert_String($0));
};
lang_Type.prototype.getFactory$2 = function($0, $1) {
  return this.getFactory(($0 == null ? null : $0.assert$lang_Type()), $assert_String($1));
};
lang_Type.prototype.getMember$1 = function($0) {
  return this.getMember($assert_String($0));
};
lang_Type.prototype.getOrMakeConcreteType$1 = function($0) {
  return this.getOrMakeConcreteType(($0 == null ? null : $0.assert$List_Type()));
};
lang_Type.prototype.isAssignable$1 = function($0) {
  return this.isAssignable(($0 == null ? null : $0.assert$lang_Type()));
};
lang_Type.prototype.isString$0 = function() {
  return this.get$isString()();
};
lang_Type.prototype.isSubtypeOf$1 = function($0) {
  return this.isSubtypeOf(($0 == null ? null : $0.assert$lang_Type()));
};
lang_Type.prototype.markUsed$0 = lang_Type.prototype.markUsed;
lang_Type.prototype.resolveMember$1 = function($0) {
  return this.resolveMember($assert_String($0));
};
lang_Type.prototype.resolveTypeParams$1 = function($0) {
  return this.resolveTypeParams(($0 == null ? null : $0.assert$ConcreteType()));
};
// ********** Code for ParameterType **************
function ParameterType(name, typeParameter) {
  this.typeParameter = typeParameter;
  // Initializers done
  lang_Type.call(this, name);
}
$inherits(ParameterType, lang_Type);
ParameterType.prototype.assert$ParameterType = function(){return this};
ParameterType.prototype.get$typeParameter = function() { return this.typeParameter; };
ParameterType.prototype.set$typeParameter = function(value) { return this.typeParameter = value; };
ParameterType.prototype.get$extendsType = function() { return this.extendsType; };
ParameterType.prototype.set$extendsType = function(value) { return this.extendsType = value; };
ParameterType.prototype.get$isClass = function() {
  return false;
}
ParameterType.prototype.get$library = function() {
  return null;
}
ParameterType.prototype.get$span = function() {
  return this.typeParameter.span;
}
ParameterType.prototype.get$constructors = function() {
  $globals.world.internalError('no constructors on type parameters yet');
}
ParameterType.prototype.getCallMethod = function() {
  return this.extendsType.getCallMethod();
}
ParameterType.prototype.genMethod = function(method) {
  this.extendsType.genMethod(method);
}
ParameterType.prototype.isSubtypeOf = function(other) {
  return true;
}
ParameterType.prototype.resolveMember = function(memberName) {
  return this.extendsType.resolveMember(memberName);
}
ParameterType.prototype.getConstructor = function(constructorName) {
  $globals.world.internalError('no constructors on type parameters yet');
}
ParameterType.prototype.getOrMakeConcreteType = function(typeArgs) {
  $globals.world.internalError('no concrete types of type parameters yet', this.get$span());
}
ParameterType.prototype.resolveTypeParams = function(inType) {
  var $0;
  return (($0 = inType.typeArguments.$index(this.name)) == null ? null : $0.assert$lang_Type());
}
ParameterType.prototype.addDirectSubtype = function(type) {
  $globals.world.internalError('no subtypes of type parameters yet', this.get$span());
}
ParameterType.prototype.resolve = function() {
  if (this.typeParameter.extendsType != null) {
    this.extendsType = this.get$enclosingElement().resolveType(this.typeParameter.extendsType, true);
  }
  else {
    this.extendsType = $globals.world.objectType;
  }
}
ParameterType.prototype.addDirectSubtype$1 = function($0) {
  return this.addDirectSubtype(($0 == null ? null : $0.assert$lang_Type()));
};
ParameterType.prototype.getConstructor$1 = function($0) {
  return this.getConstructor($assert_String($0));
};
ParameterType.prototype.getOrMakeConcreteType$1 = function($0) {
  return this.getOrMakeConcreteType(($0 == null ? null : $0.assert$List_Type()));
};
ParameterType.prototype.isSubtypeOf$1 = function($0) {
  return this.isSubtypeOf(($0 == null ? null : $0.assert$lang_Type()));
};
ParameterType.prototype.resolve$0 = ParameterType.prototype.resolve;
ParameterType.prototype.resolveMember$1 = function($0) {
  return this.resolveMember($assert_String($0));
};
ParameterType.prototype.resolveTypeParams$1 = function($0) {
  return this.resolveTypeParams(($0 == null ? null : $0.assert$ConcreteType()));
};
// ********** Code for NonNullableType **************
function NonNullableType(type) {
  this.type = type;
  // Initializers done
  lang_Type.call(this, type.name);
}
$inherits(NonNullableType, lang_Type);
NonNullableType.prototype.get$type = function() { return this.type; };
NonNullableType.prototype.get$isNullable = function() {
  return false;
}
NonNullableType.prototype.get$isBool = function() {
  return this.type.get$isBool();
}
NonNullableType.prototype.get$isUsed = function() {
  return false;
}
NonNullableType.prototype.isSubtypeOf = function(other) {
  return $eq(this, other) || $eq(this.type, other) || $notnull_bool(this.type.isSubtypeOf(other));
}
NonNullableType.prototype.resolveType = function(node, isRequired) {
  return this.type.resolveType(node, isRequired);
}
NonNullableType.prototype.resolveTypeParams = function(inType) {
  return this.type.resolveTypeParams(inType);
}
NonNullableType.prototype.addDirectSubtype = function(subtype) {
  this.type.addDirectSubtype(subtype);
}
NonNullableType.prototype.markUsed = function() {
  this.type.markUsed();
}
NonNullableType.prototype.genMethod = function(method) {
  this.type.genMethod(method);
}
NonNullableType.prototype.get$span = function() {
  return this.type.get$span();
}
NonNullableType.prototype.resolveMember = function(name) {
  return this.type.resolveMember(name);
}
NonNullableType.prototype.getMember = function(name) {
  return this.type.getMember(name);
}
NonNullableType.prototype.getConstructor = function(name) {
  var $0;
  return (($0 = this.type.getConstructor(name)) == null ? null : $0.assert$MethodMember());
}
NonNullableType.prototype.getFactory = function(t, name) {
  var $0;
  return (($0 = this.type.getFactory(t, name)) == null ? null : $0.assert$MethodMember());
}
NonNullableType.prototype.getOrMakeConcreteType = function(typeArgs) {
  return this.type.getOrMakeConcreteType(typeArgs);
}
NonNullableType.prototype.get$constructors = function() {
  return this.type.get$constructors();
}
NonNullableType.prototype.get$isClass = function() {
  return this.type.get$isClass();
}
NonNullableType.prototype.get$library = function() {
  return this.type.get$library();
}
NonNullableType.prototype.getCallMethod = function() {
  return this.type.getCallMethod();
}
NonNullableType.prototype.get$isGeneric = function() {
  return this.type.get$isGeneric();
}
NonNullableType.prototype.get$hasTypeParams = function() {
  return this.type.get$hasTypeParams();
}
NonNullableType.prototype.get$typeofName = function() {
  return this.type.get$typeofName();
}
NonNullableType.prototype.get$jsname = function() {
  return this.type.get$jsname();
}
NonNullableType.prototype.get$members = function() {
  return this.type.get$members();
}
NonNullableType.prototype.get$definition = function() {
  return this.type.get$definition();
}
NonNullableType.prototype.get$factories = function() {
  return this.type.get$factories();
}
NonNullableType.prototype.get$typeArgsInOrder = function() {
  var $0;
  return (($0 = this.type.get$typeArgsInOrder()) == null ? null : $0.assert$Collection_Type());
}
NonNullableType.prototype.get$genericType = function() {
  return this.type.get$genericType();
}
NonNullableType.prototype.get$interfaces = function() {
  return this.type.get$interfaces();
}
NonNullableType.prototype.get$parent = function() {
  return this.type.get$parent();
}
NonNullableType.prototype.getAllMembers = function() {
  return this.type.getAllMembers();
}
NonNullableType.prototype.get$isNative = function() {
  return this.type.get$isNative();
}
NonNullableType.prototype.addDirectSubtype$1 = function($0) {
  return this.addDirectSubtype(($0 == null ? null : $0.assert$lang_Type()));
};
NonNullableType.prototype.getConstructor$1 = function($0) {
  return this.getConstructor($assert_String($0));
};
NonNullableType.prototype.getFactory$2 = function($0, $1) {
  return this.getFactory(($0 == null ? null : $0.assert$lang_Type()), $assert_String($1));
};
NonNullableType.prototype.getMember$1 = function($0) {
  return this.getMember($assert_String($0));
};
NonNullableType.prototype.getOrMakeConcreteType$1 = function($0) {
  return this.getOrMakeConcreteType(($0 == null ? null : $0.assert$List_Type()));
};
NonNullableType.prototype.isSubtypeOf$1 = function($0) {
  return this.isSubtypeOf(($0 == null ? null : $0.assert$lang_Type()));
};
NonNullableType.prototype.markUsed$0 = NonNullableType.prototype.markUsed;
NonNullableType.prototype.resolveMember$1 = function($0) {
  return this.resolveMember($assert_String($0));
};
NonNullableType.prototype.resolveTypeParams$1 = function($0) {
  return this.resolveTypeParams(($0 == null ? null : $0.assert$ConcreteType()));
};
// ********** Code for ConcreteType **************
function ConcreteType(name, genericType, typeArguments, typeArgsInOrder) {
  this.genericType = genericType;
  this.typeArguments = typeArguments;
  this.typeArgsInOrder = typeArgsInOrder;
  this.constructors = $map([]);
  this.members = $map([]);
  this.factories = new FactoryMap();
  // Initializers done
  lang_Type.call(this, name);
}
$inherits(ConcreteType, lang_Type);
ConcreteType.prototype.assert$ConcreteType = function(){return this};
ConcreteType.prototype.get$genericType = function() { return this.genericType; };
ConcreteType.prototype.get$typeArgsInOrder = function() { return this.typeArgsInOrder; };
ConcreteType.prototype.set$typeArgsInOrder = function(value) { return this.typeArgsInOrder = value; };
ConcreteType.prototype.get$isList = function() {
  return this.genericType.get$isList();
}
ConcreteType.prototype.get$isClass = function() {
  return this.genericType.isClass;
}
ConcreteType.prototype.get$library = function() {
  return this.genericType.library;
}
ConcreteType.prototype.get$span = function() {
  return this.genericType.get$span();
}
ConcreteType.prototype.get$hasTypeParams = function() {
  return $assert_bool(this.typeArguments.getValues().some$1((function (e) {
    return (e instanceof ParameterType);
  })
  ));
}
ConcreteType.prototype.get$members = function() { return this.members; };
ConcreteType.prototype.set$members = function(value) { return this.members = value; };
ConcreteType.prototype.get$constructors = function() { return this.constructors; };
ConcreteType.prototype.set$constructors = function(value) { return this.constructors = value; };
ConcreteType.prototype.get$factories = function() { return this.factories; };
ConcreteType.prototype.set$factories = function(value) { return this.factories = value; };
ConcreteType.prototype.resolveTypeParams = function(inType) {
  var newTypeArgs = [];
  var needsNewType = false;
  var $list = this.typeArgsInOrder;
  for (var $i = 0;$i < $list.length; $i++) {
    var t = $list.$index($i);
    var newType = t.resolveTypeParams$1(inType);
    if ($notnull_bool($ne(newType, t))) needsNewType = true;
    newTypeArgs.add$1(newType);
  }
  if (!$notnull_bool(needsNewType)) return this;
  return this.genericType.getOrMakeConcreteType((newTypeArgs == null ? null : newTypeArgs.assert$List_Type()));
}
ConcreteType.prototype.getOrMakeConcreteType = function(typeArgs) {
  return this.genericType.getOrMakeConcreteType(typeArgs);
}
ConcreteType.prototype.get$parent = function() {
  if (this._parent == null && this.genericType.get$parent() != null) {
    this._parent = this.genericType.get$parent().resolveTypeParams(this);
  }
  return this._parent;
}
ConcreteType.prototype.get$interfaces = function() {
  if (this._interfaces == null && this.genericType.interfaces != null) {
    this._interfaces = [];
    var $list = this.genericType.interfaces;
    for (var $i = 0;$i < $list.length; $i++) {
      var i = $list.$index($i);
      this._interfaces.add(i.resolveTypeParams$1(this));
    }
  }
  return this._interfaces;
}
ConcreteType.prototype.get$subtypes = function() {
  if (this._subtypes == null) {
    this._subtypes = new HashSetImplementation();
    var $list = this.genericType.get$subtypes();
    for (var $i = this.genericType.get$subtypes().iterator(); $i.hasNext$0(); ) {
      var s = $i.next$0();
      this._subtypes.add(s.resolveTypeParams$1(this));
    }
  }
  return this._subtypes;
}
ConcreteType.prototype.getCallMethod = function() {
  return this.genericType.getCallMethod();
}
ConcreteType.prototype.getAllMembers = function() {
  var result = this.genericType.getAllMembers();
  var $list = result.getKeys$0();
  for (var $i = result.getKeys$0().iterator$0(); $i.hasNext$0(); ) {
    var memberName = $i.next$0();
    var myMember = this.members.$index(memberName);
    if ($notnull_bool($ne(myMember, null))) {
      result.$setindex(memberName, myMember);
    }
  }
  return (result == null ? null : result.assert$Map_String$Member());
}
ConcreteType.prototype.markUsed = function() {
  this.genericType.markUsed();
}
ConcreteType.prototype.genMethod = function(method) {
  this.genericType.genMethod(method);
}
ConcreteType.prototype.getFactory = function(type, constructorName) {
  return this.genericType.getFactory(type, constructorName);
}
ConcreteType.prototype.getConstructor = function(constructorName) {
  var ret = this.constructors.$index(constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  ret = this.factories.getFactory(this.name, constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  var genericMember = this.genericType.getConstructor(constructorName);
  if ($notnull_bool(genericMember == null)) return null;
  if ($notnull_bool($ne(genericMember.get$declaringType(), this.genericType))) {
    if (!$notnull_bool(genericMember.get$declaringType().get$isGeneric())) return genericMember;
    var newDeclaringType = genericMember.get$declaringType().getOrMakeConcreteType$1(this.typeArgsInOrder);
    var factory = newDeclaringType.getFactory$2(this.genericType, constructorName);
    if (factory != null) return factory;
    return newDeclaringType.getConstructor$1(constructorName);
  }
  if ($notnull_bool(genericMember.get$isFactory())) {
    ret = new ConcreteMember($assert_String(genericMember.get$name()), this, genericMember);
    this.factories.addFactory(this.name, constructorName, (ret == null ? null : ret.assert$Member()));
  }
  else {
    ret = new ConcreteMember(this.name, this, genericMember);
    this.constructors.$setindex(constructorName, ret);
  }
  return ret;
}
ConcreteType.prototype.getMember = function(memberName) {
  var $0;
  var member = (($0 = this.members.$index(memberName)) == null ? null : $0.assert$Member());
  if (member != null) {
    this._checkOverride(member);
    return member;
  }
  var genericMember = this.genericType.members.$index(memberName);
  if ($notnull_bool($ne(genericMember, null))) {
    member = new ConcreteMember($assert_String(genericMember.get$name()), this, genericMember);
    this.members.$setindex(memberName, member);
    return member;
  }
  return this._getMemberInParents(memberName);
}
ConcreteType.prototype.resolveType = function(node, isRequired) {
  var ret = this.genericType.resolveType(node, isRequired);
  return (ret == null ? null : ret.assert$lang_Type());
}
ConcreteType.prototype.addDirectSubtype = function(type) {
  this.genericType.addDirectSubtype(type);
}
ConcreteType.prototype.addDirectSubtype$1 = function($0) {
  return this.addDirectSubtype(($0 == null ? null : $0.assert$lang_Type()));
};
ConcreteType.prototype.getConstructor$1 = function($0) {
  return this.getConstructor($assert_String($0));
};
ConcreteType.prototype.getFactory$2 = function($0, $1) {
  return this.getFactory(($0 == null ? null : $0.assert$lang_Type()), $assert_String($1));
};
ConcreteType.prototype.getMember$1 = function($0) {
  return this.getMember($assert_String($0));
};
ConcreteType.prototype.getOrMakeConcreteType$1 = function($0) {
  return this.getOrMakeConcreteType(($0 == null ? null : $0.assert$List_Type()));
};
ConcreteType.prototype.markUsed$0 = ConcreteType.prototype.markUsed;
ConcreteType.prototype.resolveTypeParams$1 = function($0) {
  return this.resolveTypeParams(($0 == null ? null : $0.assert$ConcreteType()));
};
// ********** Code for DefinedType **************
function DefinedType(name, library, definition, isClass) {
  this.isUsed = false
  this.isNative = false
  this.library = library;
  this.isClass = isClass;
  this.directSubtypes = new HashSetImplementation();
  this.constructors = $map([]);
  this.members = $map([]);
  this.factories = new FactoryMap();
  // Initializers done
  lang_Type.call(this, name);
  this.setDefinition(definition);
}
$inherits(DefinedType, lang_Type);
DefinedType.prototype.assert$DefinedType = function(){return this};
DefinedType.prototype.get$definition = function() { return this.definition; };
DefinedType.prototype.set$definition = function(value) { return this.definition = value; };
DefinedType.prototype.get$library = function() { return this.library; };
DefinedType.prototype.get$isClass = function() { return this.isClass; };
DefinedType.prototype.get$parent = function() {
  return this._parent;
}
DefinedType.prototype.set$parent = function(p) {
  this._parent = p;
}
DefinedType.prototype.get$interfaces = function() { return this.interfaces; };
DefinedType.prototype.set$interfaces = function(value) { return this.interfaces = value; };
DefinedType.prototype.get$typeParameters = function() { return this.typeParameters; };
DefinedType.prototype.set$typeParameters = function(value) { return this.typeParameters = value; };
DefinedType.prototype.get$constructors = function() { return this.constructors; };
DefinedType.prototype.set$constructors = function(value) { return this.constructors = value; };
DefinedType.prototype.get$members = function() { return this.members; };
DefinedType.prototype.set$members = function(value) { return this.members = value; };
DefinedType.prototype.get$factories = function() { return this.factories; };
DefinedType.prototype.set$factories = function(value) { return this.factories = value; };
DefinedType.prototype.get$isUsed = function() { return this.isUsed; };
DefinedType.prototype.set$isUsed = function(value) { return this.isUsed = value; };
DefinedType.prototype.get$isNative = function() { return this.isNative; };
DefinedType.prototype.set$isNative = function(value) { return this.isNative = value; };
DefinedType.prototype.setDefinition = function(def) {
  var $0;
  $assert(this.definition == null, "definition == null", "type.dart", 726, 12);
  this.definition = def;
  if ((this.definition instanceof TypeDefinition) && $notnull_bool($ne(this.definition.get$nativeType(), null))) {
    this.isNative = true;
  }
  if (this.definition != null && $notnull_bool($ne(this.definition.get$typeParameters(), null))) {
    this._concreteTypes = $map([]);
    this.typeParameters = (($0 = this.definition.get$typeParameters()) == null ? null : $0.assert$List_ParameterType());
  }
}
DefinedType.prototype.get$isHiddenNativeType = function() {
  return (this.definition != null && $notnull_bool($ne(this.definition.get$nativeType(), null)) && $notnull_bool(this.definition.get$nativeType().get$isConstructorHidden()));
}
DefinedType.prototype.get$typeArgsInOrder = function() {
  if (this.typeParameters == null) return null;
  if (this._typeArgsInOrder == null) {
    this._typeArgsInOrder = new FixedCollection_lang_Type($globals.world.varType, this.typeParameters.length);
  }
  return this._typeArgsInOrder;
}
DefinedType.prototype.get$isVar = function() {
  return $eq(this, $globals.world.varType);
}
DefinedType.prototype.get$isVoid = function() {
  return $eq(this, $globals.world.voidType);
}
DefinedType.prototype.get$isTop = function() {
  return this.name == null;
}
DefinedType.prototype.get$isObject = function() {
  return $notnull_bool(this.library.get$isCore()) && this.name == 'Object';
}
DefinedType.prototype.get$isString = function() {
  return $notnull_bool(this.library.get$isCore()) && this.name == 'String' || $notnull_bool(this.library.get$isCoreImpl()) && this.name == 'StringImplementation';
}
DefinedType.prototype.get$isBool = function() {
  return $notnull_bool(this.library.get$isCore()) && this.name == 'bool';
}
DefinedType.prototype.get$isFunction = function() {
  return $notnull_bool(this.library.get$isCore()) && this.name == 'Function';
}
DefinedType.prototype.get$isList = function() {
  return $notnull_bool(this.library.get$isCore()) && this.name == 'List';
}
DefinedType.prototype.get$isGeneric = function() {
  return this.typeParameters != null;
}
DefinedType.prototype.get$span = function() {
  var $0;
  return (($0 = this.definition == null ? null : this.definition.span) == null ? null : $0.assert$SourceSpan());
}
DefinedType.prototype.get$typeofName = function() {
  if (!$notnull_bool(this.library.get$isCore())) return null;
  if ($notnull_bool(this.get$isBool())) return 'boolean';
  else if ($notnull_bool(this.get$isNum())) return 'number';
  else if ($notnull_bool(this.get$isString())) return 'string';
  else if ($notnull_bool(this.get$isFunction())) return 'function';
  else return null;
}
DefinedType.prototype.get$isNum = function() {
  return this.library != null && $notnull_bool(this.library.get$isCore()) && (this.name == 'num' || this.name == 'int' || this.name == 'double');
}
DefinedType.prototype.getCallMethod = function() {
  var $0;
  return (($0 = this.members.$index('\$call')) == null ? null : $0.assert$MethodMember());
}
DefinedType.prototype.getAllMembers = function() {
  return HashMapImplementation.HashMapImplementation$from$factory(this.members);
}
DefinedType.prototype.markUsed = function() {
  if ($notnull_bool(this.isUsed)) return;
  this.isUsed = true;
  if (this._lazyGenMethods != null) {
    var $list = orderValuesByKeys(this._lazyGenMethods);
    for (var $i = 0;$i < $list.length; $i++) {
      var method = $list.$index($i);
      $globals.world.gen.genMethod((method == null ? null : method.assert$Member()));
    }
    this._lazyGenMethods = null;
  }
  if (this.get$parent() != null) this.get$parent().markUsed();
}
DefinedType.prototype.genMethod = function(method) {
  if ($notnull_bool(this.isUsed)) {
    $globals.world.gen.genMethod(method);
  }
  else if ($notnull_bool(this.isClass)) {
    if (this._lazyGenMethods == null) this._lazyGenMethods = $map([]);
    this._lazyGenMethods.$setindex(method.name, method);
  }
}
DefinedType.prototype._resolveInterfaces = function(types) {
  var $0;
  if (types == null) return [];
  var interfaces = [];
  for (var $i = 0;$i < types.length; $i++) {
    var type = types.$index($i);
    var resolvedInterface = this.resolveType((type == null ? null : type.assert$TypeReference()), true);
    if ($notnull_bool(resolvedInterface.get$isClosed()) && !($notnull_bool(this.library.get$isCore()) || $notnull_bool(this.library.get$isCoreImpl()))) {
      $globals.world.error(('can not implement "' + resolvedInterface.get$name() + '": ') + 'only native implementation allowed', (($0 = type.get$span()) == null ? null : $0.assert$SourceSpan()));
    }
    resolvedInterface.addDirectSubtype$1(this);
    interfaces.add$1(resolvedInterface);
  }
  return (interfaces == null ? null : interfaces.assert$List_Type());
}
DefinedType.prototype.addDirectSubtype = function(type) {
  $assert(this._subtypes == null, "_subtypes == null", "type.dart", 841, 12);
  this.directSubtypes.add(type);
}
DefinedType.prototype.get$subtypes = function() {
  var $0;
  if (this._subtypes == null) {
    this._subtypes = new HashSetImplementation();
    var $list = this.directSubtypes;
    for (var $i = this.directSubtypes.iterator(); $i.hasNext$0(); ) {
      var st = $i.next$0();
      this._subtypes.add(st);
      this._subtypes.addAll((($0 = st.get$subtypes()) == null ? null : $0.assert$Collection_E()));
    }
  }
  return this._subtypes;
}
DefinedType.prototype._cycleInClassExtends = function() {
  var seen = new HashSetImplementation();
  seen.add(this);
  var ancestor = this.get$parent();
  while ($notnull_bool($ne(ancestor, null))) {
    if (ancestor === this) {
      return true;
    }
    if (seen.contains(ancestor)) {
      return false;
    }
    seen.add(ancestor);
    ancestor = ancestor.get$parent();
  }
  return false;
}
DefinedType.prototype._cycleInInterfaceExtends = function() {
  var $this = this; // closure support
  var seen = new HashSetImplementation();
  seen.add(this);
  function _helper(ancestor) {
    if ($notnull_bool(ancestor == null)) return false;
    if (ancestor === $this) return true;
    if (seen.contains(ancestor)) {
      return false;
    }
    seen.add(ancestor);
    if ($notnull_bool($ne(ancestor.get$interfaces(), null))) {
      var $list = ancestor.get$interfaces();
      for (var $i = ancestor.get$interfaces().iterator$0(); $i.hasNext$0(); ) {
        var parent = $i.next$0();
        if ($notnull_bool(_helper(parent))) return true;
      }
    }
    return false;
  }
  for (var i = 0;
   i < this.interfaces.length; i++) {
    if ($notnull_bool(_helper(this.interfaces.$index(i)))) return i;
  }
  return -1;
}
DefinedType.prototype.resolve = function() {
  var $0;
  if ((this.definition instanceof TypeDefinition)) {
    var typeDef = (($0 = this.definition) == null ? null : $0.assert$TypeDefinition());
    if ($notnull_bool(this.isClass)) {
      if (typeDef.extendsTypes != null && typeDef.extendsTypes.length > 0) {
        if (typeDef.extendsTypes.length > 1) {
          $globals.world.error('more than one base class', (($0 = typeDef.extendsTypes.$index(1).get$span()) == null ? null : $0.assert$SourceSpan()));
        }
        var extendsTypeRef = typeDef.extendsTypes.$index(0);
        if ((extendsTypeRef instanceof GenericTypeReference)) {
          var g = (extendsTypeRef == null ? null : extendsTypeRef.assert$GenericTypeReference());
          this.set$parent(this.resolveType(g.baseType, true));
        }
        this.set$parent(this.resolveType((extendsTypeRef == null ? null : extendsTypeRef.assert$TypeReference()), true));
        if (!$notnull_bool(this.get$parent().get$isClass())) {
          $globals.world.error('class may not extend an interface - use implements', (($0 = typeDef.extendsTypes.$index(0).get$span()) == null ? null : $0.assert$SourceSpan()));
        }
        this.get$parent().addDirectSubtype(this);
        if ($notnull_bool(this._cycleInClassExtends())) {
          $globals.world.error(('class "' + this.name + '" has a cycle in its inheritance chain'), (($0 = extendsTypeRef.get$span()) == null ? null : $0.assert$SourceSpan()));
        }
      }
      else {
        if (!$notnull_bool(this.get$isObject())) {
          this.set$parent($globals.world.objectType);
          this.get$parent().addDirectSubtype(this);
        }
      }
      this.interfaces = this._resolveInterfaces(typeDef.implementsTypes);
      if (typeDef.factoryType != null) {
        $globals.world.error('factory not allowed on classes', typeDef.factoryType.span);
      }
    }
    else {
      if (typeDef.implementsTypes != null && typeDef.implementsTypes.length > 0) {
        $globals.world.error('implements not allowed on interfaces (use extends)', (($0 = typeDef.implementsTypes.$index(0).get$span()) == null ? null : $0.assert$SourceSpan()));
      }
      this.interfaces = this._resolveInterfaces(typeDef.extendsTypes);
      var res = this._cycleInInterfaceExtends();
      if (res >= 0) {
        $globals.world.error(('interface "' + this.name + '" has a cycle in its inheritance chain'), (($0 = typeDef.extendsTypes.$index(res).get$span()) == null ? null : $0.assert$SourceSpan()));
      }
      if (typeDef.factoryType != null) {
        this.factory_ = this.resolveType(typeDef.factoryType, true);
        if (this.factory_ == null) {
          $globals.world.warning('unresolved factory', typeDef.factoryType.span);
        }
      }
    }
  }
  else if ((this.definition instanceof FunctionTypeDefinition)) {
    this.interfaces = [$globals.world.functionType];
  }
  if (this.typeParameters != null) {
    var $list = this.typeParameters;
    for (var $i = 0;$i < $list.length; $i++) {
      var tp = $list.$index($i);
      tp.set$enclosingElement(this);
      tp.resolve$0();
    }
  }
  $globals.world._addType(this);
  var $list = this.constructors.getValues();
  for (var $i = this.constructors.getValues().iterator$0(); $i.hasNext$0(); ) {
    var c = $i.next$0();
    c.resolve$0();
  }
  var $list0 = this.members.getValues();
  for (var $i = this.members.getValues().iterator$0(); $i.hasNext$0(); ) {
    var m = $i.next$0();
    m.resolve$0();
  }
  this.factories.forEach((function (f) {
    return f.resolve$0();
  })
  );
}
DefinedType.prototype.addMethod = function(methodName, definition) {
  if (methodName == null) methodName = definition.name.name;
  var method = new MethodMember(methodName, this, definition);
  if ($notnull_bool(method.get$isConstructor())) {
    if (this.constructors.containsKey(method.get$constructorName())) {
      $globals.world.error(('duplicate constructor definition of ' + method.get$name()), definition.span);
      return;
    }
    this.constructors.$setindex(method.get$constructorName(), method);
    return;
  }
  if (definition.modifiers != null && definition.modifiers.length == 1 && $notnull_bool($eq(definition.modifiers.$index(0).get$kind(), 75/*TokenKind.FACTORY*/))) {
    if (this.factories.getFactory($assert_String(method.get$constructorName()), $assert_String(method.get$name())) != null) {
      $globals.world.error(('duplicate factory definition of "' + method.get$name() + '"'), definition.span);
      return;
    }
    this.factories.addFactory($assert_String(method.get$constructorName()), $assert_String(method.get$name()), (method == null ? null : method.assert$Member()));
    return;
  }
  if (methodName.startsWith('get\$') || methodName.startsWith('set\$')) {
    var propName = methodName.substring(4);
    var prop = this.members.$index(propName);
    if ($notnull_bool(prop == null)) {
      prop = new PropertyMember($assert_String(propName), this);
      this.members.$setindex(propName, prop);
    }
    if (!(prop instanceof PropertyMember)) {
      $globals.world.error(('property conflicts with field "' + propName + '"'), definition.span);
      return;
    }
    if (methodName[0] == 'g') {
      if ($notnull_bool($ne(prop.get$getter(), null))) {
        $globals.world.error(('duplicate getter definition for "' + propName + '"'), definition.span);
      }
      prop.set$getter(method);
    }
    else {
      if ($notnull_bool($ne(prop.get$setter(), null))) {
        $globals.world.error(('duplicate setter definition for "' + propName + '"'), definition.span);
      }
      prop.set$setter(method);
    }
    return;
  }
  if (this.members.containsKey(methodName)) {
    $globals.world.error(('duplicate method definition of "' + method.get$name() + '"'), definition.span);
    return;
  }
  this.members.$setindex(methodName, method);
}
DefinedType.prototype.addField = function(definition) {
  for (var i = 0;
   i < definition.names.length; i++) {
    var name = definition.names.$index(i).get$name();
    if (this.members.containsKey(name)) {
      $globals.world.error(('duplicate field definition of "' + name + '"'), definition.span);
      return;
    }
    var value = null;
    if (definition.values != null) {
      value = definition.values.$index(i);
    }
    var field = new FieldMember($assert_String(name), this, definition, value);
    this.members.$setindex(name, field);
    if ($notnull_bool(this.isNative)) {
      field.set$isNative(true);
    }
  }
}
DefinedType.prototype.getFactory = function(type, constructorName) {
  var ret = this.factories.getFactory(type.name, constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  ret = this.factories.getFactory(this.name, constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  ret = this.constructors.$index(constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  return this._tryCreateDefaultConstructor(constructorName);
}
DefinedType.prototype.getConstructor = function(constructorName) {
  var ret = this.constructors.$index(constructorName);
  if ($notnull_bool($ne(ret, null))) {
    if (this.factory_ != null) {
      return this.factory_.getFactory(this, constructorName);
    }
    return ret;
  }
  ret = this.factories.getFactory(this.name, constructorName);
  if ($notnull_bool($ne(ret, null))) return ret;
  return this._tryCreateDefaultConstructor(constructorName);
}
DefinedType.prototype._tryCreateDefaultConstructor = function(name) {
  var $0;
  if (name == '' && this.definition != null && $notnull_bool(this.isClass) && this.constructors.get$length() == 0) {
    var span = this.definition.span;
    var inits = null, native_ = null, body = null;
    if ($notnull_bool(this.isNative)) {
      native_ = '';
      inits = null;
    }
    else {
      body = null;
      inits = [new CallExpression(new SuperExpression((span == null ? null : span.assert$SourceSpan())), [], (span == null ? null : span.assert$SourceSpan()))];
    }
    var typeDef = (($0 = this.definition) == null ? null : $0.assert$TypeDefinition());
    var c = new FunctionDefinition(null, null, typeDef.name, [], null, inits, native_, body, (span == null ? null : span.assert$SourceSpan()));
    this.addMethod(null, (c == null ? null : c.assert$FunctionDefinition()));
    this.constructors.$index('').resolve$0();
    return this.constructors.$index('');
  }
  return null;
}
DefinedType.prototype.getMember = function(memberName) {
  var $0;
  var member = (($0 = this.members.$index(memberName)) == null ? null : $0.assert$Member());
  if (member != null) {
    this._checkOverride(member);
    return member;
  }
  if ($notnull_bool(this.get$isTop())) {
    var libType = this.library.findTypeByName(memberName);
    if ($notnull_bool($ne(libType, null))) {
      return (($0 = libType.get$typeMember()) == null ? null : $0.assert$Member());
    }
  }
  return this._getMemberInParents(memberName);
}
DefinedType.prototype.resolveTypeParams = function(inType) {
  return this;
}
DefinedType.prototype.getOrMakeConcreteType = function(typeArgs) {
  var $0;
  $assert(this.get$isGeneric(), "isGeneric", "type.dart", 1157, 12);
  var jsnames = [];
  var names = [];
  var typeMap = $map([]);
  for (var i = 0;
   i < typeArgs.length; i++) {
    var paramName = this.typeParameters.$index(i).get$name();
    typeMap.$setindex(paramName, typeArgs.$index(i));
    names.add$1(typeArgs.$index(i).get$name());
    jsnames.add$1(typeArgs.$index(i).get$jsname());
  }
  var jsname = ('' + this.get$jsname() + '_' + Strings.join((jsnames == null ? null : jsnames.assert$List_String()), '\$'));
  var simpleName = ('' + this.name + '<' + Strings.join((names == null ? null : names.assert$List_String()), ', ') + '>');
  var key = Strings.join((names == null ? null : names.assert$List_String()), '\$');
  var ret = this._concreteTypes.$index(key);
  if ($notnull_bool(ret == null)) {
    ret = new ConcreteType($assert_String(simpleName), this, typeMap, typeArgs);
    ret._jsname = $assert_String(jsname);
    this._concreteTypes.$setindex(key, ret);
  }
  return (ret == null ? null : ret.assert$lang_Type());
}
DefinedType.prototype.getCallStub = function(args) {
  $assert(this.get$isFunction(), "isFunction", "type.dart", 1184, 12);
  var name = _getCallStubName('call', args);
  var stub = this.varStubs.$index(name);
  if ($notnull_bool(stub == null)) {
    stub = new VarFunctionStub($assert_String(name), args);
    this.varStubs.$setindex(name, stub);
  }
  return (stub == null ? null : stub.assert$VarFunctionStub());
}
DefinedType.prototype.addDirectSubtype$1 = function($0) {
  return this.addDirectSubtype(($0 == null ? null : $0.assert$lang_Type()));
};
DefinedType.prototype.addMethod$2 = function($0, $1) {
  return this.addMethod($assert_String($0), ($1 == null ? null : $1.assert$FunctionDefinition()));
};
DefinedType.prototype.getConstructor$1 = function($0) {
  return this.getConstructor($assert_String($0));
};
DefinedType.prototype.getFactory$2 = function($0, $1) {
  return this.getFactory(($0 == null ? null : $0.assert$lang_Type()), $assert_String($1));
};
DefinedType.prototype.getMember$1 = function($0) {
  return this.getMember($assert_String($0));
};
DefinedType.prototype.getOrMakeConcreteType$1 = function($0) {
  return this.getOrMakeConcreteType(($0 == null ? null : $0.assert$List_Type()));
};
DefinedType.prototype.isString$0 = function() {
  return this.get$isString()();
};
DefinedType.prototype.markUsed$0 = DefinedType.prototype.markUsed;
DefinedType.prototype.resolve$0 = DefinedType.prototype.resolve;
DefinedType.prototype.resolveTypeParams$1 = function($0) {
  return this.resolveTypeParams(($0 == null ? null : $0.assert$ConcreteType()));
};
DefinedType.prototype.setDefinition$1 = function($0) {
  return this.setDefinition(($0 == null ? null : $0.assert$Definition()));
};
// ********** Code for NativeType **************
function NativeType(spec) {
  // Initializers done
  if (spec.startsWith('*')) {
    this.name = spec.substring(1);
    this.isConstructorHidden = true;
  }
  else {
    this.name = spec;
    this.isConstructorHidden = false;
  }
}
NativeType.prototype.get$name = function() { return this.name; };
NativeType.prototype.set$name = function(value) { return this.name = value; };
NativeType.prototype.get$isConstructorHidden = function() { return this.isConstructorHidden; };
NativeType.prototype.set$isConstructorHidden = function(value) { return this.isConstructorHidden = value; };
// ********** Code for FixedCollection **************
function FixedCollection(value, length) {
  this.value = value;
  this.length = length;
  // Initializers done
}
FixedCollection.prototype.assert$Collection_E = function(){return this};
FixedCollection.prototype.assert$Collection_Object = function(){return this};
FixedCollection.prototype.assert$Collection_Type = function(){return this};
FixedCollection.prototype.assert$Iterable = function(){return this};
FixedCollection.prototype.get$value = function() { return this.value; };
FixedCollection.prototype.iterator = function() {
  return new FixedIterator_E(this.value, this.length);
}
FixedCollection.prototype.forEach = function(f) {
  Collections.forEach(this, f);
}
FixedCollection.prototype.filter = function(f) {
  return Collections.filter(this, new ListFactory(), f);
}
FixedCollection.prototype.every = function(f) {
  return Collections.every(this, f);
}
FixedCollection.prototype.some = function(f) {
  return Collections.some(this, f);
}
FixedCollection.prototype.isEmpty = function() {
  return this.length == 0;
}
FixedCollection.prototype.every$1 = function($0) {
  return this.every(to$call$1($0));
};
FixedCollection.prototype.filter$1 = function($0) {
  return this.filter(to$call$1($0));
};
FixedCollection.prototype.forEach$1 = function($0) {
  return this.forEach(to$call$1($0));
};
FixedCollection.prototype.isEmpty$0 = FixedCollection.prototype.isEmpty;
FixedCollection.prototype.iterator$0 = FixedCollection.prototype.iterator;
FixedCollection.prototype.some$1 = function($0) {
  return this.some(to$call$1($0));
};
// ********** Code for FixedCollection_lang_Type **************
function FixedCollection_lang_Type(value, length) {
  this.value = value;
  this.length = length;
  // Initializers done
}
$inherits(FixedCollection_lang_Type, FixedCollection);
FixedCollection_lang_Type.prototype.assert$Collection_E = function(){return this};
FixedCollection_lang_Type.prototype.assert$Collection_Object = function(){return this};
FixedCollection_lang_Type.prototype.assert$Collection_Type = function(){return this};
FixedCollection_lang_Type.prototype.assert$Iterable = function(){return this};
// ********** Code for FixedIterator **************
function FixedIterator(value, length) {
  this._index = 0
  this.value = value;
  this.length = length;
  // Initializers done
}
FixedIterator.prototype.assert$Iterator_T = function(){return this};
FixedIterator.prototype.get$value = function() { return this.value; };
FixedIterator.prototype.hasNext = function() {
  return this._index < this.length;
}
FixedIterator.prototype.next = function() {
  this._index++;
  return this.value;
}
FixedIterator.prototype.hasNext$0 = FixedIterator.prototype.hasNext;
FixedIterator.prototype.next$0 = FixedIterator.prototype.next;
// ********** Code for FixedIterator_E **************
function FixedIterator_E(value, length) {
  this._index = 0
  this.value = value;
  this.length = length;
  // Initializers done
}
$inherits(FixedIterator_E, FixedIterator);
FixedIterator_E.prototype.assert$Iterator_T = function(){return this};
// ********** Code for Value **************
function Value(type, code, span, needsTemp) {
  this.isSuper = false
  this.isType = false
  this.isFinal = false
  this.type = type;
  this.code = code;
  this.span = span;
  this.needsTemp = needsTemp;
  // Initializers done
  if (this.type == null) $globals.world.internalError('type passed as null', this.span);
}
Value.type$ctor = function(type, span) {
  this.isSuper = false
  this.isType = false
  this.isFinal = false
  this.type = type;
  this.span = span;
  this.code = null;
  this.needsTemp = false;
  this.isType = true;
  // Initializers done
  if (this.type == null) $globals.world.internalError('type passed as null', this.span);
}
Value.type$ctor.prototype = Value.prototype;
Value.prototype.assert$Value = function(){return this};
Value.prototype.get$type = function() { return this.type; };
Value.prototype.set$type = function(value) { return this.type = value; };
Value.prototype.get$code = function() { return this.code; };
Value.prototype.set$code = function(value) { return this.code = value; };
Value.prototype.get$span = function() { return this.span; };
Value.prototype.set$span = function(value) { return this.span = value; };
Value.prototype.get$isSuper = function() { return this.isSuper; };
Value.prototype.set$isSuper = function(value) { return this.isSuper = value; };
Value.prototype.get$isType = function() { return this.isType; };
Value.prototype.set$isType = function(value) { return this.isType = value; };
Value.prototype.get$isFinal = function() { return this.isFinal; };
Value.prototype.set$isFinal = function(value) { return this.isFinal = value; };
Value.prototype.get$needsTemp = function() { return this.needsTemp; };
Value.prototype.set$needsTemp = function(value) { return this.needsTemp = value; };
Value.prototype.get$_typeIsVarOrParameterType = function() {
  return $notnull_bool(this.type.get$isVar()) || (this.type instanceof ParameterType);
}
Value.prototype.get$isConst = function() {
  return false;
}
Value.prototype.get$canonicalCode = function() {
  return null;
}
Value.prototype.get_ = function(context, name, node) {
  var $0;
  var member = this._resolveMember(context, name, node, false);
  if ($notnull_bool($ne(member, null))) {
    return (($0 = member._get$3(context, node, this)) == null ? null : $0.assert$Value());
  }
  else {
    return this.invokeNoSuchMethod(context, ('get:' + name), node);
  }
}
Value.prototype.set_ = function(context, name, node, value, isDynamic) {
  var member = this._resolveMember(context, name, node, isDynamic);
  if ($notnull_bool($ne(member, null))) {
    return member._set(context, node, this, value, isDynamic);
  }
  else {
    return this.invokeNoSuchMethod(context, ('set:' + name), node, new Arguments(null, [value]));
  }
}
Value.prototype.invoke = function(context, name, node, args, isDynamic) {
  var $0;
  if ($notnull_bool(this.get$_typeIsVarOrParameterType()) && name == '\$ne') {
    if (args.values.length != 1) {
      $globals.world.warning('wrong number of arguments for !=', node.span);
    }
    var eq = this.invoke(context, '\$eq', node, args, isDynamic);
    $globals.world.gen.corejs.useOperator('\$ne');
    return new Value(eq.get$type(), ('\$ne(' + this.code + ', ' + args.values.$index(0).get$code() + ')'), node.span, true);
  }
  if (name == '\$call') {
    if ($notnull_bool(this.isType)) {
      $globals.world.error('must use "new" or "const" to construct a new instance', node.span);
    }
    if ($notnull_bool(this.type.needsVarCall(args))) {
      return this._varCall(context, args);
    }
  }
  var member = this._resolveMember(context, name, node, isDynamic);
  if ($notnull_bool(member == null)) {
    return this.invokeNoSuchMethod(context, name, node, args);
  }
  else {
    return (($0 = member.invoke$5(context, node, this, args, isDynamic)) == null ? null : $0.assert$Value());
  }
}
Value.prototype.canInvoke = function(context, name, args) {
  if ($notnull_bool(this.get$_typeIsVarOrParameterType()) && name == '\$ne') {
    return true;
  }
  if ($notnull_bool(this.type.get$isVarOrFunction()) && name == '\$call') {
    return true;
  }
  var member = this._resolveMember(context, name, null, true);
  return $notnull_bool($ne(member, null)) && $notnull_bool(member.canInvoke$2(context, args));
}
Value.prototype._hasOverriddenNoSuchMethod = function() {
  if ($notnull_bool(this.isSuper)) {
    var m = this.type.getMember('noSuchMethod');
    return $notnull_bool($ne(m, null)) && !$notnull_bool(m.get$declaringType().get$isObject());
  }
  else {
    var m = this.type.resolveMember('noSuchMethod');
    return $notnull_bool($ne(m, null)) && m.get$members().length > 1;
  }
}
Value.prototype._tryResolveMember = function(context, name) {
  if ($notnull_bool(this.isSuper)) {
    return this.type.getMember(name);
  }
  else {
    return this.type.resolveMember(name);
  }
}
Value.prototype._resolveMember = function(context, name, node, isDynamic) {
  var member;
  if (!$notnull_bool(this.get$_typeIsVarOrParameterType())) {
    member = this._tryResolveMember(context, name);
    if ($notnull_bool($ne(member, null)) && $notnull_bool(this.isType) && !$notnull_bool(member.get$isStatic())) {
      if (!$notnull_bool(isDynamic)) {
        $globals.world.error('can not refer to instance member as static', node.span);
      }
      return null;
    }
    if ($notnull_bool(member == null) && !$notnull_bool(isDynamic) && !$notnull_bool(this._hasOverriddenNoSuchMethod())) {
      var typeName = this.type.name == null ? this.type.get$library().name : this.type.name;
      var message = ('can not resolve "' + name + '" on "' + typeName + '"');
      if ($notnull_bool(this.isType)) {
        $globals.world.error($assert_String(message), node.span);
      }
      else {
        $globals.world.warning($assert_String(message), node.span);
      }
    }
  }
  if ($notnull_bool(member == null) && !$notnull_bool(this.isSuper) && !$notnull_bool(this.isType)) {
    member = context.findMembers(name);
    if ($notnull_bool(member == null) && !$notnull_bool(isDynamic)) {
      var where = 'the world';
      if (name.startsWith('_')) {
        where = ('library "' + context.get$library().name + '"');
      }
      $globals.world.warning(('' + name + ' is not defined anywhere in ' + where + '.'), node.span);
    }
  }
  return member;
}
Value.prototype.checkFirstClass = function(span) {
  if ($notnull_bool(this.isType)) {
    $globals.world.error('Types are not first class', span);
  }
}
Value.prototype._varCall = function(context, args) {
  var stub = $globals.world.functionType.getCallStub(args);
  return new Value($globals.world.varType, ('' + this.code + '.' + stub.get$name() + '(' + args.getCode() + ')'), this.span, true);
}
Value.prototype.needsConversion = function(toType) {
  var callMethod = toType.getCallMethod();
  if ($notnull_bool($ne(callMethod, null))) {
    var arity = $assert_num(callMethod.get$parameters().length);
    var myCall = this.type.getCallMethod();
    if ($notnull_bool(myCall == null) || $notnull_bool($ne(myCall.get$parameters().length, arity))) {
      return true;
    }
  }
  if ($notnull_bool($globals.options.enableTypeChecks)) {
    var fromType = this.type;
    if ($notnull_bool(this.type.get$isVar()) && (this.code != 'null' || !$notnull_bool(toType.get$isNullable()))) {
      fromType = $globals.world.objectType;
    }
    var bothNum = $notnull_bool(this.type.get$isNum()) && $notnull_bool(toType.get$isNum());
    return !($notnull_bool(fromType.isSubtypeOf(toType)) || $notnull_bool(bothNum));
  }
  return false;
}
Value.prototype.convertTo = function(context, toType, node, isDynamic) {
  var $0;
  var checked = !$notnull_bool(isDynamic);
  var callMethod = toType.getCallMethod();
  if ($notnull_bool($ne(callMethod, null))) {
    if ($notnull_bool(checked) && !$notnull_bool(toType.isAssignable(this.type))) {
      this.convertWarning(toType, node);
    }
    var arity = $assert_num(callMethod.get$parameters().length);
    var myCall = this.type.getCallMethod();
    if ($notnull_bool(myCall == null) || $notnull_bool($ne(myCall.get$parameters().length, arity))) {
      var stub = $globals.world.functionType.getCallStub(Arguments.Arguments$bare$factory(arity));
      var val = new Value(toType, ('to\$' + stub.name + '(' + this.code + ')'), node.span, true);
      return (($0 = $notnull_bool(this._isDomCallback(toType)) && !$notnull_bool(this._isDomCallback(this.type)) ? val._wrapDomCallback(toType, arity) : val) == null ? null : $0.assert$Value());
    }
    else if ($notnull_bool(this._isDomCallback(toType)) && !$notnull_bool(this._isDomCallback(this.type))) {
      return this._wrapDomCallback(toType, arity);
    }
  }
  var fromType = this.type;
  if ($notnull_bool(this.type.get$isVar()) && (this.code != 'null' || !$notnull_bool(toType.get$isNullable()))) {
    fromType = $globals.world.objectType;
  }
  var bothNum = $notnull_bool(this.type.get$isNum()) && $notnull_bool(toType.get$isNum());
  if ($notnull_bool(fromType.isSubtypeOf(toType)) || $notnull_bool(bothNum)) {
    return this;
  }
  if ($notnull_bool(checked) && !$notnull_bool(toType.isSubtypeOf(this.type))) {
    this.convertWarning(toType, node);
  }
  if ($notnull_bool($globals.options.enableTypeChecks)) {
    return this._typeAssert(context, toType, node, isDynamic);
  }
  else {
    return this;
  }
}
Value.prototype._isDomCallback = function(toType) {
  return ((toType.get$definition() instanceof FunctionTypeDefinition) && $notnull_bool($eq(toType.get$library(), $globals.world.get$dom())));
}
Value.prototype._wrapDomCallback = function(toType, arity) {
  if (arity == 0) {
    $globals.world.gen.corejs.useWrap0 = true;
  }
  else {
    $globals.world.gen.corejs.useWrap1 = true;
  }
  return new Value(toType, ('\$wrap_call\$' + arity + '(' + this.code + ')'), this.span, true);
}
Value.prototype._typeAssert = function(context, toType, node, isDynamic) {
  if ((toType instanceof ParameterType)) {
    var p = (toType == null ? null : toType.assert$ParameterType());
    toType = p.extendsType;
  }
  if ($notnull_bool(toType.get$isObject()) || $notnull_bool(toType.get$isVar())) {
    $globals.world.internalError(('We thought ' + this.type.name + ' is not a subtype of ' + toType.name + '?'));
  }
  var typeError = $globals.world.corelib.types.$index('TypeError');
  var typeErrorCtor = typeError.getConstructor$1('_internal');
  $globals.world.gen.corejs.ensureTypeNameOf();
  var result = typeErrorCtor.invoke$5(context, node, new Value.type$ctor(typeError, null), new Arguments(null, [new Value($globals.world.objectType, 'this', null, true), new Value($globals.world.stringType, ('"' + toType.name + '"'), null, true)]), isDynamic);
  $globals.world.gen.corejs.useThrow = true;
  var throwTypeError = ('\$throw(' + result.get$code() + ')');
  if ($notnull_bool(toType.get$isNum())) toType = $globals.world.numType;
  var check;
  if ($notnull_bool(toType.get$isVoid())) {
    check = ('\$assert_void(' + this.code + ')');
    if (toType.typeCheckCode == null) {
      toType.typeCheckCode = ("function $assert_void(x) {\n  if (x == null) return null;\n  " + throwTypeError + "\n}");
    }
  }
  else if ($eq(toType, $globals.world.nonNullBool)) {
    $globals.world.gen.corejs.useNotNullBool = true;
    check = ('\$notnull_bool(' + this.code + ')');
  }
  else if ($notnull_bool(toType.get$library().get$isCore()) && toType.get$typeofName() != null) {
    check = ('\$assert_' + toType.name + '(' + this.code + ')');
    if (toType.typeCheckCode == null) {
      toType.typeCheckCode = ("function $assert_" + toType.name + "(x) {\n  if (x == null || typeof(x) == \"" + toType.get$typeofName() + "\") return x;\n  " + throwTypeError + "\n}");
    }
  }
  else {
    toType.isChecked = true;
    var checkName = 'assert\$' + toType.get$jsname();
    var temp = context.getTemp(this);
    check = ('(' + context.assignTemp((temp == null ? null : temp.assert$Value()), this).code + ' == null ? null :');
    check = check + (' ' + temp.get$code() + '.' + checkName + '())');
    if ($ne(this, temp)) context.freeTemp((temp == null ? null : temp.assert$Value()));
    if (!$globals.world.objectType.varStubs.containsKey(checkName)) {
      $globals.world.objectType.varStubs.$setindex(checkName, new VarMethodStub(checkName, null, Arguments.get$EMPTY(), throwTypeError));
    }
  }
  return new Value(toType, check, this.span, true);
}
Value.prototype.instanceOf = function(context, toType, span, isTrue, forceCheck) {
  if ($notnull_bool(toType.get$isVar())) {
    $globals.world.error('can not resolve type', span);
  }
  var testCode = null;
  if ($notnull_bool(toType.get$isVar()) || $notnull_bool(toType.get$isObject()) || (toType instanceof ParameterType)) {
    if ($notnull_bool(this.needsTemp)) {
      return new Value($globals.world.nonNullBool, ('(' + this.code + ', true)'), span, true);
    }
    else {
      return EvaluatedValue.EvaluatedValue$factory($globals.world.nonNullBool, true, 'true', null);
    }
  }
  if ($notnull_bool(toType.get$library().get$isCore())) {
    var typeofName = toType.get$typeofName();
    if ($notnull_bool($ne(typeofName, null))) {
      testCode = ("(typeof(" + this.code + ") " + ($notnull_bool(isTrue) ? '==' : '!=') + " '" + typeofName + "')");
    }
  }
  if ($notnull_bool(toType.get$isClass()) && !(toType instanceof ConcreteType) && !$notnull_bool(toType.get$isHiddenNativeType())) {
    toType.markUsed();
    testCode = ('(' + this.code + ' instanceof ' + toType.get$jsname() + ')');
    if (!$notnull_bool(isTrue)) {
      testCode = '!' + testCode;
    }
  }
  if (testCode == null) {
    toType.isTested = true;
    var temp = context.getTemp(this);
    var checkName = ('is\$' + toType.get$jsname());
    testCode = ('(' + context.assignTemp((temp == null ? null : temp.assert$Value()), this).code + ' &&');
    testCode = testCode + (' ' + temp.get$code() + '.' + checkName + '())');
    if ($notnull_bool(isTrue)) {
      testCode = '!!' + testCode;
    }
    else {
      testCode = '!' + testCode;
    }
    if ($ne(this, temp)) context.freeTemp((temp == null ? null : temp.assert$Value()));
    if (!$globals.world.objectType.varStubs.containsKey(checkName)) {
      $globals.world.objectType.varStubs.$setindex(checkName, new VarMethodStub(checkName, null, Arguments.get$EMPTY(), 'return false'));
    }
  }
  return new Value($globals.world.nonNullBool, testCode, span, true);
}
Value.prototype.convertWarning = function(toType, node) {
  $globals.world.warning(('type "' + this.type.name + '" is not assignable to "' + toType.name + '"'), node.span);
}
Value.prototype.invokeNoSuchMethod = function(context, name, node, args) {
  var $0;
  var pos = '';
  if (args != null) {
    var argsCode = [];
    for (var i = 0;
     i < args.get$length(); i++) {
      argsCode.add$1(args.values.$index(i).get$code());
    }
    pos = Strings.join((argsCode == null ? null : argsCode.assert$List_String()), ", ");
  }
  var noSuchArgs = [new Value($globals.world.stringType, ('"' + name + '"'), node.span, true), new Value($globals.world.listType, ('[' + pos + ']'), node.span, true)];
  return (($0 = this._resolveMember(context, 'noSuchMethod', node, false).invoke$4(context, node, this, new Arguments(null, noSuchArgs))) == null ? null : $0.assert$Value());
}
Value.prototype.invokeSpecial = function(name, args, returnType) {
  $assert(name.startsWith('\$'), "name.startsWith('\\$')", "value.dart", 519, 12);
  $assert(!$notnull_bool(args.get$hasNames()), "!args.hasNames", "value.dart", 520, 12);
  var argsString = args.getCode();
  if (name == '\$index' || name == '\$setindex') {
    return new Value(returnType, ('' + this.code + '.' + name + '(' + argsString + ')'), this.span, true);
  }
  else {
    if (argsString.length > 0) argsString = (', ' + argsString);
    $globals.world.gen.corejs.useOperator(name);
    return new Value(returnType, ('' + name + '(' + this.code + argsString + ')'), this.span, true);
  }
}
Value.prototype.checkFirstClass$1 = function($0) {
  return this.checkFirstClass(($0 == null ? null : $0.assert$SourceSpan()));
};
Value.prototype.convertTo$3 = function($0, $1, $2) {
  return this.convertTo(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Type()), ($2 == null ? null : $2.assert$lang_Node()), false);
};
Value.prototype.convertTo$4 = function($0, $1, $2, $3) {
  return this.convertTo(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Type()), ($2 == null ? null : $2.assert$lang_Node()), $assert_bool($3));
};
Value.prototype.get_$3 = function($0, $1, $2) {
  return this.get_(($0 == null ? null : $0.assert$MethodGenerator()), $assert_String($1), ($2 == null ? null : $2.assert$lang_Node()));
};
Value.prototype.instanceOf$3$isTrue$forceCheck = function($0, $1, $2, isTrue, forceCheck) {
  return this.instanceOf(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Type()), ($2 == null ? null : $2.assert$SourceSpan()), $assert_bool(isTrue), $assert_bool(forceCheck));
};
Value.prototype.instanceOf$4 = function($0, $1, $2, $3) {
  return this.instanceOf(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Type()), ($2 == null ? null : $2.assert$SourceSpan()), $assert_bool($3), false);
};
Value.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), $assert_String($1), ($2 == null ? null : $2.assert$lang_Node()), ($3 == null ? null : $3.assert$Arguments()), false);
};
Value.prototype.invoke$4$isDynamic = function($0, $1, $2, $3, isDynamic) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), $assert_String($1), ($2 == null ? null : $2.assert$lang_Node()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool(isDynamic));
};
Value.prototype.invoke$5 = function($0, $1, $2, $3, $4) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), $assert_String($1), ($2 == null ? null : $2.assert$lang_Node()), ($3 == null ? null : $3.assert$Arguments()), $assert_bool($4));
};
Value.prototype.needsConversion$1 = function($0) {
  return this.needsConversion(($0 == null ? null : $0.assert$lang_Type()));
};
Value.prototype.set_$4 = function($0, $1, $2, $3) {
  return this.set_(($0 == null ? null : $0.assert$MethodGenerator()), $assert_String($1), ($2 == null ? null : $2.assert$lang_Node()), ($3 == null ? null : $3.assert$Value()), false);
};
// ********** Code for EvaluatedValue **************
function EvaluatedValue() {}
EvaluatedValue._internal$ctor = function(type, actualValue, canonicalCode, span, code) {
  this.actualValue = actualValue;
  this.canonicalCode = canonicalCode;
  // Initializers done
  Value.call(this, type, code, span, false);
}
EvaluatedValue._internal$ctor.prototype = EvaluatedValue.prototype;
$inherits(EvaluatedValue, Value);
EvaluatedValue.EvaluatedValue$factory = function(type, actualValue, canonicalCode, span) {
  return new EvaluatedValue._internal$ctor(type, actualValue, canonicalCode, span, EvaluatedValue.codeWithComments(canonicalCode, span));
}
EvaluatedValue.prototype.get$actualValue = function() { return this.actualValue; };
EvaluatedValue.prototype.set$actualValue = function(value) { return this.actualValue = value; };
EvaluatedValue.prototype.get$isConst = function() {
  return true;
}
EvaluatedValue.prototype.get$canonicalCode = function() { return this.canonicalCode; };
EvaluatedValue.prototype.set$canonicalCode = function(value) { return this.canonicalCode = value; };
EvaluatedValue.codeWithComments = function(canonicalCode, span) {
  return (span != null && span.get$text() != canonicalCode) ? ('' + canonicalCode + '/*' + span.get$text() + '*/') : canonicalCode;
}
// ********** Code for ConstListValue **************
function ConstListValue() {}
ConstListValue._internal$ctor = function(type, values, actualValue, canonicalCode, span, code) {
  this.values = values;
  // Initializers done
  EvaluatedValue._internal$ctor.call(this, (type == null ? null : type.assert$lang_Type()), actualValue, canonicalCode, (span == null ? null : span.assert$SourceSpan()), $assert_String(code));
}
ConstListValue._internal$ctor.prototype = ConstListValue.prototype;
$inherits(ConstListValue, EvaluatedValue);
ConstListValue.ConstListValue$factory = function(type, values, actualValue, canonicalCode, span) {
  return new ConstListValue._internal$ctor(type, values, actualValue, canonicalCode, span, EvaluatedValue.codeWithComments(canonicalCode, span));
}
ConstListValue.prototype.get$values = function() { return this.values; };
ConstListValue.prototype.set$values = function(value) { return this.values = value; };
// ********** Code for ConstMapValue **************
function ConstMapValue() {}
ConstMapValue._internal$ctor = function(type, values, actualValue, canonicalCode, span, code) {
  this.values = values;
  // Initializers done
  EvaluatedValue._internal$ctor.call(this, (type == null ? null : type.assert$lang_Type()), actualValue, canonicalCode, (span == null ? null : span.assert$SourceSpan()), $assert_String(code));
}
ConstMapValue._internal$ctor.prototype = ConstMapValue.prototype;
$inherits(ConstMapValue, EvaluatedValue);
ConstMapValue.ConstMapValue$factory = function(type, keyValuePairs, actualValue, canonicalCode, span) {
  var values = new HashMapImplementation();
  for (var i = 0;
   i < keyValuePairs.length; i += 2) {
    values.$setindex(keyValuePairs.$index(i).get$actualValue(), keyValuePairs.$index(i + 1));
  }
  return new ConstMapValue._internal$ctor(type, values, actualValue, canonicalCode, span, EvaluatedValue.codeWithComments(canonicalCode, span));
}
ConstMapValue.prototype.get$values = function() { return this.values; };
ConstMapValue.prototype.set$values = function(value) { return this.values = value; };
// ********** Code for ConstObjectValue **************
function ConstObjectValue() {}
ConstObjectValue._internal$ctor = function(type, fields, actualValue, canonicalCode, span, code) {
  this.fields = fields;
  // Initializers done
  EvaluatedValue._internal$ctor.call(this, (type == null ? null : type.assert$lang_Type()), actualValue, canonicalCode, (span == null ? null : span.assert$SourceSpan()), $assert_String(code));
}
ConstObjectValue._internal$ctor.prototype = ConstObjectValue.prototype;
$inherits(ConstObjectValue, EvaluatedValue);
ConstObjectValue.ConstObjectValue$factory = function(type, fields, canonicalCode, span) {
  var fieldValues = [];
  var $list = fields.getKeys();
  for (var $i = fields.getKeys().iterator$0(); $i.hasNext$0(); ) {
    var f = $i.next$0();
    fieldValues.add(('' + f + ' = ' + fields.$index(f).get$actualValue()));
  }
  fieldValues.sort((function (a, b) {
    return a.compareTo$1(b);
  })
  );
  var actualValue = ('const ' + type.get$jsname() + ' [') + Strings.join(fieldValues, ',') + ']';
  return new ConstObjectValue._internal$ctor(type, fields, actualValue, canonicalCode, span, EvaluatedValue.codeWithComments(canonicalCode, span));
}
ConstObjectValue.prototype.get$fields = function() { return this.fields; };
ConstObjectValue.prototype.set$fields = function(value) { return this.fields = value; };
// ********** Code for GlobalValue **************
function GlobalValue(type, code, isConst, field, name, exp, canonicalCode, span, _dependencies) {
  var $0;
  this.field = field;
  this.name = name;
  this.exp = exp;
  this.canonicalCode = canonicalCode;
  this.dependencies = [];
  // Initializers done
  Value.call(this, type, code, span, !$notnull_bool(isConst));
  for (var $i = 0;$i < _dependencies.length; $i++) {
    var dep = _dependencies.$index($i);
    this.dependencies.add(dep);
    this.dependencies.addAll((($0 = dep.get$dependencies()) == null ? null : $0.assert$Collection_E()));
  }
}
$inherits(GlobalValue, Value);
GlobalValue.prototype.assert$GlobalValue = function(){return this};
GlobalValue.prototype.assert$Comparable = function(){return this};
GlobalValue.GlobalValue$fromStatic$factory = function(field, exp, dependencies) {
  var $0;
  var code = ($notnull_bool(exp.get$isConst()) ? exp.get$canonicalCode() : exp.code);
  var codeWithComment = ('' + code + '/*' + field.get$declaringType().get$name() + '.' + field.get$name() + '*/');
  return new GlobalValue(exp.type, $assert_String(codeWithComment), $assert_bool(field.get$isFinal()), field, null, exp, code, exp.span, (($0 = dependencies.filter$1((function (d) {
    return (d instanceof GlobalValue);
  })
  )) == null ? null : $0.assert$List_GlobalValue()));
}
GlobalValue.GlobalValue$fromConst$factory = function(uniqueId, exp, dependencies) {
  var $0;
  var name = ("const\$" + uniqueId);
  var codeWithComment = ("" + name + "/*" + exp.span.get$text() + "*/");
  return new GlobalValue(exp.type, $assert_String(codeWithComment), true, null, name, exp, name, exp.span, (($0 = dependencies.filter$1((function (d) {
    return (d instanceof GlobalValue);
  })
  )) == null ? null : $0.assert$List_GlobalValue()));
}
GlobalValue.prototype.get$field = function() { return this.field; };
GlobalValue.prototype.set$field = function(value) { return this.field = value; };
GlobalValue.prototype.get$name = function() { return this.name; };
GlobalValue.prototype.set$name = function(value) { return this.name = value; };
GlobalValue.prototype.get$exp = function() { return this.exp; };
GlobalValue.prototype.set$exp = function(value) { return this.exp = value; };
GlobalValue.prototype.get$canonicalCode = function() { return this.canonicalCode; };
GlobalValue.prototype.set$canonicalCode = function(value) { return this.canonicalCode = value; };
GlobalValue.prototype.get$isConst = function() {
  return $notnull_bool(this.exp.get$isConst()) && (this.field == null || $notnull_bool(this.field.isFinal));
}
GlobalValue.prototype.get$actualValue = function() {
  return this.exp.get$dynamic().get$actualValue();
}
GlobalValue.prototype.get$dependencies = function() { return this.dependencies; };
GlobalValue.prototype.set$dependencies = function(value) { return this.dependencies = value; };
GlobalValue.prototype.compareTo = function(other) {
  if ($eq(other, this)) {
    return 0;
  }
  else if (this.dependencies.indexOf(other) >= 0) {
    return 1;
  }
  else if (other.dependencies.indexOf(this) >= 0) {
    return -1;
  }
  else if (this.dependencies.length > other.dependencies.length) {
    return 1;
  }
  else if (this.dependencies.length < other.dependencies.length) {
    return -1;
  }
  else if (this.name == null && other.name != null) {
    return 1;
  }
  else if (this.name != null && other.name == null) {
    return -1;
  }
  else if (this.name != null) {
    return this.name.compareTo(other.name);
  }
  else {
    return this.field.name.compareTo(other.field.name);
  }
}
GlobalValue.prototype.compareTo$1 = function($0) {
  return this.compareTo(($0 == null ? null : $0.assert$GlobalValue()));
};
// ********** Code for BareValue **************
function BareValue(home, outermost, span) {
  this.home = home;
  // Initializers done
  Value.call(this, outermost.method.declaringType, null, span, false);
  this.isType = outermost.get$isStatic();
}
$inherits(BareValue, Value);
BareValue.prototype._ensureCode = function() {
  if (this.code != null) return;
  if ($notnull_bool(this.isType)) {
    this.code = this.type.get$jsname();
  }
  else {
    this.code = this.home._makeThisCode();
  }
}
BareValue.prototype._tryResolveMember = function(context, name) {
  $assert($eq(context, this.home), "context == home", "value.dart", 740, 12);
  var member = this.type.resolveMember(name);
  if ($notnull_bool($ne(member, null))) {
    this._ensureCode();
    return member;
  }
  member = this.home.get$library().lookup(name, this.span);
  if ($notnull_bool($ne(member, null))) {
    return member;
  }
  this._ensureCode();
  return null;
}
// ********** Code for CompilerException **************
function CompilerException(_message, _location) {
  this._lang_message = _message;
  this._location = _location;
  // Initializers done
}
CompilerException.prototype.toString = function() {
  if (this._location != null) {
    return ('CompilerException: ' + this._location.toMessageString(this._lang_message));
  }
  else {
    return ('CompilerException: ' + this._lang_message);
  }
}
CompilerException.prototype.toString$0 = CompilerException.prototype.toString;
// ********** Code for World **************
function World(files) {
  this.errors = 0
  this.warnings = 0
  this.dartBytesRead = 0
  this.jsBytesWritten = 0
  this.seenFatal = false
  this.files = files;
  this.libraries = $map([]);
  this._todo = [];
  this._members = $map([]);
  this._topNames = $map([]);
  this.reader = new LibraryReader();
  // Initializers done
}
World.prototype.get$coreimpl = function() {
  var $0;
  return (($0 = this.libraries.$index('dart:coreimpl')) == null ? null : $0.assert$Library());
}
World.prototype.get$dom = function() {
  var $0;
  return (($0 = this.libraries.$index('dart:dom')) == null ? null : $0.assert$Library());
}
World.prototype.get$dynamicType = function() { return this.dynamicType; };
World.prototype.set$dynamicType = function(value) { return this.dynamicType = value; };
World.prototype.get$functionType = function() { return this.functionType; };
World.prototype.set$functionType = function(value) { return this.functionType = value; };
World.prototype.init = function() {
  var $0;
  this.corelib = new Library(this.readFile('dart:core'));
  this.libraries.$setindex('dart:core', this.corelib);
  this._todo.add(this.corelib);
  this.voidType = (($0 = this._addToCoreLib('void', false)) == null ? null : $0.assert$DefinedType());
  this.dynamicType = (($0 = this._addToCoreLib('Dynamic', false)) == null ? null : $0.assert$DefinedType());
  this.varType = this.dynamicType;
  this.objectType = (($0 = this._addToCoreLib('Object', true)) == null ? null : $0.assert$DefinedType());
  this.numType = (($0 = this._addToCoreLib('num', false)) == null ? null : $0.assert$DefinedType());
  this.intType = (($0 = this._addToCoreLib('int', false)) == null ? null : $0.assert$DefinedType());
  this.doubleType = (($0 = this._addToCoreLib('double', false)) == null ? null : $0.assert$DefinedType());
  this.boolType = (($0 = this._addToCoreLib('bool', false)) == null ? null : $0.assert$DefinedType());
  this.stringType = (($0 = this._addToCoreLib('String', false)) == null ? null : $0.assert$DefinedType());
  this.listType = (($0 = this._addToCoreLib('List', false)) == null ? null : $0.assert$DefinedType());
  this.mapType = (($0 = this._addToCoreLib('Map', false)) == null ? null : $0.assert$DefinedType());
  this.functionType = (($0 = this._addToCoreLib('Function', false)) == null ? null : $0.assert$DefinedType());
  this.nonNullBool = new NonNullableType(this.boolType);
}
World.prototype._addMember = function(member) {
  $assert(!$notnull_bool(member.get$isPrivate()), "!member.isPrivate", "world.dart", 145, 12);
  if ($notnull_bool(member.get$isStatic())) {
    if ($notnull_bool(member.declaringType.get$isTop())) {
      this._addTopName(member);
    }
    return;
  }
  var mset = this._members.$index(member.name);
  if ($notnull_bool(mset == null)) {
    mset = new MemberSet(member, true);
    this._members.$setindex(mset.get$name(), mset);
  }
  else {
    mset.get$members().add$1(member);
  }
}
World.prototype._addTopName = function(named) {
  var existing = this._topNames.$index(named.get$jsname());
  if ($notnull_bool($ne(existing, null))) {
    this.info(('mangling matching top level name "' + named.get$jsname() + '" in ') + ('both "' + named.get$library().get$jsname() + '" and "' + existing.get$library().get$jsname() + '"'));
    if ($notnull_bool(named.get$isNative())) {
      if ($notnull_bool(existing.get$isNative())) {
        $globals.world.internalError(('conflicting native names "' + named.get$jsname() + '" ') + ('(already defined in ' + existing.get$span().get$locationText() + ')'), named.get$span());
      }
      else {
        this._topNames.$setindex(named.get$jsname(), named);
        this._addJavascriptTopName((existing == null ? null : existing.assert$lang_Element()));
      }
    }
    else if ($notnull_bool(named.get$library().get$isCore())) {
      if ($notnull_bool(existing.get$library().get$isCore())) {
        $globals.world.internalError(('conflicting top-level names in core "' + named.get$jsname() + '" ') + ('(previously defined in ' + existing.get$span().get$locationText() + ')'), named.get$span());
      }
      else {
        this._topNames.$setindex(named.get$jsname(), named);
        this._addJavascriptTopName((existing == null ? null : existing.assert$lang_Element()));
      }
    }
    else {
      this._addJavascriptTopName(named);
    }
  }
  else {
    this._topNames.$setindex(named.get$jsname(), named);
  }
}
World.prototype._addJavascriptTopName = function(named) {
  named._jsname = ('' + named.get$library().get$jsname() + '_' + named.get$jsname());
  var existing = this._topNames.$index(named.get$jsname());
  if ($notnull_bool($ne(existing, null)) && $notnull_bool($ne(existing, named))) {
    $globals.world.internalError(('name mangling failed for "' + named.get$jsname() + '" ') + ('("' + named.get$jsname() + '" defined also in ' + existing.get$span().get$locationText() + ')'), named.get$span());
  }
  this._topNames.$setindex(named.get$jsname(), named);
}
World.prototype._addType = function(type) {
  if (!$notnull_bool(type.get$isTop())) this._addTopName(type);
}
World.prototype._addToCoreLib = function(name, isClass) {
  var ret = new DefinedType(name, this.corelib, null, isClass);
  this.corelib.types.$setindex(name, ret);
  return ret;
}
World.prototype.toJsIdentifier = function(name) {
  if (this._jsKeywords == null) {
    this._jsKeywords = HashSetImplementation.HashSetImplementation$from$factory(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof', 'new', 'return', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'class', 'enum', 'export', 'extends', 'import', 'super', 'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield', 'native']);
  }
  if (this._jsKeywords.contains(name)) {
    return name + '_';
  }
  else {
    return name;
  }
}
World.prototype.compile = function() {
  if ($globals.options.dartScript == null) {
    this.fatal('no script provided to compile');
    return false;
  }
  try {
    this.info(('compiling ' + $globals.options.dartScript + ' with corelib ' + this.corelib));
    if (!$notnull_bool(this.runLeg())) this.runCompilationPhases();
  } catch (exc) {
    exc = _toDartException(exc);
    if ($notnull_bool(this.get$hasErrors()) && !$notnull_bool($globals.options.throwOnErrors)) {
    }
    else {
      throw exc;
    }
  }
  this.printStatus();
  return !$notnull_bool(this.get$hasErrors());
}
World.prototype.runLeg = function() {
  var $this = this; // closure support
  if (!$notnull_bool($globals.options.enableLeg)) return false;
  var res = $assert_bool(this.withTiming('try leg compile', (function () {
    return compile($this);
  })
  ));
  if (!$notnull_bool(res) && $notnull_bool($globals.options.legOnly)) {
    this.fatal(("Leg could not compile " + $globals.options.dartScript));
    return true;
  }
  return res;
}
World.prototype.runCompilationPhases = function() {
  var $this = this; // closure support
  var lib = this.withTiming('first pass', (function () {
    return $this.processScript($globals.options.dartScript);
  })
  );
  this.withTiming('resolve top level', (function () {
    $this.resolveAll();
  })
  );
  this.withTiming('generate code', (function () {
    var $0;
    var mainMembers = lib.get$topType().resolveMember$1('main');
    var main = null;
    if ($notnull_bool(mainMembers == null) || $notnull_bool($eq(mainMembers.get$members().length, 0))) {
      $this.fatal('no main method specified');
    }
    else if (mainMembers.get$members().length > 1) {
      var $list = mainMembers.get$members();
      for (var $i = mainMembers.get$members().iterator$0(); $i.hasNext$0(); ) {
        var m = $i.next$0();
        main = m;
        $this.error('more than one main member (using last?)', (($0 = main.get$span()) == null ? null : $0.assert$SourceSpan()));
      }
    }
    else {
      main = mainMembers.get$members().$index(0);
    }
    var codeWriter = new CodeWriter();
    $this.gen = new WorldGenerator(main, codeWriter);
    $this.gen.run();
    $this.jsBytesWritten = $assert_num(codeWriter.get$text().length);
  })
  );
}
World.prototype.getGeneratedCode = function() {
  if (this.legCode != null) {
    $assert($globals.options.enableLeg, "options.enableLeg", "world.dart", 310, 14);
    return this.legCode;
  }
  else {
    return this.gen.writer.get$text();
  }
}
World.prototype.readFile = function(filename) {
  try {
    var sourceFile = this.reader.readFile(filename);
    this.dartBytesRead += sourceFile.get$text().length;
    return sourceFile;
  } catch (e) {
    e = _toDartException(e);
    this.warning(('Error reading file: ' + filename));
    return new SourceFile(filename, '');
  }
}
World.prototype.getOrAddLibrary = function(filename) {
  var $0;
  var library = (($0 = this.libraries.$index(filename)) == null ? null : $0.assert$Library());
  if (library == null) {
    library = new Library(this.readFile(filename));
    this.info(('read library ' + filename));
    if (!$notnull_bool(library.get$isCore()) && !library.imports.some((function (li) {
      return li.get$library().get$isCore();
    })
    )) {
      library.imports.add(new LibraryImport(this.corelib));
    }
    this.libraries.$setindex(filename, library);
    this._todo.add(library);
  }
  return library;
}
World.prototype.process = function() {
  while (this._todo.length > 0) {
    var todo = this._todo;
    this._todo = [];
    for (var $i = 0;$i < todo.length; $i++) {
      var lib = todo.$index($i);
      lib.visitSources$0();
    }
  }
}
World.prototype.processScript = function(filename) {
  var library = this.getOrAddLibrary(filename);
  this.process();
  return library;
}
World.prototype.resolveAll = function() {
  var $list = this.libraries.getValues();
  for (var $i = this.libraries.getValues().iterator$0(); $i.hasNext$0(); ) {
    var lib = $i.next$0();
    lib.resolve$0();
  }
}
World.prototype._message = function(message, span, span1, span2, throwing) {
  var text = message;
  if (span != null) {
    text = span.toMessageString(message);
  }
  print(text);
  if (span1 != null) {
    print(span1.toMessageString(message));
  }
  if (span2 != null) {
    print(span2.toMessageString(message));
  }
  if ($notnull_bool(throwing)) {
    $throw(new CompilerException(message, span));
  }
}
World.prototype.error = function(message, span, span1, span2) {
  this.errors++;
  this._message(('error: ' + message), span, span1, span2, $globals.options.throwOnErrors);
}
World.prototype.warning = function(message, span, span1, span2) {
  if ($notnull_bool($globals.options.warningsAsErrors)) {
    this.error(message, span, span1, span2);
    return;
  }
  this.warnings++;
  if ($notnull_bool($globals.options.showWarnings)) {
    this._message(('warning: ' + message), span, span1, span2, $globals.options.throwOnWarnings);
  }
}
World.prototype.fatal = function(message, span, span1, span2) {
  this.errors++;
  this.seenFatal = true;
  this._message(('fatal: ' + message), span, span1, span2, $notnull_bool($globals.options.throwOnFatal) || $notnull_bool($globals.options.throwOnErrors));
}
World.prototype.internalError = function(message, span, span1, span2) {
  this._message(('We are sorry, but... ' + message), span, span1, span2, true);
}
World.prototype.info = function(message, span, span1, span2) {
  if ($notnull_bool($globals.options.showInfo)) {
    this._message(('info: ' + message), span, span1, span2, false);
  }
}
World.prototype.get$hasErrors = function() {
  return this.errors > 0;
}
World.prototype.printStatus = function() {
  this.info(('compiled ' + this.dartBytesRead + ' bytes Dart -> ' + this.jsBytesWritten + ' bytes JS'));
  if ($notnull_bool(this.get$hasErrors())) {
    print(('compilation failed with ' + this.errors + ' errors'));
  }
  else {
    if (this.warnings > 0) {
      this.info(('compilation completed successfully with ' + this.warnings + ' warnings'));
    }
    else {
      this.info('compilation completed sucessfully');
    }
  }
}
World.prototype.withTiming = function(name, f) {
  var sw = new StopwatchImplementation();
  sw.start();
  var result = f();
  sw.stop();
  this.info(('' + name + ' in ' + sw.elapsedInMs() + 'msec'));
  return result;
}
// ********** Code for FrogOptions **************
function FrogOptions(homedir, args, files) {
  var $0;
  this.enableLeg = false
  this.legOnly = false
  this.enableAsserts = false
  this.enableTypeChecks = false
  this.warningsAsErrors = false
  this.verifyImplements = false
  this.compileAll = false
  this.dietParse = false
  this.compileOnly = false
  this.throwOnErrors = false
  this.throwOnWarnings = false
  this.throwOnFatal = false
  this.showInfo = false
  this.showWarnings = true
  // Initializers done
  this.libDir = homedir + '/lib';
  var ignoreUnrecognizedFlags = false;
  var passedLibDir = false;
  this.childArgs = [];
  loop:
  for (var i = 2;
   i < $assert_num(args.length); i++) {
    var arg = args.$index(i);
    switch (arg) {
      case '--enable_leg':

        this.enableLeg = true;
        continue loop;

      case '--leg_only':

        this.enableLeg = true;
        this.legOnly = true;
        continue loop;

      case '--enable_asserts':

        this.enableAsserts = true;
        continue loop;

      case '--enable_type_checks':

        this.enableTypeChecks = true;
        this.enableAsserts = true;
        continue loop;

      case '--verify_implements':

        this.verifyImplements = true;
        continue loop;

      case '--compile_all':

        this.compileAll = true;
        continue loop;

      case '--diet-parse':

        this.dietParse = true;
        continue loop;

      case '--ignore-unrecognized-flags':

        ignoreUnrecognizedFlags = true;
        continue loop;

      case '--verbose':

        this.showInfo = true;
        continue loop;

      case '--suppress_warnings':

        this.showWarnings = false;
        continue loop;

      case '--warnings_as_errors':

        this.warningsAsErrors = true;
        continue loop;

      case '--throw_on_errors':

        this.throwOnErrors = true;
        continue loop;

      case '--throw_on_warnings':

        this.throwOnWarnings = true;
        continue loop;

      case '--compile-only':

        this.compileOnly = true;
        continue loop;

      default:

        if ($notnull_bool(arg.endsWith$1('.dart'))) {
          this.dartScript = $assert_String(arg);
          this.childArgs = (($0 = args.getRange(i + 1, args.length - i - 1)) == null ? null : $0.assert$List_String());
          break loop;
        }
        else if ($notnull_bool(arg.startsWith$1('--out='))) {
          this.outfile = $assert_String(arg.substring$1('--out='.length));
        }
        else if ($notnull_bool(arg.startsWith$1('--libdir='))) {
          this.libDir = $assert_String(arg.substring$1('--libdir='.length));
          passedLibDir = true;
        }
        else {
          if (!$notnull_bool(ignoreUnrecognizedFlags)) {
            print(('unrecognized flag: "' + arg + '"'));
          }
        }

    }
  }
  if (!$notnull_bool(passedLibDir) && !$notnull_bool(files.fileExists(this.libDir))) {
    var temp = 'frog/lib';
    if ($notnull_bool(files.fileExists($assert_String(temp)))) {
      this.libDir = $assert_String(temp);
    }
    else {
      this.libDir = 'lib';
    }
  }
}
// ********** Code for LibraryReader **************
function LibraryReader() {
  // Initializers done
  this._specialLibs = $map(['dart:core', joinPaths($globals.options.libDir, 'corelib.dart'), 'dart:coreimpl', joinPaths($globals.options.libDir, 'corelib_impl.dart'), 'dart:html', joinPaths($globals.options.libDir, '../../client/html/release/html.dart'), 'dart:htmlimpl', joinPaths($globals.options.libDir, '../../client/html/release/htmlimpl.dart'), 'dart:dom', joinPaths($globals.options.libDir, '../../client/dom/frog/frog_dom.dart'), 'dart:json', joinPaths($globals.options.libDir, 'json.dart')]);
}
LibraryReader.prototype.readFile = function(fullname) {
  var filename = this._specialLibs.$index(fullname);
  if ($notnull_bool(filename == null)) {
    filename = fullname;
  }
  if ($notnull_bool($globals.world.files.fileExists($assert_String(filename)))) {
    return new SourceFile(filename, $globals.world.files.readAll($assert_String(filename)));
  }
  else {
    $globals.world.error(('File not found: ' + filename));
    return new SourceFile(filename, '');
  }
}
// ********** Code for VarMember **************
function VarMember(name) {
  this.name = name;
  // Initializers done
}
VarMember.prototype.assert$VarMember = function(){return this};
VarMember.prototype.get$name = function() { return this.name; };
VarMember.prototype.get$returnType = function() {
  return $globals.world.varType;
}
VarMember.prototype.invoke = function(context, node, target, args) {
  return new Value(this.get$returnType(), ('' + target.code + '.' + this.name + '(' + args.getCode() + ')'), node.span, true);
}
VarMember.prototype.generate$1 = function($0) {
  return this.generate(($0 == null ? null : $0.assert$CodeWriter()));
};
VarMember.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()));
};
// ********** Code for VarFunctionStub **************
function VarFunctionStub(name, callArgs) {
  this.args = callArgs.toCallStubArgs();
  // Initializers done
  VarMember.call(this, name);
  $globals.world.gen.corejs.useGenStub = true;
}
$inherits(VarFunctionStub, VarMember);
VarFunctionStub.prototype.assert$VarFunctionStub = function(){return this};
VarFunctionStub.prototype.generate = function(code) {
  if ($notnull_bool(this.args.get$hasNames())) {
    this.generateNamed(code);
  }
  else {
    this.generatePositional(code);
  }
}
VarFunctionStub.prototype.generatePositional = function(w) {
  var arity = this.args.get$length();
  w.enterBlock(('Function.prototype.to\$' + this.name + ' = function() {'));
  w.writeln(('this.' + this.name + ' = this.\$genStub(' + arity + ');'));
  w.writeln(('this.to\$' + this.name + ' = function() { return this.' + this.name + '; };'));
  w.writeln(('return this.' + this.name + ';'));
  w.exitBlock('};');
  var argsCode = this.args.getCode();
  w.enterBlock(('Function.prototype.' + this.name + ' = function(' + argsCode + ') {'));
  w.writeln(('return this.to\$' + this.name + '()(' + argsCode + ');'));
  w.exitBlock('};');
  w.writeln(('function to\$' + this.name + '(f) { return f && f.to\$' + this.name + '(); }'));
}
VarFunctionStub.prototype.generateNamed = function(w) {
  var named = Strings.join(this.args.getNames(), '", "');
  var argsCode = this.args.getCode();
  w.enterBlock(('Function.prototype.' + this.name + ' = function(' + argsCode + ') {'));
  w.writeln(('this.' + this.name + ' = this.\$genStub(' + this.args.get$length() + ', ["' + named + '"]);'));
  w.writeln(('return this.' + this.name + '(' + argsCode + ');'));
  w.exitBlock('}');
}
VarFunctionStub.prototype.generate$1 = function($0) {
  return this.generate(($0 == null ? null : $0.assert$CodeWriter()));
};
// ********** Code for VarMethodStub **************
function VarMethodStub(name, member, args, body) {
  this.member = member;
  this.args = args;
  this.body = body;
  // Initializers done
  VarMember.call(this, name);
}
$inherits(VarMethodStub, VarMember);
VarMethodStub.prototype.get$body = function() { return this.body; };
VarMethodStub.prototype.get$isHidden = function() {
  return $assert_bool(this.member != null ? this.member.declaringType.get$isHiddenNativeType() : false);
}
VarMethodStub.prototype.get$returnType = function() {
  var $0;
  return (($0 = this.member != null ? this.member.get$returnType() : $globals.world.varType) == null ? null : $0.assert$lang_Type());
}
VarMethodStub.prototype.get$declaringType = function() {
  var $0;
  return (($0 = this.member != null ? this.member.declaringType : $globals.world.objectType) == null ? null : $0.assert$lang_Type());
}
VarMethodStub.prototype.generate = function(code) {
  code.write($globals.world.gen._prototypeOf(this.get$declaringType(), this.name) + ' = ');
  if (!$notnull_bool(this.get$isHidden()) && $notnull_bool(this._useDirectCall(this.args))) {
    code.writeln(('' + this.get$declaringType().get$jsname() + '.prototype.' + this.member.get$jsname() + ';'));
  }
  else if ($notnull_bool(this._needsExactTypeCheck())) {
    code.enterBlock(('function(' + this.args.getCode() + ') {'));
    code.enterBlock(('if (Object.getPrototypeOf(this).hasOwnProperty("' + this.name + '")) {'));
    code.writeln(('' + this.body + ';'));
    code.exitBlock('}');
    var argsCode = this.args.getCode();
    if (argsCode != '') argsCode = ', ' + argsCode;
    code.writeln(('return Object.prototype.' + this.name + '.call(this' + argsCode + ');'));
    code.exitBlock('};');
  }
  else {
    code.enterBlock(('function(' + this.args.getCode() + ') {'));
    code.writeln(('' + this.body + ';'));
    code.exitBlock('};');
  }
}
VarMethodStub.prototype._needsExactTypeCheck = function() {
  var $this = this; // closure support
  if (this.member == null || $notnull_bool(this.member.declaringType.get$isObject())) return false;
  var members = this.member.declaringType.resolveMember(this.member.name).members;
  return members.filter$1((function (m) {
    return $notnull_bool($ne(m, $this.member)) && $notnull_bool(m.get$declaringType().get$isHiddenNativeType());
  })
  ).length >= 1;
}
VarMethodStub.prototype._useDirectCall = function(args) {
  var $0;
  if ((this.member instanceof MethodMember) && !$notnull_bool(this.member.declaringType.get$hasNativeSubtypes())) {
    var method = (($0 = this.member) == null ? null : $0.assert$MethodMember());
    if ($notnull_bool(method.needsArgumentConversion(args))) {
      return false;
    }
    for (var i = args.get$length();
     i < method.parameters.length; i++) {
      if ($notnull_bool($ne(method.parameters.$index(i).get$value().get$code(), 'null'))) {
        return false;
      }
    }
    return method.namesInOrder(args);
  }
  else {
    return false;
  }
}
VarMethodStub.prototype.generate$1 = function($0) {
  return this.generate(($0 == null ? null : $0.assert$CodeWriter()));
};
// ********** Code for VarMethodSet **************
function VarMethodSet(name, members, callArgs, returnType) {
  this.invoked = false
  this.members = members;
  this.returnType = returnType;
  this.args = callArgs.toCallStubArgs();
  // Initializers done
  VarMember.call(this, name);
}
$inherits(VarMethodSet, VarMember);
VarMethodSet.prototype.get$members = function() { return this.members; };
VarMethodSet.prototype.get$returnType = function() { return this.returnType; };
VarMethodSet.prototype.get$baseName = function() {
  return $assert_String(this.members.$index(0).get$name());
}
VarMethodSet.prototype.invoke = function(context, node, target, args) {
  this._invokeMembers(context, node);
  return VarMember.prototype.invoke.call(this, context, node, target, args);
}
VarMethodSet.prototype._invokeMembers = function(context, node) {
  var $0;
  if ($notnull_bool(this.invoked)) return;
  this.invoked = true;
  var hasObjectType = false;
  var $list = this.members;
  for (var $i = 0;$i < $list.length; $i++) {
    var member = $list.$index($i);
    var type = member.get$declaringType();
    var target = new Value(type, 'this', node.span, true);
    var result = member.invoke$4$isDynamic(context, node, target, this.args, true);
    var stub = new VarMethodStub(this.name, member, this.args, 'return ' + result.get$code());
    type.get$varStubs().$setindex(stub.get$name(), stub);
    if ($notnull_bool(type.get$isObject())) hasObjectType = true;
  }
  if (!$notnull_bool(hasObjectType)) {
    var target = new Value($globals.world.objectType, 'this', node.span, true);
    var result = target.invokeNoSuchMethod(context, this.get$baseName(), node, this.args);
    var stub = new VarMethodStub(this.name, null, this.args, 'return ' + result.get$code());
    $globals.world.objectType.varStubs.$setindex(stub.get$name(), stub);
  }
}
VarMethodSet.prototype.generate = function(code) {

}
VarMethodSet.prototype.generate$1 = function($0) {
  return this.generate(($0 == null ? null : $0.assert$CodeWriter()));
};
VarMethodSet.prototype.invoke$4 = function($0, $1, $2, $3) {
  return this.invoke(($0 == null ? null : $0.assert$MethodGenerator()), ($1 == null ? null : $1.assert$lang_Node()), ($2 == null ? null : $2.assert$Value()), ($3 == null ? null : $3.assert$Arguments()));
};
// ********** Code for top level **************
function map(source, mapper) {
  var result = new ListFactory();
  if (!!(source && source.is$List())) {
    var list = (source == null ? null : source.assert$List());
    result.length = list.length;
    for (var i = 0;
     i < list.length; i++) {
      result.$setindex(i, mapper(list.$index(i)));
    }
  }
  else {
    for (var $i = source.iterator(); $i.hasNext$0(); ) {
      var item = $i.next$0();
      result.add(mapper(item));
    }
  }
  return result;
}
function reduce(source, callback, initialValue) {
  var i = source.iterator();
  var current = initialValue;
  if ($notnull_bool(current == null) && $notnull_bool(i.hasNext$0())) {
    current = i.next$0();
  }
  while ($notnull_bool(i.hasNext$0())) {
    current = callback.call$2(current, i.next$0());
  }
  return current;
}
function orderValuesByKeys(map) {
  var $0;
  var keys = (($0 = map.getKeys()) == null ? null : $0.assert$List());
  keys.sort((function (x, y) {
    return x.compareTo$1(y);
  })
  );
  var values = [];
  for (var $i = 0;$i < keys.length; $i++) {
    var k = keys.$index($i);
    values.add(map.$index(k));
  }
  return values;
}
function isMultilineString(text) {
  return text.startsWith('"""') || text.startsWith("'''");
}
function isRawMultilineString(text) {
  return text.startsWith('@"""') || text.startsWith("@'''");
}
function toDoubleQuote(s) {
  return s.replaceAll('"', '\\"').replaceAll("\\'", "'");
}
function parseStringLiteral(lit) {
  if (lit.startsWith('@')) {
    if ($notnull_bool(isRawMultilineString(lit))) {
      return stripLeadingNewline(lit.substring(4, lit.length - 3));
    }
    else {
      return lit.substring(2, lit.length - 1);
    }
  }
  else if ($notnull_bool(isMultilineString(lit))) {
    lit = lit.substring(3, lit.length - 3).replaceAll('\\\$', '\$');
    return stripLeadingNewline(lit);
  }
  else {
    return lit.substring(1, lit.length - 1).replaceAll('\\\$', '\$');
  }
}
function stripLeadingNewline(text) {
  if (text.startsWith('\n')) {
    return text.substring(1);
  }
  else if (text.startsWith('\r')) {
    if (text.startsWith('\r\n')) {
      return text.substring(2);
    }
    else {
      return text.substring(1);
    }
  }
  else {
    return text;
  }
}
var world;
function initializeWorld(files) {
  $assert($globals.world == null, "world == null", "world.dart", 13, 10);
  $globals.world = new World(files);
  $globals.world.init();
}
function lang_compile(homedir, args, files) {
  parseOptions(homedir, args, files);
  initializeWorld(files);
  var success = $globals.world.compile();
  if ($globals.options.outfile != null) {
    if ($notnull_bool(success)) {
      var code = $globals.world.getGeneratedCode();
      if (!$globals.options.outfile.endsWith('.js')) {
        code = '#!/usr/bin/env node\n' + code;
      }
      $globals.world.files.writeString($globals.options.outfile, $assert_String(code));
    }
    else {
      $globals.world.files.writeString($globals.options.outfile, "throw 'Sorry, but I could not generate reasonable code to run.\\n';");
    }
  }
  return $assert_bool(success);
}
var options;
function parseOptions(homedir, args, files) {
  $assert($globals.options == null, "options == null", "frog_options.dart", 10, 10);
  $globals.options = new FrogOptions(homedir, args, files);
}
function _getCallStubName(name, args) {
  var nameBuilder = new StringBufferImpl(('' + name + '\$' + args.get$bareCount()));
  for (var i = args.get$bareCount();
   i < args.get$length(); i++) {
    nameBuilder.add('\$').add(args.getName(i));
  }
  return nameBuilder.toString();
}
//  ********** Library frog **************
// ********** Code for top level **************
function main() {
  var homedir = path.dirname(fs.realpathSync($assert_String(process.argv.$index(1))));
  var argv = ListFactory.ListFactory$from$factory(process.argv);
  if ($notnull_bool(lang_compile($assert_String(homedir), (argv == null ? null : argv.assert$List_String()), new NodeFileSystem()))) {
    var code = $globals.world.getGeneratedCode();
    if (!$notnull_bool($globals.options.compileOnly)) {
      process.argv = [argv.$index(0), argv.$index(1)];
      process.argv.addAll($globals.options.childArgs);
      vm.runInNewContext($assert_String(code), createSandbox());
    }
  }
  else {
    process.exit(1);
  }
}
// ********** Generic Type Inheritance **************
/** Implements extends for generic types. */
function $inheritsMembers(child, parent) {
  child = child.prototype;
  parent = parent.prototype;
  Object.getOwnPropertyNames(parent).forEach(function(name) {
    if (typeof(child[name]) == 'undefined') child[name] = parent[name];
  });
}
$inheritsMembers(_DoubleLinkedQueueEntrySentinel_E, DoubleLinkedQueueEntry_E);
$inheritsMembers(_DoubleLinkedQueueEntrySentinel_KeyValuePair_K$V, DoubleLinkedQueueEntry_KeyValuePair_K$V);
$inheritsMembers(ArrayBasedScanner_SourceString, AbstractScanner_SourceString);
//  ********** Globals **************
function $static_init(){
  $globals.Node__HASH_COUNTER = 0;
  $globals.HTracer__singleton = null;
}
var const$0 = new NoMoreElementsException()/*const NoMoreElementsException()*/;
var const$1 = new _DeletedKeySentinel()/*const _DeletedKeySentinel()*/;
var const$10 = new StringWrapper('double')/*const SourceString('double')*/;
var const$101 = new Keyword("interface", true)/*const Keyword("interface", true)*/;
var const$103 = new Keyword("library", true)/*const Keyword("library", true)*/;
var const$105 = new Keyword("native", true)/*const Keyword("native", true)*/;
var const$107 = new Keyword("negate", true)/*const Keyword("negate", true)*/;
var const$109 = new Keyword("operator", true)/*const Keyword("operator", true)*/;
var const$111 = new Keyword("set", true)/*const Keyword("set", true)*/;
var const$113 = new Keyword("source", true)/*const Keyword("source", true)*/;
var const$115 = new Keyword("static", true)/*const Keyword("static", true)*/;
var const$117 = new Keyword("typedef", true)/*const Keyword("typedef", true)*/;
var const$12 = new StringWrapper('Dynamic')/*const SourceString('Dynamic')*/;
var const$121 = new StringWrapper('EOF')/*const SourceString('EOF')*/;
var const$14 = new StringWrapper('String')/*const SourceString('String')*/;
var const$16 = new StringWrapper('bool')/*const SourceString('bool')*/;
var const$18 = new StringWrapper('Object')/*const SourceString('Object')*/;
var const$20 = new IllegalAccessException()/*const IllegalAccessException()*/;
var const$209 = new LinkTail()/*const EmptyLink<Node>()*/;
var const$21 = ImmutableList.ImmutableList$from$factory([])/*const []*/;
var const$210 = new LinkTail()/*const EmptyLink<Element>()*/;
var const$213 = new LinkTail()/*const EmptyLink<Type>()*/;
var const$214 = new ElementKind('class')/*const ElementKind('class')*/;
var const$216 = new ElementKind('function')/*const ElementKind('function')*/;
var const$218 = new StringWrapper('JS')/*const SourceString('JS')*/;
var const$219 = new ElementKind('foreign')/*const ElementKind('foreign')*/;
var const$22 = new LinkTail()/*const EmptyLink<Token>()*/;
var const$221 = new StringWrapper('main')/*const SourceString('main')*/;
var const$223 = new StringWrapper(';')/*const SourceString(';')*/;
var const$224 = new ImmutableMap([])/*const {}*/;
var const$225 = new MessageKind('cannot resolve #{1}')/*const MessageKind(
      'cannot resolve #{1}')*/;
var const$227 = new StringWrapper('var')/*const SourceString('var')*/;
var const$228 = new MessageKind('cannot resolve type #{1}')/*const MessageKind(
      'cannot resolve type #{1}')*/;
var const$230 = new MessageKind('#{1} is not a type')/*const MessageKind(
      '#{1} is not a type')*/;
var const$232 = new ElementKind('parameter')/*const ElementKind('parameter')*/;
var const$234 = new MessageKind('duplicate definition of #{1}')/*const MessageKind(
      'duplicate definition of #{1}')*/;
var const$236 = new LinkTail()/*const LinkTail()*/;
var const$237 = new StringWrapper('neg')/*const SourceString('neg')*/;
var const$238 = new StringWrapper('not')/*const SourceString('not')*/;
var const$239 = new ExceptionImplementation("Internal Error (Leg): UNREACHABLE")/*const Exception("Internal Error (Leg): UNREACHABLE")*/;
var const$240 = new StringWrapper('add')/*const SourceString('add')*/;
var const$241 = new StringWrapper('sub')/*const SourceString('sub')*/;
var const$242 = new StringWrapper('mul')/*const SourceString('mul')*/;
var const$243 = new StringWrapper('div')/*const SourceString('div')*/;
var const$244 = new StringWrapper('tdiv')/*const SourceString('tdiv')*/;
var const$245 = new StringWrapper('mod')/*const SourceString('mod')*/;
var const$246 = new StringWrapper('shl')/*const SourceString('shl')*/;
var const$247 = new StringWrapper('shr')/*const SourceString('shr')*/;
var const$248 = new StringWrapper('or')/*const SourceString('or')*/;
var const$249 = new StringWrapper('and')/*const SourceString('and')*/;
var const$250 = new StringWrapper('xor')/*const SourceString('xor')*/;
var const$251 = new StringWrapper('eq')/*const SourceString('eq')*/;
var const$252 = new StringWrapper('lt')/*const SourceString('lt')*/;
var const$253 = new StringWrapper('le')/*const SourceString('le')*/;
var const$254 = new StringWrapper('gt')/*const SourceString('gt')*/;
var const$255 = new StringWrapper('ge')/*const SourceString('ge')*/;
var const$256 = new ElementKind('variable')/*const ElementKind('variable')*/;
var const$258 = new MessageKind('#{2} is not assignable to #{1}')/*const MessageKind(
      '#{2} is not assignable to #{1}')*/;
var const$260 = new MessageKind('cannot return value from void function')/*const MessageKind(
      'cannot return value from void function')*/;
var const$262 = new MessageKind('value of type #{1} expected')/*const MessageKind(
      'value of type #{1} expected')*/;
var const$264 = new MessageKind('missing argument')/*const MessageKind(
      'missing argument')*/;
var const$266 = new MessageKind('additional argument')/*const MessageKind(
      'additional argument')*/;
var const$268 = new MessageKind('variable cannot be of type void')/*const MessageKind(
      'variable cannot be of type void')*/;
var const$270 = new MessageKind('expression does not yield a value')/*const MessageKind(
      'expression does not yield a value')*/;
var const$272 = new MessageKind('#{1}')/*const MessageKind('#{1}')*/;
var const$278 = new StringWrapper("&&")/*const SourceString("&&")*/;
var const$279 = new StringWrapper("||")/*const SourceString("||")*/;
var const$280 = new StringWrapper("!")/*const SourceString("!")*/;
var const$281 = new StringWrapper("=")/*const SourceString("=")*/;
var const$284 = new StringWrapper("++")/*const SourceString("++")*/;
var const$285 = new StringWrapper("--")/*const SourceString("--")*/;
var const$295 = ImmutableList.ImmutableList$from$factory(["__PROTO__", "prototype"])/*const <String>["__PROTO__", "prototype"]*/;
var const$297 = ImmutableList.ImmutableList$from$factory(["NaN", "Infinity", "undefined", "eval", "parseInt", "parseFloat", "isNan", "isFinite", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Object", "Function", "Array", "String", "Boolean", "Number", "Date", "RegExp", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "Math", "arguments", "escape", "unescape", "applicationCache", "closed", "Components", "content", "controllers", "crypto", "defaultStatus", "dialogArguments", "directories", "document", "frameElement", "frames", "fullScreen", "globalStorage", "history", "innerHeight", "innerWidth", "length", "location", "locationbar", "localStorage", "menubar", "mozInnerScreenX", "mozInnerScreenY", "mozScreenPixelsPerCssPixel", "name", "navigator", "opener", "outerHeight", "outerWidth", "pageXOffset", "pageYOffset", "parent", "personalbar", "pkcs11", "returnValue", "screen", "scrollbars", "scrollMaxX", "scrollMaxY", "self", "sessionStorage", "sidebar", "status", "statusbar", "toolbar", "top", "window", "alert", "addEventListener", "atob", "back", "blur", "btoa", "captureEvents", "clearInterval", "clearTimeout", "close", "confirm", "disableExternalCapture", "dispatchEvent", "dump", "enableExternalCapture", "escape", "find", "focus", "forward", "GeckoActiveXObject", "getAttention", "getAttentionWithCycleCount", "getComputedStyle", "getSelection", "home", "maximize", "minimize", "moveBy", "moveTo", "open", "openDialog", "postMessage", "print", "prompt", "QueryInterface", "releaseEvents", "removeEventListener", "resizeBy", "resizeTo", "restore", "routeEvent", "scroll", "scrollBy", "scrollByLines", "scrollByPages", "scrollTo", "setInterval", "setResizeable", "setTimeout", "showModalDialog", "sizeToContent", "stop", "uuescape", "updateCommands", "XPCNativeWrapper", "XPCSafeJSOjbectWrapper", "onabort", "onbeforeunload", "onchange", "onclick", "onclose", "oncontextmenu", "ondragdrop", "onerror", "onfocus", "onhashchange", "onkeydown", "onkeypress", "onkeyup", "onload", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmozorientation", "onpaint", "onreset", "onresize", "onscroll", "onselect", "onsubmit", "onunload", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ongesturestart", "ongesturechange", "ongestureend", "uneval", "getPrototypeOf", "let", "yield", "abstract", "int", "short", "boolean", "interface", "static", "byte", "long", "char", "final", "native", "synchronized", "float", "package", "throws", "goto", "private", "transient", "implements", "protected", "volatile", "double", "public", "attachEvent", "clientInformation", "clipboardData", "createPopup", "dialogHeight", "dialogLeft", "dialogTop", "dialogWidth", "onafterprint", "onbeforedeactivate", "onbeforeprint", "oncontrolselect", "ondeactivate", "onhelp", "onresizeend", "event", "external", "Debug", "Enumerator", "Global", "Image", "ActiveXObject", "VBArray", "Components", "toString", "getClass", "constructor", "prototype", "valueOf", "Anchor", "Applet", "Attr", "Canvas", "CanvasGradient", "CanvasPattern", "CanvasRenderingContext2D", "CDATASection", "CharacterData", "Comment", "CSS2Properties", "CSSRule", "CSSStyleSheet", "Document", "DocumentFragment", "DocumentType", "DOMException", "DOMImplementation", "DOMParser", "Element", "Event", "ExternalInterface", "FlashPlayer", "Form", "Frame", "History", "HTMLCollection", "HTMLDocument", "HTMLElement", "IFrame", "Image", "Input", "JSObject", "KeyEvent", "Link", "Location", "MimeType", "MouseEvent", "Navigator", "Node", "NodeList", "Option", "Plugin", "ProcessingInstruction", "Range", "RangeException", "Screen", "Select", "Table", "TableCell", "TableRow", "TableSelection", "Text", "TextArea", "UIEvent", "Window", "XMLHttpRequest", "XMLSerializer", "XPathException", "XPathResult", "XSLTProcessor", "java", "Packages", "netscape", "sun", "JavaObject", "JavaClass", "JavaArray", "JavaMember", "\$wnd", "\$doc", "\$entry", "\$moduleName", "\$moduleBase", "\$gwt_version", "\$sessionId", "\$stack", "\$stackDepth", "\$location", "call"])/*const <String>[
    // Section references are from Ecma-262
    // (http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)

    // 15.1.1 Value Properties of the Global Object
    "NaN", "Infinity", "undefined",

    // 15.1.2 Function Properties of the Global Object
    "eval", "parseInt", "parseFloat", "isNan", "isFinite",

    // 15.1.3 URI Handling Function Properties
    "decodeURI", "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",

    // 15.1.4 Constructor Properties of the Global Object
    "Object", "Function", "Array", "String", "Boolean", "Number", "Date",
    "RegExp", "Error", "EvalError", "RangeError", "ReferenceError",
    "SyntaxError", "TypeError", "URIError",

    // 15.1.5 Other Properties of the Global Object
    "Math",

    // 10.1.6 Activation Object
    "arguments",

    // B.2 Additional Properties (non-normative)
    "escape", "unescape",

    // Window props (https://developer.mozilla.org/en/DOM/window)
    "applicationCache", "closed", "Components", "content", "controllers",
    "crypto", "defaultStatus", "dialogArguments", "directories",
    "document", "frameElement", "frames", "fullScreen", "globalStorage",
    "history", "innerHeight", "innerWidth", "length",
    "location", "locationbar", "localStorage", "menubar",
    "mozInnerScreenX", "mozInnerScreenY", "mozScreenPixelsPerCssPixel",
    "name", "navigator", "opener", "outerHeight", "outerWidth",
    "pageXOffset", "pageYOffset", "parent", "personalbar", "pkcs11",
    "returnValue", "screen", "scrollbars", "scrollMaxX", "scrollMaxY",
    "self", "sessionStorage", "sidebar", "status", "statusbar", "toolbar",
    "top", "window",

    // Window methods (https://developer.mozilla.org/en/DOM/window)
    "alert", "addEventListener", "atob", "back", "blur", "btoa",
    "captureEvents", "clearInterval", "clearTimeout", "close", "confirm",
    "disableExternalCapture", "dispatchEvent", "dump",
    "enableExternalCapture", "escape", "find", "focus", "forward",
    "GeckoActiveXObject", "getAttention", "getAttentionWithCycleCount",
    "getComputedStyle", "getSelection", "home", "maximize", "minimize",
    "moveBy", "moveTo", "open", "openDialog", "postMessage", "print",
    "prompt", "QueryInterface", "releaseEvents", "removeEventListener",
    "resizeBy", "resizeTo", "restore", "routeEvent", "scroll", "scrollBy",
    "scrollByLines", "scrollByPages", "scrollTo", "setInterval",
    "setResizeable", "setTimeout", "showModalDialog", "sizeToContent",
    "stop", "uuescape", "updateCommands", "XPCNativeWrapper",
    "XPCSafeJSOjbectWrapper",

    // Mozilla Window event handlers, same cite
    "onabort", "onbeforeunload", "onchange", "onclick", "onclose",
    "oncontextmenu", "ondragdrop", "onerror", "onfocus", "onhashchange",
    "onkeydown", "onkeypress", "onkeyup", "onload", "onmousedown",
    "onmousemove", "onmouseout", "onmouseover", "onmouseup",
    "onmozorientation", "onpaint", "onreset", "onresize", "onscroll",
    "onselect", "onsubmit", "onunload",

    // Safari Web Content Guide
    // http://developer.apple.com/library/safari/#documentation/AppleApplications/Reference/SafariWebContent/SafariWebContent.pdf
    // WebKit Window member data, from WebKit DOM Reference
    // (http://developer.apple.com/safari/library/documentation/AppleApplications/Reference/WebKitDOMRef/DOMWindow_idl/Classes/DOMWindow/index.html)
    "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart",
    "ongesturestart", "ongesturechange", "ongestureend",

    // extra window methods
    "uneval",

    // keywords https://developer.mozilla.org/en/New_in_JavaScript_1.7,
    // https://developer.mozilla.org/en/New_in_JavaScript_1.8.1
    "getPrototypeOf", "let", "yield",

    // "future reserved words"
    "abstract", "int", "short", "boolean", "interface", "static", "byte",
    "long", "char", "final", "native", "synchronized", "float", "package",
    "throws", "goto", "private", "transient", "implements", "protected",
    "volatile", "double", "public",

    // IE methods
    // (http://msdn.microsoft.com/en-us/library/ms535873(VS.85).aspx#)
    "attachEvent", "clientInformation", "clipboardData", "createPopup",
    "dialogHeight", "dialogLeft", "dialogTop", "dialogWidth",
    "onafterprint", "onbeforedeactivate", "onbeforeprint",
    "oncontrolselect", "ondeactivate", "onhelp", "onresizeend",

    // Common browser-defined identifiers not defined in ECMAScript
    "event", "external", "Debug", "Enumerator", "Global", "Image",
    "ActiveXObject", "VBArray", "Components",

    // Functions commonly defined on Object
    "toString", "getClass", "constructor", "prototype", "valueOf",

    // Client-side JavaScript identifiers, which are needed for linkers
    // that don't ensure GWT's window != $wnd, document != $doc, etc.
    // Taken from the Rhino book, pg 715
    "Anchor", "Applet", "Attr", "Canvas", "CanvasGradient",
    "CanvasPattern", "CanvasRenderingContext2D", "CDATASection",
    "CharacterData", "Comment", "CSS2Properties", "CSSRule",
    "CSSStyleSheet", "Document", "DocumentFragment", "DocumentType",
    "DOMException", "DOMImplementation", "DOMParser", "Element", "Event",
    "ExternalInterface", "FlashPlayer", "Form", "Frame", "History",
    "HTMLCollection", "HTMLDocument", "HTMLElement", "IFrame", "Image",
    "Input", "JSObject", "KeyEvent", "Link", "Location", "MimeType",
    "MouseEvent", "Navigator", "Node", "NodeList", "Option", "Plugin",
    "ProcessingInstruction", "Range", "RangeException", "Screen", "Select",
    "Table", "TableCell", "TableRow", "TableSelection", "Text", "TextArea",
    "UIEvent", "Window", "XMLHttpRequest", "XMLSerializer",
    "XPathException", "XPathResult", "XSLTProcessor",

    // These keywords trigger the loading of the java-plugin. For the
    // next-generation plugin, this results in starting a new Java process.
    "java", "Packages", "netscape", "sun", "JavaObject", "JavaClass",
    "JavaArray", "JavaMember",

    // GWT-defined identifiers
    "\$wnd", "\$doc", "\$entry", "\$moduleName", "\$moduleBase",
    "\$gwt_version", "\$sessionId",

    // Identifiers used by JsStackEmulator; later set to obfuscatable
    "\$stack", "\$stackDepth", "\$location",

    // TODO: prove why this is necessary or remove it
    "call"
  ]*/;
var const$299 = ImmutableList.ImmutableList$from$factory(["break", "delete", "function", "return", "typeof", "case", "do", "if", "switch", "var", "catch", "else", "in", "this", "void", "continue", "false", "instanceof", "throw", "while", "debugger", "finally", "new", "true", "with", "default", "for", "null", "try", "abstract", "double", "goto", "native", "static", "boolean", "enum", "implements", "package", "super", "byte", "export", "import", "private", "synchronized", "char", "extends", "int", "protected", "throws", "class", "final", "interface", "public", "transient", "const", "float", "long", "short", "volatile"])/*const <String>[
    // These are current keywords
    "break", "delete", "function", "return", "typeof", "case", "do", "if",
    "switch", "var", "catch", "else", "in", "this", "void", "continue",
    "false", "instanceof", "throw", "while", "debugger", "finally", "new",
    "true", "with", "default", "for", "null", "try",

    // These are future keywords
    "abstract", "double", "goto", "native", "static", "boolean", "enum",
    "implements", "package", "super", "byte", "export", "import", "private",
    "synchronized", "char", "extends", "int", "protected", "throws",
    "class", "final", "interface", "public", "transient", "const", "float",
    "long", "short", "volatile"
  ]*/;
var const$301 = new StringWrapper('guard\$num')/*const SourceString('guard\$num')*/;
var const$302 = new StringWrapper('guard\$string')/*const SourceString('guard\$string')*/;
var const$31 = new Keyword("break", false)/*const Keyword("break")*/;
var const$33 = new Keyword("case", false)/*const Keyword("case")*/;
var const$35 = new Keyword("catch", false)/*const Keyword("catch")*/;
var const$37 = new Keyword("const", false)/*const Keyword("const")*/;
var const$39 = new Keyword("continue", false)/*const Keyword("continue")*/;
var const$4 = new StringWrapper('global scope')/*const SourceString('global scope')*/;
var const$41 = new Keyword("default", false)/*const Keyword("default")*/;
var const$43 = new Keyword("do", false)/*const Keyword("do")*/;
var const$45 = new Keyword("else", false)/*const Keyword("else")*/;
var const$47 = new Keyword("false", false)/*const Keyword("false")*/;
var const$49 = new Keyword("final", false)/*const Keyword("final")*/;
var const$5 = new EmptyQueueException()/*const EmptyQueueException()*/;
var const$51 = new Keyword("finally", false)/*const Keyword("finally")*/;
var const$53 = new Keyword("for", false)/*const Keyword("for")*/;
var const$55 = new Keyword("if", false)/*const Keyword("if")*/;
var const$57 = new Keyword("in", false)/*const Keyword("in")*/;
var const$59 = new Keyword("is", false)/*const Keyword("is")*/;
var const$6 = new StringWrapper('void')/*const SourceString('void')*/;
var const$61 = new Keyword("new", false)/*const Keyword("new")*/;
var const$63 = new Keyword("null", false)/*const Keyword("null")*/;
var const$65 = new Keyword("return", false)/*const Keyword("return")*/;
var const$67 = new Keyword("super", false)/*const Keyword("super")*/;
var const$69 = new Keyword("switch", false)/*const Keyword("switch")*/;
var const$71 = new Keyword("this", false)/*const Keyword("this")*/;
var const$73 = new Keyword("throw", false)/*const Keyword("throw")*/;
var const$75 = new Keyword("true", false)/*const Keyword("true")*/;
var const$77 = new Keyword("try", false)/*const Keyword("try")*/;
var const$79 = new Keyword("var", false)/*const Keyword("var")*/;
var const$8 = new StringWrapper('int')/*const SourceString('int')*/;
var const$81 = new Keyword("void", false)/*const Keyword("void")*/;
var const$83 = new Keyword("while", false)/*const Keyword("while")*/;
var const$85 = new Keyword("abstract", true)/*const Keyword("abstract", true)*/;
var const$87 = new Keyword("assert", true)/*const Keyword("assert", true)*/;
var const$89 = new Keyword("class", true)/*const Keyword("class", true)*/;
var const$91 = new Keyword("extends", true)/*const Keyword("extends", true)*/;
var const$93 = new Keyword("factory", true)/*const Keyword("factory", true)*/;
var const$95 = new Keyword("get", true)/*const Keyword("get", true)*/;
var const$97 = new Keyword("implements", true)/*const Keyword("implements", true)*/;
var const$99 = new Keyword("import", true)/*const Keyword("import", true)*/;
var const$119 = ImmutableList.ImmutableList$from$factory([const$31, const$33, const$35, const$37, const$39, const$41, const$43, const$45, const$47, const$49, const$51, const$53, const$55, const$57, const$59, const$61, const$63, const$65, const$67, const$69, const$71, const$73, const$75, const$77, const$79, const$81, const$83, const$85, const$87, const$89, const$91, const$93, const$95, const$97, const$99, const$101, const$103, const$105, const$107, const$109, const$111, const$113, const$115, const$117])/*const <Keyword> [
      BREAK,
      CASE,
      CATCH,
      CONST,
      CONTINUE,
      DEFAULT,
      DO,
      ELSE,
      FALSE,
      FINAL,
      FINALLY,
      FOR,
      IF,
      IN,
      IS,
      NEW,
      NULL,
      RETURN,
      SUPER,
      SWITCH,
      THIS,
      THROW,
      TRUE,
      TRY,
      VAR,
      VOID,
      WHILE,
      ABSTRACT,
      ASSERT,
      CLASS,
      EXTENDS,
      FACTORY,
      GET,
      IMPLEMENTS,
      IMPORT,
      INTERFACE,
      LIBRARY,
      NATIVE,
      NEGATE,
      OPERATOR,
      SET,
      SOURCE,
      STATIC,
      TYPEDEF ]*/;
var $globals = {};
$static_init();
main();
