// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Generated by scripts/tree_gen.py.

/////////////////////////////////////////////////////////////////////////
// CSS specific types:
/////////////////////////////////////////////////////////////////////////


class Identifier extends lang.Node {
  String name;

  Identifier(this.name, lang.SourceSpan span): super(span) {}

  visit(TreeVisitor visitor) => visitor.visitIdentifier(this);

  String toString() => name;
}

class Wildcard extends lang.Node {
  Wildcard(lang.SourceSpan span): super(span);

  visit(TreeVisitor visitor) => visitor.visitWildcard(this);

  String toString() => '*';
}

class SelectorGroup extends lang.Node {
  // List of SimpleSelector(s) list contain any mix SimpleSelector or
  // SimpleSlectorName (or class derived from SimpleSelectorName e.g.,
  // IdSelector, ClassSelector, ElementSelector, PseudoClassSelector,
  // PseudoElementSelector, NotSelector, or Attribute
  List<SimpleSelector> selectors;

  SelectorGroup(this.selectors, lang.SourceSpan span): super(span);

  visit(TreeVisitor visitor) => visitor.visitSelectorGroup(this);

  String toString() {
    StringBuffer buff = new StringBuffer();
    for (selector in selectors) {
      if (selector.isCombinatorDescendant()) {
        buff.add(' ');        
      } else if (selector.isCombinatorPlus()) {
        buff.add(' + ');
      } else if (selector.isCombinatorGreater()) {
        buff.add(' > ');
      } else if (selector.isCombinatorTilde()) {
        buff.add(' ~ ');
      }
      buff.add(selector.toString());
    }
    return buff.toString();
  }

  /** A multiline string showing the node and its children. */
  String toDebugString() {
    var to = new lang.TreeOutput();
    var tp = new TreePrinter(to);
    this.visit(tp);
    return to.buf.toString();
  }
}

/* All other selectors (element, #id, .class, attribute, pseudo, negation,
 * namespace, *) are derived from this selector.
 */
class SimpleSelector extends lang.Node {
  int _combinator;      // +, >, ~ or descendant (space), and NONE
  var _name;

  SimpleSelector(this._name, lang.SourceSpan span,
      [this._combinator = TokenKind.COMBINATOR_NONE]) : super(span);

  // Name can be an Identifier or WildCard we'll return either the name or '*'.
  String get name() => isWildcard() ? '*' : _name.name;

  bool isWildcard() => _name is Wildcard;

  // TODO(terry): Kind of hacky to reset combinator to NONE
  void resetCombinatorNone() {
    assert(isCombinatorDescendant());
    _combinator = TokenKind.COMBINATOR_NONE;
  }

  bool isCombinatorNone() => _combinator == TokenKind.COMBINATOR_NONE;
  bool isCombinatorDescendant() =>
      _combinator == TokenKind.COMBINATOR_DESCENDANT;
  bool isCombinatorPlus() => _combinator == TokenKind.COMBINATOR_PLUS;
  bool isCombinatorGreater() => _combinator == TokenKind.COMBINATOR_GREATER;
  bool isCombinatorTilde() => _combinator == TokenKind.COMBINATOR_TILDE;

  visit(TreeVisitor visitor) => visitor.visitSimpleSelector(this);

  String toString() => name;
}

// element name
class ElementSelector extends SimpleSelector {
  ElementSelector(var name, lang.SourceSpan span,
      [int combinator = TokenKind.COMBINATOR_NONE]) :
      super(name, span, combinator);

  visit(TreeVisitor visitor) => visitor.visitElementSelector(this);

  String toString() => "$name";

  /** A multiline string showing the node and its children. */
  String toDebugString() {
    var to = new lang.TreeOutput();
    var tp = new TreePrinter(to);
    this.visit(tp);
    return to.buf.toString();
  }
}

// namespace|element
class NamespaceSelector extends SimpleSelector {
  var _namespace;           // null, Wildcard or Identifier

  NamespaceSelector(this._namespace, var name, lang.SourceSpan span,
      [int combinator = TokenKind.COMBINATOR_NONE]) :
      super(name, span, combinator);

  String get namespace() => _namespace is Wildcard ? '*' : _namespace.name;

  bool isNamespaceWildcard() => _namespace is Wildcard;

  SimpleSelector get nameAsSimpleSelector() => _name;

  visit(TreeVisitor visitor) => visitor.visitNamespaceSelector(this);

  String toString() => "$namespace|$nameAsSimpleSelector";
}

// #id
class IdSelector extends SimpleSelector {
  IdSelector(Identifier name, lang.SourceSpan span,
    [int combinator = TokenKind.COMBINATOR_NONE]) :
    super(name, span, combinator);

  visit(TreeVisitor visitor) => visitor.visitIdSelector(this);

  String toString() => "#$name";
}

// .class
class ClassSelector extends SimpleSelector {
  ClassSelector(Identifier name, lang.SourceSpan span,
    [int combinator = TokenKind.COMBINATOR_NONE]) :
    super(name, span, combinator);

  visit(TreeVisitor visitor) => visitor.visitClassSelector(this);

  String toString() => ".$name";
}

// :pseudoClass
class PseudoClassSelector extends SimpleSelector {
  PseudoClassSelector(Identifier name, lang.SourceSpan span,
      [int combinator = TokenKind.COMBINATOR_NONE]) :
      super(name, span, combinator);

  visit(TreeVisitor visitor) => visitor.visitPseudoClassSelector(this);

  String toString() => ":$name";
}

// ::pseudoElement
class PseudoElementSelector extends SimpleSelector {
  PseudoElementSelector(Identifier name, lang.SourceSpan span,
      [int combinator = TokenKind.COMBINATOR_NONE]) :
      super(name, span, combinator);

  visit(TreeVisitor visitor) => visitor.visitPseudoElementSelector(this);

  String toString() => "::$name";
}

// TODO(terry): Implement
// NOT
class NotSelector extends SimpleSelector {
  NotSelector(String name, lang.SourceSpan span,
    [lang.Token combinator = TokenKind.COMBINATOR_NONE]) :
    super(name, span, combinator);

  visit(TreeVisitor visitor) => visitor.visitNotSelector(this);
}

// TODO(terry): Implement
// [attribute]
class Attribute extends lang.Node {
  var name;         // NamespaceSelector or SimpleSelector
  int matchType;    // ~=, |=, ^=, $=, *=, =
  String value;
}

interface TreeVisitor {
  void visitSelectorGroup(SelectorGroup node);
  void visitSimpleSelector(SimpleSelector node);
  void visitElementSelector(ElementSelector node);
  void visitNamespaceSelector(NamespaceSelector node);
  void visitIdSelector(IdSelector node);
  void visitClassSelector(ClassSelector node);
  void visitPseudoClassSelector(PseudoClassSelector node);
  void visitPseudoElementSelector(PseudoElementSelector node);
  void visitNotSelector(NotSelector node);
  
  void visitIdentifier(Identifier node);
  void visitWildcard(Wildcard node);

  // TODO(terry): Defined for ../tree.dart.
  void visitTypeReference(lang.TypeReference node);
}

class TreePrinter implements TreeVisitor {
  var output;
  TreePrinter(this.output) { output.printer = this; }

  void visitSelectorGroup(SelectorGroup node) {
    output.heading('Selector Group', node.span);
    output.writeNodeList('selectors', node.selectors);
    output.writeln('');
  }

  void visitSimpleSelector(SimpleSelector node) {
    if (node.isCombinatorNone()) {
      output.writeValue('combinator', "NONE");
    } else if (node.isCombinatorDescendant()) {
      output.writeValue('combinator', "descendant");
    } else if (node.isCombinatorPlus()) {
      output.writeValue('combinator', "+");
    } else if (node.isCombinatorGreater()) {
      output.writeValue('combinator', ">");
    } else if (node.isCombinatorTilde()) {
      output.writeValue('combinator', "~");
    } else {
      output.writeValue('combinator', "ERROR UNKNOWN");
    }
  }

  void visitNamespaceSelector(NamespaceSelector node) {
    output.heading('Namespace Selector', node.span);
    visitSimpleSelector(node);
    output.writeNode('namespace', node._namespace);
    output.writeNode('name', node._name);
  }

  void visitElementSelector(ElementSelector node) {
    output.heading('Element Selector', node.span);
    visitSimpleSelector(node);
    output.writeNode('name', node._name);
  }

  void visitIdSelector(IdSelector node) {
    output.heading('Id Selector', node.span);
    visitSimpleSelector(node);
    output.writeNode('name', node._name);
  }

  void visitClassSelector(ClassSelector node) {
    output.heading('Class Selector', node.span);
    visitSimpleSelector(node);
    output.writeNode('name', node._name);
  }

  void visitPseudoClassSelector(PseudoClassSelector node) {
    output.heading('Pseudo Class Selector', node.span);
    visitSimpleSelector(node);
    output.writeNode('name', node._name);
  }

  void visitPseudoElementSelector(PseudoElementSelector node) {
    output.heading('Pseudo Element Selector', node.span);
    visitSimpleSelector(node);
    output.writeNode('name', node._name);
  }

  void visitNotSelector(NotSelector node) {
    visitSimpleSelector(node);
    output.heading('Not Selector', node.span);
  }

  void visitIdentifier(Identifier node) {
    output.heading('Identifier(' + output.toValue(node.name) + ")", node.span);
  }

  void visitWildcard(Wildcard node) {
    output.heading('Wildcard(*)', node.span);
  }

  // TODO(terry): Defined for frog/tree.dart.
  void visitTypeReference(lang.TypeReference node) {
    output.heading('Unimplemented');
  }
}
